import { jsx as M, jsxs as Nt, Fragment as ah } from "react/jsx-runtime";
import * as Fe from "react";
import Tt, { forwardRef as fr, useContext as dr, createContext as wa, useLayoutEffect as ph, useEffect as dt, useState as ot, useRef as Ue, useMemo as gt, useCallback as re, useReducer as cJ, useInsertionEffect as j5, createElement as S_, useId as ko, cloneElement as ya, Children as Gc, isValidElement as hh, memo as G5, useSyncExternalStore as x_, PureComponent as dJ, Fragment as B0, Component as fJ, useImperativeHandle as pJ } from "react";
function hJ(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function mJ(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var vJ = /* @__PURE__ */ function() {
  function e(n) {
    var o = this;
    this._insertTag = function(a) {
      var l;
      o.tags.length === 0 ? o.insertionPoint ? l = o.insertionPoint.nextSibling : o.prepend ? l = o.container.firstChild : l = o.before : l = o.tags[o.tags.length - 1].nextSibling, o.container.insertBefore(a, l), o.tags.push(a);
    }, this.isSpeedy = n.speedy === void 0 ? process.env.NODE_ENV === "production" : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(o) {
    o.forEach(this._insertTag);
  }, t.insert = function(o) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(mJ(this));
    var a = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var l = o.charCodeAt(0) === 64 && o.charCodeAt(1) === 105;
      l && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + o + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !l;
    }
    if (this.isSpeedy) {
      var u = hJ(a);
      try {
        u.insertRule(o, u.cssRules.length);
      } catch (f) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(o) && console.error('There was a problem inserting the following rule: "' + o + '"', f);
      }
    } else
      a.appendChild(document.createTextNode(o));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(o) {
      return o.parentNode && o.parentNode.removeChild(o);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, e;
}(), Ci = "-ms-", _w = "-moz-", Hn = "-webkit-", C_ = "comm", w_ = "rule", E_ = "decl", gJ = "@import", W5 = "@keyframes", yJ = "@layer", bJ = Math.abs, DE = String.fromCharCode, SJ = Object.assign;
function xJ(e, t) {
  return ei(e, 0) ^ 45 ? (((t << 2 ^ ei(e, 0)) << 2 ^ ei(e, 1)) << 2 ^ ei(e, 2)) << 2 ^ ei(e, 3) : 0;
}
function U5(e) {
  return e.trim();
}
function CJ(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function jn(e, t, n) {
  return e.replace(t, n);
}
function DP(e, t) {
  return e.indexOf(t);
}
function ei(e, t) {
  return e.charCodeAt(t) | 0;
}
function V0(e, t, n) {
  return e.slice(t, n);
}
function lu(e) {
  return e.length;
}
function T_(e) {
  return e.length;
}
function yC(e, t) {
  return t.push(e), e;
}
function wJ(e, t) {
  return e.map(t).join("");
}
var NE = 1, ig = 1, X5 = 0, ba = 0, fo = 0, wg = "";
function ME(e, t, n, o, a, l, u) {
  return { value: e, root: t, parent: n, type: o, props: a, children: l, line: NE, column: ig, length: u, return: "" };
}
function Gb(e, t) {
  return SJ(ME("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function EJ() {
  return fo;
}
function TJ() {
  return fo = ba > 0 ? ei(wg, --ba) : 0, ig--, fo === 10 && (ig = 1, NE--), fo;
}
function ja() {
  return fo = ba < X5 ? ei(wg, ba++) : 0, ig++, fo === 10 && (ig = 1, NE++), fo;
}
function pu() {
  return ei(wg, ba);
}
function qC() {
  return ba;
}
function iS(e, t) {
  return V0(wg, e, t);
}
function $0(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Z5(e) {
  return NE = ig = 1, X5 = lu(wg = e), ba = 0, [];
}
function Y5(e) {
  return wg = "", e;
}
function ew(e) {
  return U5(iS(ba - 1, NP(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function IJ(e) {
  for (; (fo = pu()) && fo < 33; )
    ja();
  return $0(e) > 2 || $0(fo) > 3 ? "" : " ";
}
function AJ(e, t) {
  for (; --t && ja() && !(fo < 48 || fo > 102 || fo > 57 && fo < 65 || fo > 70 && fo < 97); )
    ;
  return iS(e, qC() + (t < 6 && pu() == 32 && ja() == 32));
}
function NP(e) {
  for (; ja(); )
    switch (fo) {
      case e:
        return ba;
      case 34:
      case 39:
        e !== 34 && e !== 39 && NP(fo);
        break;
      case 40:
        e === 41 && NP(e);
        break;
      case 92:
        ja();
        break;
    }
  return ba;
}
function kJ(e, t) {
  for (; ja() && e + fo !== 57; )
    if (e + fo === 84 && pu() === 47)
      break;
  return "/*" + iS(t, ba - 1) + "*" + DE(e === 47 ? e : ja());
}
function RJ(e) {
  for (; !$0(pu()); )
    ja();
  return iS(e, ba);
}
function PJ(e) {
  return Y5(tw("", null, null, null, [""], e = Z5(e), 0, [0], e));
}
function tw(e, t, n, o, a, l, u, f, h) {
  for (var v = 0, g = 0, b = u, S = 0, w = 0, E = 0, T = 1, A = 1, P = 1, _ = 0, D = "", L = a, F = l, V = o, $ = D; A; )
    switch (E = _, _ = ja()) {
      case 40:
        if (E != 108 && ei($, b - 1) == 58) {
          DP($ += jn(ew(_), "&", "&\f"), "&\f") != -1 && (P = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        $ += ew(_);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        $ += IJ(E);
        break;
      case 92:
        $ += AJ(qC() - 1, 7);
        continue;
      case 47:
        switch (pu()) {
          case 42:
          case 47:
            yC(OJ(kJ(ja(), qC()), t, n), h);
            break;
          default:
            $ += "/";
        }
        break;
      case 123 * T:
        f[v++] = lu($) * P;
      case 125 * T:
      case 59:
      case 0:
        switch (_) {
          case 0:
          case 125:
            A = 0;
          case 59 + g:
            P == -1 && ($ = jn($, /\f/g, "")), w > 0 && lu($) - b && yC(w > 32 ? RF($ + ";", o, n, b - 1) : RF(jn($, " ", "") + ";", o, n, b - 2), h);
            break;
          case 59:
            $ += ";";
          default:
            if (yC(V = kF($, t, n, v, g, a, f, D, L = [], F = [], b), l), _ === 123)
              if (g === 0)
                tw($, t, V, V, L, l, b, f, F);
              else
                switch (S === 99 && ei($, 3) === 110 ? 100 : S) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    tw(e, V, V, o && yC(kF(e, V, V, 0, 0, a, f, D, a, L = [], b), F), a, F, b, f, o ? L : F);
                    break;
                  default:
                    tw($, V, V, V, [""], F, 0, f, F);
                }
        }
        v = g = w = 0, T = P = 1, D = $ = "", b = u;
        break;
      case 58:
        b = 1 + lu($), w = E;
      default:
        if (T < 1) {
          if (_ == 123)
            --T;
          else if (_ == 125 && T++ == 0 && TJ() == 125)
            continue;
        }
        switch ($ += DE(_), _ * T) {
          case 38:
            P = g > 0 ? 1 : ($ += "\f", -1);
            break;
          case 44:
            f[v++] = (lu($) - 1) * P, P = 1;
            break;
          case 64:
            pu() === 45 && ($ += ew(ja())), S = pu(), g = b = lu(D = $ += RJ(qC())), _++;
            break;
          case 45:
            E === 45 && lu($) == 2 && (T = 0);
        }
    }
  return l;
}
function kF(e, t, n, o, a, l, u, f, h, v, g) {
  for (var b = a - 1, S = a === 0 ? l : [""], w = T_(S), E = 0, T = 0, A = 0; E < o; ++E)
    for (var P = 0, _ = V0(e, b + 1, b = bJ(T = u[E])), D = e; P < w; ++P)
      (D = U5(T > 0 ? S[P] + " " + _ : jn(_, /&\f/g, S[P]))) && (h[A++] = D);
  return ME(e, t, n, a === 0 ? w_ : f, h, v, g);
}
function OJ(e, t, n) {
  return ME(e, t, n, C_, DE(EJ()), V0(e, 2, -2), 0);
}
function RF(e, t, n, o) {
  return ME(e, t, n, E_, V0(e, 0, o), V0(e, o + 1, -1), o);
}
function jv(e, t) {
  for (var n = "", o = T_(e), a = 0; a < o; a++)
    n += t(e[a], a, e, t) || "";
  return n;
}
function _J(e, t, n, o) {
  switch (e.type) {
    case yJ:
      if (e.children.length)
        break;
    case gJ:
    case E_:
      return e.return = e.return || e.value;
    case C_:
      return "";
    case W5:
      return e.return = e.value + "{" + jv(e.children, o) + "}";
    case w_:
      e.value = e.props.join(",");
  }
  return lu(n = jv(e.children, o)) ? e.return = e.value + "{" + n + "}" : "";
}
function DJ(e) {
  var t = T_(e);
  return function(n, o, a, l) {
    for (var u = "", f = 0; f < t; f++)
      u += e[f](n, o, a, l) || "";
    return u;
  };
}
function NJ(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
var PF = function(t) {
  var n = /* @__PURE__ */ new WeakMap();
  return function(o) {
    if (n.has(o))
      return n.get(o);
    var a = t(o);
    return n.set(o, a), a;
  };
};
function J5(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var MJ = function(t, n, o) {
  for (var a = 0, l = 0; a = l, l = pu(), a === 38 && l === 12 && (n[o] = 1), !$0(l); )
    ja();
  return iS(t, ba);
}, LJ = function(t, n) {
  var o = -1, a = 44;
  do
    switch ($0(a)) {
      case 0:
        a === 38 && pu() === 12 && (n[o] = 1), t[o] += MJ(ba - 1, n, o);
        break;
      case 2:
        t[o] += ew(a);
        break;
      case 4:
        if (a === 44) {
          t[++o] = pu() === 58 ? "&\f" : "", n[o] = t[o].length;
          break;
        }
      default:
        t[o] += DE(a);
    }
  while (a = ja());
  return t;
}, FJ = function(t, n) {
  return Y5(LJ(Z5(t), n));
}, OF = /* @__PURE__ */ new WeakMap(), BJ = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, o = t.parent, a = t.column === o.column && t.line === o.line; o.type !== "rule"; )
      if (o = o.parent, !o)
        return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !OF.get(o)) && !a) {
      OF.set(t, !0);
      for (var l = [], u = FJ(n, l), f = o.props, h = 0, v = 0; h < u.length; h++)
        for (var g = 0; g < f.length; g++, v++)
          t.props[v] = l[h] ? u[h].replace(/&\f/g, f[g]) : f[g] + " " + u[h];
    }
  }
}, VJ = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
}, $J = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", zJ = function(t) {
  return t.type === "comm" && t.children.indexOf($J) > -1;
}, HJ = function(t) {
  return function(n, o, a) {
    if (!(n.type !== "rule" || t.compat)) {
      var l = n.value.match(/(:first|:nth|:nth-last)-child/g);
      if (l) {
        for (var u = !!n.parent, f = u ? n.parent.children : (
          // global rule at the root level
          a
        ), h = f.length - 1; h >= 0; h--) {
          var v = f[h];
          if (v.line < n.line)
            break;
          if (v.column < n.column) {
            if (zJ(v))
              return;
            break;
          }
        }
        l.forEach(function(g) {
          console.error('The pseudo class "' + g + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + g.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, Q5 = function(t) {
  return t.type.charCodeAt(1) === 105 && t.type.charCodeAt(0) === 64;
}, jJ = function(t, n) {
  for (var o = t - 1; o >= 0; o--)
    if (!Q5(n[o]))
      return !0;
  return !1;
}, _F = function(t) {
  t.type = "", t.value = "", t.return = "", t.children = "", t.props = "";
}, GJ = function(t, n, o) {
  Q5(t) && (t.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), _F(t)) : jJ(n, o) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), _F(t)));
};
function K5(e, t) {
  switch (xJ(e, t)) {
    case 5103:
      return Hn + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Hn + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Hn + e + _w + e + Ci + e + e;
    case 6828:
    case 4268:
      return Hn + e + Ci + e + e;
    case 6165:
      return Hn + e + Ci + "flex-" + e + e;
    case 5187:
      return Hn + e + jn(e, /(\w+).+(:[^]+)/, Hn + "box-$1$2" + Ci + "flex-$1$2") + e;
    case 5443:
      return Hn + e + Ci + "flex-item-" + jn(e, /flex-|-self/, "") + e;
    case 4675:
      return Hn + e + Ci + "flex-line-pack" + jn(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return Hn + e + Ci + jn(e, "shrink", "negative") + e;
    case 5292:
      return Hn + e + Ci + jn(e, "basis", "preferred-size") + e;
    case 6060:
      return Hn + "box-" + jn(e, "-grow", "") + Hn + e + Ci + jn(e, "grow", "positive") + e;
    case 4554:
      return Hn + jn(e, /([^-])(transform)/g, "$1" + Hn + "$2") + e;
    case 6187:
      return jn(jn(jn(e, /(zoom-|grab)/, Hn + "$1"), /(image-set)/, Hn + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return jn(e, /(image-set\([^]*)/, Hn + "$1$`$1");
    case 4968:
      return jn(jn(e, /(.+:)(flex-)?(.*)/, Hn + "box-pack:$3" + Ci + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Hn + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return jn(e, /(.+)-inline(.+)/, Hn + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (lu(e) - 1 - t > 6)
        switch (ei(e, t + 1)) {
          case 109:
            if (ei(e, t + 4) !== 45)
              break;
          case 102:
            return jn(e, /(.+:)(.+)-([^]+)/, "$1" + Hn + "$2-$3$1" + _w + (ei(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~DP(e, "stretch") ? K5(jn(e, "stretch", "fill-available"), t) + e : e;
        }
      break;
    case 4949:
      if (ei(e, t + 1) !== 115)
        break;
    case 6444:
      switch (ei(e, lu(e) - 3 - (~DP(e, "!important") && 10))) {
        case 107:
          return jn(e, ":", ":" + Hn) + e;
        case 101:
          return jn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Hn + (ei(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Hn + "$2$3$1" + Ci + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (ei(e, t + 11)) {
        case 114:
          return Hn + e + Ci + jn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Hn + e + Ci + jn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Hn + e + Ci + jn(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Hn + e + Ci + e + e;
  }
  return e;
}
var WJ = function(t, n, o, a) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case E_:
        t.return = K5(t.value, t.length);
        break;
      case W5:
        return jv([Gb(t, {
          value: jn(t.value, "@", "@" + Hn)
        })], a);
      case w_:
        if (t.length)
          return wJ(t.props, function(l) {
            switch (CJ(l, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return jv([Gb(t, {
                  props: [jn(l, /:(read-\w+)/, ":" + _w + "$1")]
                })], a);
              case "::placeholder":
                return jv([Gb(t, {
                  props: [jn(l, /:(plac\w+)/, ":" + Hn + "input-$1")]
                }), Gb(t, {
                  props: [jn(l, /:(plac\w+)/, ":" + _w + "$1")]
                }), Gb(t, {
                  props: [jn(l, /:(plac\w+)/, Ci + "input-$1")]
                })], a);
            }
            return "";
          });
    }
}, UJ = [WJ], XJ = function(t) {
  var n = t.key;
  if (process.env.NODE_ENV !== "production" && !n)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (n === "css") {
    var o = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(o, function(T) {
      var A = T.getAttribute("data-emotion");
      A.indexOf(" ") !== -1 && (document.head.appendChild(T), T.setAttribute("data-s", ""));
    });
  }
  var a = t.stylisPlugins || UJ;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(n))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + n + '" was passed');
  var l = {}, u, f = [];
  u = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(T) {
      for (var A = T.getAttribute("data-emotion").split(" "), P = 1; P < A.length; P++)
        l[A[P]] = !0;
      f.push(T);
    }
  );
  var h, v = [BJ, VJ];
  process.env.NODE_ENV !== "production" && v.push(HJ({
    get compat() {
      return E.compat;
    }
  }), GJ);
  {
    var g, b = [_J, process.env.NODE_ENV !== "production" ? function(T) {
      T.root || (T.return ? g.insert(T.return) : T.value && T.type !== C_ && g.insert(T.value + "{}"));
    } : NJ(function(T) {
      g.insert(T);
    })], S = DJ(v.concat(a, b)), w = function(A) {
      return jv(PJ(A), S);
    };
    h = function(A, P, _, D) {
      g = _, process.env.NODE_ENV !== "production" && P.map !== void 0 && (g = {
        insert: function(F) {
          _.insert(F + P.map);
        }
      }), w(A ? A + "{" + P.styles + "}" : P.styles), D && (E.inserted[P.name] = !0);
    };
  }
  var E = {
    key: n,
    sheet: new vJ({
      key: n,
      container: u,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: l,
    registered: {},
    insert: h
  };
  return E.sheet.hydrate(f), E;
};
function Dt() {
  return Dt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Dt.apply(this, arguments);
}
var bC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function I_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var MP = { exports: {} }, Jn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DF;
function ZJ() {
  return DF || (DF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, o = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, l = e ? Symbol.for("react.profiler") : 60114, u = e ? Symbol.for("react.provider") : 60109, f = e ? Symbol.for("react.context") : 60110, h = e ? Symbol.for("react.async_mode") : 60111, v = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, S = e ? Symbol.for("react.suspense_list") : 60120, w = e ? Symbol.for("react.memo") : 60115, E = e ? Symbol.for("react.lazy") : 60116, T = e ? Symbol.for("react.block") : 60121, A = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, _ = e ? Symbol.for("react.scope") : 60119;
    function D(fe) {
      return typeof fe == "string" || typeof fe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      fe === o || fe === v || fe === l || fe === a || fe === b || fe === S || typeof fe == "object" && fe !== null && (fe.$$typeof === E || fe.$$typeof === w || fe.$$typeof === u || fe.$$typeof === f || fe.$$typeof === g || fe.$$typeof === A || fe.$$typeof === P || fe.$$typeof === _ || fe.$$typeof === T);
    }
    function L(fe) {
      if (typeof fe == "object" && fe !== null) {
        var ze = fe.$$typeof;
        switch (ze) {
          case t:
            var Ve = fe.type;
            switch (Ve) {
              case h:
              case v:
              case o:
              case l:
              case a:
              case b:
                return Ve;
              default:
                var Ie = Ve && Ve.$$typeof;
                switch (Ie) {
                  case f:
                  case g:
                  case E:
                  case w:
                  case u:
                    return Ie;
                  default:
                    return ze;
                }
            }
          case n:
            return ze;
        }
      }
    }
    var F = h, V = v, $ = f, U = u, W = t, H = g, G = o, oe = E, ce = w, te = n, Ee = l, me = a, J = b, Q = !1;
    function ge(fe) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Y(fe) || L(fe) === h;
    }
    function Y(fe) {
      return L(fe) === v;
    }
    function q(fe) {
      return L(fe) === f;
    }
    function de(fe) {
      return L(fe) === u;
    }
    function K(fe) {
      return typeof fe == "object" && fe !== null && fe.$$typeof === t;
    }
    function ne(fe) {
      return L(fe) === g;
    }
    function pe(fe) {
      return L(fe) === o;
    }
    function Oe(fe) {
      return L(fe) === E;
    }
    function Ce(fe) {
      return L(fe) === w;
    }
    function xe(fe) {
      return L(fe) === n;
    }
    function ie(fe) {
      return L(fe) === l;
    }
    function ye(fe) {
      return L(fe) === a;
    }
    function we(fe) {
      return L(fe) === b;
    }
    Jn.AsyncMode = F, Jn.ConcurrentMode = V, Jn.ContextConsumer = $, Jn.ContextProvider = U, Jn.Element = W, Jn.ForwardRef = H, Jn.Fragment = G, Jn.Lazy = oe, Jn.Memo = ce, Jn.Portal = te, Jn.Profiler = Ee, Jn.StrictMode = me, Jn.Suspense = J, Jn.isAsyncMode = ge, Jn.isConcurrentMode = Y, Jn.isContextConsumer = q, Jn.isContextProvider = de, Jn.isElement = K, Jn.isForwardRef = ne, Jn.isFragment = pe, Jn.isLazy = Oe, Jn.isMemo = Ce, Jn.isPortal = xe, Jn.isProfiler = ie, Jn.isStrictMode = ye, Jn.isSuspense = we, Jn.isValidElementType = D, Jn.typeOf = L;
  }()), Jn;
}
var Qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NF;
function YJ() {
  if (NF)
    return Qn;
  NF = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, o = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, l = e ? Symbol.for("react.profiler") : 60114, u = e ? Symbol.for("react.provider") : 60109, f = e ? Symbol.for("react.context") : 60110, h = e ? Symbol.for("react.async_mode") : 60111, v = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, S = e ? Symbol.for("react.suspense_list") : 60120, w = e ? Symbol.for("react.memo") : 60115, E = e ? Symbol.for("react.lazy") : 60116, T = e ? Symbol.for("react.block") : 60121, A = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, _ = e ? Symbol.for("react.scope") : 60119;
  function D(F) {
    if (typeof F == "object" && F !== null) {
      var V = F.$$typeof;
      switch (V) {
        case t:
          switch (F = F.type, F) {
            case h:
            case v:
            case o:
            case l:
            case a:
            case b:
              return F;
            default:
              switch (F = F && F.$$typeof, F) {
                case f:
                case g:
                case E:
                case w:
                case u:
                  return F;
                default:
                  return V;
              }
          }
        case n:
          return V;
      }
    }
  }
  function L(F) {
    return D(F) === v;
  }
  return Qn.AsyncMode = h, Qn.ConcurrentMode = v, Qn.ContextConsumer = f, Qn.ContextProvider = u, Qn.Element = t, Qn.ForwardRef = g, Qn.Fragment = o, Qn.Lazy = E, Qn.Memo = w, Qn.Portal = n, Qn.Profiler = l, Qn.StrictMode = a, Qn.Suspense = b, Qn.isAsyncMode = function(F) {
    return L(F) || D(F) === h;
  }, Qn.isConcurrentMode = L, Qn.isContextConsumer = function(F) {
    return D(F) === f;
  }, Qn.isContextProvider = function(F) {
    return D(F) === u;
  }, Qn.isElement = function(F) {
    return typeof F == "object" && F !== null && F.$$typeof === t;
  }, Qn.isForwardRef = function(F) {
    return D(F) === g;
  }, Qn.isFragment = function(F) {
    return D(F) === o;
  }, Qn.isLazy = function(F) {
    return D(F) === E;
  }, Qn.isMemo = function(F) {
    return D(F) === w;
  }, Qn.isPortal = function(F) {
    return D(F) === n;
  }, Qn.isProfiler = function(F) {
    return D(F) === l;
  }, Qn.isStrictMode = function(F) {
    return D(F) === a;
  }, Qn.isSuspense = function(F) {
    return D(F) === b;
  }, Qn.isValidElementType = function(F) {
    return typeof F == "string" || typeof F == "function" || F === o || F === v || F === l || F === a || F === b || F === S || typeof F == "object" && F !== null && (F.$$typeof === E || F.$$typeof === w || F.$$typeof === u || F.$$typeof === f || F.$$typeof === g || F.$$typeof === A || F.$$typeof === P || F.$$typeof === _ || F.$$typeof === T);
  }, Qn.typeOf = D, Qn;
}
process.env.NODE_ENV === "production" ? MP.exports = YJ() : MP.exports = ZJ();
var A_ = MP.exports, q5 = A_, JJ = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, QJ = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, e4 = {};
e4[q5.ForwardRef] = JJ;
e4[q5.Memo] = QJ;
var KJ = !0;
function k_(e, t, n) {
  var o = "";
  return n.split(" ").forEach(function(a) {
    e[a] !== void 0 ? t.push(e[a] + ";") : o += a + " ";
  }), o;
}
var LE = function(t, n, o) {
  var a = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (o === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  KJ === !1) && t.registered[a] === void 0 && (t.registered[a] = n.styles);
}, FE = function(t, n, o) {
  LE(t, n, o);
  var a = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var l = n;
    do
      t.insert(n === l ? "." + a : "", l, t.sheet, !0), l = l.next;
    while (l !== void 0);
  }
};
function qJ(e) {
  for (var t = 0, n, o = 0, a = e.length; a >= 4; ++o, a -= 4)
    n = e.charCodeAt(o) & 255 | (e.charCodeAt(++o) & 255) << 8 | (e.charCodeAt(++o) & 255) << 16 | (e.charCodeAt(++o) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(o) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var eQ = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, MF = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, tQ = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", nQ = /[A-Z]|^ms/g, t4 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, R_ = function(t) {
  return t.charCodeAt(1) === 45;
}, LF = function(t) {
  return t != null && typeof t != "boolean";
}, uR = /* @__PURE__ */ J5(function(e) {
  return R_(e) ? e : e.replace(nQ, "-$&").toLowerCase();
}), Dw = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(t4, function(o, a, l) {
          return hl = {
            name: a,
            styles: l,
            next: hl
          }, a;
        });
  }
  return eQ[t] !== 1 && !R_(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
if (process.env.NODE_ENV !== "production") {
  var rQ = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, oQ = ["normal", "none", "initial", "inherit", "unset"], iQ = Dw, aQ = /^-ms-/, sQ = /-(.)/g, FF = {};
  Dw = function(t, n) {
    if (t === "content" && (typeof n != "string" || oQ.indexOf(n) === -1 && !rQ.test(n) && (n.charAt(0) !== n.charAt(n.length - 1) || n.charAt(0) !== '"' && n.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + n + "\"'`");
    var o = iQ(t, n);
    return o !== "" && !R_(t) && t.indexOf("-") !== -1 && FF[t] === void 0 && (FF[t] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + t.replace(aQ, "ms-").replace(sQ, function(a, l) {
      return l.toUpperCase();
    }) + "?")), o;
  };
}
var n4 = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function z0(e, t, n) {
  if (n == null)
    return "";
  if (n.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && n.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(n4);
    return n;
  }
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      if (n.anim === 1)
        return hl = {
          name: n.name,
          styles: n.styles,
          next: hl
        }, n.name;
      if (n.styles !== void 0) {
        var o = n.next;
        if (o !== void 0)
          for (; o !== void 0; )
            hl = {
              name: o.name,
              styles: o.styles,
              next: hl
            }, o = o.next;
        var a = n.styles + ";";
        return process.env.NODE_ENV !== "production" && n.map !== void 0 && (a += n.map), a;
      }
      return lQ(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var l = hl, u = n(e);
        return hl = l, z0(e, t, u);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var f = [], h = n.replace(t4, function(g, b, S) {
          var w = "animation" + f.length;
          return f.push("const " + w + " = keyframes`" + S.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + w + "}";
        });
        f.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(f, ["`" + h + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + h + "`"));
      }
      break;
  }
  if (t == null)
    return n;
  var v = t[n];
  return v !== void 0 ? v : n;
}
function lQ(e, t, n) {
  var o = "";
  if (Array.isArray(n))
    for (var a = 0; a < n.length; a++)
      o += z0(e, t, n[a]) + ";";
  else
    for (var l in n) {
      var u = n[l];
      if (typeof u != "object")
        t != null && t[u] !== void 0 ? o += l + "{" + t[u] + "}" : LF(u) && (o += uR(l) + ":" + Dw(l, u) + ";");
      else {
        if (l === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(n4);
        if (Array.isArray(u) && typeof u[0] == "string" && (t == null || t[u[0]] === void 0))
          for (var f = 0; f < u.length; f++)
            LF(u[f]) && (o += uR(l) + ":" + Dw(l, u[f]) + ";");
        else {
          var h = z0(e, t, u);
          switch (l) {
            case "animation":
            case "animationName": {
              o += uR(l) + ":" + h + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && l === "undefined" && console.error(tQ), o += l + "{" + h + "}";
          }
        }
      }
    }
  return o;
}
var BF = /label:\s*([^\s;\n{]+)\s*(;|$)/g, r4;
process.env.NODE_ENV !== "production" && (r4 = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var hl, ag = function(t, n, o) {
  if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
    return t[0];
  var a = !0, l = "";
  hl = void 0;
  var u = t[0];
  u == null || u.raw === void 0 ? (a = !1, l += z0(o, n, u)) : (process.env.NODE_ENV !== "production" && u[0] === void 0 && console.error(MF), l += u[0]);
  for (var f = 1; f < t.length; f++)
    l += z0(o, n, t[f]), a && (process.env.NODE_ENV !== "production" && u[f] === void 0 && console.error(MF), l += u[f]);
  var h;
  process.env.NODE_ENV !== "production" && (l = l.replace(r4, function(S) {
    return h = S, "";
  })), BF.lastIndex = 0;
  for (var v = "", g; (g = BF.exec(l)) !== null; )
    v += "-" + // $FlowFixMe we know it's not null
    g[1];
  var b = qJ(l) + v;
  return process.env.NODE_ENV !== "production" ? {
    name: b,
    styles: l,
    map: h,
    next: hl,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: b,
    styles: l,
    next: hl
  };
}, uQ = function(t) {
  return t();
}, o4 = Fe.useInsertionEffect ? Fe.useInsertionEffect : !1, P_ = o4 || uQ, VF = o4 || Fe.useLayoutEffect, O_ = {}.hasOwnProperty, __ = /* @__PURE__ */ Fe.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ XJ({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (__.displayName = "EmotionCacheContext");
__.Provider;
var BE = function(t) {
  return /* @__PURE__ */ fr(function(n, o) {
    var a = dr(__);
    return t(n, a, o);
  });
}, df = /* @__PURE__ */ Fe.createContext({});
process.env.NODE_ENV !== "production" && (df.displayName = "EmotionThemeContext");
var cQ = function(t, n) {
  if (typeof n == "function") {
    var o = n(t);
    if (process.env.NODE_ENV !== "production" && (o == null || typeof o != "object" || Array.isArray(o)))
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    return o;
  }
  if (process.env.NODE_ENV !== "production" && (n == null || typeof n != "object" || Array.isArray(n)))
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  return Dt({}, t, n);
}, dQ = /* @__PURE__ */ PF(function(e) {
  return PF(function(t) {
    return cQ(e, t);
  });
}), fQ = function(t) {
  var n = Fe.useContext(df);
  return t.theme !== n && (n = dQ(n)(t.theme)), /* @__PURE__ */ Fe.createElement(df.Provider, {
    value: n
  }, t.children);
}, $F = function(t) {
  var n = t.split(".");
  return n[n.length - 1];
}, pQ = function(t) {
  var n = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(t);
  if (n || (n = /^([A-Za-z0-9$.]+)@/.exec(t), n))
    return $F(n[1]);
}, hQ = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]), mQ = function(t) {
  return t.replace(/\$/g, "-");
}, vQ = function(t) {
  if (t)
    for (var n = t.split(`
`), o = 0; o < n.length; o++) {
      var a = pQ(n[o]);
      if (a) {
        if (hQ.has(a))
          break;
        if (/^[A-Z]/.test(a))
          return mQ(a);
      }
    }
}, LP = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", FP = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", gQ = function(t, n) {
  if (process.env.NODE_ENV !== "production" && typeof n.css == "string" && // check if there is a css declaration
  n.css.indexOf(":") !== -1)
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + n.css + "`");
  var o = {};
  for (var a in n)
    O_.call(n, a) && (o[a] = n[a]);
  if (o[LP] = t, process.env.NODE_ENV !== "production" && n.css && (typeof n.css != "object" || typeof n.css.name != "string" || n.css.name.indexOf("-") === -1)) {
    var l = vQ(new Error().stack);
    l && (o[FP] = l);
  }
  return o;
}, yQ = function(t) {
  var n = t.cache, o = t.serialized, a = t.isStringTag;
  return LE(n, o, a), P_(function() {
    return FE(n, o, a);
  }), null;
}, i4 = /* @__PURE__ */ BE(function(e, t, n) {
  var o = e.css;
  typeof o == "string" && t.registered[o] !== void 0 && (o = t.registered[o]);
  var a = e[LP], l = [o], u = "";
  typeof e.className == "string" ? u = k_(t.registered, l, e.className) : e.className != null && (u = e.className + " ");
  var f = ag(l, void 0, Fe.useContext(df));
  if (process.env.NODE_ENV !== "production" && f.name.indexOf("-") === -1) {
    var h = e[FP];
    h && (f = ag([f, "label:" + h + ";"]));
  }
  u += t.key + "-" + f.name;
  var v = {};
  for (var g in e)
    O_.call(e, g) && g !== "css" && g !== LP && (process.env.NODE_ENV === "production" || g !== FP) && (v[g] = e[g]);
  return v.ref = n, v.className = u, /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, /* @__PURE__ */ Fe.createElement(yQ, {
    cache: t,
    serialized: f,
    isStringTag: typeof a == "string"
  }), /* @__PURE__ */ Fe.createElement(a, v));
});
process.env.NODE_ENV !== "production" && (i4.displayName = "EmotionCssPropInternal");
var bQ = i4, SQ = {
  name: "@emotion/react",
  version: "11.11.3",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.2",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, Ht = function(t, n) {
  var o = arguments;
  if (n == null || !O_.call(n, "css"))
    return Fe.createElement.apply(void 0, o);
  var a = o.length, l = new Array(a);
  l[0] = bQ, l[1] = gQ(t, n);
  for (var u = 2; u < a; u++)
    l[u] = o[u];
  return Fe.createElement.apply(null, l);
}, zF = !1, aS = /* @__PURE__ */ BE(function(e, t) {
  process.env.NODE_ENV !== "production" && !zF && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (e.className || e.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), zF = !0);
  var n = e.styles, o = ag([n], void 0, Fe.useContext(df)), a = Fe.useRef();
  return VF(function() {
    var l = t.key + "-global", u = new t.sheet.constructor({
      key: l,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), f = !1, h = document.querySelector('style[data-emotion="' + l + " " + o.name + '"]');
    return t.sheet.tags.length && (u.before = t.sheet.tags[0]), h !== null && (f = !0, h.setAttribute("data-emotion", l), u.hydrate([h])), a.current = [u, f], function() {
      u.flush();
    };
  }, [t]), VF(function() {
    var l = a.current, u = l[0], f = l[1];
    if (f) {
      l[1] = !1;
      return;
    }
    if (o.next !== void 0 && FE(t, o.next, !0), u.tags.length) {
      var h = u.tags[u.tags.length - 1].nextElementSibling;
      u.before = h, u.flush();
    }
    t.insert("", o, u, !1);
  }, [t, o.name]), null;
});
process.env.NODE_ENV !== "production" && (aS.displayName = "EmotionGlobal");
function D_() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return ag(t);
}
var Ps = function() {
  var t = D_.apply(void 0, arguments), n = "animation-" + t.name;
  return {
    name: n,
    styles: "@keyframes " + n + "{" + t.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, xQ = function e(t) {
  for (var n = t.length, o = 0, a = ""; o < n; o++) {
    var l = t[o];
    if (l != null) {
      var u = void 0;
      switch (typeof l) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(l))
            u = e(l);
          else {
            process.env.NODE_ENV !== "production" && l.styles !== void 0 && l.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), u = "";
            for (var f in l)
              l[f] && f && (u && (u += " "), u += f);
          }
          break;
        }
        default:
          u = l;
      }
      u && (a && (a += " "), a += u);
    }
  }
  return a;
};
function CQ(e, t, n) {
  var o = [], a = k_(e, o, n);
  return o.length < 2 ? n : a + t(o);
}
var wQ = function(t) {
  var n = t.cache, o = t.serializedArr;
  return P_(function() {
    for (var a = 0; a < o.length; a++)
      FE(n, o[a], !1);
  }), null;
}, EQ = /* @__PURE__ */ BE(function(e, t) {
  var n = !1, o = [], a = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var v = arguments.length, g = new Array(v), b = 0; b < v; b++)
      g[b] = arguments[b];
    var S = ag(g, t.registered);
    return o.push(S), LE(t, S, !1), t.key + "-" + S.name;
  }, l = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var v = arguments.length, g = new Array(v), b = 0; b < v; b++)
      g[b] = arguments[b];
    return CQ(t.registered, a, xQ(g));
  }, u = {
    css: a,
    cx: l,
    theme: Fe.useContext(df)
  }, f = e.children(u);
  return n = !0, /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, /* @__PURE__ */ Fe.createElement(wQ, {
    cache: t,
    serializedArr: o
  }), f);
});
process.env.NODE_ENV !== "production" && (EQ.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var HF = !0, TQ = typeof jest < "u" || typeof vi < "u";
  if (HF && !TQ) {
    var jF = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : HF ? window : global
    ), GF = "__EMOTION_REACT_" + SQ.version.split(".")[0] + "__";
    jF[GF] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), jF[GF] = !0;
  }
}
var a4 = String.raw, s4 = a4`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, IQ = () => /* @__PURE__ */ M(aS, { styles: s4 }), AQ = ({ scope: e = "" }) => /* @__PURE__ */ M(
  aS,
  {
    styles: a4`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${e} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${e} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${e} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${e} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${e} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${e} :where(b, strong) {
        font-weight: bold;
      }

      ${e} small {
        font-size: 80%;
      }

      ${e} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${e} sub {
        bottom: -0.25em;
      }

      ${e} sup {
        top: -0.5em;
      }

      ${e} img {
        border-style: none;
      }

      ${e} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${e} :where(button, input) {
        overflow: visible;
      }

      ${e} :where(button, select) {
        text-transform: none;
      }

      ${e} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${e} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${e} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${e} progress {
        vertical-align: baseline;
      }

      ${e} textarea {
        overflow: auto;
      }

      ${e} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${e} input[type="number"]::-webkit-inner-spin-button,
      ${e} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${e} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${e} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${e} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${e} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${e} details {
        display: block;
      }

      ${e} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${e} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${e} button {
        background: transparent;
        padding: 0;
      }

      ${e} fieldset {
        margin: 0;
        padding: 0;
      }

      ${e} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${e} textarea {
        resize: vertical;
      }

      ${e} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${e} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${e} table {
        border-collapse: collapse;
      }

      ${e} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${e} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${e} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${e} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${e} select::-ms-expand {
        display: none;
      }

      ${s4}
    `
  }
);
function kQ(e, t) {
  return `${e} returned \`undefined\`. Seems you forgot to wrap component within ${t}`;
}
function En(e = {}) {
  const {
    name: t,
    strict: n = !0,
    hookName: o = "useContext",
    providerName: a = "Provider",
    errorMessage: l,
    defaultValue: u
  } = e, f = wa(u);
  f.displayName = t;
  function h() {
    var v;
    const g = dr(f);
    if (!g && n) {
      const b = new Error(
        l ?? kQ(o, a)
      );
      throw b.name = "ContextError", (v = Error.captureStackTrace) == null || v.call(Error, b, h), b;
    }
    return g;
  }
  return [f.Provider, h, f];
}
var [RQ, PQ] = En({
  strict: !1,
  name: "PortalManagerContext"
});
function l4(e) {
  const { children: t, zIndex: n } = e;
  return /* @__PURE__ */ M(RQ, { value: { zIndex: n }, children: t });
}
l4.displayName = "PortalManager";
var Ss = globalThis != null && globalThis.document ? ph : dt, BP = { exports: {} }, da = {}, SC = { exports: {} }, cR = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WF;
function OQ() {
  return WF || (WF = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, o = 5;
      function a(Xe, _e) {
        var Je = Xe.length;
        Xe.push(_e), f(Xe, _e, Je);
      }
      function l(Xe) {
        return Xe.length === 0 ? null : Xe[0];
      }
      function u(Xe) {
        if (Xe.length === 0)
          return null;
        var _e = Xe[0], Je = Xe.pop();
        return Je !== _e && (Xe[0] = Je, h(Xe, Je, 0)), _e;
      }
      function f(Xe, _e, Je) {
        for (var Kt = Je; Kt > 0; ) {
          var He = Kt - 1 >>> 1, tt = Xe[He];
          if (v(tt, _e) > 0)
            Xe[He] = _e, Xe[Kt] = tt, Kt = He;
          else
            return;
        }
      }
      function h(Xe, _e, Je) {
        for (var Kt = Je, He = Xe.length, tt = He >>> 1; Kt < tt; ) {
          var ft = (Kt + 1) * 2 - 1, mt = Xe[ft], kt = ft + 1, Mn = Xe[kt];
          if (v(mt, _e) < 0)
            kt < He && v(Mn, mt) < 0 ? (Xe[Kt] = Mn, Xe[kt] = _e, Kt = kt) : (Xe[Kt] = mt, Xe[ft] = _e, Kt = ft);
          else if (kt < He && v(Mn, _e) < 0)
            Xe[Kt] = Mn, Xe[kt] = _e, Kt = kt;
          else
            return;
        }
      }
      function v(Xe, _e) {
        var Je = Xe.sortIndex - _e.sortIndex;
        return Je !== 0 ? Je : Xe.id - _e.id;
      }
      var g = 1, b = 2, S = 3, w = 4, E = 5;
      function T(Xe, _e) {
      }
      var A = typeof performance == "object" && typeof performance.now == "function";
      if (A) {
        var P = performance;
        e.unstable_now = function() {
          return P.now();
        };
      } else {
        var _ = Date, D = _.now();
        e.unstable_now = function() {
          return _.now() - D;
        };
      }
      var L = 1073741823, F = -1, V = 250, $ = 5e3, U = 1e4, W = L, H = [], G = [], oe = 1, ce = null, te = S, Ee = !1, me = !1, J = !1, Q = typeof setTimeout == "function" ? setTimeout : null, ge = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function q(Xe) {
        for (var _e = l(G); _e !== null; ) {
          if (_e.callback === null)
            u(G);
          else if (_e.startTime <= Xe)
            u(G), _e.sortIndex = _e.expirationTime, a(H, _e);
          else
            return;
          _e = l(G);
        }
      }
      function de(Xe) {
        if (J = !1, q(Xe), !me)
          if (l(H) !== null)
            me = !0, un(K);
          else {
            var _e = l(G);
            _e !== null && Tn(de, _e.startTime - Xe);
          }
      }
      function K(Xe, _e) {
        me = !1, J && (J = !1, je()), Ee = !0;
        var Je = te;
        try {
          var Kt;
          if (!n)
            return ne(Xe, _e);
        } finally {
          ce = null, te = Je, Ee = !1;
        }
      }
      function ne(Xe, _e) {
        var Je = _e;
        for (q(Je), ce = l(H); ce !== null && !t && !(ce.expirationTime > Je && (!Xe || tn())); ) {
          var Kt = ce.callback;
          if (typeof Kt == "function") {
            ce.callback = null, te = ce.priorityLevel;
            var He = ce.expirationTime <= Je, tt = Kt(He);
            Je = e.unstable_now(), typeof tt == "function" ? ce.callback = tt : ce === l(H) && u(H), q(Je);
          } else
            u(H);
          ce = l(H);
        }
        if (ce !== null)
          return !0;
        var ft = l(G);
        return ft !== null && Tn(de, ft.startTime - Je), !1;
      }
      function pe(Xe, _e) {
        switch (Xe) {
          case g:
          case b:
          case S:
          case w:
          case E:
            break;
          default:
            Xe = S;
        }
        var Je = te;
        te = Xe;
        try {
          return _e();
        } finally {
          te = Je;
        }
      }
      function Oe(Xe) {
        var _e;
        switch (te) {
          case g:
          case b:
          case S:
            _e = S;
            break;
          default:
            _e = te;
            break;
        }
        var Je = te;
        te = _e;
        try {
          return Xe();
        } finally {
          te = Je;
        }
      }
      function Ce(Xe) {
        var _e = te;
        return function() {
          var Je = te;
          te = _e;
          try {
            return Xe.apply(this, arguments);
          } finally {
            te = Je;
          }
        };
      }
      function xe(Xe, _e, Je) {
        var Kt = e.unstable_now(), He;
        if (typeof Je == "object" && Je !== null) {
          var tt = Je.delay;
          typeof tt == "number" && tt > 0 ? He = Kt + tt : He = Kt;
        } else
          He = Kt;
        var ft;
        switch (Xe) {
          case g:
            ft = F;
            break;
          case b:
            ft = V;
            break;
          case E:
            ft = W;
            break;
          case w:
            ft = U;
            break;
          case S:
          default:
            ft = $;
            break;
        }
        var mt = He + ft, kt = {
          id: oe++,
          callback: _e,
          priorityLevel: Xe,
          startTime: He,
          expirationTime: mt,
          sortIndex: -1
        };
        return He > Kt ? (kt.sortIndex = He, a(G, kt), l(H) === null && kt === l(G) && (J ? je() : J = !0, Tn(de, He - Kt))) : (kt.sortIndex = mt, a(H, kt), !me && !Ee && (me = !0, un(K))), kt;
      }
      function ie() {
      }
      function ye() {
        !me && !Ee && (me = !0, un(K));
      }
      function we() {
        return l(H);
      }
      function fe(Xe) {
        Xe.callback = null;
      }
      function ze() {
        return te;
      }
      var Ve = !1, Ie = null, qe = -1, Qe = o, lt = -1;
      function tn() {
        var Xe = e.unstable_now() - lt;
        return !(Xe < Qe);
      }
      function Yt() {
      }
      function hn(Xe) {
        if (Xe < 0 || Xe > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Xe > 0 ? Qe = Math.floor(1e3 / Xe) : Qe = o;
      }
      var vn = function() {
        if (Ie !== null) {
          var Xe = e.unstable_now();
          lt = Xe;
          var _e = !0, Je = !0;
          try {
            Je = Ie(_e, Xe);
          } finally {
            Je ? nn() : (Ve = !1, Ie = null);
          }
        } else
          Ve = !1;
      }, nn;
      if (typeof Y == "function")
        nn = function() {
          Y(vn);
        };
      else if (typeof MessageChannel < "u") {
        var rn = new MessageChannel(), mn = rn.port2;
        rn.port1.onmessage = vn, nn = function() {
          mn.postMessage(null);
        };
      } else
        nn = function() {
          Q(vn, 0);
        };
      function un(Xe) {
        Ie = Xe, Ve || (Ve = !0, nn());
      }
      function Tn(Xe, _e) {
        qe = Q(function() {
          Xe(e.unstable_now());
        }, _e);
      }
      function je() {
        ge(qe), qe = -1;
      }
      var Ot = Yt, an = null;
      e.unstable_IdlePriority = E, e.unstable_ImmediatePriority = g, e.unstable_LowPriority = w, e.unstable_NormalPriority = S, e.unstable_Profiling = an, e.unstable_UserBlockingPriority = b, e.unstable_cancelCallback = fe, e.unstable_continueExecution = ye, e.unstable_forceFrameRate = hn, e.unstable_getCurrentPriorityLevel = ze, e.unstable_getFirstCallbackNode = we, e.unstable_next = Oe, e.unstable_pauseExecution = ie, e.unstable_requestPaint = Ot, e.unstable_runWithPriority = pe, e.unstable_scheduleCallback = xe, e.unstable_shouldYield = tn, e.unstable_wrapCallback = Ce, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(cR)), cR;
}
var dR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UF;
function _Q() {
  return UF || (UF = 1, function(e) {
    function t(Q, ge) {
      var Y = Q.length;
      Q.push(ge);
      e:
        for (; 0 < Y; ) {
          var q = Y - 1 >>> 1, de = Q[q];
          if (0 < a(de, ge))
            Q[q] = ge, Q[Y] = de, Y = q;
          else
            break e;
        }
    }
    function n(Q) {
      return Q.length === 0 ? null : Q[0];
    }
    function o(Q) {
      if (Q.length === 0)
        return null;
      var ge = Q[0], Y = Q.pop();
      if (Y !== ge) {
        Q[0] = Y;
        e:
          for (var q = 0, de = Q.length, K = de >>> 1; q < K; ) {
            var ne = 2 * (q + 1) - 1, pe = Q[ne], Oe = ne + 1, Ce = Q[Oe];
            if (0 > a(pe, Y))
              Oe < de && 0 > a(Ce, pe) ? (Q[q] = Ce, Q[Oe] = Y, q = Oe) : (Q[q] = pe, Q[ne] = Y, q = ne);
            else if (Oe < de && 0 > a(Ce, Y))
              Q[q] = Ce, Q[Oe] = Y, q = Oe;
            else
              break e;
          }
      }
      return ge;
    }
    function a(Q, ge) {
      var Y = Q.sortIndex - ge.sortIndex;
      return Y !== 0 ? Y : Q.id - ge.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var l = performance;
      e.unstable_now = function() {
        return l.now();
      };
    } else {
      var u = Date, f = u.now();
      e.unstable_now = function() {
        return u.now() - f;
      };
    }
    var h = [], v = [], g = 1, b = null, S = 3, w = !1, E = !1, T = !1, A = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function D(Q) {
      for (var ge = n(v); ge !== null; ) {
        if (ge.callback === null)
          o(v);
        else if (ge.startTime <= Q)
          o(v), ge.sortIndex = ge.expirationTime, t(h, ge);
        else
          break;
        ge = n(v);
      }
    }
    function L(Q) {
      if (T = !1, D(Q), !E)
        if (n(h) !== null)
          E = !0, me(F);
        else {
          var ge = n(v);
          ge !== null && J(L, ge.startTime - Q);
        }
    }
    function F(Q, ge) {
      E = !1, T && (T = !1, P(U), U = -1), w = !0;
      var Y = S;
      try {
        for (D(ge), b = n(h); b !== null && (!(b.expirationTime > ge) || Q && !G()); ) {
          var q = b.callback;
          if (typeof q == "function") {
            b.callback = null, S = b.priorityLevel;
            var de = q(b.expirationTime <= ge);
            ge = e.unstable_now(), typeof de == "function" ? b.callback = de : b === n(h) && o(h), D(ge);
          } else
            o(h);
          b = n(h);
        }
        if (b !== null)
          var K = !0;
        else {
          var ne = n(v);
          ne !== null && J(L, ne.startTime - ge), K = !1;
        }
        return K;
      } finally {
        b = null, S = Y, w = !1;
      }
    }
    var V = !1, $ = null, U = -1, W = 5, H = -1;
    function G() {
      return !(e.unstable_now() - H < W);
    }
    function oe() {
      if ($ !== null) {
        var Q = e.unstable_now();
        H = Q;
        var ge = !0;
        try {
          ge = $(!0, Q);
        } finally {
          ge ? ce() : (V = !1, $ = null);
        }
      } else
        V = !1;
    }
    var ce;
    if (typeof _ == "function")
      ce = function() {
        _(oe);
      };
    else if (typeof MessageChannel < "u") {
      var te = new MessageChannel(), Ee = te.port2;
      te.port1.onmessage = oe, ce = function() {
        Ee.postMessage(null);
      };
    } else
      ce = function() {
        A(oe, 0);
      };
    function me(Q) {
      $ = Q, V || (V = !0, ce());
    }
    function J(Q, ge) {
      U = A(function() {
        Q(e.unstable_now());
      }, ge);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(Q) {
      Q.callback = null;
    }, e.unstable_continueExecution = function() {
      E || w || (E = !0, me(F));
    }, e.unstable_forceFrameRate = function(Q) {
      0 > Q || 125 < Q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : W = 0 < Q ? Math.floor(1e3 / Q) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return S;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(h);
    }, e.unstable_next = function(Q) {
      switch (S) {
        case 1:
        case 2:
        case 3:
          var ge = 3;
          break;
        default:
          ge = S;
      }
      var Y = S;
      S = ge;
      try {
        return Q();
      } finally {
        S = Y;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(Q, ge) {
      switch (Q) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Q = 3;
      }
      var Y = S;
      S = Q;
      try {
        return ge();
      } finally {
        S = Y;
      }
    }, e.unstable_scheduleCallback = function(Q, ge, Y) {
      var q = e.unstable_now();
      switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? q + Y : q) : Y = q, Q) {
        case 1:
          var de = -1;
          break;
        case 2:
          de = 250;
          break;
        case 5:
          de = 1073741823;
          break;
        case 4:
          de = 1e4;
          break;
        default:
          de = 5e3;
      }
      return de = Y + de, Q = { id: g++, callback: ge, priorityLevel: Q, startTime: Y, expirationTime: de, sortIndex: -1 }, Y > q ? (Q.sortIndex = Y, t(v, Q), n(h) === null && Q === n(v) && (T ? (P(U), U = -1) : T = !0, J(L, Y - q))) : (Q.sortIndex = de, t(h, Q), E || w || (E = !0, me(F))), Q;
    }, e.unstable_shouldYield = G, e.unstable_wrapCallback = function(Q) {
      var ge = S;
      return function() {
        var Y = S;
        S = ge;
        try {
          return Q.apply(this, arguments);
        } finally {
          S = Y;
        }
      };
    };
  }(dR)), dR;
}
var XF;
function u4() {
  return XF || (XF = 1, process.env.NODE_ENV === "production" ? SC.exports = _Q() : SC.exports = OQ()), SC.exports;
}
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZF;
function DQ() {
  return ZF || (ZF = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Tt, t = u4(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function a(r) {
      o = r;
    }
    function l(r) {
      if (!o) {
        for (var i = arguments.length, d = new Array(i > 1 ? i - 1 : 0), p = 1; p < i; p++)
          d[p - 1] = arguments[p];
        f("warn", r, d);
      }
    }
    function u(r) {
      if (!o) {
        for (var i = arguments.length, d = new Array(i > 1 ? i - 1 : 0), p = 1; p < i; p++)
          d[p - 1] = arguments[p];
        f("error", r, d);
      }
    }
    function f(r, i, d) {
      {
        var p = n.ReactDebugCurrentFrame, y = p.getStackAddendum();
        y !== "" && (i += "%s", d = d.concat([y]));
        var C = d.map(function(k) {
          return String(k);
        });
        C.unshift("Warning: " + i), Function.prototype.apply.call(console[r], console, C);
      }
    }
    var h = 0, v = 1, g = 2, b = 3, S = 4, w = 5, E = 6, T = 7, A = 8, P = 9, _ = 10, D = 11, L = 12, F = 13, V = 14, $ = 15, U = 16, W = 17, H = 18, G = 19, oe = 21, ce = 22, te = 23, Ee = 24, me = 25, J = !0, Q = !1, ge = !1, Y = !1, q = !1, de = !0, K = !1, ne = !1, pe = !0, Oe = !0, Ce = !0, xe = /* @__PURE__ */ new Set(), ie = {}, ye = {};
    function we(r, i) {
      fe(r, i), fe(r + "Capture", i);
    }
    function fe(r, i) {
      ie[r] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", r), ie[r] = i;
      {
        var d = r.toLowerCase();
        ye[d] = r, r === "onDoubleClick" && (ye.ondblclick = r);
      }
      for (var p = 0; p < i.length; p++)
        xe.add(i[p]);
    }
    var ze = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ve = Object.prototype.hasOwnProperty;
    function Ie(r) {
      {
        var i = typeof Symbol == "function" && Symbol.toStringTag, d = i && r[Symbol.toStringTag] || r.constructor.name || "Object";
        return d;
      }
    }
    function qe(r) {
      try {
        return Qe(r), !1;
      } catch {
        return !0;
      }
    }
    function Qe(r) {
      return "" + r;
    }
    function lt(r, i) {
      if (qe(r))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ie(r)), Qe(r);
    }
    function tn(r) {
      if (qe(r))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ie(r)), Qe(r);
    }
    function Yt(r, i) {
      if (qe(r))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ie(r)), Qe(r);
    }
    function hn(r, i) {
      if (qe(r))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ie(r)), Qe(r);
    }
    function vn(r) {
      if (qe(r))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Ie(r)), Qe(r);
    }
    function nn(r) {
      if (qe(r))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Ie(r)), Qe(r);
    }
    var rn = 0, mn = 1, un = 2, Tn = 3, je = 4, Ot = 5, an = 6, Xe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", _e = Xe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Je = new RegExp("^[" + Xe + "][" + _e + "]*$"), Kt = {}, He = {};
    function tt(r) {
      return Ve.call(He, r) ? !0 : Ve.call(Kt, r) ? !1 : Je.test(r) ? (He[r] = !0, !0) : (Kt[r] = !0, u("Invalid attribute name: `%s`", r), !1);
    }
    function ft(r, i, d) {
      return i !== null ? i.type === rn : d ? !1 : r.length > 2 && (r[0] === "o" || r[0] === "O") && (r[1] === "n" || r[1] === "N");
    }
    function mt(r, i, d, p) {
      if (d !== null && d.type === rn)
        return !1;
      switch (typeof i) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (p)
            return !1;
          if (d !== null)
            return !d.acceptsBooleans;
          var y = r.toLowerCase().slice(0, 5);
          return y !== "data-" && y !== "aria-";
        }
        default:
          return !1;
      }
    }
    function kt(r, i, d, p) {
      if (i === null || typeof i > "u" || mt(r, i, d, p))
        return !0;
      if (p)
        return !1;
      if (d !== null)
        switch (d.type) {
          case Tn:
            return !i;
          case je:
            return i === !1;
          case Ot:
            return isNaN(i);
          case an:
            return isNaN(i) || i < 1;
        }
      return !1;
    }
    function Mn(r) {
      return Qt.hasOwnProperty(r) ? Qt[r] : null;
    }
    function sn(r, i, d, p, y, C, k) {
      this.acceptsBooleans = i === un || i === Tn || i === je, this.attributeName = p, this.attributeNamespace = y, this.mustUseProperty = d, this.propertyName = r, this.type = i, this.sanitizeURL = C, this.removeEmptyString = k;
    }
    var Qt = {}, Ro = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ro.forEach(function(r) {
      Qt[r] = new sn(
        r,
        rn,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
      var i = r[0], d = r[1];
      Qt[i] = new sn(
        i,
        mn,
        !1,
        // mustUseProperty
        d,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
      Qt[r] = new sn(
        r,
        un,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
      Qt[r] = new sn(
        r,
        un,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(r) {
      Qt[r] = new sn(
        r,
        Tn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      Qt[r] = new sn(
        r,
        Tn,
        !0,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      Qt[r] = new sn(
        r,
        je,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      Qt[r] = new sn(
        r,
        an,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(r) {
      Qt[r] = new sn(
        r,
        Ot,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Gr = /[\-\:]([a-z])/g, ni = function(r) {
      return r[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var i = r.replace(Gr, ni);
      Qt[i] = new sn(
        i,
        mn,
        !1,
        // mustUseProperty
        r,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var i = r.replace(Gr, ni);
      Qt[i] = new sn(
        i,
        mn,
        !1,
        // mustUseProperty
        r,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var i = r.replace(Gr, ni);
      Qt[i] = new sn(
        i,
        mn,
        !1,
        // mustUseProperty
        r,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(r) {
      Qt[r] = new sn(
        r,
        mn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Yc = "xlinkHref";
    Qt[Yc] = new sn(
      "xlinkHref",
      mn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(r) {
      Qt[r] = new sn(
        r,
        mn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ia = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Tl = !1;
    function Os(r) {
      !Tl && Ia.test(r) && (Tl = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(r)));
    }
    function Wr(r, i, d, p) {
      if (p.mustUseProperty) {
        var y = p.propertyName;
        return r[y];
      } else {
        lt(d, i), p.sanitizeURL && Os("" + d);
        var C = p.attributeName, k = null;
        if (p.type === je) {
          if (r.hasAttribute(C)) {
            var O = r.getAttribute(C);
            return O === "" ? !0 : kt(i, d, p, !1) ? O : O === "" + d ? d : O;
          }
        } else if (r.hasAttribute(C)) {
          if (kt(i, d, p, !1))
            return r.getAttribute(C);
          if (p.type === Tn)
            return d;
          k = r.getAttribute(C);
        }
        return kt(i, d, p, !1) ? k === null ? d : k : k === "" + d ? d : k;
      }
    }
    function Ja(r, i, d, p) {
      {
        if (!tt(i))
          return;
        if (!r.hasAttribute(i))
          return d === void 0 ? void 0 : null;
        var y = r.getAttribute(i);
        return lt(d, i), y === "" + d ? d : y;
      }
    }
    function Wi(r, i, d, p) {
      var y = Mn(i);
      if (!ft(i, y, p)) {
        if (kt(i, d, y, p) && (d = null), p || y === null) {
          if (tt(i)) {
            var C = i;
            d === null ? r.removeAttribute(C) : (lt(d, i), r.setAttribute(C, "" + d));
          }
          return;
        }
        var k = y.mustUseProperty;
        if (k) {
          var O = y.propertyName;
          if (d === null) {
            var N = y.type;
            r[O] = N === Tn ? !1 : "";
          } else
            r[O] = d;
          return;
        }
        var z = y.attributeName, j = y.attributeNamespace;
        if (d === null)
          r.removeAttribute(z);
        else {
          var ue = y.type, ae;
          ue === Tn || ue === je && d === !0 ? ae = "" : (lt(d, z), ae = "" + d, y.sanitizeURL && Os(ae.toString())), j ? r.setAttributeNS(j, z, ae) : r.setAttribute(z, ae);
        }
      }
    }
    var Qa = Symbol.for("react.element"), Po = Symbol.for("react.portal"), Aa = Symbol.for("react.fragment"), Ti = Symbol.for("react.strict_mode"), Tu = Symbol.for("react.profiler"), Rf = Symbol.for("react.provider"), Pf = Symbol.for("react.context"), Il = Symbol.for("react.forward_ref"), Ui = Symbol.for("react.suspense"), Xi = Symbol.for("react.suspense_list"), Al = Symbol.for("react.memo"), mo = Symbol.for("react.lazy"), Eh = Symbol.for("react.scope"), Th = Symbol.for("react.debug_trace_mode"), Of = Symbol.for("react.offscreen"), Ih = Symbol.for("react.legacy_hidden"), _f = Symbol.for("react.cache"), Ng = Symbol.for("react.tracing_marker"), qn = Symbol.iterator, Df = "@@iterator";
    function ka(r) {
      if (r === null || typeof r != "object")
        return null;
      var i = qn && r[qn] || r[Df];
      return typeof i == "function" ? i : null;
    }
    var on = Object.assign, Ra = 0, Ah, Nf, Iu, ri, kh, oi, Rh;
    function Ph() {
    }
    Ph.__reactDisabledLog = !0;
    function Mg() {
      {
        if (Ra === 0) {
          Ah = console.log, Nf = console.info, Iu = console.warn, ri = console.error, kh = console.group, oi = console.groupCollapsed, Rh = console.groupEnd;
          var r = {
            configurable: !0,
            enumerable: !0,
            value: Ph,
            writable: !0
          };
          Object.defineProperties(console, {
            info: r,
            log: r,
            warn: r,
            error: r,
            group: r,
            groupCollapsed: r,
            groupEnd: r
          });
        }
        Ra++;
      }
    }
    function Jc() {
      {
        if (Ra--, Ra === 0) {
          var r = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: on({}, r, {
              value: Ah
            }),
            info: on({}, r, {
              value: Nf
            }),
            warn: on({}, r, {
              value: Iu
            }),
            error: on({}, r, {
              value: ri
            }),
            group: on({}, r, {
              value: kh
            }),
            groupCollapsed: on({}, r, {
              value: oi
            }),
            groupEnd: on({}, r, {
              value: Rh
            })
          });
        }
        Ra < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var kl = n.ReactCurrentDispatcher, _s;
    function Ii(r, i, d) {
      {
        if (_s === void 0)
          try {
            throw Error();
          } catch (y) {
            var p = y.stack.trim().match(/\n( *(at )?)/);
            _s = p && p[1] || "";
          }
        return `
` + _s + r;
      }
    }
    var Mf = !1, Ds;
    {
      var Au = typeof WeakMap == "function" ? WeakMap : Map;
      Ds = new Au();
    }
    function Qc(r, i) {
      if (!r || Mf)
        return "";
      {
        var d = Ds.get(r);
        if (d !== void 0)
          return d;
      }
      var p;
      Mf = !0;
      var y = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var C;
      C = kl.current, kl.current = null, Mg();
      try {
        if (i) {
          var k = function() {
            throw Error();
          };
          if (Object.defineProperty(k.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(k, []);
            } catch (ke) {
              p = ke;
            }
            Reflect.construct(r, [], k);
          } else {
            try {
              k.call();
            } catch (ke) {
              p = ke;
            }
            r.call(k.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ke) {
            p = ke;
          }
          r();
        }
      } catch (ke) {
        if (ke && p && typeof ke.stack == "string") {
          for (var O = ke.stack.split(`
`), N = p.stack.split(`
`), z = O.length - 1, j = N.length - 1; z >= 1 && j >= 0 && O[z] !== N[j]; )
            j--;
          for (; z >= 1 && j >= 0; z--, j--)
            if (O[z] !== N[j]) {
              if (z !== 1 || j !== 1)
                do
                  if (z--, j--, j < 0 || O[z] !== N[j]) {
                    var ue = `
` + O[z].replace(" at new ", " at ");
                    return r.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", r.displayName)), typeof r == "function" && Ds.set(r, ue), ue;
                  }
                while (z >= 1 && j >= 0);
              break;
            }
        }
      } finally {
        Mf = !1, kl.current = C, Jc(), Error.prepareStackTrace = y;
      }
      var ae = r ? r.displayName || r.name : "", Ae = ae ? Ii(ae) : "";
      return typeof r == "function" && Ds.set(r, Ae), Ae;
    }
    function Lf(r, i, d) {
      return Qc(r, !0);
    }
    function Ka(r, i, d) {
      return Qc(r, !1);
    }
    function Lg(r) {
      var i = r.prototype;
      return !!(i && i.isReactComponent);
    }
    function ku(r, i, d) {
      if (r == null)
        return "";
      if (typeof r == "function")
        return Qc(r, Lg(r));
      if (typeof r == "string")
        return Ii(r);
      switch (r) {
        case Ui:
          return Ii("Suspense");
        case Xi:
          return Ii("SuspenseList");
      }
      if (typeof r == "object")
        switch (r.$$typeof) {
          case Il:
            return Ka(r.render);
          case Al:
            return ku(r.type, i, d);
          case mo: {
            var p = r, y = p._payload, C = p._init;
            try {
              return ku(C(y), i, d);
            } catch {
            }
          }
        }
      return "";
    }
    function On(r) {
      switch (r._debugOwner && r._debugOwner.type, r._debugSource, r.tag) {
        case w:
          return Ii(r.type);
        case U:
          return Ii("Lazy");
        case F:
          return Ii("Suspense");
        case G:
          return Ii("SuspenseList");
        case h:
        case g:
        case $:
          return Ka(r.type);
        case D:
          return Ka(r.type.render);
        case v:
          return Lf(r.type);
        default:
          return "";
      }
    }
    function Kc(r) {
      try {
        var i = "", d = r;
        do
          i += On(d), d = d.return;
        while (d);
        return i;
      } catch (p) {
        return `
Error generating stack: ` + p.message + `
` + p.stack;
      }
    }
    function Oh(r, i, d) {
      var p = r.displayName;
      if (p)
        return p;
      var y = i.displayName || i.name || "";
      return y !== "" ? d + "(" + y + ")" : d;
    }
    function qc(r) {
      return r.displayName || "Context";
    }
    function $n(r) {
      if (r == null)
        return null;
      if (typeof r.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof r == "function")
        return r.displayName || r.name || null;
      if (typeof r == "string")
        return r;
      switch (r) {
        case Aa:
          return "Fragment";
        case Po:
          return "Portal";
        case Tu:
          return "Profiler";
        case Ti:
          return "StrictMode";
        case Ui:
          return "Suspense";
        case Xi:
          return "SuspenseList";
      }
      if (typeof r == "object")
        switch (r.$$typeof) {
          case Pf:
            var i = r;
            return qc(i) + ".Consumer";
          case Rf:
            var d = r;
            return qc(d._context) + ".Provider";
          case Il:
            return Oh(r, r.render, "ForwardRef");
          case Al:
            var p = r.displayName || null;
            return p !== null ? p : $n(r.type) || "Memo";
          case mo: {
            var y = r, C = y._payload, k = y._init;
            try {
              return $n(k(C));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function ed(r, i, d) {
      var p = i.displayName || i.name || "";
      return r.displayName || (p !== "" ? d + "(" + p + ")" : d);
    }
    function Ff(r) {
      return r.displayName || "Context";
    }
    function Ut(r) {
      var i = r.tag, d = r.type;
      switch (i) {
        case Ee:
          return "Cache";
        case P:
          var p = d;
          return Ff(p) + ".Consumer";
        case _:
          var y = d;
          return Ff(y._context) + ".Provider";
        case H:
          return "DehydratedFragment";
        case D:
          return ed(d, d.render, "ForwardRef");
        case T:
          return "Fragment";
        case w:
          return d;
        case S:
          return "Portal";
        case b:
          return "Root";
        case E:
          return "Text";
        case U:
          return $n(d);
        case A:
          return d === Ti ? "StrictMode" : "Mode";
        case ce:
          return "Offscreen";
        case L:
          return "Profiler";
        case oe:
          return "Scope";
        case F:
          return "Suspense";
        case G:
          return "SuspenseList";
        case me:
          return "TracingMarker";
        case v:
        case h:
        case W:
        case g:
        case V:
        case $:
          if (typeof d == "function")
            return d.displayName || d.name || null;
          if (typeof d == "string")
            return d;
          break;
      }
      return null;
    }
    var Ru = n.ReactDebugCurrentFrame, or = null, Oo = !1;
    function _o() {
      {
        if (or === null)
          return null;
        var r = or._debugOwner;
        if (r !== null && typeof r < "u")
          return Ut(r);
      }
      return null;
    }
    function Ns() {
      return or === null ? "" : Kc(or);
    }
    function kr() {
      Ru.getCurrentStack = null, or = null, Oo = !1;
    }
    function _n(r) {
      Ru.getCurrentStack = r === null ? null : Ns, or = r, Oo = !1;
    }
    function Bf() {
      return or;
    }
    function ii(r) {
      Oo = r;
    }
    function pr(r) {
      return "" + r;
    }
    function ai(r) {
      switch (typeof r) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return r;
        case "object":
          return nn(r), r;
        default:
          return "";
      }
    }
    var _h = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ms(r, i) {
      _h[i.type] || i.onChange || i.onInput || i.readOnly || i.disabled || i.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), i.onChange || i.readOnly || i.disabled || i.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Vf(r) {
      var i = r.type, d = r.nodeName;
      return d && d.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
    }
    function $f(r) {
      return r._valueTracker;
    }
    function Pu(r) {
      r._valueTracker = null;
    }
    function Ou(r) {
      var i = "";
      return r && (Vf(r) ? i = r.checked ? "true" : "false" : i = r.value), i;
    }
    function Ls(r) {
      var i = Vf(r) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(r.constructor.prototype, i);
      nn(r[i]);
      var p = "" + r[i];
      if (!(r.hasOwnProperty(i) || typeof d > "u" || typeof d.get != "function" || typeof d.set != "function")) {
        var y = d.get, C = d.set;
        Object.defineProperty(r, i, {
          configurable: !0,
          get: function() {
            return y.call(this);
          },
          set: function(O) {
            nn(O), p = "" + O, C.call(this, O);
          }
        }), Object.defineProperty(r, i, {
          enumerable: d.enumerable
        });
        var k = {
          getValue: function() {
            return p;
          },
          setValue: function(O) {
            nn(O), p = "" + O;
          },
          stopTracking: function() {
            Pu(r), delete r[i];
          }
        };
        return k;
      }
    }
    function Fs(r) {
      $f(r) || (r._valueTracker = Ls(r));
    }
    function X(r) {
      if (!r)
        return !1;
      var i = $f(r);
      if (!i)
        return !0;
      var d = i.getValue(), p = Ou(r);
      return p !== d ? (i.setValue(p), !0) : !1;
    }
    function se(r) {
      if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u")
        return null;
      try {
        return r.activeElement || r.body;
      } catch {
        return r.body;
      }
    }
    var Re = !1, it = !1, fn = !1, Dn = !1;
    function wn(r) {
      var i = r.type === "checkbox" || r.type === "radio";
      return i ? r.checked != null : r.value != null;
    }
    function ln(r, i) {
      var d = r, p = i.checked, y = on({}, i, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: p ?? d._wrapperState.initialChecked
      });
      return y;
    }
    function Ln(r, i) {
      Ms("input", i), i.checked !== void 0 && i.defaultChecked !== void 0 && !it && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", _o() || "A component", i.type), it = !0), i.value !== void 0 && i.defaultValue !== void 0 && !Re && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", _o() || "A component", i.type), Re = !0);
      var d = r, p = i.defaultValue == null ? "" : i.defaultValue;
      d._wrapperState = {
        initialChecked: i.checked != null ? i.checked : i.defaultChecked,
        initialValue: ai(i.value != null ? i.value : p),
        controlled: wn(i)
      };
    }
    function Do(r, i) {
      var d = r, p = i.checked;
      p != null && Wi(d, "checked", p, !1);
    }
    function Nr(r, i) {
      var d = r;
      {
        var p = wn(i);
        !d._wrapperState.controlled && p && !Dn && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Dn = !0), d._wrapperState.controlled && !p && !fn && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), fn = !0);
      }
      Do(r, i);
      var y = ai(i.value), C = i.type;
      if (y != null)
        C === "number" ? (y === 0 && d.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        d.value != y) && (d.value = pr(y)) : d.value !== pr(y) && (d.value = pr(y));
      else if (C === "submit" || C === "reset") {
        d.removeAttribute("value");
        return;
      }
      i.hasOwnProperty("value") ? Oa(d, i.type, y) : i.hasOwnProperty("defaultValue") && Oa(d, i.type, ai(i.defaultValue)), i.checked == null && i.defaultChecked != null && (d.defaultChecked = !!i.defaultChecked);
    }
    function Pa(r, i, d) {
      var p = r;
      if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
        var y = i.type, C = y === "submit" || y === "reset";
        if (C && (i.value === void 0 || i.value === null))
          return;
        var k = pr(p._wrapperState.initialValue);
        d || k !== p.value && (p.value = k), p.defaultValue = k;
      }
      var O = p.name;
      O !== "" && (p.name = ""), p.defaultChecked = !p.defaultChecked, p.defaultChecked = !!p._wrapperState.initialChecked, O !== "" && (p.name = O);
    }
    function td(r, i) {
      var d = r;
      Nr(d, i), vo(d, i);
    }
    function vo(r, i) {
      var d = i.name;
      if (i.type === "radio" && d != null) {
        for (var p = r; p.parentNode; )
          p = p.parentNode;
        lt(d, "name");
        for (var y = p.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), C = 0; C < y.length; C++) {
          var k = y[C];
          if (!(k === r || k.form !== r.form)) {
            var O = ox(k);
            if (!O)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            X(k), Nr(k, O);
          }
        }
      }
    }
    function Oa(r, i, d) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (i !== "number" || se(r.ownerDocument) !== r) && (d == null ? r.defaultValue = pr(r._wrapperState.initialValue) : r.defaultValue !== pr(d) && (r.defaultValue = pr(d)));
    }
    var Dh = !1, nd = !1, RS = !1;
    function Nh(r, i) {
      i.value == null && (typeof i.children == "object" && i.children !== null ? e.Children.forEach(i.children, function(d) {
        d != null && (typeof d == "string" || typeof d == "number" || nd || (nd = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : i.dangerouslySetInnerHTML != null && (RS || (RS = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), i.selected != null && !Dh && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Dh = !0);
    }
    function Fg(r, i) {
      i.value != null && r.setAttribute("value", pr(ai(i.value)));
    }
    var zf = Array.isArray;
    function eo(r) {
      return zf(r);
    }
    var Mh;
    Mh = !1;
    function PS() {
      var r = _o();
      return r ? `

Check the render method of \`` + r + "`." : "";
    }
    var OS = ["value", "defaultValue"];
    function LT(r) {
      {
        Ms("select", r);
        for (var i = 0; i < OS.length; i++) {
          var d = OS[i];
          if (r[d] != null) {
            var p = eo(r[d]);
            r.multiple && !p ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", d, PS()) : !r.multiple && p && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", d, PS());
          }
        }
      }
    }
    function Rl(r, i, d, p) {
      var y = r.options;
      if (i) {
        for (var C = d, k = {}, O = 0; O < C.length; O++)
          k["$" + C[O]] = !0;
        for (var N = 0; N < y.length; N++) {
          var z = k.hasOwnProperty("$" + y[N].value);
          y[N].selected !== z && (y[N].selected = z), z && p && (y[N].defaultSelected = !0);
        }
      } else {
        for (var j = pr(ai(d)), ue = null, ae = 0; ae < y.length; ae++) {
          if (y[ae].value === j) {
            y[ae].selected = !0, p && (y[ae].defaultSelected = !0);
            return;
          }
          ue === null && !y[ae].disabled && (ue = y[ae]);
        }
        ue !== null && (ue.selected = !0);
      }
    }
    function Bg(r, i) {
      return on({}, i, {
        value: void 0
      });
    }
    function _S(r, i) {
      var d = r;
      LT(i), d._wrapperState = {
        wasMultiple: !!i.multiple
      }, i.value !== void 0 && i.defaultValue !== void 0 && !Mh && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Mh = !0);
    }
    function FT(r, i) {
      var d = r;
      d.multiple = !!i.multiple;
      var p = i.value;
      p != null ? Rl(d, !!i.multiple, p, !1) : i.defaultValue != null && Rl(d, !!i.multiple, i.defaultValue, !0);
    }
    function BT(r, i) {
      var d = r, p = d._wrapperState.wasMultiple;
      d._wrapperState.wasMultiple = !!i.multiple;
      var y = i.value;
      y != null ? Rl(d, !!i.multiple, y, !1) : p !== !!i.multiple && (i.defaultValue != null ? Rl(d, !!i.multiple, i.defaultValue, !0) : Rl(d, !!i.multiple, i.multiple ? [] : "", !1));
    }
    function VT(r, i) {
      var d = r, p = i.value;
      p != null && Rl(d, !!i.multiple, p, !1);
    }
    var Vg = !1;
    function $g(r, i) {
      var d = r;
      if (i.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var p = on({}, i, {
        value: void 0,
        defaultValue: void 0,
        children: pr(d._wrapperState.initialValue)
      });
      return p;
    }
    function DS(r, i) {
      var d = r;
      Ms("textarea", i), i.value !== void 0 && i.defaultValue !== void 0 && !Vg && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", _o() || "A component"), Vg = !0);
      var p = i.value;
      if (p == null) {
        var y = i.children, C = i.defaultValue;
        if (y != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (C != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (eo(y)) {
              if (y.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              y = y[0];
            }
            C = y;
          }
        }
        C == null && (C = ""), p = C;
      }
      d._wrapperState = {
        initialValue: ai(p)
      };
    }
    function NS(r, i) {
      var d = r, p = ai(i.value), y = ai(i.defaultValue);
      if (p != null) {
        var C = pr(p);
        C !== d.value && (d.value = C), i.defaultValue == null && d.defaultValue !== C && (d.defaultValue = C);
      }
      y != null && (d.defaultValue = pr(y));
    }
    function MS(r, i) {
      var d = r, p = d.textContent;
      p === d._wrapperState.initialValue && p !== "" && p !== null && (d.value = p);
    }
    function zg(r, i) {
      NS(r, i);
    }
    var Bs = "http://www.w3.org/1999/xhtml", $T = "http://www.w3.org/1998/Math/MathML", Hg = "http://www.w3.org/2000/svg";
    function Lh(r) {
      switch (r) {
        case "svg":
          return Hg;
        case "math":
          return $T;
        default:
          return Bs;
      }
    }
    function jg(r, i) {
      return r == null || r === Bs ? Lh(i) : r === Hg && i === "foreignObject" ? Bs : r;
    }
    var zT = function(r) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, d, p, y) {
        MSApp.execUnsafeLocalFunction(function() {
          return r(i, d, p, y);
        });
      } : r;
    }, Fh, LS = zT(function(r, i) {
      if (r.namespaceURI === Hg && !("innerHTML" in r)) {
        Fh = Fh || document.createElement("div"), Fh.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>";
        for (var d = Fh.firstChild; r.firstChild; )
          r.removeChild(r.firstChild);
        for (; d.firstChild; )
          r.appendChild(d.firstChild);
        return;
      }
      r.innerHTML = i;
    }), si = 1, Vs = 3, Mr = 8, _a = 9, _u = 11, Bh = function(r, i) {
      if (i) {
        var d = r.firstChild;
        if (d && d === r.lastChild && d.nodeType === Vs) {
          d.nodeValue = i;
          return;
        }
      }
      r.textContent = i;
    }, FS = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, rd = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function BS(r, i) {
      return r + i.charAt(0).toUpperCase() + i.substring(1);
    }
    var VS = ["Webkit", "ms", "Moz", "O"];
    Object.keys(rd).forEach(function(r) {
      VS.forEach(function(i) {
        rd[BS(i, r)] = rd[r];
      });
    });
    function Vh(r, i, d) {
      var p = i == null || typeof i == "boolean" || i === "";
      return p ? "" : !d && typeof i == "number" && i !== 0 && !(rd.hasOwnProperty(r) && rd[r]) ? i + "px" : (hn(i, r), ("" + i).trim());
    }
    var od = /([A-Z])/g, HT = /^ms-/;
    function jT(r) {
      return r.replace(od, "-$1").toLowerCase().replace(HT, "-ms-");
    }
    var $S = function() {
    };
    {
      var zS = /^(?:webkit|moz|o)[A-Z]/, HS = /^-ms-/, Hf = /-(.)/g, id = /;\s*$/, ad = {}, sd = {}, jS = !1, Gg = !1, Wg = function(r) {
        return r.replace(Hf, function(i, d) {
          return d.toUpperCase();
        });
      }, Ug = function(r) {
        ad.hasOwnProperty(r) && ad[r] || (ad[r] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          r,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Wg(r.replace(HS, "ms-"))
        ));
      }, GS = function(r) {
        ad.hasOwnProperty(r) && ad[r] || (ad[r] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", r, r.charAt(0).toUpperCase() + r.slice(1)));
      }, WS = function(r, i) {
        sd.hasOwnProperty(i) && sd[i] || (sd[i] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, r, i.replace(id, "")));
      }, US = function(r, i) {
        jS || (jS = !0, u("`NaN` is an invalid value for the `%s` css style property.", r));
      }, GT = function(r, i) {
        Gg || (Gg = !0, u("`Infinity` is an invalid value for the `%s` css style property.", r));
      };
      $S = function(r, i) {
        r.indexOf("-") > -1 ? Ug(r) : zS.test(r) ? GS(r) : id.test(i) && WS(r, i), typeof i == "number" && (isNaN(i) ? US(r, i) : isFinite(i) || GT(r, i));
      };
    }
    var WT = $S;
    function UT(r) {
      {
        var i = "", d = "";
        for (var p in r)
          if (r.hasOwnProperty(p)) {
            var y = r[p];
            if (y != null) {
              var C = p.indexOf("--") === 0;
              i += d + (C ? p : jT(p)) + ":", i += Vh(p, y, C), d = ";";
            }
          }
        return i || null;
      }
    }
    function XS(r, i) {
      var d = r.style;
      for (var p in i)
        if (i.hasOwnProperty(p)) {
          var y = p.indexOf("--") === 0;
          y || WT(p, i[p]);
          var C = Vh(p, i[p], y);
          p === "float" && (p = "cssFloat"), y ? d.setProperty(p, C) : d[p] = C;
        }
    }
    function XT(r) {
      return r == null || typeof r == "boolean" || r === "";
    }
    function Zi(r) {
      var i = {};
      for (var d in r)
        for (var p = FS[d] || [d], y = 0; y < p.length; y++)
          i[p[y]] = d;
      return i;
    }
    function jf(r, i) {
      {
        if (!i)
          return;
        var d = Zi(r), p = Zi(i), y = {};
        for (var C in d) {
          var k = d[C], O = p[C];
          if (O && k !== O) {
            var N = k + "," + O;
            if (y[N])
              continue;
            y[N] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", XT(r[k]) ? "Removing" : "Updating", k, O);
          }
        }
      }
    }
    var ZS = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, YS = on({
      menuitem: !0
    }, ZS), JS = "__html";
    function $h(r, i) {
      if (i) {
        if (YS[r] && (i.children != null || i.dangerouslySetInnerHTML != null))
          throw new Error(r + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (i.dangerouslySetInnerHTML != null) {
          if (i.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof i.dangerouslySetInnerHTML != "object" || !(JS in i.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!i.suppressContentEditableWarning && i.contentEditable && i.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), i.style != null && typeof i.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function $s(r, i) {
      if (r.indexOf("-") === -1)
        return typeof i.is == "string";
      switch (r) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var zh = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, QS = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Da = {}, Xg = new RegExp("^(aria)-[" + _e + "]*$"), Gf = new RegExp("^(aria)[A-Z][" + _e + "]*$");
    function Zg(r, i) {
      {
        if (Ve.call(Da, i) && Da[i])
          return !0;
        if (Gf.test(i)) {
          var d = "aria-" + i.slice(4).toLowerCase(), p = QS.hasOwnProperty(d) ? d : null;
          if (p == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", i), Da[i] = !0, !0;
          if (i !== p)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", i, p), Da[i] = !0, !0;
        }
        if (Xg.test(i)) {
          var y = i.toLowerCase(), C = QS.hasOwnProperty(y) ? y : null;
          if (C == null)
            return Da[i] = !0, !1;
          if (i !== C)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", i, C), Da[i] = !0, !0;
        }
      }
      return !0;
    }
    function KS(r, i) {
      {
        var d = [];
        for (var p in i) {
          var y = Zg(r, p);
          y || d.push(p);
        }
        var C = d.map(function(k) {
          return "`" + k + "`";
        }).join(", ");
        d.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, r) : d.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, r);
      }
    }
    function Hh(r, i) {
      $s(r, i) || KS(r, i);
    }
    var Du = !1;
    function Yg(r, i) {
      {
        if (r !== "input" && r !== "textarea" && r !== "select")
          return;
        i != null && i.value === null && !Du && (Du = !0, r === "select" && i.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", r) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", r));
      }
    }
    var Jg = function() {
    };
    {
      var to = {}, Qg = /^on./, qS = /^on[^A-Z]/, e1 = new RegExp("^(aria)-[" + _e + "]*$"), t1 = new RegExp("^(aria)[A-Z][" + _e + "]*$");
      Jg = function(r, i, d, p) {
        if (Ve.call(to, i) && to[i])
          return !0;
        var y = i.toLowerCase();
        if (y === "onfocusin" || y === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), to[i] = !0, !0;
        if (p != null) {
          var C = p.registrationNameDependencies, k = p.possibleRegistrationNames;
          if (C.hasOwnProperty(i))
            return !0;
          var O = k.hasOwnProperty(y) ? k[y] : null;
          if (O != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", i, O), to[i] = !0, !0;
          if (Qg.test(i))
            return u("Unknown event handler property `%s`. It will be ignored.", i), to[i] = !0, !0;
        } else if (Qg.test(i))
          return qS.test(i) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", i), to[i] = !0, !0;
        if (e1.test(i) || t1.test(i))
          return !0;
        if (y === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), to[i] = !0, !0;
        if (y === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), to[i] = !0, !0;
        if (y === "is" && d !== null && d !== void 0 && typeof d != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof d), to[i] = !0, !0;
        if (typeof d == "number" && isNaN(d))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", i), to[i] = !0, !0;
        var N = Mn(i), z = N !== null && N.type === rn;
        if (zh.hasOwnProperty(y)) {
          var j = zh[y];
          if (j !== i)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", i, j), to[i] = !0, !0;
        } else if (!z && i !== y)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", i, y), to[i] = !0, !0;
        return typeof d == "boolean" && mt(i, d, N, !1) ? (d ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', d, i, i, d, i) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', d, i, i, d, i, i, i), to[i] = !0, !0) : z ? !0 : mt(i, d, N, !1) ? (to[i] = !0, !1) : ((d === "false" || d === "true") && N !== null && N.type === Tn && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", d, i, d === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', i, d), to[i] = !0), !0);
      };
    }
    var n1 = function(r, i, d) {
      {
        var p = [];
        for (var y in i) {
          var C = Jg(r, y, i[y], d);
          C || p.push(y);
        }
        var k = p.map(function(O) {
          return "`" + O + "`";
        }).join(", ");
        p.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", k, r) : p.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", k, r);
      }
    };
    function r1(r, i, d) {
      $s(r, i) || n1(r, i, d);
    }
    var zs = 1, Wf = 2, Nu = 4, ZT = zs | Wf | Nu, Uf = null;
    function Xf(r) {
      Uf !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Uf = r;
    }
    function YT() {
      Uf === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Uf = null;
    }
    function o1(r) {
      return r === Uf;
    }
    function jh(r) {
      var i = r.target || r.srcElement || window;
      return i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === Vs ? i.parentNode : i;
    }
    var er = null, Pl = null, Hs = null;
    function ld(r) {
      var i = Nd(r);
      if (i) {
        if (typeof er != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var d = i.stateNode;
        if (d) {
          var p = ox(d);
          er(i.stateNode, i.type, p);
        }
      }
    }
    function i1(r) {
      er = r;
    }
    function Gh(r) {
      Pl ? Hs ? Hs.push(r) : Hs = [r] : Pl = r;
    }
    function Zf() {
      return Pl !== null || Hs !== null;
    }
    function Yf() {
      if (Pl) {
        var r = Pl, i = Hs;
        if (Pl = null, Hs = null, ld(r), i)
          for (var d = 0; d < i.length; d++)
            ld(i[d]);
      }
    }
    var Mu = function(r, i) {
      return r(i);
    }, Kg = function() {
    }, qg = !1;
    function JT() {
      var r = Zf();
      r && (Kg(), Yf());
    }
    function ey(r, i, d) {
      if (qg)
        return r(i, d);
      qg = !0;
      try {
        return Mu(r, i, d);
      } finally {
        qg = !1, JT();
      }
    }
    function Wh(r, i, d) {
      Mu = r, Kg = d;
    }
    function Uh(r) {
      return r === "button" || r === "input" || r === "select" || r === "textarea";
    }
    function ty(r, i, d) {
      switch (r) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(d.disabled && Uh(i));
        default:
          return !1;
      }
    }
    function Lu(r, i) {
      var d = r.stateNode;
      if (d === null)
        return null;
      var p = ox(d);
      if (p === null)
        return null;
      var y = p[i];
      if (ty(i, r.type, p))
        return null;
      if (y && typeof y != "function")
        throw new Error("Expected `" + i + "` listener to be a function, instead got a value of `" + typeof y + "` type.");
      return y;
    }
    var Jf = !1;
    if (ze)
      try {
        var Fu = {};
        Object.defineProperty(Fu, "passive", {
          get: function() {
            Jf = !0;
          }
        }), window.addEventListener("test", Fu, Fu), window.removeEventListener("test", Fu, Fu);
      } catch {
        Jf = !1;
      }
    function a1(r, i, d, p, y, C, k, O, N) {
      var z = Array.prototype.slice.call(arguments, 3);
      try {
        i.apply(d, z);
      } catch (j) {
        this.onError(j);
      }
    }
    var ny = a1;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var ry = document.createElement("react");
      ny = function(i, d, p, y, C, k, O, N, z) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var j = document.createEvent("Event"), ue = !1, ae = !0, Ae = window.event, ke = Object.getOwnPropertyDescriptor(window, "event");
        function Ne() {
          ry.removeEventListener(Me, Rt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ae);
        }
        var pt = Array.prototype.slice.call(arguments, 3);
        function Rt() {
          ue = !0, Ne(), d.apply(p, pt), ae = !1;
        }
        var Et, xn = !1, yn = !1;
        function be(Se) {
          if (Et = Se.error, xn = !0, Et === null && Se.colno === 0 && Se.lineno === 0 && (yn = !0), Se.defaultPrevented && Et != null && typeof Et == "object")
            try {
              Et._suppressLogging = !0;
            } catch {
            }
        }
        var Me = "react-" + (i || "aittorguardedcallback");
        if (window.addEventListener("error", be), ry.addEventListener(Me, Rt, !1), j.initEvent(Me, !1, !1), ry.dispatchEvent(j), ke && Object.defineProperty(window, "event", ke), ue && ae && (xn ? yn && (Et = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Et = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Et)), window.removeEventListener("error", be), !ue)
          return Ne(), a1.apply(this, arguments);
      };
    }
    var QT = ny, Ol = !1, Na = null, Qf = !1, _l = null, qa = {
      onError: function(r) {
        Ol = !0, Na = r;
      }
    };
    function Bu(r, i, d, p, y, C, k, O, N) {
      Ol = !1, Na = null, QT.apply(qa, arguments);
    }
    function js(r, i, d, p, y, C, k, O, N) {
      if (Bu.apply(this, arguments), Ol) {
        var z = iy();
        Qf || (Qf = !0, _l = z);
      }
    }
    function oy() {
      if (Qf) {
        var r = _l;
        throw Qf = !1, _l = null, r;
      }
    }
    function KT() {
      return Ol;
    }
    function iy() {
      if (Ol) {
        var r = Na;
        return Ol = !1, Na = null, r;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Yi(r) {
      return r._reactInternals;
    }
    function Kf(r) {
      return r._reactInternals !== void 0;
    }
    function ud(r, i) {
      r._reactInternals = i;
    }
    var At = (
      /*                      */
      0
    ), Dl = (
      /*                */
      1
    ), ir = (
      /*                    */
      2
    ), qt = (
      /*                       */
      4
    ), Nn = (
      /*                */
      16
    ), Fn = (
      /*                 */
      32
    ), es = (
      /*                     */
      64
    ), jt = (
      /*                   */
      128
    ), Tr = (
      /*            */
      256
    ), li = (
      /*                          */
      512
    ), Ji = (
      /*                     */
      1024
    ), hr = (
      /*                      */
      2048
    ), Qi = (
      /*                    */
      4096
    ), Nl = (
      /*                   */
      8192
    ), qf = (
      /*             */
      16384
    ), Xh = hr | qt | es | li | Ji | qf, s1 = (
      /*               */
      32767
    ), Ai = (
      /*                   */
      32768
    ), no = (
      /*                */
      65536
    ), ep = (
      /* */
      131072
    ), ay = (
      /*                       */
      1048576
    ), sy = (
      /*                    */
      2097152
    ), ui = (
      /*                 */
      4194304
    ), Ml = (
      /*                */
      8388608
    ), ci = (
      /*               */
      16777216
    ), Vu = (
      /*              */
      33554432
    ), cd = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      qt | Ji | 0
    ), di = ir | qt | Nn | Fn | li | Qi | Nl, No = qt | es | li | Nl, Ki = hr | Nn, go = ui | Ml | sy, Gs = n.ReactCurrentOwner;
    function ki(r) {
      var i = r, d = r;
      if (r.alternate)
        for (; i.return; )
          i = i.return;
      else {
        var p = i;
        do
          i = p, (i.flags & (ir | Qi)) !== At && (d = i.return), p = i.return;
        while (p);
      }
      return i.tag === b ? d : null;
    }
    function ly(r) {
      if (r.tag === F) {
        var i = r.memoizedState;
        if (i === null) {
          var d = r.alternate;
          d !== null && (i = d.memoizedState);
        }
        if (i !== null)
          return i.dehydrated;
      }
      return null;
    }
    function Zh(r) {
      return r.tag === b ? r.stateNode.containerInfo : null;
    }
    function uy(r) {
      return ki(r) === r;
    }
    function Ri(r) {
      {
        var i = Gs.current;
        if (i !== null && i.tag === v) {
          var d = i, p = d.stateNode;
          p._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ut(d) || "A component"), p._warnedAboutRefsInRender = !0;
        }
      }
      var y = Yi(r);
      return y ? ki(y) === y : !1;
    }
    function fi(r) {
      if (ki(r) !== r)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function ar(r) {
      var i = r.alternate;
      if (!i) {
        var d = ki(r);
        if (d === null)
          throw new Error("Unable to find node on an unmounted component.");
        return d !== r ? null : r;
      }
      for (var p = r, y = i; ; ) {
        var C = p.return;
        if (C === null)
          break;
        var k = C.alternate;
        if (k === null) {
          var O = C.return;
          if (O !== null) {
            p = y = O;
            continue;
          }
          break;
        }
        if (C.child === k.child) {
          for (var N = C.child; N; ) {
            if (N === p)
              return fi(C), r;
            if (N === y)
              return fi(C), i;
            N = N.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (p.return !== y.return)
          p = C, y = k;
        else {
          for (var z = !1, j = C.child; j; ) {
            if (j === p) {
              z = !0, p = C, y = k;
              break;
            }
            if (j === y) {
              z = !0, y = C, p = k;
              break;
            }
            j = j.sibling;
          }
          if (!z) {
            for (j = k.child; j; ) {
              if (j === p) {
                z = !0, p = k, y = C;
                break;
              }
              if (j === y) {
                z = !0, y = k, p = C;
                break;
              }
              j = j.sibling;
            }
            if (!z)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (p.alternate !== y)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (p.tag !== b)
        throw new Error("Unable to find node on an unmounted component.");
      return p.stateNode.current === p ? r : i;
    }
    function qi(r) {
      var i = ar(r);
      return i !== null ? cy(i) : null;
    }
    function cy(r) {
      if (r.tag === w || r.tag === E)
        return r;
      for (var i = r.child; i !== null; ) {
        var d = cy(i);
        if (d !== null)
          return d;
        i = i.sibling;
      }
      return null;
    }
    function l1(r) {
      var i = ar(r);
      return i !== null ? Yh(i) : null;
    }
    function Yh(r) {
      if (r.tag === w || r.tag === E)
        return r;
      for (var i = r.child; i !== null; ) {
        if (i.tag !== S) {
          var d = Yh(i);
          if (d !== null)
            return d;
        }
        i = i.sibling;
      }
      return null;
    }
    var Jh = t.unstable_scheduleCallback, u1 = t.unstable_cancelCallback, Qh = t.unstable_shouldYield, c1 = t.unstable_requestPaint, yr = t.unstable_now, dy = t.unstable_getCurrentPriorityLevel, Kh = t.unstable_ImmediatePriority, Pi = t.unstable_UserBlockingPriority, ts = t.unstable_NormalPriority, qh = t.unstable_LowPriority, Ll = t.unstable_IdlePriority, fy = t.unstable_yieldValue, py = t.unstable_setDisableYieldValue, Fl = null, ro = null, nt = null, Rr = !1, yo = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function hy(r) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var i = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (i.isDisabled)
        return !0;
      if (!i.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        pe && (r = on({}, r, {
          getLaneLabelMap: Vl,
          injectProfilingHooks: Us
        })), Fl = i.inject(r), ro = i;
      } catch (d) {
        u("React instrumentation encountered an error: %s.", d);
      }
      return !!i.checkDCE;
    }
    function d1(r, i) {
      if (ro && typeof ro.onScheduleFiberRoot == "function")
        try {
          ro.onScheduleFiberRoot(Fl, r, i);
        } catch (d) {
          Rr || (Rr = !0, u("React instrumentation encountered an error: %s", d));
        }
    }
    function Ws(r, i) {
      if (ro && typeof ro.onCommitFiberRoot == "function")
        try {
          var d = (r.current.flags & jt) === jt;
          if (Oe) {
            var p;
            switch (i) {
              case Mo:
                p = Kh;
                break;
              case bo:
                p = Pi;
                break;
              case Zs:
                p = ts;
                break;
              case up:
                p = Ll;
                break;
              default:
                p = ts;
                break;
            }
            ro.onCommitFiberRoot(Fl, r, p, d);
          }
        } catch (y) {
          Rr || (Rr = !0, u("React instrumentation encountered an error: %s", y));
        }
    }
    function Bl(r) {
      if (ro && typeof ro.onPostCommitFiberRoot == "function")
        try {
          ro.onPostCommitFiberRoot(Fl, r);
        } catch (i) {
          Rr || (Rr = !0, u("React instrumentation encountered an error: %s", i));
        }
    }
    function my(r) {
      if (ro && typeof ro.onCommitFiberUnmount == "function")
        try {
          ro.onCommitFiberUnmount(Fl, r);
        } catch (i) {
          Rr || (Rr = !0, u("React instrumentation encountered an error: %s", i));
        }
    }
    function Ur(r) {
      if (typeof fy == "function" && (py(r), a(r)), ro && typeof ro.setStrictMode == "function")
        try {
          ro.setStrictMode(Fl, r);
        } catch (i) {
          Rr || (Rr = !0, u("React instrumentation encountered an error: %s", i));
        }
    }
    function Us(r) {
      nt = r;
    }
    function Vl() {
      {
        for (var r = /* @__PURE__ */ new Map(), i = 1, d = 0; d < sr; d++) {
          var p = qT(i);
          r.set(i, p), i *= 2;
        }
        return r;
      }
    }
    function em(r) {
      nt !== null && typeof nt.markCommitStarted == "function" && nt.markCommitStarted(r);
    }
    function vy() {
      nt !== null && typeof nt.markCommitStopped == "function" && nt.markCommitStopped();
    }
    function $l(r) {
      nt !== null && typeof nt.markComponentRenderStarted == "function" && nt.markComponentRenderStarted(r);
    }
    function $u() {
      nt !== null && typeof nt.markComponentRenderStopped == "function" && nt.markComponentRenderStopped();
    }
    function f1(r) {
      nt !== null && typeof nt.markComponentPassiveEffectMountStarted == "function" && nt.markComponentPassiveEffectMountStarted(r);
    }
    function gy() {
      nt !== null && typeof nt.markComponentPassiveEffectMountStopped == "function" && nt.markComponentPassiveEffectMountStopped();
    }
    function tm(r) {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStarted == "function" && nt.markComponentPassiveEffectUnmountStarted(r);
    }
    function p1() {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStopped == "function" && nt.markComponentPassiveEffectUnmountStopped();
    }
    function h1(r) {
      nt !== null && typeof nt.markComponentLayoutEffectMountStarted == "function" && nt.markComponentLayoutEffectMountStarted(r);
    }
    function m1() {
      nt !== null && typeof nt.markComponentLayoutEffectMountStopped == "function" && nt.markComponentLayoutEffectMountStopped();
    }
    function nm(r) {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStarted == "function" && nt.markComponentLayoutEffectUnmountStarted(r);
    }
    function dd() {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStopped == "function" && nt.markComponentLayoutEffectUnmountStopped();
    }
    function rm(r, i, d) {
      nt !== null && typeof nt.markComponentErrored == "function" && nt.markComponentErrored(r, i, d);
    }
    function v1(r, i, d) {
      nt !== null && typeof nt.markComponentSuspended == "function" && nt.markComponentSuspended(r, i, d);
    }
    function g1(r) {
      nt !== null && typeof nt.markLayoutEffectsStarted == "function" && nt.markLayoutEffectsStarted(r);
    }
    function fd() {
      nt !== null && typeof nt.markLayoutEffectsStopped == "function" && nt.markLayoutEffectsStopped();
    }
    function y1(r) {
      nt !== null && typeof nt.markPassiveEffectsStarted == "function" && nt.markPassiveEffectsStarted(r);
    }
    function tp() {
      nt !== null && typeof nt.markPassiveEffectsStopped == "function" && nt.markPassiveEffectsStopped();
    }
    function Ma(r) {
      nt !== null && typeof nt.markRenderStarted == "function" && nt.markRenderStarted(r);
    }
    function np() {
      nt !== null && typeof nt.markRenderYielded == "function" && nt.markRenderYielded();
    }
    function pd() {
      nt !== null && typeof nt.markRenderStopped == "function" && nt.markRenderStopped();
    }
    function zu(r) {
      nt !== null && typeof nt.markRenderScheduled == "function" && nt.markRenderScheduled(r);
    }
    function yy(r, i) {
      nt !== null && typeof nt.markForceUpdateScheduled == "function" && nt.markForceUpdateScheduled(r, i);
    }
    function zl(r, i) {
      nt !== null && typeof nt.markStateUpdateScheduled == "function" && nt.markStateUpdateScheduled(r, i);
    }
    var _t = (
      /*                         */
      0
    ), pn = (
      /*                 */
      1
    ), Mt = (
      /*                    */
      2
    ), br = (
      /*               */
      8
    ), ea = (
      /*              */
      16
    ), om = Math.clz32 ? Math.clz32 : Hu, im = Math.log, by = Math.LN2;
    function Hu(r) {
      var i = r >>> 0;
      return i === 0 ? 32 : 31 - (im(i) / by | 0) | 0;
    }
    var sr = 31, Be = (
      /*                        */
      0
    ), bn = (
      /*                          */
      0
    ), Lt = (
      /*                        */
      1
    ), ns = (
      /*    */
      2
    ), Oi = (
      /*             */
      4
    ), ju = (
      /*            */
      8
    ), lr = (
      /*                     */
      16
    ), Gu = (
      /*                */
      32
    ), Hl = (
      /*                       */
      4194240
    ), Wu = (
      /*                        */
      64
    ), ta = (
      /*                        */
      128
    ), pi = (
      /*                        */
      256
    ), Uu = (
      /*                        */
      512
    ), rp = (
      /*                        */
      1024
    ), op = (
      /*                        */
      2048
    ), am = (
      /*                        */
      4096
    ), sm = (
      /*                        */
      8192
    ), lm = (
      /*                        */
      16384
    ), um = (
      /*                       */
      32768
    ), cm = (
      /*                       */
      65536
    ), dm = (
      /*                       */
      131072
    ), fm = (
      /*                       */
      262144
    ), pm = (
      /*                       */
      524288
    ), Xu = (
      /*                       */
      1048576
    ), hm = (
      /*                       */
      2097152
    ), Zu = (
      /*                            */
      130023424
    ), Xs = (
      /*                             */
      4194304
    ), mm = (
      /*                             */
      8388608
    ), ip = (
      /*                             */
      16777216
    ), vm = (
      /*                             */
      33554432
    ), gm = (
      /*                             */
      67108864
    ), Sy = Xs, hd = (
      /*          */
      134217728
    ), ym = (
      /*                          */
      268435455
    ), md = (
      /*               */
      268435456
    ), jl = (
      /*                        */
      536870912
    ), hi = (
      /*                   */
      1073741824
    );
    function qT(r) {
      {
        if (r & Lt)
          return "Sync";
        if (r & ns)
          return "InputContinuousHydration";
        if (r & Oi)
          return "InputContinuous";
        if (r & ju)
          return "DefaultHydration";
        if (r & lr)
          return "Default";
        if (r & Gu)
          return "TransitionHydration";
        if (r & Hl)
          return "Transition";
        if (r & Zu)
          return "Retry";
        if (r & hd)
          return "SelectiveHydration";
        if (r & md)
          return "IdleHydration";
        if (r & jl)
          return "Idle";
        if (r & hi)
          return "Offscreen";
      }
    }
    var tr = -1, bm = Wu, Sm = Xs;
    function vd(r) {
      switch (Lr(r)) {
        case Lt:
          return Lt;
        case ns:
          return ns;
        case Oi:
          return Oi;
        case ju:
          return ju;
        case lr:
          return lr;
        case Gu:
          return Gu;
        case Wu:
        case ta:
        case pi:
        case Uu:
        case rp:
        case op:
        case am:
        case sm:
        case lm:
        case um:
        case cm:
        case dm:
        case fm:
        case pm:
        case Xu:
        case hm:
          return r & Hl;
        case Xs:
        case mm:
        case ip:
        case vm:
        case gm:
          return r & Zu;
        case hd:
          return hd;
        case md:
          return md;
        case jl:
          return jl;
        case hi:
          return hi;
        default:
          return u("Should have found matching lanes. This is a bug in React."), r;
      }
    }
    function ap(r, i) {
      var d = r.pendingLanes;
      if (d === Be)
        return Be;
      var p = Be, y = r.suspendedLanes, C = r.pingedLanes, k = d & ym;
      if (k !== Be) {
        var O = k & ~y;
        if (O !== Be)
          p = vd(O);
        else {
          var N = k & C;
          N !== Be && (p = vd(N));
        }
      } else {
        var z = d & ~y;
        z !== Be ? p = vd(z) : C !== Be && (p = vd(C));
      }
      if (p === Be)
        return Be;
      if (i !== Be && i !== p && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (i & y) === Be) {
        var j = Lr(p), ue = Lr(i);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          j >= ue || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          j === lr && (ue & Hl) !== Be
        )
          return i;
      }
      (p & Oi) !== Be && (p |= d & lr);
      var ae = r.entangledLanes;
      if (ae !== Be)
        for (var Ae = r.entanglements, ke = p & ae; ke > 0; ) {
          var Ne = Gl(ke), pt = 1 << Ne;
          p |= Ae[Ne], ke &= ~pt;
        }
      return p;
    }
    function b1(r, i) {
      for (var d = r.eventTimes, p = tr; i > 0; ) {
        var y = Gl(i), C = 1 << y, k = d[y];
        k > p && (p = k), i &= ~C;
      }
      return p;
    }
    function xm(r, i) {
      switch (r) {
        case Lt:
        case ns:
        case Oi:
          return i + 250;
        case ju:
        case lr:
        case Gu:
        case Wu:
        case ta:
        case pi:
        case Uu:
        case rp:
        case op:
        case am:
        case sm:
        case lm:
        case um:
        case cm:
        case dm:
        case fm:
        case pm:
        case Xu:
        case hm:
          return i + 5e3;
        case Xs:
        case mm:
        case ip:
        case vm:
        case gm:
          return tr;
        case hd:
        case md:
        case jl:
        case hi:
          return tr;
        default:
          return u("Should have found matching lanes. This is a bug in React."), tr;
      }
    }
    function eI(r, i) {
      for (var d = r.pendingLanes, p = r.suspendedLanes, y = r.pingedLanes, C = r.expirationTimes, k = d; k > 0; ) {
        var O = Gl(k), N = 1 << O, z = C[O];
        z === tr ? ((N & p) === Be || (N & y) !== Be) && (C[O] = xm(N, i)) : z <= i && (r.expiredLanes |= N), k &= ~N;
      }
    }
    function tI(r) {
      return vd(r.pendingLanes);
    }
    function xy(r) {
      var i = r.pendingLanes & ~hi;
      return i !== Be ? i : i & hi ? hi : Be;
    }
    function gd(r) {
      return (r & Lt) !== Be;
    }
    function sp(r) {
      return (r & ym) !== Be;
    }
    function Cm(r) {
      return (r & Zu) === r;
    }
    function nI(r) {
      var i = Lt | Oi | lr;
      return (r & i) === Be;
    }
    function S1(r) {
      return (r & Hl) === r;
    }
    function lp(r, i) {
      var d = ns | Oi | ju | lr;
      return (i & d) !== Be;
    }
    function x1(r, i) {
      return (i & r.expiredLanes) !== Be;
    }
    function Cy(r) {
      return (r & Hl) !== Be;
    }
    function wy() {
      var r = bm;
      return bm <<= 1, (bm & Hl) === Be && (bm = Wu), r;
    }
    function rI() {
      var r = Sm;
      return Sm <<= 1, (Sm & Zu) === Be && (Sm = Xs), r;
    }
    function Lr(r) {
      return r & -r;
    }
    function Xr(r) {
      return Lr(r);
    }
    function Gl(r) {
      return 31 - om(r);
    }
    function wm(r) {
      return Gl(r);
    }
    function mi(r, i) {
      return (r & i) !== Be;
    }
    function Yu(r, i) {
      return (r & i) === i;
    }
    function en(r, i) {
      return r | i;
    }
    function yd(r, i) {
      return r & ~i;
    }
    function Ey(r, i) {
      return r & i;
    }
    function C1(r) {
      return r;
    }
    function w1(r, i) {
      return r !== bn && r < i ? r : i;
    }
    function Em(r) {
      for (var i = [], d = 0; d < sr; d++)
        i.push(r);
      return i;
    }
    function Ju(r, i, d) {
      r.pendingLanes |= i, i !== jl && (r.suspendedLanes = Be, r.pingedLanes = Be);
      var p = r.eventTimes, y = wm(i);
      p[y] = d;
    }
    function Ty(r, i) {
      r.suspendedLanes |= i, r.pingedLanes &= ~i;
      for (var d = r.expirationTimes, p = i; p > 0; ) {
        var y = Gl(p), C = 1 << y;
        d[y] = tr, p &= ~C;
      }
    }
    function Iy(r, i, d) {
      r.pingedLanes |= r.suspendedLanes & i;
    }
    function Ay(r, i) {
      var d = r.pendingLanes & ~i;
      r.pendingLanes = i, r.suspendedLanes = Be, r.pingedLanes = Be, r.expiredLanes &= i, r.mutableReadLanes &= i, r.entangledLanes &= i;
      for (var p = r.entanglements, y = r.eventTimes, C = r.expirationTimes, k = d; k > 0; ) {
        var O = Gl(k), N = 1 << O;
        p[O] = Be, y[O] = tr, C[O] = tr, k &= ~N;
      }
    }
    function bd(r, i) {
      for (var d = r.entangledLanes |= i, p = r.entanglements, y = d; y; ) {
        var C = Gl(y), k = 1 << C;
        // Is this one of the newly entangled lanes?
        k & i | // Is this lane transitively entangled with the newly entangled lanes?
        p[C] & i && (p[C] |= i), y &= ~k;
      }
    }
    function oI(r, i) {
      var d = Lr(i), p;
      switch (d) {
        case Oi:
          p = ns;
          break;
        case lr:
          p = ju;
          break;
        case Wu:
        case ta:
        case pi:
        case Uu:
        case rp:
        case op:
        case am:
        case sm:
        case lm:
        case um:
        case cm:
        case dm:
        case fm:
        case pm:
        case Xu:
        case hm:
        case Xs:
        case mm:
        case ip:
        case vm:
        case gm:
          p = Gu;
          break;
        case jl:
          p = md;
          break;
        default:
          p = bn;
          break;
      }
      return (p & (r.suspendedLanes | i)) !== bn ? bn : p;
    }
    function ky(r, i, d) {
      if (yo)
        for (var p = r.pendingUpdatersLaneMap; d > 0; ) {
          var y = wm(d), C = 1 << y, k = p[y];
          k.add(i), d &= ~C;
        }
    }
    function Tm(r, i) {
      if (yo)
        for (var d = r.pendingUpdatersLaneMap, p = r.memoizedUpdaters; i > 0; ) {
          var y = wm(i), C = 1 << y, k = d[y];
          k.size > 0 && (k.forEach(function(O) {
            var N = O.alternate;
            (N === null || !p.has(N)) && p.add(O);
          }), k.clear()), i &= ~C;
        }
    }
    function Ry(r, i) {
      return null;
    }
    var Mo = Lt, bo = Oi, Zs = lr, up = jl, Qu = bn;
    function na() {
      return Qu;
    }
    function Zr(r) {
      Qu = r;
    }
    function cp(r, i) {
      var d = Qu;
      try {
        return Qu = r, i();
      } finally {
        Qu = d;
      }
    }
    function Lo(r, i) {
      return r !== 0 && r < i ? r : i;
    }
    function iI(r, i) {
      return r === 0 || r > i ? r : i;
    }
    function Py(r, i) {
      return r !== 0 && r < i;
    }
    function dp(r) {
      var i = Lr(r);
      return Py(Mo, i) ? Py(bo, i) ? sp(i) ? Zs : up : bo : Mo;
    }
    function Yr(r) {
      var i = r.current.memoizedState;
      return i.isDehydrated;
    }
    var E1;
    function yt(r) {
      E1 = r;
    }
    function Sd(r) {
      E1(r);
    }
    var fp;
    function T1(r) {
      fp = r;
    }
    var I1;
    function pp(r) {
      I1 = r;
    }
    var hp;
    function Oy(r) {
      hp = r;
    }
    var _y;
    function A1(r) {
      _y = r;
    }
    var Im = !1, xd = [], rs = null, mr = null, oo = null, ra = /* @__PURE__ */ new Map(), Cd = /* @__PURE__ */ new Map(), Ys = [], La = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function k1(r) {
      return La.indexOf(r) > -1;
    }
    function os(r, i, d, p, y) {
      return {
        blockedOn: r,
        domEventName: i,
        eventSystemFlags: d,
        nativeEvent: y,
        targetContainers: [p]
      };
    }
    function R1(r, i) {
      switch (r) {
        case "focusin":
        case "focusout":
          rs = null;
          break;
        case "dragenter":
        case "dragleave":
          mr = null;
          break;
        case "mouseover":
        case "mouseout":
          oo = null;
          break;
        case "pointerover":
        case "pointerout": {
          var d = i.pointerId;
          ra.delete(d);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var p = i.pointerId;
          Cd.delete(p);
          break;
        }
      }
    }
    function wd(r, i, d, p, y, C) {
      if (r === null || r.nativeEvent !== C) {
        var k = os(i, d, p, y, C);
        if (i !== null) {
          var O = Nd(i);
          O !== null && fp(O);
        }
        return k;
      }
      r.eventSystemFlags |= p;
      var N = r.targetContainers;
      return y !== null && N.indexOf(y) === -1 && N.push(y), r;
    }
    function P1(r, i, d, p, y) {
      switch (i) {
        case "focusin": {
          var C = y;
          return rs = wd(rs, r, i, d, p, C), !0;
        }
        case "dragenter": {
          var k = y;
          return mr = wd(mr, r, i, d, p, k), !0;
        }
        case "mouseover": {
          var O = y;
          return oo = wd(oo, r, i, d, p, O), !0;
        }
        case "pointerover": {
          var N = y, z = N.pointerId;
          return ra.set(z, wd(ra.get(z) || null, r, i, d, p, N)), !0;
        }
        case "gotpointercapture": {
          var j = y, ue = j.pointerId;
          return Cd.set(ue, wd(Cd.get(ue) || null, r, i, d, p, j)), !0;
        }
      }
      return !1;
    }
    function Dy(r) {
      var i = wp(r.target);
      if (i !== null) {
        var d = ki(i);
        if (d !== null) {
          var p = d.tag;
          if (p === F) {
            var y = ly(d);
            if (y !== null) {
              r.blockedOn = y, _y(r.priority, function() {
                I1(d);
              });
              return;
            }
          } else if (p === b) {
            var C = d.stateNode;
            if (Yr(C)) {
              r.blockedOn = Zh(d);
              return;
            }
          }
        }
      }
      r.blockedOn = null;
    }
    function O1(r) {
      for (var i = hp(), d = {
        blockedOn: null,
        target: r,
        priority: i
      }, p = 0; p < Ys.length && Py(i, Ys[p].priority); p++)
        ;
      Ys.splice(p, 0, d), p === 0 && Dy(d);
    }
    function Am(r) {
      if (r.blockedOn !== null)
        return !1;
      for (var i = r.targetContainers; i.length > 0; ) {
        var d = i[0], p = Ku(r.domEventName, r.eventSystemFlags, d, r.nativeEvent);
        if (p === null) {
          var y = r.nativeEvent, C = new y.constructor(y.type, y);
          Xf(C), y.target.dispatchEvent(C), YT();
        } else {
          var k = Nd(p);
          return k !== null && fp(k), r.blockedOn = p, !1;
        }
        i.shift();
      }
      return !0;
    }
    function mp(r, i, d) {
      Am(r) && d.delete(i);
    }
    function Ny() {
      Im = !1, rs !== null && Am(rs) && (rs = null), mr !== null && Am(mr) && (mr = null), oo !== null && Am(oo) && (oo = null), ra.forEach(mp), Cd.forEach(mp);
    }
    function Fo(r, i) {
      r.blockedOn === i && (r.blockedOn = null, Im || (Im = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Ny)));
    }
    function gn(r) {
      if (xd.length > 0) {
        Fo(xd[0], r);
        for (var i = 1; i < xd.length; i++) {
          var d = xd[i];
          d.blockedOn === r && (d.blockedOn = null);
        }
      }
      rs !== null && Fo(rs, r), mr !== null && Fo(mr, r), oo !== null && Fo(oo, r);
      var p = function(O) {
        return Fo(O, r);
      };
      ra.forEach(p), Cd.forEach(p);
      for (var y = 0; y < Ys.length; y++) {
        var C = Ys[y];
        C.blockedOn === r && (C.blockedOn = null);
      }
      for (; Ys.length > 0; ) {
        var k = Ys[0];
        if (k.blockedOn !== null)
          break;
        Dy(k), k.blockedOn === null && Ys.shift();
      }
    }
    var Sr = n.ReactCurrentBatchConfig, Ir = !0;
    function io(r) {
      Ir = !!r;
    }
    function _i() {
      return Ir;
    }
    function Ed(r, i, d) {
      var p = Ho(i), y;
      switch (p) {
        case Mo:
          y = Jr;
          break;
        case bo:
          y = vp;
          break;
        case Zs:
        default:
          y = Js;
          break;
      }
      return y.bind(null, i, d, r);
    }
    function Jr(r, i, d, p) {
      var y = na(), C = Sr.transition;
      Sr.transition = null;
      try {
        Zr(Mo), Js(r, i, d, p);
      } finally {
        Zr(y), Sr.transition = C;
      }
    }
    function vp(r, i, d, p) {
      var y = na(), C = Sr.transition;
      Sr.transition = null;
      try {
        Zr(bo), Js(r, i, d, p);
      } finally {
        Zr(y), Sr.transition = C;
      }
    }
    function Js(r, i, d, p) {
      Ir && km(r, i, d, p);
    }
    function km(r, i, d, p) {
      var y = Ku(r, i, d, p);
      if (y === null) {
        TI(r, i, p, Td, d), R1(r, p);
        return;
      }
      if (P1(y, r, i, d, p)) {
        p.stopPropagation();
        return;
      }
      if (R1(r, p), i & Nu && k1(r)) {
        for (; y !== null; ) {
          var C = Nd(y);
          C !== null && Sd(C);
          var k = Ku(r, i, d, p);
          if (k === null && TI(r, i, p, Td, d), k === y)
            break;
          y = k;
        }
        y !== null && p.stopPropagation();
        return;
      }
      TI(r, i, p, null, d);
    }
    var Td = null;
    function Ku(r, i, d, p) {
      Td = null;
      var y = jh(p), C = wp(y);
      if (C !== null) {
        var k = ki(C);
        if (k === null)
          C = null;
        else {
          var O = k.tag;
          if (O === F) {
            var N = ly(k);
            if (N !== null)
              return N;
            C = null;
          } else if (O === b) {
            var z = k.stateNode;
            if (Yr(z))
              return Zh(k);
            C = null;
          } else
            k !== C && (C = null);
        }
      }
      return Td = C, null;
    }
    function Ho(r) {
      switch (r) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Mo;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return bo;
        case "message": {
          var i = dy();
          switch (i) {
            case Kh:
              return Mo;
            case Pi:
              return bo;
            case ts:
            case qh:
              return Zs;
            case Ll:
              return up;
            default:
              return Zs;
          }
        }
        default:
          return Zs;
      }
    }
    function My(r, i, d) {
      return r.addEventListener(i, d, !1), d;
    }
    function Id(r, i, d) {
      return r.addEventListener(i, d, !0), d;
    }
    function Qs(r, i, d, p) {
      return r.addEventListener(i, d, {
        capture: !0,
        passive: p
      }), d;
    }
    function Rm(r, i, d, p) {
      return r.addEventListener(i, d, {
        passive: p
      }), d;
    }
    var qu = null, is = null, Wl = null;
    function Ul(r) {
      return qu = r, is = Om(), !0;
    }
    function Pm() {
      qu = null, is = null, Wl = null;
    }
    function Ad() {
      if (Wl)
        return Wl;
      var r, i = is, d = i.length, p, y = Om(), C = y.length;
      for (r = 0; r < d && i[r] === y[r]; r++)
        ;
      var k = d - r;
      for (p = 1; p <= k && i[d - p] === y[C - p]; p++)
        ;
      var O = p > 1 ? 1 - p : void 0;
      return Wl = y.slice(r, O), Wl;
    }
    function Om() {
      return "value" in qu ? qu.value : qu.textContent;
    }
    function ec(r) {
      var i, d = r.keyCode;
      return "charCode" in r ? (i = r.charCode, i === 0 && d === 13 && (i = 13)) : i = d, i === 10 && (i = 13), i >= 32 || i === 13 ? i : 0;
    }
    function tc() {
      return !0;
    }
    function Bo() {
      return !1;
    }
    function Fr(r) {
      function i(d, p, y, C, k) {
        this._reactName = d, this._targetInst = y, this.type = p, this.nativeEvent = C, this.target = k, this.currentTarget = null;
        for (var O in r)
          if (r.hasOwnProperty(O)) {
            var N = r[O];
            N ? this[O] = N(C) : this[O] = C[O];
          }
        var z = C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1;
        return z ? this.isDefaultPrevented = tc : this.isDefaultPrevented = Bo, this.isPropagationStopped = Bo, this;
      }
      return on(i.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = tc);
        },
        stopPropagation: function() {
          var d = this.nativeEvent;
          d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = tc);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: tc
      }), i;
    }
    var Vo = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(r) {
        return r.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, $o = Fr(Vo), kd = on({}, Vo, {
      view: 0,
      detail: 0
    }), Ly = Fr(kd), gp, Fy, oa;
    function _1(r) {
      r !== oa && (oa && r.type === "mousemove" ? (gp = r.screenX - oa.screenX, Fy = r.screenY - oa.screenY) : (gp = 0, Fy = 0), oa = r);
    }
    var Rd = on({}, kd, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Nm,
      button: 0,
      buttons: 0,
      relatedTarget: function(r) {
        return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
      },
      movementX: function(r) {
        return "movementX" in r ? r.movementX : (_1(r), gp);
      },
      movementY: function(r) {
        return "movementY" in r ? r.movementY : Fy;
      }
    }), Xl = Fr(Rd), By = on({}, Rd, {
      dataTransfer: 0
    }), nc = Fr(By), D1 = on({}, kd, {
      relatedTarget: 0
    }), _m = Fr(D1), Vy = on({}, Vo, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Dm = Fr(Vy), aI = on({}, Vo, {
      clipboardData: function(r) {
        return "clipboardData" in r ? r.clipboardData : window.clipboardData;
      }
    }), sI = Fr(aI), N1 = on({}, Vo, {
      data: 0
    }), $y = Fr(N1), rc = $y, lI = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Pd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function M1(r) {
      if (r.key) {
        var i = lI[r.key] || r.key;
        if (i !== "Unidentified")
          return i;
      }
      if (r.type === "keypress") {
        var d = ec(r);
        return d === 13 ? "Enter" : String.fromCharCode(d);
      }
      return r.type === "keydown" || r.type === "keyup" ? Pd[r.keyCode] || "Unidentified" : "";
    }
    var Ar = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function uI(r) {
      var i = this, d = i.nativeEvent;
      if (d.getModifierState)
        return d.getModifierState(r);
      var p = Ar[r];
      return p ? !!d[p] : !1;
    }
    function Nm(r) {
      return uI;
    }
    var cI = on({}, kd, {
      key: M1,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Nm,
      // Legacy Interface
      charCode: function(r) {
        return r.type === "keypress" ? ec(r) : 0;
      },
      keyCode: function(r) {
        return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      },
      which: function(r) {
        return r.type === "keypress" ? ec(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      }
    }), dI = Fr(cI), L1 = on({}, Rd, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), zy = Fr(L1), fI = on({}, kd, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Nm
    }), ia = Fr(fI), Hy = on({}, Vo, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), pI = Fr(Hy), Zl = on({}, Rd, {
      deltaX: function(r) {
        return "deltaX" in r ? r.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in r ? -r.wheelDeltaX : 0
        );
      },
      deltaY: function(r) {
        return "deltaY" in r ? r.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in r ? -r.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in r ? -r.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Mm = Fr(Zl), oc = [9, 13, 27, 32], yp = 229, bp = ze && "CompositionEvent" in window, ic = null;
    ze && "documentMode" in document && (ic = document.documentMode);
    var hI = ze && "TextEvent" in window && !ic, Lm = ze && (!bp || ic && ic > 8 && ic <= 11), F1 = 32, jy = String.fromCharCode(F1);
    function B1() {
      we("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), we("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), we("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), we("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Sp = !1;
    function Fm(r) {
      return (r.ctrlKey || r.altKey || r.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(r.ctrlKey && r.altKey);
    }
    function V1(r) {
      switch (r) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Gy(r, i) {
      return r === "keydown" && i.keyCode === yp;
    }
    function $1(r, i) {
      switch (r) {
        case "keyup":
          return oc.indexOf(i.keyCode) !== -1;
        case "keydown":
          return i.keyCode !== yp;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Wy(r) {
      var i = r.detail;
      return typeof i == "object" && "data" in i ? i.data : null;
    }
    function Bm(r) {
      return r.locale === "ko";
    }
    var Ks = !1;
    function Uy(r, i, d, p, y) {
      var C, k;
      if (bp ? C = V1(i) : Ks ? $1(i, p) && (C = "onCompositionEnd") : Gy(i, p) && (C = "onCompositionStart"), !C)
        return null;
      Lm && !Bm(p) && (!Ks && C === "onCompositionStart" ? Ks = Ul(y) : C === "onCompositionEnd" && Ks && (k = Ad()));
      var O = W1(d, C);
      if (O.length > 0) {
        var N = new $y(C, i, null, p, y);
        if (r.push({
          event: N,
          listeners: O
        }), k)
          N.data = k;
        else {
          var z = Wy(p);
          z !== null && (N.data = z);
        }
      }
    }
    function Vm(r, i) {
      switch (r) {
        case "compositionend":
          return Wy(i);
        case "keypress":
          var d = i.which;
          return d !== F1 ? null : (Sp = !0, jy);
        case "textInput":
          var p = i.data;
          return p === jy && Sp ? null : p;
        default:
          return null;
      }
    }
    function z1(r, i) {
      if (Ks) {
        if (r === "compositionend" || !bp && $1(r, i)) {
          var d = Ad();
          return Pm(), Ks = !1, d;
        }
        return null;
      }
      switch (r) {
        case "paste":
          return null;
        case "keypress":
          if (!Fm(i)) {
            if (i.char && i.char.length > 1)
              return i.char;
            if (i.which)
              return String.fromCharCode(i.which);
          }
          return null;
        case "compositionend":
          return Lm && !Bm(i) ? null : i.data;
        default:
          return null;
      }
    }
    function mI(r, i, d, p, y) {
      var C;
      if (hI ? C = Vm(i, p) : C = z1(i, p), !C)
        return null;
      var k = W1(d, "onBeforeInput");
      if (k.length > 0) {
        var O = new rc("onBeforeInput", "beforeinput", null, p, y);
        r.push({
          event: O,
          listeners: k
        }), O.data = C;
      }
    }
    function $m(r, i, d, p, y, C, k) {
      Uy(r, i, d, p, y), mI(r, i, d, p, y);
    }
    var vI = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Od(r) {
      var i = r && r.nodeName && r.nodeName.toLowerCase();
      return i === "input" ? !!vI[r.type] : i === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function gI(r) {
      if (!ze)
        return !1;
      var i = "on" + r, d = i in document;
      if (!d) {
        var p = document.createElement("div");
        p.setAttribute(i, "return;"), d = typeof p[i] == "function";
      }
      return d;
    }
    function zm() {
      we("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function s(r, i, d, p) {
      Gh(p);
      var y = W1(i, "onChange");
      if (y.length > 0) {
        var C = new $o("onChange", "change", null, d, p);
        r.push({
          event: C,
          listeners: y
        });
      }
    }
    var c = null, m = null;
    function x(r) {
      var i = r.nodeName && r.nodeName.toLowerCase();
      return i === "select" || i === "input" && r.type === "file";
    }
    function I(r) {
      var i = [];
      s(i, m, r, jh(r)), ey(R, i);
    }
    function R(r) {
      aN(r, 0);
    }
    function B(r) {
      var i = Xm(r);
      if (X(i))
        return r;
    }
    function Z(r, i) {
      if (r === "change")
        return i;
    }
    var ee = !1;
    ze && (ee = gI("input") && (!document.documentMode || document.documentMode > 9));
    function Pe(r, i) {
      c = r, m = i, c.attachEvent("onpropertychange", Ze);
    }
    function We() {
      c && (c.detachEvent("onpropertychange", Ze), c = null, m = null);
    }
    function Ze(r) {
      r.propertyName === "value" && B(m) && I(r);
    }
    function Ge(r, i, d) {
      r === "focusin" ? (We(), Pe(i, d)) : r === "focusout" && We();
    }
    function ut(r, i) {
      if (r === "selectionchange" || r === "keyup" || r === "keydown")
        return B(m);
    }
    function bt(r) {
      var i = r.nodeName;
      return i && i.toLowerCase() === "input" && (r.type === "checkbox" || r.type === "radio");
    }
    function Ct(r, i) {
      if (r === "click")
        return B(i);
    }
    function Pr(r, i) {
      if (r === "input" || r === "change")
        return B(i);
    }
    function ve(r) {
      var i = r._wrapperState;
      !i || !i.controlled || r.type !== "number" || Oa(r, "number", r.value);
    }
    function le(r, i, d, p, y, C, k) {
      var O = d ? Xm(d) : window, N, z;
      if (x(O) ? N = Z : Od(O) ? ee ? N = Pr : (N = ut, z = Ge) : bt(O) && (N = Ct), N) {
        var j = N(i, d);
        if (j) {
          s(r, j, p, y);
          return;
        }
      }
      z && z(i, O, d), i === "focusout" && ve(O);
    }
    function Te() {
      fe("onMouseEnter", ["mouseout", "mouseover"]), fe("onMouseLeave", ["mouseout", "mouseover"]), fe("onPointerEnter", ["pointerout", "pointerover"]), fe("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Ke(r, i, d, p, y, C, k) {
      var O = i === "mouseover" || i === "pointerover", N = i === "mouseout" || i === "pointerout";
      if (O && !o1(p)) {
        var z = p.relatedTarget || p.fromElement;
        if (z && (wp(z) || ab(z)))
          return;
      }
      if (!(!N && !O)) {
        var j;
        if (y.window === y)
          j = y;
        else {
          var ue = y.ownerDocument;
          ue ? j = ue.defaultView || ue.parentWindow : j = window;
        }
        var ae, Ae;
        if (N) {
          var ke = p.relatedTarget || p.toElement;
          if (ae = d, Ae = ke ? wp(ke) : null, Ae !== null) {
            var Ne = ki(Ae);
            (Ae !== Ne || Ae.tag !== w && Ae.tag !== E) && (Ae = null);
          }
        } else
          ae = null, Ae = d;
        if (ae !== Ae) {
          var pt = Xl, Rt = "onMouseLeave", Et = "onMouseEnter", xn = "mouse";
          (i === "pointerout" || i === "pointerover") && (pt = zy, Rt = "onPointerLeave", Et = "onPointerEnter", xn = "pointer");
          var yn = ae == null ? j : Xm(ae), be = Ae == null ? j : Xm(Ae), Me = new pt(Rt, xn + "leave", ae, p, y);
          Me.target = yn, Me.relatedTarget = be;
          var Se = null, Ye = wp(y);
          if (Ye === d) {
            var ht = new pt(Et, xn + "enter", Ae, p, y);
            ht.target = be, ht.relatedTarget = yn, Se = ht;
          }
          j6(r, Me, Se, ae, Ae);
        }
      }
    }
    function wt(r, i) {
      return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i;
    }
    var St = typeof Object.is == "function" ? Object.is : wt;
    function It(r, i) {
      if (St(r, i))
        return !0;
      if (typeof r != "object" || r === null || typeof i != "object" || i === null)
        return !1;
      var d = Object.keys(r), p = Object.keys(i);
      if (d.length !== p.length)
        return !1;
      for (var y = 0; y < d.length; y++) {
        var C = d[y];
        if (!Ve.call(i, C) || !St(r[C], i[C]))
          return !1;
      }
      return !0;
    }
    function Gt(r) {
      for (; r && r.firstChild; )
        r = r.firstChild;
      return r;
    }
    function ao(r) {
      for (; r; ) {
        if (r.nextSibling)
          return r.nextSibling;
        r = r.parentNode;
      }
    }
    function In(r, i) {
      for (var d = Gt(r), p = 0, y = 0; d; ) {
        if (d.nodeType === Vs) {
          if (y = p + d.textContent.length, p <= i && y >= i)
            return {
              node: d,
              offset: i - p
            };
          p = y;
        }
        d = Gt(ao(d));
      }
    }
    function Yl(r) {
      var i = r.ownerDocument, d = i && i.defaultView || window, p = d.getSelection && d.getSelection();
      if (!p || p.rangeCount === 0)
        return null;
      var y = p.anchorNode, C = p.anchorOffset, k = p.focusNode, O = p.focusOffset;
      try {
        y.nodeType, k.nodeType;
      } catch {
        return null;
      }
      return yI(r, y, C, k, O);
    }
    function yI(r, i, d, p, y) {
      var C = 0, k = -1, O = -1, N = 0, z = 0, j = r, ue = null;
      e:
        for (; ; ) {
          for (var ae = null; j === i && (d === 0 || j.nodeType === Vs) && (k = C + d), j === p && (y === 0 || j.nodeType === Vs) && (O = C + y), j.nodeType === Vs && (C += j.nodeValue.length), (ae = j.firstChild) !== null; )
            ue = j, j = ae;
          for (; ; ) {
            if (j === r)
              break e;
            if (ue === i && ++N === d && (k = C), ue === p && ++z === y && (O = C), (ae = j.nextSibling) !== null)
              break;
            j = ue, ue = j.parentNode;
          }
          j = ae;
        }
      return k === -1 || O === -1 ? null : {
        start: k,
        end: O
      };
    }
    function E6(r, i) {
      var d = r.ownerDocument || document, p = d && d.defaultView || window;
      if (p.getSelection) {
        var y = p.getSelection(), C = r.textContent.length, k = Math.min(i.start, C), O = i.end === void 0 ? k : Math.min(i.end, C);
        if (!y.extend && k > O) {
          var N = O;
          O = k, k = N;
        }
        var z = In(r, k), j = In(r, O);
        if (z && j) {
          if (y.rangeCount === 1 && y.anchorNode === z.node && y.anchorOffset === z.offset && y.focusNode === j.node && y.focusOffset === j.offset)
            return;
          var ue = d.createRange();
          ue.setStart(z.node, z.offset), y.removeAllRanges(), k > O ? (y.addRange(ue), y.extend(j.node, j.offset)) : (ue.setEnd(j.node, j.offset), y.addRange(ue));
        }
      }
    }
    function ZD(r) {
      return r && r.nodeType === Vs;
    }
    function YD(r, i) {
      return !r || !i ? !1 : r === i ? !0 : ZD(r) ? !1 : ZD(i) ? YD(r, i.parentNode) : "contains" in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1;
    }
    function T6(r) {
      return r && r.ownerDocument && YD(r.ownerDocument.documentElement, r);
    }
    function I6(r) {
      try {
        return typeof r.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function JD() {
      for (var r = window, i = se(); i instanceof r.HTMLIFrameElement; ) {
        if (I6(i))
          r = i.contentWindow;
        else
          return i;
        i = se(r.document);
      }
      return i;
    }
    function bI(r) {
      var i = r && r.nodeName && r.nodeName.toLowerCase();
      return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true");
    }
    function A6() {
      var r = JD();
      return {
        focusedElem: r,
        selectionRange: bI(r) ? R6(r) : null
      };
    }
    function k6(r) {
      var i = JD(), d = r.focusedElem, p = r.selectionRange;
      if (i !== d && T6(d)) {
        p !== null && bI(d) && P6(d, p);
        for (var y = [], C = d; C = C.parentNode; )
          C.nodeType === si && y.push({
            element: C,
            left: C.scrollLeft,
            top: C.scrollTop
          });
        typeof d.focus == "function" && d.focus();
        for (var k = 0; k < y.length; k++) {
          var O = y[k];
          O.element.scrollLeft = O.left, O.element.scrollTop = O.top;
        }
      }
    }
    function R6(r) {
      var i;
      return "selectionStart" in r ? i = {
        start: r.selectionStart,
        end: r.selectionEnd
      } : i = Yl(r), i || {
        start: 0,
        end: 0
      };
    }
    function P6(r, i) {
      var d = i.start, p = i.end;
      p === void 0 && (p = d), "selectionStart" in r ? (r.selectionStart = d, r.selectionEnd = Math.min(p, r.value.length)) : E6(r, i);
    }
    var O6 = ze && "documentMode" in document && document.documentMode <= 11;
    function _6() {
      we("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Hm = null, SI = null, Xy = null, xI = !1;
    function D6(r) {
      if ("selectionStart" in r && bI(r))
        return {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      var i = r.ownerDocument && r.ownerDocument.defaultView || window, d = i.getSelection();
      return {
        anchorNode: d.anchorNode,
        anchorOffset: d.anchorOffset,
        focusNode: d.focusNode,
        focusOffset: d.focusOffset
      };
    }
    function N6(r) {
      return r.window === r ? r.document : r.nodeType === _a ? r : r.ownerDocument;
    }
    function QD(r, i, d) {
      var p = N6(d);
      if (!(xI || Hm == null || Hm !== se(p))) {
        var y = D6(Hm);
        if (!Xy || !It(Xy, y)) {
          Xy = y;
          var C = W1(SI, "onSelect");
          if (C.length > 0) {
            var k = new $o("onSelect", "select", null, i, d);
            r.push({
              event: k,
              listeners: C
            }), k.target = Hm;
          }
        }
      }
    }
    function M6(r, i, d, p, y, C, k) {
      var O = d ? Xm(d) : window;
      switch (i) {
        case "focusin":
          (Od(O) || O.contentEditable === "true") && (Hm = O, SI = d, Xy = null);
          break;
        case "focusout":
          Hm = null, SI = null, Xy = null;
          break;
        case "mousedown":
          xI = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          xI = !1, QD(r, p, y);
          break;
        case "selectionchange":
          if (O6)
            break;
        case "keydown":
        case "keyup":
          QD(r, p, y);
      }
    }
    function H1(r, i) {
      var d = {};
      return d[r.toLowerCase()] = i.toLowerCase(), d["Webkit" + r] = "webkit" + i, d["Moz" + r] = "moz" + i, d;
    }
    var jm = {
      animationend: H1("Animation", "AnimationEnd"),
      animationiteration: H1("Animation", "AnimationIteration"),
      animationstart: H1("Animation", "AnimationStart"),
      transitionend: H1("Transition", "TransitionEnd")
    }, CI = {}, KD = {};
    ze && (KD = document.createElement("div").style, "AnimationEvent" in window || (delete jm.animationend.animation, delete jm.animationiteration.animation, delete jm.animationstart.animation), "TransitionEvent" in window || delete jm.transitionend.transition);
    function j1(r) {
      if (CI[r])
        return CI[r];
      if (!jm[r])
        return r;
      var i = jm[r];
      for (var d in i)
        if (i.hasOwnProperty(d) && d in KD)
          return CI[r] = i[d];
      return r;
    }
    var qD = j1("animationend"), eN = j1("animationiteration"), tN = j1("animationstart"), nN = j1("transitionend"), rN = /* @__PURE__ */ new Map(), oN = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function _d(r, i) {
      rN.set(r, i), we(i, [r]);
    }
    function L6() {
      for (var r = 0; r < oN.length; r++) {
        var i = oN[r], d = i.toLowerCase(), p = i[0].toUpperCase() + i.slice(1);
        _d(d, "on" + p);
      }
      _d(qD, "onAnimationEnd"), _d(eN, "onAnimationIteration"), _d(tN, "onAnimationStart"), _d("dblclick", "onDoubleClick"), _d("focusin", "onFocus"), _d("focusout", "onBlur"), _d(nN, "onTransitionEnd");
    }
    function F6(r, i, d, p, y, C, k) {
      var O = rN.get(i);
      if (O !== void 0) {
        var N = $o, z = i;
        switch (i) {
          case "keypress":
            if (ec(p) === 0)
              return;
          case "keydown":
          case "keyup":
            N = dI;
            break;
          case "focusin":
            z = "focus", N = _m;
            break;
          case "focusout":
            z = "blur", N = _m;
            break;
          case "beforeblur":
          case "afterblur":
            N = _m;
            break;
          case "click":
            if (p.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            N = Xl;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            N = nc;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            N = ia;
            break;
          case qD:
          case eN:
          case tN:
            N = Dm;
            break;
          case nN:
            N = pI;
            break;
          case "scroll":
            N = Ly;
            break;
          case "wheel":
            N = Mm;
            break;
          case "copy":
          case "cut":
          case "paste":
            N = sI;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            N = zy;
            break;
        }
        var j = (C & Nu) !== 0;
        {
          var ue = !j && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          i === "scroll", ae = z6(d, O, p.type, j, ue);
          if (ae.length > 0) {
            var Ae = new N(O, z, null, p, y);
            r.push({
              event: Ae,
              listeners: ae
            });
          }
        }
      }
    }
    L6(), Te(), zm(), _6(), B1();
    function B6(r, i, d, p, y, C, k) {
      F6(r, i, d, p, y, C);
      var O = (C & ZT) === 0;
      O && (Ke(r, i, d, p, y), le(r, i, d, p, y), M6(r, i, d, p, y), $m(r, i, d, p, y));
    }
    var Zy = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], wI = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Zy));
    function iN(r, i, d) {
      var p = r.type || "unknown-event";
      r.currentTarget = d, js(p, i, void 0, r), r.currentTarget = null;
    }
    function V6(r, i, d) {
      var p;
      if (d)
        for (var y = i.length - 1; y >= 0; y--) {
          var C = i[y], k = C.instance, O = C.currentTarget, N = C.listener;
          if (k !== p && r.isPropagationStopped())
            return;
          iN(r, N, O), p = k;
        }
      else
        for (var z = 0; z < i.length; z++) {
          var j = i[z], ue = j.instance, ae = j.currentTarget, Ae = j.listener;
          if (ue !== p && r.isPropagationStopped())
            return;
          iN(r, Ae, ae), p = ue;
        }
    }
    function aN(r, i) {
      for (var d = (i & Nu) !== 0, p = 0; p < r.length; p++) {
        var y = r[p], C = y.event, k = y.listeners;
        V6(C, k, d);
      }
      oy();
    }
    function $6(r, i, d, p, y) {
      var C = jh(d), k = [];
      B6(k, r, p, d, C, i), aN(k, i);
    }
    function xr(r, i) {
      wI.has(r) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', r);
      var d = !1, p = vX(i), y = G6(r, d);
      p.has(y) || (sN(i, r, Wf, d), p.add(y));
    }
    function EI(r, i, d) {
      wI.has(r) && !i && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', r);
      var p = 0;
      i && (p |= Nu), sN(d, r, p, i);
    }
    var G1 = "_reactListening" + Math.random().toString(36).slice(2);
    function Yy(r) {
      if (!r[G1]) {
        r[G1] = !0, xe.forEach(function(d) {
          d !== "selectionchange" && (wI.has(d) || EI(d, !1, r), EI(d, !0, r));
        });
        var i = r.nodeType === _a ? r : r.ownerDocument;
        i !== null && (i[G1] || (i[G1] = !0, EI("selectionchange", !1, i)));
      }
    }
    function sN(r, i, d, p, y) {
      var C = Ed(r, i, d), k = void 0;
      Jf && (i === "touchstart" || i === "touchmove" || i === "wheel") && (k = !0), r = r, p ? k !== void 0 ? Qs(r, i, C, k) : Id(r, i, C) : k !== void 0 ? Rm(r, i, C, k) : My(r, i, C);
    }
    function lN(r, i) {
      return r === i || r.nodeType === Mr && r.parentNode === i;
    }
    function TI(r, i, d, p, y) {
      var C = p;
      if (!(i & zs) && !(i & Wf)) {
        var k = y;
        if (p !== null) {
          var O = p;
          e:
            for (; ; ) {
              if (O === null)
                return;
              var N = O.tag;
              if (N === b || N === S) {
                var z = O.stateNode.containerInfo;
                if (lN(z, k))
                  break;
                if (N === S)
                  for (var j = O.return; j !== null; ) {
                    var ue = j.tag;
                    if (ue === b || ue === S) {
                      var ae = j.stateNode.containerInfo;
                      if (lN(ae, k))
                        return;
                    }
                    j = j.return;
                  }
                for (; z !== null; ) {
                  var Ae = wp(z);
                  if (Ae === null)
                    return;
                  var ke = Ae.tag;
                  if (ke === w || ke === E) {
                    O = C = Ae;
                    continue e;
                  }
                  z = z.parentNode;
                }
              }
              O = O.return;
            }
        }
      }
      ey(function() {
        return $6(r, i, d, C);
      });
    }
    function Jy(r, i, d) {
      return {
        instance: r,
        listener: i,
        currentTarget: d
      };
    }
    function z6(r, i, d, p, y, C) {
      for (var k = i !== null ? i + "Capture" : null, O = p ? k : i, N = [], z = r, j = null; z !== null; ) {
        var ue = z, ae = ue.stateNode, Ae = ue.tag;
        if (Ae === w && ae !== null && (j = ae, O !== null)) {
          var ke = Lu(z, O);
          ke != null && N.push(Jy(z, ke, j));
        }
        if (y)
          break;
        z = z.return;
      }
      return N;
    }
    function W1(r, i) {
      for (var d = i + "Capture", p = [], y = r; y !== null; ) {
        var C = y, k = C.stateNode, O = C.tag;
        if (O === w && k !== null) {
          var N = k, z = Lu(y, d);
          z != null && p.unshift(Jy(y, z, N));
          var j = Lu(y, i);
          j != null && p.push(Jy(y, j, N));
        }
        y = y.return;
      }
      return p;
    }
    function Gm(r) {
      if (r === null)
        return null;
      do
        r = r.return;
      while (r && r.tag !== w);
      return r || null;
    }
    function H6(r, i) {
      for (var d = r, p = i, y = 0, C = d; C; C = Gm(C))
        y++;
      for (var k = 0, O = p; O; O = Gm(O))
        k++;
      for (; y - k > 0; )
        d = Gm(d), y--;
      for (; k - y > 0; )
        p = Gm(p), k--;
      for (var N = y; N--; ) {
        if (d === p || p !== null && d === p.alternate)
          return d;
        d = Gm(d), p = Gm(p);
      }
      return null;
    }
    function uN(r, i, d, p, y) {
      for (var C = i._reactName, k = [], O = d; O !== null && O !== p; ) {
        var N = O, z = N.alternate, j = N.stateNode, ue = N.tag;
        if (z !== null && z === p)
          break;
        if (ue === w && j !== null) {
          var ae = j;
          if (y) {
            var Ae = Lu(O, C);
            Ae != null && k.unshift(Jy(O, Ae, ae));
          } else if (!y) {
            var ke = Lu(O, C);
            ke != null && k.push(Jy(O, ke, ae));
          }
        }
        O = O.return;
      }
      k.length !== 0 && r.push({
        event: i,
        listeners: k
      });
    }
    function j6(r, i, d, p, y) {
      var C = p && y ? H6(p, y) : null;
      p !== null && uN(r, i, p, C, !1), y !== null && d !== null && uN(r, d, y, C, !0);
    }
    function G6(r, i) {
      return r + "__" + (i ? "capture" : "bubble");
    }
    var aa = !1, Qy = "dangerouslySetInnerHTML", U1 = "suppressContentEditableWarning", Dd = "suppressHydrationWarning", cN = "autoFocus", xp = "children", Cp = "style", X1 = "__html", II, Z1, Ky, dN, Y1, fN, pN;
    II = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Z1 = function(r, i) {
      Hh(r, i), Yg(r, i), r1(r, i, {
        registrationNameDependencies: ie,
        possibleRegistrationNames: ye
      });
    }, fN = ze && !document.documentMode, Ky = function(r, i, d) {
      if (!aa) {
        var p = J1(d), y = J1(i);
        y !== p && (aa = !0, u("Prop `%s` did not match. Server: %s Client: %s", r, JSON.stringify(y), JSON.stringify(p)));
      }
    }, dN = function(r) {
      if (!aa) {
        aa = !0;
        var i = [];
        r.forEach(function(d) {
          i.push(d);
        }), u("Extra attributes from the server: %s", i);
      }
    }, Y1 = function(r, i) {
      i === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", r, r, r) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", r, typeof i);
    }, pN = function(r, i) {
      var d = r.namespaceURI === Bs ? r.ownerDocument.createElement(r.tagName) : r.ownerDocument.createElementNS(r.namespaceURI, r.tagName);
      return d.innerHTML = i, d.innerHTML;
    };
    var W6 = /\r\n?/g, U6 = /\u0000|\uFFFD/g;
    function J1(r) {
      vn(r);
      var i = typeof r == "string" ? r : "" + r;
      return i.replace(W6, `
`).replace(U6, "");
    }
    function Q1(r, i, d, p) {
      var y = J1(i), C = J1(r);
      if (C !== y && (p && (aa || (aa = !0, u('Text content did not match. Server: "%s" Client: "%s"', C, y))), d && J))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function hN(r) {
      return r.nodeType === _a ? r : r.ownerDocument;
    }
    function X6() {
    }
    function K1(r) {
      r.onclick = X6;
    }
    function Z6(r, i, d, p, y) {
      for (var C in p)
        if (p.hasOwnProperty(C)) {
          var k = p[C];
          if (C === Cp)
            k && Object.freeze(k), XS(i, k);
          else if (C === Qy) {
            var O = k ? k[X1] : void 0;
            O != null && LS(i, O);
          } else if (C === xp)
            if (typeof k == "string") {
              var N = r !== "textarea" || k !== "";
              N && Bh(i, k);
            } else
              typeof k == "number" && Bh(i, "" + k);
          else
            C === U1 || C === Dd || C === cN || (ie.hasOwnProperty(C) ? k != null && (typeof k != "function" && Y1(C, k), C === "onScroll" && xr("scroll", i)) : k != null && Wi(i, C, k, y));
        }
    }
    function Y6(r, i, d, p) {
      for (var y = 0; y < i.length; y += 2) {
        var C = i[y], k = i[y + 1];
        C === Cp ? XS(r, k) : C === Qy ? LS(r, k) : C === xp ? Bh(r, k) : Wi(r, C, k, p);
      }
    }
    function J6(r, i, d, p) {
      var y, C = hN(d), k, O = p;
      if (O === Bs && (O = Lh(r)), O === Bs) {
        if (y = $s(r, i), !y && r !== r.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", r), r === "script") {
          var N = C.createElement("div");
          N.innerHTML = "<script><\/script>";
          var z = N.firstChild;
          k = N.removeChild(z);
        } else if (typeof i.is == "string")
          k = C.createElement(r, {
            is: i.is
          });
        else if (k = C.createElement(r), r === "select") {
          var j = k;
          i.multiple ? j.multiple = !0 : i.size && (j.size = i.size);
        }
      } else
        k = C.createElementNS(O, r);
      return O === Bs && !y && Object.prototype.toString.call(k) === "[object HTMLUnknownElement]" && !Ve.call(II, r) && (II[r] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", r)), k;
    }
    function Q6(r, i) {
      return hN(i).createTextNode(r);
    }
    function K6(r, i, d, p) {
      var y = $s(i, d);
      Z1(i, d);
      var C;
      switch (i) {
        case "dialog":
          xr("cancel", r), xr("close", r), C = d;
          break;
        case "iframe":
        case "object":
        case "embed":
          xr("load", r), C = d;
          break;
        case "video":
        case "audio":
          for (var k = 0; k < Zy.length; k++)
            xr(Zy[k], r);
          C = d;
          break;
        case "source":
          xr("error", r), C = d;
          break;
        case "img":
        case "image":
        case "link":
          xr("error", r), xr("load", r), C = d;
          break;
        case "details":
          xr("toggle", r), C = d;
          break;
        case "input":
          Ln(r, d), C = ln(r, d), xr("invalid", r);
          break;
        case "option":
          Nh(r, d), C = d;
          break;
        case "select":
          _S(r, d), C = Bg(r, d), xr("invalid", r);
          break;
        case "textarea":
          DS(r, d), C = $g(r, d), xr("invalid", r);
          break;
        default:
          C = d;
      }
      switch ($h(i, C), Z6(i, r, p, C, y), i) {
        case "input":
          Fs(r), Pa(r, d, !1);
          break;
        case "textarea":
          Fs(r), MS(r);
          break;
        case "option":
          Fg(r, d);
          break;
        case "select":
          FT(r, d);
          break;
        default:
          typeof C.onClick == "function" && K1(r);
          break;
      }
    }
    function q6(r, i, d, p, y) {
      Z1(i, p);
      var C = null, k, O;
      switch (i) {
        case "input":
          k = ln(r, d), O = ln(r, p), C = [];
          break;
        case "select":
          k = Bg(r, d), O = Bg(r, p), C = [];
          break;
        case "textarea":
          k = $g(r, d), O = $g(r, p), C = [];
          break;
        default:
          k = d, O = p, typeof k.onClick != "function" && typeof O.onClick == "function" && K1(r);
          break;
      }
      $h(i, O);
      var N, z, j = null;
      for (N in k)
        if (!(O.hasOwnProperty(N) || !k.hasOwnProperty(N) || k[N] == null))
          if (N === Cp) {
            var ue = k[N];
            for (z in ue)
              ue.hasOwnProperty(z) && (j || (j = {}), j[z] = "");
          } else
            N === Qy || N === xp || N === U1 || N === Dd || N === cN || (ie.hasOwnProperty(N) ? C || (C = []) : (C = C || []).push(N, null));
      for (N in O) {
        var ae = O[N], Ae = k != null ? k[N] : void 0;
        if (!(!O.hasOwnProperty(N) || ae === Ae || ae == null && Ae == null))
          if (N === Cp)
            if (ae && Object.freeze(ae), Ae) {
              for (z in Ae)
                Ae.hasOwnProperty(z) && (!ae || !ae.hasOwnProperty(z)) && (j || (j = {}), j[z] = "");
              for (z in ae)
                ae.hasOwnProperty(z) && Ae[z] !== ae[z] && (j || (j = {}), j[z] = ae[z]);
            } else
              j || (C || (C = []), C.push(N, j)), j = ae;
          else if (N === Qy) {
            var ke = ae ? ae[X1] : void 0, Ne = Ae ? Ae[X1] : void 0;
            ke != null && Ne !== ke && (C = C || []).push(N, ke);
          } else
            N === xp ? (typeof ae == "string" || typeof ae == "number") && (C = C || []).push(N, "" + ae) : N === U1 || N === Dd || (ie.hasOwnProperty(N) ? (ae != null && (typeof ae != "function" && Y1(N, ae), N === "onScroll" && xr("scroll", r)), !C && Ae !== ae && (C = [])) : (C = C || []).push(N, ae));
      }
      return j && (jf(j, O[Cp]), (C = C || []).push(Cp, j)), C;
    }
    function e8(r, i, d, p, y) {
      d === "input" && y.type === "radio" && y.name != null && Do(r, y);
      var C = $s(d, p), k = $s(d, y);
      switch (Y6(r, i, C, k), d) {
        case "input":
          Nr(r, y);
          break;
        case "textarea":
          NS(r, y);
          break;
        case "select":
          BT(r, y);
          break;
      }
    }
    function t8(r) {
      {
        var i = r.toLowerCase();
        return zh.hasOwnProperty(i) && zh[i] || null;
      }
    }
    function n8(r, i, d, p, y, C, k) {
      var O, N;
      switch (O = $s(i, d), Z1(i, d), i) {
        case "dialog":
          xr("cancel", r), xr("close", r);
          break;
        case "iframe":
        case "object":
        case "embed":
          xr("load", r);
          break;
        case "video":
        case "audio":
          for (var z = 0; z < Zy.length; z++)
            xr(Zy[z], r);
          break;
        case "source":
          xr("error", r);
          break;
        case "img":
        case "image":
        case "link":
          xr("error", r), xr("load", r);
          break;
        case "details":
          xr("toggle", r);
          break;
        case "input":
          Ln(r, d), xr("invalid", r);
          break;
        case "option":
          Nh(r, d);
          break;
        case "select":
          _S(r, d), xr("invalid", r);
          break;
        case "textarea":
          DS(r, d), xr("invalid", r);
          break;
      }
      $h(i, d);
      {
        N = /* @__PURE__ */ new Set();
        for (var j = r.attributes, ue = 0; ue < j.length; ue++) {
          var ae = j[ue].name.toLowerCase();
          switch (ae) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              N.add(j[ue].name);
          }
        }
      }
      var Ae = null;
      for (var ke in d)
        if (d.hasOwnProperty(ke)) {
          var Ne = d[ke];
          if (ke === xp)
            typeof Ne == "string" ? r.textContent !== Ne && (d[Dd] !== !0 && Q1(r.textContent, Ne, C, k), Ae = [xp, Ne]) : typeof Ne == "number" && r.textContent !== "" + Ne && (d[Dd] !== !0 && Q1(r.textContent, Ne, C, k), Ae = [xp, "" + Ne]);
          else if (ie.hasOwnProperty(ke))
            Ne != null && (typeof Ne != "function" && Y1(ke, Ne), ke === "onScroll" && xr("scroll", r));
          else if (k && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof O == "boolean") {
            var pt = void 0, Rt = O && K ? null : Mn(ke);
            if (d[Dd] !== !0) {
              if (!(ke === U1 || ke === Dd || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              ke === "value" || ke === "checked" || ke === "selected")) {
                if (ke === Qy) {
                  var Et = r.innerHTML, xn = Ne ? Ne[X1] : void 0;
                  if (xn != null) {
                    var yn = pN(r, xn);
                    yn !== Et && Ky(ke, Et, yn);
                  }
                } else if (ke === Cp) {
                  if (N.delete(ke), fN) {
                    var be = UT(Ne);
                    pt = r.getAttribute("style"), be !== pt && Ky(ke, pt, be);
                  }
                } else if (O && !K)
                  N.delete(ke.toLowerCase()), pt = Ja(r, ke, Ne), Ne !== pt && Ky(ke, pt, Ne);
                else if (!ft(ke, Rt, O) && !kt(ke, Ne, Rt, O)) {
                  var Me = !1;
                  if (Rt !== null)
                    N.delete(Rt.attributeName), pt = Wr(r, ke, Ne, Rt);
                  else {
                    var Se = p;
                    if (Se === Bs && (Se = Lh(i)), Se === Bs)
                      N.delete(ke.toLowerCase());
                    else {
                      var Ye = t8(ke);
                      Ye !== null && Ye !== ke && (Me = !0, N.delete(Ye)), N.delete(ke);
                    }
                    pt = Ja(r, ke, Ne);
                  }
                  var ht = K;
                  !ht && Ne !== pt && !Me && Ky(ke, pt, Ne);
                }
              }
            }
          }
        }
      switch (k && // $FlowFixMe - Should be inferred as not undefined.
      N.size > 0 && d[Dd] !== !0 && dN(N), i) {
        case "input":
          Fs(r), Pa(r, d, !0);
          break;
        case "textarea":
          Fs(r), MS(r);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof d.onClick == "function" && K1(r);
          break;
      }
      return Ae;
    }
    function r8(r, i, d) {
      var p = r.nodeValue !== i;
      return p;
    }
    function AI(r, i) {
      {
        if (aa)
          return;
        aa = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", i.nodeName.toLowerCase(), r.nodeName.toLowerCase());
      }
    }
    function kI(r, i) {
      {
        if (aa)
          return;
        aa = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', i.nodeValue, r.nodeName.toLowerCase());
      }
    }
    function RI(r, i, d) {
      {
        if (aa)
          return;
        aa = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", i, r.nodeName.toLowerCase());
      }
    }
    function PI(r, i) {
      {
        if (i === "" || aa)
          return;
        aa = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', i, r.nodeName.toLowerCase());
      }
    }
    function o8(r, i, d) {
      switch (i) {
        case "input":
          td(r, d);
          return;
        case "textarea":
          zg(r, d);
          return;
        case "select":
          VT(r, d);
          return;
      }
    }
    var qy = function() {
    }, eb = function() {
    };
    {
      var i8 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], mN = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], a8 = mN.concat(["button"]), s8 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], vN = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      eb = function(r, i) {
        var d = on({}, r || vN), p = {
          tag: i
        };
        return mN.indexOf(i) !== -1 && (d.aTagInScope = null, d.buttonTagInScope = null, d.nobrTagInScope = null), a8.indexOf(i) !== -1 && (d.pTagInButtonScope = null), i8.indexOf(i) !== -1 && i !== "address" && i !== "div" && i !== "p" && (d.listItemTagAutoclosing = null, d.dlItemTagAutoclosing = null), d.current = p, i === "form" && (d.formTag = p), i === "a" && (d.aTagInScope = p), i === "button" && (d.buttonTagInScope = p), i === "nobr" && (d.nobrTagInScope = p), i === "p" && (d.pTagInButtonScope = p), i === "li" && (d.listItemTagAutoclosing = p), (i === "dd" || i === "dt") && (d.dlItemTagAutoclosing = p), d;
      };
      var l8 = function(r, i) {
        switch (i) {
          case "select":
            return r === "option" || r === "optgroup" || r === "#text";
          case "optgroup":
            return r === "option" || r === "#text";
          case "option":
            return r === "#text";
          case "tr":
            return r === "th" || r === "td" || r === "style" || r === "script" || r === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return r === "tr" || r === "style" || r === "script" || r === "template";
          case "colgroup":
            return r === "col" || r === "template";
          case "table":
            return r === "caption" || r === "colgroup" || r === "tbody" || r === "tfoot" || r === "thead" || r === "style" || r === "script" || r === "template";
          case "head":
            return r === "base" || r === "basefont" || r === "bgsound" || r === "link" || r === "meta" || r === "title" || r === "noscript" || r === "noframes" || r === "style" || r === "script" || r === "template";
          case "html":
            return r === "head" || r === "body" || r === "frameset";
          case "frameset":
            return r === "frame";
          case "#document":
            return r === "html";
        }
        switch (r) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return i !== "h1" && i !== "h2" && i !== "h3" && i !== "h4" && i !== "h5" && i !== "h6";
          case "rp":
          case "rt":
            return s8.indexOf(i) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return i == null;
        }
        return !0;
      }, u8 = function(r, i) {
        switch (r) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return i.pTagInButtonScope;
          case "form":
            return i.formTag || i.pTagInButtonScope;
          case "li":
            return i.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return i.dlItemTagAutoclosing;
          case "button":
            return i.buttonTagInScope;
          case "a":
            return i.aTagInScope;
          case "nobr":
            return i.nobrTagInScope;
        }
        return null;
      }, gN = {};
      qy = function(r, i, d) {
        d = d || vN;
        var p = d.current, y = p && p.tag;
        i != null && (r != null && u("validateDOMNesting: when childText is passed, childTag should be null"), r = "#text");
        var C = l8(r, y) ? null : p, k = C ? null : u8(r, d), O = C || k;
        if (O) {
          var N = O.tag, z = !!C + "|" + r + "|" + N;
          if (!gN[z]) {
            gN[z] = !0;
            var j = r, ue = "";
            if (r === "#text" ? /\S/.test(i) ? j = "Text nodes" : (j = "Whitespace text nodes", ue = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : j = "<" + r + ">", C) {
              var ae = "";
              N === "table" && r === "tr" && (ae += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", j, N, ue, ae);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", j, N);
          }
        }
      };
    }
    var q1 = "suppressHydrationWarning", ex = "$", tx = "/$", tb = "$?", nb = "$!", c8 = "style", OI = null, _I = null;
    function d8(r) {
      var i, d, p = r.nodeType;
      switch (p) {
        case _a:
        case _u: {
          i = p === _a ? "#document" : "#fragment";
          var y = r.documentElement;
          d = y ? y.namespaceURI : jg(null, "");
          break;
        }
        default: {
          var C = p === Mr ? r.parentNode : r, k = C.namespaceURI || null;
          i = C.tagName, d = jg(k, i);
          break;
        }
      }
      {
        var O = i.toLowerCase(), N = eb(null, O);
        return {
          namespace: d,
          ancestorInfo: N
        };
      }
    }
    function f8(r, i, d) {
      {
        var p = r, y = jg(p.namespace, i), C = eb(p.ancestorInfo, i);
        return {
          namespace: y,
          ancestorInfo: C
        };
      }
    }
    function J2e(r) {
      return r;
    }
    function p8(r) {
      OI = _i(), _I = A6();
      var i = null;
      return io(!1), i;
    }
    function h8(r) {
      k6(_I), io(OI), OI = null, _I = null;
    }
    function m8(r, i, d, p, y) {
      var C;
      {
        var k = p;
        if (qy(r, null, k.ancestorInfo), typeof i.children == "string" || typeof i.children == "number") {
          var O = "" + i.children, N = eb(k.ancestorInfo, r);
          qy(null, O, N);
        }
        C = k.namespace;
      }
      var z = J6(r, i, d, C);
      return ib(y, z), $I(z, i), z;
    }
    function v8(r, i) {
      r.appendChild(i);
    }
    function g8(r, i, d, p, y) {
      switch (K6(r, i, d, p), i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!d.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function y8(r, i, d, p, y, C) {
      {
        var k = C;
        if (typeof p.children != typeof d.children && (typeof p.children == "string" || typeof p.children == "number")) {
          var O = "" + p.children, N = eb(k.ancestorInfo, i);
          qy(null, O, N);
        }
      }
      return q6(r, i, d, p);
    }
    function DI(r, i) {
      return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
    }
    function b8(r, i, d, p) {
      {
        var y = d;
        qy(null, r, y.ancestorInfo);
      }
      var C = Q6(r, i);
      return ib(p, C), C;
    }
    function S8() {
      var r = window.event;
      return r === void 0 ? Zs : Ho(r.type);
    }
    var NI = typeof setTimeout == "function" ? setTimeout : void 0, x8 = typeof clearTimeout == "function" ? clearTimeout : void 0, MI = -1, yN = typeof Promise == "function" ? Promise : void 0, C8 = typeof queueMicrotask == "function" ? queueMicrotask : typeof yN < "u" ? function(r) {
      return yN.resolve(null).then(r).catch(w8);
    } : NI;
    function w8(r) {
      setTimeout(function() {
        throw r;
      });
    }
    function E8(r, i, d, p) {
      switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && r.focus();
          return;
        case "img": {
          d.src && (r.src = d.src);
          return;
        }
      }
    }
    function T8(r, i, d, p, y, C) {
      e8(r, i, d, p, y), $I(r, y);
    }
    function bN(r) {
      Bh(r, "");
    }
    function I8(r, i, d) {
      r.nodeValue = d;
    }
    function A8(r, i) {
      r.appendChild(i);
    }
    function k8(r, i) {
      var d;
      r.nodeType === Mr ? (d = r.parentNode, d.insertBefore(i, r)) : (d = r, d.appendChild(i));
      var p = r._reactRootContainer;
      p == null && d.onclick === null && K1(d);
    }
    function R8(r, i, d) {
      r.insertBefore(i, d);
    }
    function P8(r, i, d) {
      r.nodeType === Mr ? r.parentNode.insertBefore(i, d) : r.insertBefore(i, d);
    }
    function O8(r, i) {
      r.removeChild(i);
    }
    function _8(r, i) {
      r.nodeType === Mr ? r.parentNode.removeChild(i) : r.removeChild(i);
    }
    function LI(r, i) {
      var d = i, p = 0;
      do {
        var y = d.nextSibling;
        if (r.removeChild(d), y && y.nodeType === Mr) {
          var C = y.data;
          if (C === tx)
            if (p === 0) {
              r.removeChild(y), gn(i);
              return;
            } else
              p--;
          else
            (C === ex || C === tb || C === nb) && p++;
        }
        d = y;
      } while (d);
      gn(i);
    }
    function D8(r, i) {
      r.nodeType === Mr ? LI(r.parentNode, i) : r.nodeType === si && LI(r, i), gn(r);
    }
    function N8(r) {
      r = r;
      var i = r.style;
      typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none";
    }
    function M8(r) {
      r.nodeValue = "";
    }
    function L8(r, i) {
      r = r;
      var d = i[c8], p = d != null && d.hasOwnProperty("display") ? d.display : null;
      r.style.display = Vh("display", p);
    }
    function F8(r, i) {
      r.nodeValue = i;
    }
    function B8(r) {
      r.nodeType === si ? r.textContent = "" : r.nodeType === _a && r.documentElement && r.removeChild(r.documentElement);
    }
    function V8(r, i, d) {
      return r.nodeType !== si || i.toLowerCase() !== r.nodeName.toLowerCase() ? null : r;
    }
    function $8(r, i) {
      return i === "" || r.nodeType !== Vs ? null : r;
    }
    function z8(r) {
      return r.nodeType !== Mr ? null : r;
    }
    function SN(r) {
      return r.data === tb;
    }
    function FI(r) {
      return r.data === nb;
    }
    function H8(r) {
      var i = r.nextSibling && r.nextSibling.dataset, d, p, y;
      return i && (d = i.dgst, p = i.msg, y = i.stck), {
        message: p,
        digest: d,
        stack: y
      };
    }
    function j8(r, i) {
      r._reactRetry = i;
    }
    function nx(r) {
      for (; r != null; r = r.nextSibling) {
        var i = r.nodeType;
        if (i === si || i === Vs)
          break;
        if (i === Mr) {
          var d = r.data;
          if (d === ex || d === nb || d === tb)
            break;
          if (d === tx)
            return null;
        }
      }
      return r;
    }
    function rb(r) {
      return nx(r.nextSibling);
    }
    function G8(r) {
      return nx(r.firstChild);
    }
    function W8(r) {
      return nx(r.firstChild);
    }
    function U8(r) {
      return nx(r.nextSibling);
    }
    function X8(r, i, d, p, y, C, k) {
      ib(C, r), $I(r, d);
      var O;
      {
        var N = y;
        O = N.namespace;
      }
      var z = (C.mode & pn) !== _t;
      return n8(r, i, d, O, p, z, k);
    }
    function Z8(r, i, d, p) {
      return ib(d, r), d.mode & pn, r8(r, i);
    }
    function Y8(r, i) {
      ib(i, r);
    }
    function J8(r) {
      for (var i = r.nextSibling, d = 0; i; ) {
        if (i.nodeType === Mr) {
          var p = i.data;
          if (p === tx) {
            if (d === 0)
              return rb(i);
            d--;
          } else
            (p === ex || p === nb || p === tb) && d++;
        }
        i = i.nextSibling;
      }
      return null;
    }
    function xN(r) {
      for (var i = r.previousSibling, d = 0; i; ) {
        if (i.nodeType === Mr) {
          var p = i.data;
          if (p === ex || p === nb || p === tb) {
            if (d === 0)
              return i;
            d--;
          } else
            p === tx && d++;
        }
        i = i.previousSibling;
      }
      return null;
    }
    function Q8(r) {
      gn(r);
    }
    function K8(r) {
      gn(r);
    }
    function q8(r) {
      return r !== "head" && r !== "body";
    }
    function eX(r, i, d, p) {
      var y = !0;
      Q1(i.nodeValue, d, p, y);
    }
    function tX(r, i, d, p, y, C) {
      if (i[q1] !== !0) {
        var k = !0;
        Q1(p.nodeValue, y, C, k);
      }
    }
    function nX(r, i) {
      i.nodeType === si ? AI(r, i) : i.nodeType === Mr || kI(r, i);
    }
    function rX(r, i) {
      {
        var d = r.parentNode;
        d !== null && (i.nodeType === si ? AI(d, i) : i.nodeType === Mr || kI(d, i));
      }
    }
    function oX(r, i, d, p, y) {
      (y || i[q1] !== !0) && (p.nodeType === si ? AI(d, p) : p.nodeType === Mr || kI(d, p));
    }
    function iX(r, i, d) {
      RI(r, i);
    }
    function aX(r, i) {
      PI(r, i);
    }
    function sX(r, i, d) {
      {
        var p = r.parentNode;
        p !== null && RI(p, i);
      }
    }
    function lX(r, i) {
      {
        var d = r.parentNode;
        d !== null && PI(d, i);
      }
    }
    function uX(r, i, d, p, y, C) {
      (C || i[q1] !== !0) && RI(d, p);
    }
    function cX(r, i, d, p, y) {
      (y || i[q1] !== !0) && PI(d, p);
    }
    function dX(r) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", r.nodeName.toLowerCase());
    }
    function fX(r) {
      Yy(r);
    }
    var Wm = Math.random().toString(36).slice(2), Um = "__reactFiber$" + Wm, BI = "__reactProps$" + Wm, ob = "__reactContainer$" + Wm, VI = "__reactEvents$" + Wm, pX = "__reactListeners$" + Wm, hX = "__reactHandles$" + Wm;
    function mX(r) {
      delete r[Um], delete r[BI], delete r[VI], delete r[pX], delete r[hX];
    }
    function ib(r, i) {
      i[Um] = r;
    }
    function rx(r, i) {
      i[ob] = r;
    }
    function CN(r) {
      r[ob] = null;
    }
    function ab(r) {
      return !!r[ob];
    }
    function wp(r) {
      var i = r[Um];
      if (i)
        return i;
      for (var d = r.parentNode; d; ) {
        if (i = d[ob] || d[Um], i) {
          var p = i.alternate;
          if (i.child !== null || p !== null && p.child !== null)
            for (var y = xN(r); y !== null; ) {
              var C = y[Um];
              if (C)
                return C;
              y = xN(y);
            }
          return i;
        }
        r = d, d = r.parentNode;
      }
      return null;
    }
    function Nd(r) {
      var i = r[Um] || r[ob];
      return i && (i.tag === w || i.tag === E || i.tag === F || i.tag === b) ? i : null;
    }
    function Xm(r) {
      if (r.tag === w || r.tag === E)
        return r.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function ox(r) {
      return r[BI] || null;
    }
    function $I(r, i) {
      r[BI] = i;
    }
    function vX(r) {
      var i = r[VI];
      return i === void 0 && (i = r[VI] = /* @__PURE__ */ new Set()), i;
    }
    var wN = {}, EN = n.ReactDebugCurrentFrame;
    function ix(r) {
      if (r) {
        var i = r._owner, d = ku(r.type, r._source, i ? i.type : null);
        EN.setExtraStackFrame(d);
      } else
        EN.setExtraStackFrame(null);
    }
    function qs(r, i, d, p, y) {
      {
        var C = Function.call.bind(Ve);
        for (var k in r)
          if (C(r, k)) {
            var O = void 0;
            try {
              if (typeof r[k] != "function") {
                var N = Error((p || "React class") + ": " + d + " type `" + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof r[k] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw N.name = "Invariant Violation", N;
              }
              O = r[k](i, k, p, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (z) {
              O = z;
            }
            O && !(O instanceof Error) && (ix(y), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", p || "React class", d, k, typeof O), ix(null)), O instanceof Error && !(O.message in wN) && (wN[O.message] = !0, ix(y), u("Failed %s type: %s", d, O.message), ix(null));
          }
      }
    }
    var zI = [], ax;
    ax = [];
    var ac = -1;
    function Md(r) {
      return {
        current: r
      };
    }
    function gi(r, i) {
      if (ac < 0) {
        u("Unexpected pop.");
        return;
      }
      i !== ax[ac] && u("Unexpected Fiber popped."), r.current = zI[ac], zI[ac] = null, ax[ac] = null, ac--;
    }
    function yi(r, i, d) {
      ac++, zI[ac] = r.current, ax[ac] = d, r.current = i;
    }
    var HI;
    HI = {};
    var Fa = {};
    Object.freeze(Fa);
    var sc = Md(Fa), Jl = Md(!1), jI = Fa;
    function Zm(r, i, d) {
      return d && Ql(i) ? jI : sc.current;
    }
    function TN(r, i, d) {
      {
        var p = r.stateNode;
        p.__reactInternalMemoizedUnmaskedChildContext = i, p.__reactInternalMemoizedMaskedChildContext = d;
      }
    }
    function Ym(r, i) {
      {
        var d = r.type, p = d.contextTypes;
        if (!p)
          return Fa;
        var y = r.stateNode;
        if (y && y.__reactInternalMemoizedUnmaskedChildContext === i)
          return y.__reactInternalMemoizedMaskedChildContext;
        var C = {};
        for (var k in p)
          C[k] = i[k];
        {
          var O = Ut(r) || "Unknown";
          qs(p, C, "context", O);
        }
        return y && TN(r, i, C), C;
      }
    }
    function sx() {
      return Jl.current;
    }
    function Ql(r) {
      {
        var i = r.childContextTypes;
        return i != null;
      }
    }
    function lx(r) {
      gi(Jl, r), gi(sc, r);
    }
    function GI(r) {
      gi(Jl, r), gi(sc, r);
    }
    function IN(r, i, d) {
      {
        if (sc.current !== Fa)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        yi(sc, i, r), yi(Jl, d, r);
      }
    }
    function AN(r, i, d) {
      {
        var p = r.stateNode, y = i.childContextTypes;
        if (typeof p.getChildContext != "function") {
          {
            var C = Ut(r) || "Unknown";
            HI[C] || (HI[C] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", C, C));
          }
          return d;
        }
        var k = p.getChildContext();
        for (var O in k)
          if (!(O in y))
            throw new Error((Ut(r) || "Unknown") + '.getChildContext(): key "' + O + '" is not defined in childContextTypes.');
        {
          var N = Ut(r) || "Unknown";
          qs(y, k, "child context", N);
        }
        return on({}, d, k);
      }
    }
    function ux(r) {
      {
        var i = r.stateNode, d = i && i.__reactInternalMemoizedMergedChildContext || Fa;
        return jI = sc.current, yi(sc, d, r), yi(Jl, Jl.current, r), !0;
      }
    }
    function kN(r, i, d) {
      {
        var p = r.stateNode;
        if (!p)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (d) {
          var y = AN(r, i, jI);
          p.__reactInternalMemoizedMergedChildContext = y, gi(Jl, r), gi(sc, r), yi(sc, y, r), yi(Jl, d, r);
        } else
          gi(Jl, r), yi(Jl, d, r);
      }
    }
    function gX(r) {
      {
        if (!uy(r) || r.tag !== v)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var i = r;
        do {
          switch (i.tag) {
            case b:
              return i.stateNode.context;
            case v: {
              var d = i.type;
              if (Ql(d))
                return i.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          i = i.return;
        } while (i !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ld = 0, cx = 1, lc = null, WI = !1, UI = !1;
    function RN(r) {
      lc === null ? lc = [r] : lc.push(r);
    }
    function yX(r) {
      WI = !0, RN(r);
    }
    function PN() {
      WI && Fd();
    }
    function Fd() {
      if (!UI && lc !== null) {
        UI = !0;
        var r = 0, i = na();
        try {
          var d = !0, p = lc;
          for (Zr(Mo); r < p.length; r++) {
            var y = p[r];
            do
              y = y(d);
            while (y !== null);
          }
          lc = null, WI = !1;
        } catch (C) {
          throw lc !== null && (lc = lc.slice(r + 1)), Jh(Kh, Fd), C;
        } finally {
          Zr(i), UI = !1;
        }
      }
      return null;
    }
    var Jm = [], Qm = 0, dx = null, fx = 0, as = [], ss = 0, Ep = null, uc = 1, cc = "";
    function bX(r) {
      return Ip(), (r.flags & ay) !== At;
    }
    function SX(r) {
      return Ip(), fx;
    }
    function xX() {
      var r = cc, i = uc, d = i & ~CX(i);
      return d.toString(32) + r;
    }
    function Tp(r, i) {
      Ip(), Jm[Qm++] = fx, Jm[Qm++] = dx, dx = r, fx = i;
    }
    function ON(r, i, d) {
      Ip(), as[ss++] = uc, as[ss++] = cc, as[ss++] = Ep, Ep = r;
      var p = uc, y = cc, C = px(p) - 1, k = p & ~(1 << C), O = d + 1, N = px(i) + C;
      if (N > 30) {
        var z = C - C % 5, j = (1 << z) - 1, ue = (k & j).toString(32), ae = k >> z, Ae = C - z, ke = px(i) + Ae, Ne = O << Ae, pt = Ne | ae, Rt = ue + y;
        uc = 1 << ke | pt, cc = Rt;
      } else {
        var Et = O << C, xn = Et | k, yn = y;
        uc = 1 << N | xn, cc = yn;
      }
    }
    function XI(r) {
      Ip();
      var i = r.return;
      if (i !== null) {
        var d = 1, p = 0;
        Tp(r, d), ON(r, d, p);
      }
    }
    function px(r) {
      return 32 - om(r);
    }
    function CX(r) {
      return 1 << px(r) - 1;
    }
    function ZI(r) {
      for (; r === dx; )
        dx = Jm[--Qm], Jm[Qm] = null, fx = Jm[--Qm], Jm[Qm] = null;
      for (; r === Ep; )
        Ep = as[--ss], as[ss] = null, cc = as[--ss], as[ss] = null, uc = as[--ss], as[ss] = null;
    }
    function wX() {
      return Ip(), Ep !== null ? {
        id: uc,
        overflow: cc
      } : null;
    }
    function EX(r, i) {
      Ip(), as[ss++] = uc, as[ss++] = cc, as[ss++] = Ep, uc = i.id, cc = i.overflow, Ep = r;
    }
    function Ip() {
      Go() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var jo = null, ls = null, el = !1, Ap = !1, Bd = null;
    function TX() {
      el && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function _N() {
      Ap = !0;
    }
    function IX() {
      return Ap;
    }
    function AX(r) {
      var i = r.stateNode.containerInfo;
      return ls = W8(i), jo = r, el = !0, Bd = null, Ap = !1, !0;
    }
    function kX(r, i, d) {
      return ls = U8(i), jo = r, el = !0, Bd = null, Ap = !1, d !== null && EX(r, d), !0;
    }
    function DN(r, i) {
      switch (r.tag) {
        case b: {
          nX(r.stateNode.containerInfo, i);
          break;
        }
        case w: {
          var d = (r.mode & pn) !== _t;
          oX(
            r.type,
            r.memoizedProps,
            r.stateNode,
            i,
            // TODO: Delete this argument when we remove the legacy root API.
            d
          );
          break;
        }
        case F: {
          var p = r.memoizedState;
          p.dehydrated !== null && rX(p.dehydrated, i);
          break;
        }
      }
    }
    function NN(r, i) {
      DN(r, i);
      var d = OY();
      d.stateNode = i, d.return = r;
      var p = r.deletions;
      p === null ? (r.deletions = [d], r.flags |= Nn) : p.push(d);
    }
    function YI(r, i) {
      {
        if (Ap)
          return;
        switch (r.tag) {
          case b: {
            var d = r.stateNode.containerInfo;
            switch (i.tag) {
              case w:
                var p = i.type;
                i.pendingProps, iX(d, p);
                break;
              case E:
                var y = i.pendingProps;
                aX(d, y);
                break;
            }
            break;
          }
          case w: {
            var C = r.type, k = r.memoizedProps, O = r.stateNode;
            switch (i.tag) {
              case w: {
                var N = i.type, z = i.pendingProps, j = (r.mode & pn) !== _t;
                uX(
                  C,
                  k,
                  O,
                  N,
                  z,
                  // TODO: Delete this argument when we remove the legacy root API.
                  j
                );
                break;
              }
              case E: {
                var ue = i.pendingProps, ae = (r.mode & pn) !== _t;
                cX(
                  C,
                  k,
                  O,
                  ue,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ae
                );
                break;
              }
            }
            break;
          }
          case F: {
            var Ae = r.memoizedState, ke = Ae.dehydrated;
            if (ke !== null)
              switch (i.tag) {
                case w:
                  var Ne = i.type;
                  i.pendingProps, sX(ke, Ne);
                  break;
                case E:
                  var pt = i.pendingProps;
                  lX(ke, pt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function MN(r, i) {
      i.flags = i.flags & ~Qi | ir, YI(r, i);
    }
    function LN(r, i) {
      switch (r.tag) {
        case w: {
          var d = r.type;
          r.pendingProps;
          var p = V8(i, d);
          return p !== null ? (r.stateNode = p, jo = r, ls = G8(p), !0) : !1;
        }
        case E: {
          var y = r.pendingProps, C = $8(i, y);
          return C !== null ? (r.stateNode = C, jo = r, ls = null, !0) : !1;
        }
        case F: {
          var k = z8(i);
          if (k !== null) {
            var O = {
              dehydrated: k,
              treeContext: wX(),
              retryLane: hi
            };
            r.memoizedState = O;
            var N = _Y(k);
            return N.return = r, r.child = N, jo = r, ls = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function JI(r) {
      return (r.mode & pn) !== _t && (r.flags & jt) === At;
    }
    function QI(r) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function KI(r) {
      if (el) {
        var i = ls;
        if (!i) {
          JI(r) && (YI(jo, r), QI()), MN(jo, r), el = !1, jo = r;
          return;
        }
        var d = i;
        if (!LN(r, i)) {
          JI(r) && (YI(jo, r), QI()), i = rb(d);
          var p = jo;
          if (!i || !LN(r, i)) {
            MN(jo, r), el = !1, jo = r;
            return;
          }
          NN(p, d);
        }
      }
    }
    function RX(r, i, d) {
      var p = r.stateNode, y = !Ap, C = X8(p, r.type, r.memoizedProps, i, d, r, y);
      return r.updateQueue = C, C !== null;
    }
    function PX(r) {
      var i = r.stateNode, d = r.memoizedProps, p = Z8(i, d, r);
      if (p) {
        var y = jo;
        if (y !== null)
          switch (y.tag) {
            case b: {
              var C = y.stateNode.containerInfo, k = (y.mode & pn) !== _t;
              eX(
                C,
                i,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                k
              );
              break;
            }
            case w: {
              var O = y.type, N = y.memoizedProps, z = y.stateNode, j = (y.mode & pn) !== _t;
              tX(
                O,
                N,
                z,
                i,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                j
              );
              break;
            }
          }
      }
      return p;
    }
    function OX(r) {
      var i = r.memoizedState, d = i !== null ? i.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Y8(d, r);
    }
    function _X(r) {
      var i = r.memoizedState, d = i !== null ? i.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return J8(d);
    }
    function FN(r) {
      for (var i = r.return; i !== null && i.tag !== w && i.tag !== b && i.tag !== F; )
        i = i.return;
      jo = i;
    }
    function hx(r) {
      if (r !== jo)
        return !1;
      if (!el)
        return FN(r), el = !0, !1;
      if (r.tag !== b && (r.tag !== w || q8(r.type) && !DI(r.type, r.memoizedProps))) {
        var i = ls;
        if (i)
          if (JI(r))
            BN(r), QI();
          else
            for (; i; )
              NN(r, i), i = rb(i);
      }
      return FN(r), r.tag === F ? ls = _X(r) : ls = jo ? rb(r.stateNode) : null, !0;
    }
    function DX() {
      return el && ls !== null;
    }
    function BN(r) {
      for (var i = ls; i; )
        DN(r, i), i = rb(i);
    }
    function Km() {
      jo = null, ls = null, el = !1, Ap = !1;
    }
    function VN() {
      Bd !== null && (DL(Bd), Bd = null);
    }
    function Go() {
      return el;
    }
    function qI(r) {
      Bd === null ? Bd = [r] : Bd.push(r);
    }
    var NX = n.ReactCurrentBatchConfig, MX = null;
    function LX() {
      return NX.transition;
    }
    var tl = {
      recordUnsafeLifecycleWarnings: function(r, i) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(r, i) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var FX = function(r) {
        for (var i = null, d = r; d !== null; )
          d.mode & br && (i = d), d = d.return;
        return i;
      }, kp = function(r) {
        var i = [];
        return r.forEach(function(d) {
          i.push(d);
        }), i.sort().join(", ");
      }, sb = [], lb = [], ub = [], cb = [], db = [], fb = [], Rp = /* @__PURE__ */ new Set();
      tl.recordUnsafeLifecycleWarnings = function(r, i) {
        Rp.has(r.type) || (typeof i.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        i.componentWillMount.__suppressDeprecationWarning !== !0 && sb.push(r), r.mode & br && typeof i.UNSAFE_componentWillMount == "function" && lb.push(r), typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ub.push(r), r.mode & br && typeof i.UNSAFE_componentWillReceiveProps == "function" && cb.push(r), typeof i.componentWillUpdate == "function" && i.componentWillUpdate.__suppressDeprecationWarning !== !0 && db.push(r), r.mode & br && typeof i.UNSAFE_componentWillUpdate == "function" && fb.push(r));
      }, tl.flushPendingUnsafeLifecycleWarnings = function() {
        var r = /* @__PURE__ */ new Set();
        sb.length > 0 && (sb.forEach(function(ae) {
          r.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), sb = []);
        var i = /* @__PURE__ */ new Set();
        lb.length > 0 && (lb.forEach(function(ae) {
          i.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), lb = []);
        var d = /* @__PURE__ */ new Set();
        ub.length > 0 && (ub.forEach(function(ae) {
          d.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), ub = []);
        var p = /* @__PURE__ */ new Set();
        cb.length > 0 && (cb.forEach(function(ae) {
          p.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), cb = []);
        var y = /* @__PURE__ */ new Set();
        db.length > 0 && (db.forEach(function(ae) {
          y.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), db = []);
        var C = /* @__PURE__ */ new Set();
        if (fb.length > 0 && (fb.forEach(function(ae) {
          C.add(Ut(ae) || "Component"), Rp.add(ae.type);
        }), fb = []), i.size > 0) {
          var k = kp(i);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, k);
        }
        if (p.size > 0) {
          var O = kp(p);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, O);
        }
        if (C.size > 0) {
          var N = kp(C);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, N);
        }
        if (r.size > 0) {
          var z = kp(r);
          l(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, z);
        }
        if (d.size > 0) {
          var j = kp(d);
          l(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, j);
        }
        if (y.size > 0) {
          var ue = kp(y);
          l(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ue);
        }
      };
      var mx = /* @__PURE__ */ new Map(), $N = /* @__PURE__ */ new Set();
      tl.recordLegacyContextWarning = function(r, i) {
        var d = FX(r);
        if (d === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!$N.has(r.type)) {
          var p = mx.get(d);
          (r.type.contextTypes != null || r.type.childContextTypes != null || i !== null && typeof i.getChildContext == "function") && (p === void 0 && (p = [], mx.set(d, p)), p.push(r));
        }
      }, tl.flushLegacyContextWarning = function() {
        mx.forEach(function(r, i) {
          if (r.length !== 0) {
            var d = r[0], p = /* @__PURE__ */ new Set();
            r.forEach(function(C) {
              p.add(Ut(C) || "Component"), $N.add(C.type);
            });
            var y = kp(p);
            try {
              _n(d), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, y);
            } finally {
              kr();
            }
          }
        });
      }, tl.discardPendingWarnings = function() {
        sb = [], lb = [], ub = [], cb = [], db = [], fb = [], mx = /* @__PURE__ */ new Map();
      };
    }
    function nl(r, i) {
      if (r && r.defaultProps) {
        var d = on({}, i), p = r.defaultProps;
        for (var y in p)
          d[y] === void 0 && (d[y] = p[y]);
        return d;
      }
      return i;
    }
    var eA = Md(null), tA;
    tA = {};
    var vx = null, qm = null, nA = null, gx = !1;
    function yx() {
      vx = null, qm = null, nA = null, gx = !1;
    }
    function zN() {
      gx = !0;
    }
    function HN() {
      gx = !1;
    }
    function jN(r, i, d) {
      yi(eA, i._currentValue, r), i._currentValue = d, i._currentRenderer !== void 0 && i._currentRenderer !== null && i._currentRenderer !== tA && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), i._currentRenderer = tA;
    }
    function rA(r, i) {
      var d = eA.current;
      gi(eA, i), r._currentValue = d;
    }
    function oA(r, i, d) {
      for (var p = r; p !== null; ) {
        var y = p.alternate;
        if (Yu(p.childLanes, i) ? y !== null && !Yu(y.childLanes, i) && (y.childLanes = en(y.childLanes, i)) : (p.childLanes = en(p.childLanes, i), y !== null && (y.childLanes = en(y.childLanes, i))), p === d)
          break;
        p = p.return;
      }
      p !== d && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function BX(r, i, d) {
      VX(r, i, d);
    }
    function VX(r, i, d) {
      var p = r.child;
      for (p !== null && (p.return = r); p !== null; ) {
        var y = void 0, C = p.dependencies;
        if (C !== null) {
          y = p.child;
          for (var k = C.firstContext; k !== null; ) {
            if (k.context === i) {
              if (p.tag === v) {
                var O = Xr(d), N = dc(tr, O);
                N.tag = Sx;
                var z = p.updateQueue;
                if (z !== null) {
                  var j = z.shared, ue = j.pending;
                  ue === null ? N.next = N : (N.next = ue.next, ue.next = N), j.pending = N;
                }
              }
              p.lanes = en(p.lanes, d);
              var ae = p.alternate;
              ae !== null && (ae.lanes = en(ae.lanes, d)), oA(p.return, d, r), C.lanes = en(C.lanes, d);
              break;
            }
            k = k.next;
          }
        } else if (p.tag === _)
          y = p.type === r.type ? null : p.child;
        else if (p.tag === H) {
          var Ae = p.return;
          if (Ae === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ae.lanes = en(Ae.lanes, d);
          var ke = Ae.alternate;
          ke !== null && (ke.lanes = en(ke.lanes, d)), oA(Ae, d, r), y = p.sibling;
        } else
          y = p.child;
        if (y !== null)
          y.return = p;
        else
          for (y = p; y !== null; ) {
            if (y === r) {
              y = null;
              break;
            }
            var Ne = y.sibling;
            if (Ne !== null) {
              Ne.return = y.return, y = Ne;
              break;
            }
            y = y.return;
          }
        p = y;
      }
    }
    function ev(r, i) {
      vx = r, qm = null, nA = null;
      var d = r.dependencies;
      if (d !== null) {
        var p = d.firstContext;
        p !== null && (mi(d.lanes, i) && Ib(), d.firstContext = null);
      }
    }
    function so(r) {
      gx && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var i = r._currentValue;
      if (nA !== r) {
        var d = {
          context: r,
          memoizedValue: i,
          next: null
        };
        if (qm === null) {
          if (vx === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          qm = d, vx.dependencies = {
            lanes: Be,
            firstContext: d
          };
        } else
          qm = qm.next = d;
      }
      return i;
    }
    var Pp = null;
    function iA(r) {
      Pp === null ? Pp = [r] : Pp.push(r);
    }
    function $X() {
      if (Pp !== null) {
        for (var r = 0; r < Pp.length; r++) {
          var i = Pp[r], d = i.interleaved;
          if (d !== null) {
            i.interleaved = null;
            var p = d.next, y = i.pending;
            if (y !== null) {
              var C = y.next;
              y.next = p, d.next = C;
            }
            i.pending = d;
          }
        }
        Pp = null;
      }
    }
    function GN(r, i, d, p) {
      var y = i.interleaved;
      return y === null ? (d.next = d, iA(i)) : (d.next = y.next, y.next = d), i.interleaved = d, bx(r, p);
    }
    function zX(r, i, d, p) {
      var y = i.interleaved;
      y === null ? (d.next = d, iA(i)) : (d.next = y.next, y.next = d), i.interleaved = d;
    }
    function HX(r, i, d, p) {
      var y = i.interleaved;
      return y === null ? (d.next = d, iA(i)) : (d.next = y.next, y.next = d), i.interleaved = d, bx(r, p);
    }
    function sa(r, i) {
      return bx(r, i);
    }
    var jX = bx;
    function bx(r, i) {
      r.lanes = en(r.lanes, i);
      var d = r.alternate;
      d !== null && (d.lanes = en(d.lanes, i)), d === null && (r.flags & (ir | Qi)) !== At && WL(r);
      for (var p = r, y = r.return; y !== null; )
        y.childLanes = en(y.childLanes, i), d = y.alternate, d !== null ? d.childLanes = en(d.childLanes, i) : (y.flags & (ir | Qi)) !== At && WL(r), p = y, y = y.return;
      if (p.tag === b) {
        var C = p.stateNode;
        return C;
      } else
        return null;
    }
    var WN = 0, UN = 1, Sx = 2, aA = 3, xx = !1, sA, Cx;
    sA = !1, Cx = null;
    function lA(r) {
      var i = {
        baseState: r.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Be
        },
        effects: null
      };
      r.updateQueue = i;
    }
    function XN(r, i) {
      var d = i.updateQueue, p = r.updateQueue;
      if (d === p) {
        var y = {
          baseState: p.baseState,
          firstBaseUpdate: p.firstBaseUpdate,
          lastBaseUpdate: p.lastBaseUpdate,
          shared: p.shared,
          effects: p.effects
        };
        i.updateQueue = y;
      }
    }
    function dc(r, i) {
      var d = {
        eventTime: r,
        lane: i,
        tag: WN,
        payload: null,
        callback: null,
        next: null
      };
      return d;
    }
    function Vd(r, i, d) {
      var p = r.updateQueue;
      if (p === null)
        return null;
      var y = p.shared;
      if (Cx === y && !sA && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), sA = !0), jZ()) {
        var C = y.pending;
        return C === null ? i.next = i : (i.next = C.next, C.next = i), y.pending = i, jX(r, d);
      } else
        return HX(r, y, i, d);
    }
    function wx(r, i, d) {
      var p = i.updateQueue;
      if (p !== null) {
        var y = p.shared;
        if (Cy(d)) {
          var C = y.lanes;
          C = Ey(C, r.pendingLanes);
          var k = en(C, d);
          y.lanes = k, bd(r, k);
        }
      }
    }
    function uA(r, i) {
      var d = r.updateQueue, p = r.alternate;
      if (p !== null) {
        var y = p.updateQueue;
        if (d === y) {
          var C = null, k = null, O = d.firstBaseUpdate;
          if (O !== null) {
            var N = O;
            do {
              var z = {
                eventTime: N.eventTime,
                lane: N.lane,
                tag: N.tag,
                payload: N.payload,
                callback: N.callback,
                next: null
              };
              k === null ? C = k = z : (k.next = z, k = z), N = N.next;
            } while (N !== null);
            k === null ? C = k = i : (k.next = i, k = i);
          } else
            C = k = i;
          d = {
            baseState: y.baseState,
            firstBaseUpdate: C,
            lastBaseUpdate: k,
            shared: y.shared,
            effects: y.effects
          }, r.updateQueue = d;
          return;
        }
      }
      var j = d.lastBaseUpdate;
      j === null ? d.firstBaseUpdate = i : j.next = i, d.lastBaseUpdate = i;
    }
    function GX(r, i, d, p, y, C) {
      switch (d.tag) {
        case UN: {
          var k = d.payload;
          if (typeof k == "function") {
            zN();
            var O = k.call(C, p, y);
            {
              if (r.mode & br) {
                Ur(!0);
                try {
                  k.call(C, p, y);
                } finally {
                  Ur(!1);
                }
              }
              HN();
            }
            return O;
          }
          return k;
        }
        case aA:
          r.flags = r.flags & ~no | jt;
        case WN: {
          var N = d.payload, z;
          if (typeof N == "function") {
            zN(), z = N.call(C, p, y);
            {
              if (r.mode & br) {
                Ur(!0);
                try {
                  N.call(C, p, y);
                } finally {
                  Ur(!1);
                }
              }
              HN();
            }
          } else
            z = N;
          return z == null ? p : on({}, p, z);
        }
        case Sx:
          return xx = !0, p;
      }
      return p;
    }
    function Ex(r, i, d, p) {
      var y = r.updateQueue;
      xx = !1, Cx = y.shared;
      var C = y.firstBaseUpdate, k = y.lastBaseUpdate, O = y.shared.pending;
      if (O !== null) {
        y.shared.pending = null;
        var N = O, z = N.next;
        N.next = null, k === null ? C = z : k.next = z, k = N;
        var j = r.alternate;
        if (j !== null) {
          var ue = j.updateQueue, ae = ue.lastBaseUpdate;
          ae !== k && (ae === null ? ue.firstBaseUpdate = z : ae.next = z, ue.lastBaseUpdate = N);
        }
      }
      if (C !== null) {
        var Ae = y.baseState, ke = Be, Ne = null, pt = null, Rt = null, Et = C;
        do {
          var xn = Et.lane, yn = Et.eventTime;
          if (Yu(p, xn)) {
            if (Rt !== null) {
              var Me = {
                eventTime: yn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: bn,
                tag: Et.tag,
                payload: Et.payload,
                callback: Et.callback,
                next: null
              };
              Rt = Rt.next = Me;
            }
            Ae = GX(r, y, Et, Ae, i, d);
            var Se = Et.callback;
            if (Se !== null && // If the update was already committed, we should not queue its
            // callback again.
            Et.lane !== bn) {
              r.flags |= es;
              var Ye = y.effects;
              Ye === null ? y.effects = [Et] : Ye.push(Et);
            }
          } else {
            var be = {
              eventTime: yn,
              lane: xn,
              tag: Et.tag,
              payload: Et.payload,
              callback: Et.callback,
              next: null
            };
            Rt === null ? (pt = Rt = be, Ne = Ae) : Rt = Rt.next = be, ke = en(ke, xn);
          }
          if (Et = Et.next, Et === null) {
            if (O = y.shared.pending, O === null)
              break;
            var ht = O, at = ht.next;
            ht.next = null, Et = at, y.lastBaseUpdate = ht, y.shared.pending = null;
          }
        } while (!0);
        Rt === null && (Ne = Ae), y.baseState = Ne, y.firstBaseUpdate = pt, y.lastBaseUpdate = Rt;
        var zt = y.shared.interleaved;
        if (zt !== null) {
          var Jt = zt;
          do
            ke = en(ke, Jt.lane), Jt = Jt.next;
          while (Jt !== zt);
        } else
          C === null && (y.shared.lanes = Be);
        Bb(ke), r.lanes = ke, r.memoizedState = Ae;
      }
      Cx = null;
    }
    function WX(r, i) {
      if (typeof r != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + r));
      r.call(i);
    }
    function ZN() {
      xx = !1;
    }
    function Tx() {
      return xx;
    }
    function YN(r, i, d) {
      var p = i.effects;
      if (i.effects = null, p !== null)
        for (var y = 0; y < p.length; y++) {
          var C = p[y], k = C.callback;
          k !== null && (C.callback = null, WX(k, d));
        }
    }
    var cA = {}, JN = new e.Component().refs, dA, fA, pA, hA, mA, QN, Ix, vA, gA, yA;
    {
      dA = /* @__PURE__ */ new Set(), fA = /* @__PURE__ */ new Set(), pA = /* @__PURE__ */ new Set(), hA = /* @__PURE__ */ new Set(), vA = /* @__PURE__ */ new Set(), mA = /* @__PURE__ */ new Set(), gA = /* @__PURE__ */ new Set(), yA = /* @__PURE__ */ new Set();
      var KN = /* @__PURE__ */ new Set();
      Ix = function(r, i) {
        if (!(r === null || typeof r == "function")) {
          var d = i + "_" + r;
          KN.has(d) || (KN.add(d), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", i, r));
        }
      }, QN = function(r, i) {
        if (i === void 0) {
          var d = $n(r) || "Component";
          mA.has(d) || (mA.add(d), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      }, Object.defineProperty(cA, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(cA);
    }
    function bA(r, i, d, p) {
      var y = r.memoizedState, C = d(p, y);
      {
        if (r.mode & br) {
          Ur(!0);
          try {
            C = d(p, y);
          } finally {
            Ur(!1);
          }
        }
        QN(i, C);
      }
      var k = C == null ? y : on({}, y, C);
      if (r.memoizedState = k, r.lanes === Be) {
        var O = r.updateQueue;
        O.baseState = k;
      }
    }
    var SA = {
      isMounted: Ri,
      enqueueSetState: function(r, i, d) {
        var p = Yi(r), y = Mi(), C = Xd(p), k = dc(y, C);
        k.payload = i, d != null && (Ix(d, "setState"), k.callback = d);
        var O = Vd(p, k, C);
        O !== null && (Ao(O, p, C, y), wx(O, p, C)), zl(p, C);
      },
      enqueueReplaceState: function(r, i, d) {
        var p = Yi(r), y = Mi(), C = Xd(p), k = dc(y, C);
        k.tag = UN, k.payload = i, d != null && (Ix(d, "replaceState"), k.callback = d);
        var O = Vd(p, k, C);
        O !== null && (Ao(O, p, C, y), wx(O, p, C)), zl(p, C);
      },
      enqueueForceUpdate: function(r, i) {
        var d = Yi(r), p = Mi(), y = Xd(d), C = dc(p, y);
        C.tag = Sx, i != null && (Ix(i, "forceUpdate"), C.callback = i);
        var k = Vd(d, C, y);
        k !== null && (Ao(k, d, y, p), wx(k, d, y)), yy(d, y);
      }
    };
    function qN(r, i, d, p, y, C, k) {
      var O = r.stateNode;
      if (typeof O.shouldComponentUpdate == "function") {
        var N = O.shouldComponentUpdate(p, C, k);
        {
          if (r.mode & br) {
            Ur(!0);
            try {
              N = O.shouldComponentUpdate(p, C, k);
            } finally {
              Ur(!1);
            }
          }
          N === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", $n(i) || "Component");
        }
        return N;
      }
      return i.prototype && i.prototype.isPureReactComponent ? !It(d, p) || !It(y, C) : !0;
    }
    function UX(r, i, d) {
      var p = r.stateNode;
      {
        var y = $n(i) || "Component", C = p.render;
        C || (i.prototype && typeof i.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", y) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", y)), p.getInitialState && !p.getInitialState.isReactClassApproved && !p.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", y), p.getDefaultProps && !p.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", y), p.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", y), p.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", y), p.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", y), i.contextType && i.contextTypes && !gA.has(i) && (gA.add(i), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", y)), typeof p.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", y), i.prototype && i.prototype.isPureReactComponent && typeof p.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", $n(i) || "A pure component"), typeof p.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", y), typeof p.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", y), typeof p.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", y), typeof p.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", y);
        var k = p.props !== d;
        p.props !== void 0 && k && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", y, y), p.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", y, y), typeof p.getSnapshotBeforeUpdate == "function" && typeof p.componentDidUpdate != "function" && !pA.has(i) && (pA.add(i), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", $n(i))), typeof p.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", y), typeof p.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", y), typeof i.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", y);
        var O = p.state;
        O && (typeof O != "object" || eo(O)) && u("%s.state: must be set to an object or null", y), typeof p.getChildContext == "function" && typeof i.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", y);
      }
    }
    function eM(r, i) {
      i.updater = SA, r.stateNode = i, ud(i, r), i._reactInternalInstance = cA;
    }
    function tM(r, i, d) {
      var p = !1, y = Fa, C = Fa, k = i.contextType;
      if ("contextType" in i) {
        var O = (
          // Allow null for conditional declaration
          k === null || k !== void 0 && k.$$typeof === Pf && k._context === void 0
        );
        if (!O && !yA.has(i)) {
          yA.add(i);
          var N = "";
          k === void 0 ? N = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof k != "object" ? N = " However, it is set to a " + typeof k + "." : k.$$typeof === Rf ? N = " Did you accidentally pass the Context.Provider instead?" : k._context !== void 0 ? N = " Did you accidentally pass the Context.Consumer instead?" : N = " However, it is set to an object with keys {" + Object.keys(k).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", $n(i) || "Component", N);
        }
      }
      if (typeof k == "object" && k !== null)
        C = so(k);
      else {
        y = Zm(r, i, !0);
        var z = i.contextTypes;
        p = z != null, C = p ? Ym(r, y) : Fa;
      }
      var j = new i(d, C);
      if (r.mode & br) {
        Ur(!0);
        try {
          j = new i(d, C);
        } finally {
          Ur(!1);
        }
      }
      var ue = r.memoizedState = j.state !== null && j.state !== void 0 ? j.state : null;
      eM(r, j);
      {
        if (typeof i.getDerivedStateFromProps == "function" && ue === null) {
          var ae = $n(i) || "Component";
          fA.has(ae) || (fA.add(ae), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", ae, j.state === null ? "null" : "undefined", ae));
        }
        if (typeof i.getDerivedStateFromProps == "function" || typeof j.getSnapshotBeforeUpdate == "function") {
          var Ae = null, ke = null, Ne = null;
          if (typeof j.componentWillMount == "function" && j.componentWillMount.__suppressDeprecationWarning !== !0 ? Ae = "componentWillMount" : typeof j.UNSAFE_componentWillMount == "function" && (Ae = "UNSAFE_componentWillMount"), typeof j.componentWillReceiveProps == "function" && j.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ke = "componentWillReceiveProps" : typeof j.UNSAFE_componentWillReceiveProps == "function" && (ke = "UNSAFE_componentWillReceiveProps"), typeof j.componentWillUpdate == "function" && j.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ne = "componentWillUpdate" : typeof j.UNSAFE_componentWillUpdate == "function" && (Ne = "UNSAFE_componentWillUpdate"), Ae !== null || ke !== null || Ne !== null) {
            var pt = $n(i) || "Component", Rt = typeof i.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            hA.has(pt) || (hA.add(pt), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, pt, Rt, Ae !== null ? `
  ` + Ae : "", ke !== null ? `
  ` + ke : "", Ne !== null ? `
  ` + Ne : ""));
          }
        }
      }
      return p && TN(r, y, C), j;
    }
    function XX(r, i) {
      var d = i.state;
      typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), d !== i.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ut(r) || "Component"), SA.enqueueReplaceState(i, i.state, null));
    }
    function nM(r, i, d, p) {
      var y = i.state;
      if (typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(d, p), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(d, p), i.state !== y) {
        {
          var C = Ut(r) || "Component";
          dA.has(C) || (dA.add(C), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", C));
        }
        SA.enqueueReplaceState(i, i.state, null);
      }
    }
    function xA(r, i, d, p) {
      UX(r, i, d);
      var y = r.stateNode;
      y.props = d, y.state = r.memoizedState, y.refs = JN, lA(r);
      var C = i.contextType;
      if (typeof C == "object" && C !== null)
        y.context = so(C);
      else {
        var k = Zm(r, i, !0);
        y.context = Ym(r, k);
      }
      {
        if (y.state === d) {
          var O = $n(i) || "Component";
          vA.has(O) || (vA.add(O), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", O));
        }
        r.mode & br && tl.recordLegacyContextWarning(r, y), tl.recordUnsafeLifecycleWarnings(r, y);
      }
      y.state = r.memoizedState;
      var N = i.getDerivedStateFromProps;
      if (typeof N == "function" && (bA(r, i, N, d), y.state = r.memoizedState), typeof i.getDerivedStateFromProps != "function" && typeof y.getSnapshotBeforeUpdate != "function" && (typeof y.UNSAFE_componentWillMount == "function" || typeof y.componentWillMount == "function") && (XX(r, y), Ex(r, d, y, p), y.state = r.memoizedState), typeof y.componentDidMount == "function") {
        var z = qt;
        z |= ui, (r.mode & ea) !== _t && (z |= ci), r.flags |= z;
      }
    }
    function ZX(r, i, d, p) {
      var y = r.stateNode, C = r.memoizedProps;
      y.props = C;
      var k = y.context, O = i.contextType, N = Fa;
      if (typeof O == "object" && O !== null)
        N = so(O);
      else {
        var z = Zm(r, i, !0);
        N = Ym(r, z);
      }
      var j = i.getDerivedStateFromProps, ue = typeof j == "function" || typeof y.getSnapshotBeforeUpdate == "function";
      !ue && (typeof y.UNSAFE_componentWillReceiveProps == "function" || typeof y.componentWillReceiveProps == "function") && (C !== d || k !== N) && nM(r, y, d, N), ZN();
      var ae = r.memoizedState, Ae = y.state = ae;
      if (Ex(r, d, y, p), Ae = r.memoizedState, C === d && ae === Ae && !sx() && !Tx()) {
        if (typeof y.componentDidMount == "function") {
          var ke = qt;
          ke |= ui, (r.mode & ea) !== _t && (ke |= ci), r.flags |= ke;
        }
        return !1;
      }
      typeof j == "function" && (bA(r, i, j, d), Ae = r.memoizedState);
      var Ne = Tx() || qN(r, i, C, d, ae, Ae, N);
      if (Ne) {
        if (!ue && (typeof y.UNSAFE_componentWillMount == "function" || typeof y.componentWillMount == "function") && (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function") {
          var pt = qt;
          pt |= ui, (r.mode & ea) !== _t && (pt |= ci), r.flags |= pt;
        }
      } else {
        if (typeof y.componentDidMount == "function") {
          var Rt = qt;
          Rt |= ui, (r.mode & ea) !== _t && (Rt |= ci), r.flags |= Rt;
        }
        r.memoizedProps = d, r.memoizedState = Ae;
      }
      return y.props = d, y.state = Ae, y.context = N, Ne;
    }
    function YX(r, i, d, p, y) {
      var C = i.stateNode;
      XN(r, i);
      var k = i.memoizedProps, O = i.type === i.elementType ? k : nl(i.type, k);
      C.props = O;
      var N = i.pendingProps, z = C.context, j = d.contextType, ue = Fa;
      if (typeof j == "object" && j !== null)
        ue = so(j);
      else {
        var ae = Zm(i, d, !0);
        ue = Ym(i, ae);
      }
      var Ae = d.getDerivedStateFromProps, ke = typeof Ae == "function" || typeof C.getSnapshotBeforeUpdate == "function";
      !ke && (typeof C.UNSAFE_componentWillReceiveProps == "function" || typeof C.componentWillReceiveProps == "function") && (k !== N || z !== ue) && nM(i, C, p, ue), ZN();
      var Ne = i.memoizedState, pt = C.state = Ne;
      if (Ex(i, p, C, y), pt = i.memoizedState, k === N && Ne === pt && !sx() && !Tx() && !ge)
        return typeof C.componentDidUpdate == "function" && (k !== r.memoizedProps || Ne !== r.memoizedState) && (i.flags |= qt), typeof C.getSnapshotBeforeUpdate == "function" && (k !== r.memoizedProps || Ne !== r.memoizedState) && (i.flags |= Ji), !1;
      typeof Ae == "function" && (bA(i, d, Ae, p), pt = i.memoizedState);
      var Rt = Tx() || qN(i, d, O, p, Ne, pt, ue) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      ge;
      return Rt ? (!ke && (typeof C.UNSAFE_componentWillUpdate == "function" || typeof C.componentWillUpdate == "function") && (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(p, pt, ue), typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(p, pt, ue)), typeof C.componentDidUpdate == "function" && (i.flags |= qt), typeof C.getSnapshotBeforeUpdate == "function" && (i.flags |= Ji)) : (typeof C.componentDidUpdate == "function" && (k !== r.memoizedProps || Ne !== r.memoizedState) && (i.flags |= qt), typeof C.getSnapshotBeforeUpdate == "function" && (k !== r.memoizedProps || Ne !== r.memoizedState) && (i.flags |= Ji), i.memoizedProps = p, i.memoizedState = pt), C.props = p, C.state = pt, C.context = ue, Rt;
    }
    var CA, wA, EA, TA, IA, rM = function(r, i) {
    };
    CA = !1, wA = !1, EA = {}, TA = {}, IA = {}, rM = function(r, i) {
      if (!(r === null || typeof r != "object") && !(!r._store || r._store.validated || r.key != null)) {
        if (typeof r._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        r._store.validated = !0;
        var d = Ut(i) || "Component";
        TA[d] || (TA[d] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function pb(r, i, d) {
      var p = d.ref;
      if (p !== null && typeof p != "function" && typeof p != "object") {
        if ((r.mode & br || ne) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(d._owner && d._self && d._owner.stateNode !== d._self)) {
          var y = Ut(r) || "Component";
          EA[y] || (u('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', p), EA[y] = !0);
        }
        if (d._owner) {
          var C = d._owner, k;
          if (C) {
            var O = C;
            if (O.tag !== v)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            k = O.stateNode;
          }
          if (!k)
            throw new Error("Missing owner for string ref " + p + ". This error is likely caused by a bug in React. Please file an issue.");
          var N = k;
          Yt(p, "ref");
          var z = "" + p;
          if (i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === z)
            return i.ref;
          var j = function(ue) {
            var ae = N.refs;
            ae === JN && (ae = N.refs = {}), ue === null ? delete ae[z] : ae[z] = ue;
          };
          return j._stringRef = z, j;
        } else {
          if (typeof p != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!d._owner)
            throw new Error("Element ref was specified as a string (" + p + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return p;
    }
    function Ax(r, i) {
      var d = Object.prototype.toString.call(i);
      throw new Error("Objects are not valid as a React child (found: " + (d === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : d) + "). If you meant to render a collection of children, use an array instead.");
    }
    function kx(r) {
      {
        var i = Ut(r) || "Component";
        if (IA[i])
          return;
        IA[i] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function oM(r) {
      var i = r._payload, d = r._init;
      return d(i);
    }
    function iM(r) {
      function i(be, Me) {
        if (r) {
          var Se = be.deletions;
          Se === null ? (be.deletions = [Me], be.flags |= Nn) : Se.push(Me);
        }
      }
      function d(be, Me) {
        if (!r)
          return null;
        for (var Se = Me; Se !== null; )
          i(be, Se), Se = Se.sibling;
        return null;
      }
      function p(be, Me) {
        for (var Se = /* @__PURE__ */ new Map(), Ye = Me; Ye !== null; )
          Ye.key !== null ? Se.set(Ye.key, Ye) : Se.set(Ye.index, Ye), Ye = Ye.sibling;
        return Se;
      }
      function y(be, Me) {
        var Se = Bp(be, Me);
        return Se.index = 0, Se.sibling = null, Se;
      }
      function C(be, Me, Se) {
        if (be.index = Se, !r)
          return be.flags |= ay, Me;
        var Ye = be.alternate;
        if (Ye !== null) {
          var ht = Ye.index;
          return ht < Me ? (be.flags |= ir, Me) : ht;
        } else
          return be.flags |= ir, Me;
      }
      function k(be) {
        return r && be.alternate === null && (be.flags |= ir), be;
      }
      function O(be, Me, Se, Ye) {
        if (Me === null || Me.tag !== E) {
          var ht = qk(Se, be.mode, Ye);
          return ht.return = be, ht;
        } else {
          var at = y(Me, Se);
          return at.return = be, at;
        }
      }
      function N(be, Me, Se, Ye) {
        var ht = Se.type;
        if (ht === Aa)
          return j(be, Me, Se.props.children, Ye, Se.key);
        if (Me !== null && (Me.elementType === ht || // Keep this check inline so it only runs on the false path:
        YL(Me, Se) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof ht == "object" && ht !== null && ht.$$typeof === mo && oM(ht) === Me.type)) {
          var at = y(Me, Se.props);
          return at.ref = pb(be, Me, Se), at.return = be, at._debugSource = Se._source, at._debugOwner = Se._owner, at;
        }
        var zt = Kk(Se, be.mode, Ye);
        return zt.ref = pb(be, Me, Se), zt.return = be, zt;
      }
      function z(be, Me, Se, Ye) {
        if (Me === null || Me.tag !== S || Me.stateNode.containerInfo !== Se.containerInfo || Me.stateNode.implementation !== Se.implementation) {
          var ht = eR(Se, be.mode, Ye);
          return ht.return = be, ht;
        } else {
          var at = y(Me, Se.children || []);
          return at.return = be, at;
        }
      }
      function j(be, Me, Se, Ye, ht) {
        if (Me === null || Me.tag !== T) {
          var at = Yd(Se, be.mode, Ye, ht);
          return at.return = be, at;
        } else {
          var zt = y(Me, Se);
          return zt.return = be, zt;
        }
      }
      function ue(be, Me, Se) {
        if (typeof Me == "string" && Me !== "" || typeof Me == "number") {
          var Ye = qk("" + Me, be.mode, Se);
          return Ye.return = be, Ye;
        }
        if (typeof Me == "object" && Me !== null) {
          switch (Me.$$typeof) {
            case Qa: {
              var ht = Kk(Me, be.mode, Se);
              return ht.ref = pb(be, null, Me), ht.return = be, ht;
            }
            case Po: {
              var at = eR(Me, be.mode, Se);
              return at.return = be, at;
            }
            case mo: {
              var zt = Me._payload, Jt = Me._init;
              return ue(be, Jt(zt), Se);
            }
          }
          if (eo(Me) || ka(Me)) {
            var Yn = Yd(Me, be.mode, Se, null);
            return Yn.return = be, Yn;
          }
          Ax(be, Me);
        }
        return typeof Me == "function" && kx(be), null;
      }
      function ae(be, Me, Se, Ye) {
        var ht = Me !== null ? Me.key : null;
        if (typeof Se == "string" && Se !== "" || typeof Se == "number")
          return ht !== null ? null : O(be, Me, "" + Se, Ye);
        if (typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case Qa:
              return Se.key === ht ? N(be, Me, Se, Ye) : null;
            case Po:
              return Se.key === ht ? z(be, Me, Se, Ye) : null;
            case mo: {
              var at = Se._payload, zt = Se._init;
              return ae(be, Me, zt(at), Ye);
            }
          }
          if (eo(Se) || ka(Se))
            return ht !== null ? null : j(be, Me, Se, Ye, null);
          Ax(be, Se);
        }
        return typeof Se == "function" && kx(be), null;
      }
      function Ae(be, Me, Se, Ye, ht) {
        if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number") {
          var at = be.get(Se) || null;
          return O(Me, at, "" + Ye, ht);
        }
        if (typeof Ye == "object" && Ye !== null) {
          switch (Ye.$$typeof) {
            case Qa: {
              var zt = be.get(Ye.key === null ? Se : Ye.key) || null;
              return N(Me, zt, Ye, ht);
            }
            case Po: {
              var Jt = be.get(Ye.key === null ? Se : Ye.key) || null;
              return z(Me, Jt, Ye, ht);
            }
            case mo:
              var Yn = Ye._payload, kn = Ye._init;
              return Ae(be, Me, Se, kn(Yn), ht);
          }
          if (eo(Ye) || ka(Ye)) {
            var Qr = be.get(Se) || null;
            return j(Me, Qr, Ye, ht, null);
          }
          Ax(Me, Ye);
        }
        return typeof Ye == "function" && kx(Me), null;
      }
      function ke(be, Me, Se) {
        {
          if (typeof be != "object" || be === null)
            return Me;
          switch (be.$$typeof) {
            case Qa:
            case Po:
              rM(be, Se);
              var Ye = be.key;
              if (typeof Ye != "string")
                break;
              if (Me === null) {
                Me = /* @__PURE__ */ new Set(), Me.add(Ye);
                break;
              }
              if (!Me.has(Ye)) {
                Me.add(Ye);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Ye);
              break;
            case mo:
              var ht = be._payload, at = be._init;
              ke(at(ht), Me, Se);
              break;
          }
        }
        return Me;
      }
      function Ne(be, Me, Se, Ye) {
        for (var ht = null, at = 0; at < Se.length; at++) {
          var zt = Se[at];
          ht = ke(zt, ht, be);
        }
        for (var Jt = null, Yn = null, kn = Me, Qr = 0, Rn = 0, Br = null; kn !== null && Rn < Se.length; Rn++) {
          kn.index > Rn ? (Br = kn, kn = null) : Br = kn.sibling;
          var Si = ae(be, kn, Se[Rn], Ye);
          if (Si === null) {
            kn === null && (kn = Br);
            break;
          }
          r && kn && Si.alternate === null && i(be, kn), Qr = C(Si, Qr, Rn), Yn === null ? Jt = Si : Yn.sibling = Si, Yn = Si, kn = Br;
        }
        if (Rn === Se.length) {
          if (d(be, kn), Go()) {
            var Qo = Rn;
            Tp(be, Qo);
          }
          return Jt;
        }
        if (kn === null) {
          for (; Rn < Se.length; Rn++) {
            var Va = ue(be, Se[Rn], Ye);
            Va !== null && (Qr = C(Va, Qr, Rn), Yn === null ? Jt = Va : Yn.sibling = Va, Yn = Va);
          }
          if (Go()) {
            var Li = Rn;
            Tp(be, Li);
          }
          return Jt;
        }
        for (var Fi = p(be, kn); Rn < Se.length; Rn++) {
          var xi = Ae(Fi, be, Rn, Se[Rn], Ye);
          xi !== null && (r && xi.alternate !== null && Fi.delete(xi.key === null ? Rn : xi.key), Qr = C(xi, Qr, Rn), Yn === null ? Jt = xi : Yn.sibling = xi, Yn = xi);
        }
        if (r && Fi.forEach(function(gv) {
          return i(be, gv);
        }), Go()) {
          var gc = Rn;
          Tp(be, gc);
        }
        return Jt;
      }
      function pt(be, Me, Se, Ye) {
        var ht = ka(Se);
        if (typeof ht != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Se[Symbol.toStringTag] === "Generator" && (wA || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), wA = !0), Se.entries === ht && (CA || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), CA = !0);
          var at = ht.call(Se);
          if (at)
            for (var zt = null, Jt = at.next(); !Jt.done; Jt = at.next()) {
              var Yn = Jt.value;
              zt = ke(Yn, zt, be);
            }
        }
        var kn = ht.call(Se);
        if (kn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Qr = null, Rn = null, Br = Me, Si = 0, Qo = 0, Va = null, Li = kn.next(); Br !== null && !Li.done; Qo++, Li = kn.next()) {
          Br.index > Qo ? (Va = Br, Br = null) : Va = Br.sibling;
          var Fi = ae(be, Br, Li.value, Ye);
          if (Fi === null) {
            Br === null && (Br = Va);
            break;
          }
          r && Br && Fi.alternate === null && i(be, Br), Si = C(Fi, Si, Qo), Rn === null ? Qr = Fi : Rn.sibling = Fi, Rn = Fi, Br = Va;
        }
        if (Li.done) {
          if (d(be, Br), Go()) {
            var xi = Qo;
            Tp(be, xi);
          }
          return Qr;
        }
        if (Br === null) {
          for (; !Li.done; Qo++, Li = kn.next()) {
            var gc = ue(be, Li.value, Ye);
            gc !== null && (Si = C(gc, Si, Qo), Rn === null ? Qr = gc : Rn.sibling = gc, Rn = gc);
          }
          if (Go()) {
            var gv = Qo;
            Tp(be, gv);
          }
          return Qr;
        }
        for (var jb = p(be, Br); !Li.done; Qo++, Li = kn.next()) {
          var iu = Ae(jb, be, Qo, Li.value, Ye);
          iu !== null && (r && iu.alternate !== null && jb.delete(iu.key === null ? Qo : iu.key), Si = C(iu, Si, Qo), Rn === null ? Qr = iu : Rn.sibling = iu, Rn = iu);
        }
        if (r && jb.forEach(function(uJ) {
          return i(be, uJ);
        }), Go()) {
          var lJ = Qo;
          Tp(be, lJ);
        }
        return Qr;
      }
      function Rt(be, Me, Se, Ye) {
        if (Me !== null && Me.tag === E) {
          d(be, Me.sibling);
          var ht = y(Me, Se);
          return ht.return = be, ht;
        }
        d(be, Me);
        var at = qk(Se, be.mode, Ye);
        return at.return = be, at;
      }
      function Et(be, Me, Se, Ye) {
        for (var ht = Se.key, at = Me; at !== null; ) {
          if (at.key === ht) {
            var zt = Se.type;
            if (zt === Aa) {
              if (at.tag === T) {
                d(be, at.sibling);
                var Jt = y(at, Se.props.children);
                return Jt.return = be, Jt._debugSource = Se._source, Jt._debugOwner = Se._owner, Jt;
              }
            } else if (at.elementType === zt || // Keep this check inline so it only runs on the false path:
            YL(at, Se) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof zt == "object" && zt !== null && zt.$$typeof === mo && oM(zt) === at.type) {
              d(be, at.sibling);
              var Yn = y(at, Se.props);
              return Yn.ref = pb(be, at, Se), Yn.return = be, Yn._debugSource = Se._source, Yn._debugOwner = Se._owner, Yn;
            }
            d(be, at);
            break;
          } else
            i(be, at);
          at = at.sibling;
        }
        if (Se.type === Aa) {
          var kn = Yd(Se.props.children, be.mode, Ye, Se.key);
          return kn.return = be, kn;
        } else {
          var Qr = Kk(Se, be.mode, Ye);
          return Qr.ref = pb(be, Me, Se), Qr.return = be, Qr;
        }
      }
      function xn(be, Me, Se, Ye) {
        for (var ht = Se.key, at = Me; at !== null; ) {
          if (at.key === ht)
            if (at.tag === S && at.stateNode.containerInfo === Se.containerInfo && at.stateNode.implementation === Se.implementation) {
              d(be, at.sibling);
              var zt = y(at, Se.children || []);
              return zt.return = be, zt;
            } else {
              d(be, at);
              break;
            }
          else
            i(be, at);
          at = at.sibling;
        }
        var Jt = eR(Se, be.mode, Ye);
        return Jt.return = be, Jt;
      }
      function yn(be, Me, Se, Ye) {
        var ht = typeof Se == "object" && Se !== null && Se.type === Aa && Se.key === null;
        if (ht && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case Qa:
              return k(Et(be, Me, Se, Ye));
            case Po:
              return k(xn(be, Me, Se, Ye));
            case mo:
              var at = Se._payload, zt = Se._init;
              return yn(be, Me, zt(at), Ye);
          }
          if (eo(Se))
            return Ne(be, Me, Se, Ye);
          if (ka(Se))
            return pt(be, Me, Se, Ye);
          Ax(be, Se);
        }
        return typeof Se == "string" && Se !== "" || typeof Se == "number" ? k(Rt(be, Me, "" + Se, Ye)) : (typeof Se == "function" && kx(be), d(be, Me));
      }
      return yn;
    }
    var tv = iM(!0), aM = iM(!1);
    function JX(r, i) {
      if (r !== null && i.child !== r.child)
        throw new Error("Resuming work not yet implemented.");
      if (i.child !== null) {
        var d = i.child, p = Bp(d, d.pendingProps);
        for (i.child = p, p.return = i; d.sibling !== null; )
          d = d.sibling, p = p.sibling = Bp(d, d.pendingProps), p.return = i;
        p.sibling = null;
      }
    }
    function QX(r, i) {
      for (var d = r.child; d !== null; )
        IY(d, i), d = d.sibling;
    }
    var hb = {}, $d = Md(hb), mb = Md(hb), Rx = Md(hb);
    function Px(r) {
      if (r === hb)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return r;
    }
    function sM() {
      var r = Px(Rx.current);
      return r;
    }
    function AA(r, i) {
      yi(Rx, i, r), yi(mb, r, r), yi($d, hb, r);
      var d = d8(i);
      gi($d, r), yi($d, d, r);
    }
    function nv(r) {
      gi($d, r), gi(mb, r), gi(Rx, r);
    }
    function kA() {
      var r = Px($d.current);
      return r;
    }
    function lM(r) {
      Px(Rx.current);
      var i = Px($d.current), d = f8(i, r.type);
      i !== d && (yi(mb, r, r), yi($d, d, r));
    }
    function RA(r) {
      mb.current === r && (gi($d, r), gi(mb, r));
    }
    var KX = 0, uM = 1, cM = 1, vb = 2, rl = Md(KX);
    function PA(r, i) {
      return (r & i) !== 0;
    }
    function rv(r) {
      return r & uM;
    }
    function OA(r, i) {
      return r & uM | i;
    }
    function qX(r, i) {
      return r | i;
    }
    function zd(r, i) {
      yi(rl, i, r);
    }
    function ov(r) {
      gi(rl, r);
    }
    function e7(r, i) {
      var d = r.memoizedState;
      return d !== null ? d.dehydrated !== null : (r.memoizedProps, !0);
    }
    function Ox(r) {
      for (var i = r; i !== null; ) {
        if (i.tag === F) {
          var d = i.memoizedState;
          if (d !== null) {
            var p = d.dehydrated;
            if (p === null || SN(p) || FI(p))
              return i;
          }
        } else if (i.tag === G && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        i.memoizedProps.revealOrder !== void 0) {
          var y = (i.flags & jt) !== At;
          if (y)
            return i;
        } else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === r)
          return null;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === r)
            return null;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return null;
    }
    var la = (
      /*   */
      0
    ), So = (
      /* */
      1
    ), Kl = (
      /*  */
      2
    ), xo = (
      /*    */
      4
    ), Wo = (
      /*   */
      8
    ), _A = [];
    function DA() {
      for (var r = 0; r < _A.length; r++) {
        var i = _A[r];
        i._workInProgressVersionPrimary = null;
      }
      _A.length = 0;
    }
    function t7(r, i) {
      var d = i._getVersion, p = d(i._source);
      r.mutableSourceEagerHydrationData == null ? r.mutableSourceEagerHydrationData = [i, p] : r.mutableSourceEagerHydrationData.push(i, p);
    }
    var ct = n.ReactCurrentDispatcher, gb = n.ReactCurrentBatchConfig, NA, iv;
    NA = /* @__PURE__ */ new Set();
    var Op = Be, Zn = null, Co = null, wo = null, _x = !1, yb = !1, bb = 0, n7 = 0, r7 = 25, $e = null, us = null, Hd = -1, MA = !1;
    function Bn() {
      {
        var r = $e;
        us === null ? us = [r] : us.push(r);
      }
    }
    function rt() {
      {
        var r = $e;
        us !== null && (Hd++, us[Hd] !== r && o7(r));
      }
    }
    function av(r) {
      r != null && !eo(r) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", $e, typeof r);
    }
    function o7(r) {
      {
        var i = Ut(Zn);
        if (!NA.has(i) && (NA.add(i), us !== null)) {
          for (var d = "", p = 30, y = 0; y <= Hd; y++) {
            for (var C = us[y], k = y === Hd ? r : C, O = y + 1 + ". " + C; O.length < p; )
              O += " ";
            O += k + `
`, d += O;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, i, d);
        }
      }
    }
    function bi() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function LA(r, i) {
      if (MA)
        return !1;
      if (i === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", $e), !1;
      r.length !== i.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, $e, "[" + i.join(", ") + "]", "[" + r.join(", ") + "]");
      for (var d = 0; d < i.length && d < r.length; d++)
        if (!St(r[d], i[d]))
          return !1;
      return !0;
    }
    function sv(r, i, d, p, y, C) {
      Op = C, Zn = i, us = r !== null ? r._debugHookTypes : null, Hd = -1, MA = r !== null && r.type !== i.type, i.memoizedState = null, i.updateQueue = null, i.lanes = Be, r !== null && r.memoizedState !== null ? ct.current = _M : us !== null ? ct.current = OM : ct.current = PM;
      var k = d(p, y);
      if (yb) {
        var O = 0;
        do {
          if (yb = !1, bb = 0, O >= r7)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          O += 1, MA = !1, Co = null, wo = null, i.updateQueue = null, Hd = -1, ct.current = DM, k = d(p, y);
        } while (yb);
      }
      ct.current = Wx, i._debugHookTypes = us;
      var N = Co !== null && Co.next !== null;
      if (Op = Be, Zn = null, Co = null, wo = null, $e = null, us = null, Hd = -1, r !== null && (r.flags & go) !== (i.flags & go) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (r.mode & pn) !== _t && u("Internal React error: Expected static flag was missing. Please notify the React team."), _x = !1, N)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return k;
    }
    function lv() {
      var r = bb !== 0;
      return bb = 0, r;
    }
    function dM(r, i, d) {
      i.updateQueue = r.updateQueue, (i.mode & ea) !== _t ? i.flags &= ~(Vu | ci | hr | qt) : i.flags &= ~(hr | qt), r.lanes = yd(r.lanes, d);
    }
    function fM() {
      if (ct.current = Wx, _x) {
        for (var r = Zn.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), r = r.next;
        }
        _x = !1;
      }
      Op = Be, Zn = null, Co = null, wo = null, us = null, Hd = -1, $e = null, TM = !1, yb = !1, bb = 0;
    }
    function ql() {
      var r = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return wo === null ? Zn.memoizedState = wo = r : wo = wo.next = r, wo;
    }
    function cs() {
      var r;
      if (Co === null) {
        var i = Zn.alternate;
        i !== null ? r = i.memoizedState : r = null;
      } else
        r = Co.next;
      var d;
      if (wo === null ? d = Zn.memoizedState : d = wo.next, d !== null)
        wo = d, d = wo.next, Co = r;
      else {
        if (r === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Co = r;
        var p = {
          memoizedState: Co.memoizedState,
          baseState: Co.baseState,
          baseQueue: Co.baseQueue,
          queue: Co.queue,
          next: null
        };
        wo === null ? Zn.memoizedState = wo = p : wo = wo.next = p;
      }
      return wo;
    }
    function pM() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function FA(r, i) {
      return typeof i == "function" ? i(r) : i;
    }
    function BA(r, i, d) {
      var p = ql(), y;
      d !== void 0 ? y = d(i) : y = i, p.memoizedState = p.baseState = y;
      var C = {
        pending: null,
        interleaved: null,
        lanes: Be,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: y
      };
      p.queue = C;
      var k = C.dispatch = l7.bind(null, Zn, C);
      return [p.memoizedState, k];
    }
    function VA(r, i, d) {
      var p = cs(), y = p.queue;
      if (y === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      y.lastRenderedReducer = r;
      var C = Co, k = C.baseQueue, O = y.pending;
      if (O !== null) {
        if (k !== null) {
          var N = k.next, z = O.next;
          k.next = z, O.next = N;
        }
        C.baseQueue !== k && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), C.baseQueue = k = O, y.pending = null;
      }
      if (k !== null) {
        var j = k.next, ue = C.baseState, ae = null, Ae = null, ke = null, Ne = j;
        do {
          var pt = Ne.lane;
          if (Yu(Op, pt)) {
            if (ke !== null) {
              var Et = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: bn,
                action: Ne.action,
                hasEagerState: Ne.hasEagerState,
                eagerState: Ne.eagerState,
                next: null
              };
              ke = ke.next = Et;
            }
            if (Ne.hasEagerState)
              ue = Ne.eagerState;
            else {
              var xn = Ne.action;
              ue = r(ue, xn);
            }
          } else {
            var Rt = {
              lane: pt,
              action: Ne.action,
              hasEagerState: Ne.hasEagerState,
              eagerState: Ne.eagerState,
              next: null
            };
            ke === null ? (Ae = ke = Rt, ae = ue) : ke = ke.next = Rt, Zn.lanes = en(Zn.lanes, pt), Bb(pt);
          }
          Ne = Ne.next;
        } while (Ne !== null && Ne !== j);
        ke === null ? ae = ue : ke.next = Ae, St(ue, p.memoizedState) || Ib(), p.memoizedState = ue, p.baseState = ae, p.baseQueue = ke, y.lastRenderedState = ue;
      }
      var yn = y.interleaved;
      if (yn !== null) {
        var be = yn;
        do {
          var Me = be.lane;
          Zn.lanes = en(Zn.lanes, Me), Bb(Me), be = be.next;
        } while (be !== yn);
      } else
        k === null && (y.lanes = Be);
      var Se = y.dispatch;
      return [p.memoizedState, Se];
    }
    function $A(r, i, d) {
      var p = cs(), y = p.queue;
      if (y === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      y.lastRenderedReducer = r;
      var C = y.dispatch, k = y.pending, O = p.memoizedState;
      if (k !== null) {
        y.pending = null;
        var N = k.next, z = N;
        do {
          var j = z.action;
          O = r(O, j), z = z.next;
        } while (z !== N);
        St(O, p.memoizedState) || Ib(), p.memoizedState = O, p.baseQueue === null && (p.baseState = O), y.lastRenderedState = O;
      }
      return [O, C];
    }
    function Q2e(r, i, d) {
    }
    function K2e(r, i, d) {
    }
    function zA(r, i, d) {
      var p = Zn, y = ql(), C, k = Go();
      if (k) {
        if (d === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        C = d(), iv || C !== d() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), iv = !0);
      } else {
        if (C = i(), !iv) {
          var O = i();
          St(C, O) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), iv = !0);
        }
        var N = uC();
        if (N === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        lp(N, Op) || hM(p, i, C);
      }
      y.memoizedState = C;
      var z = {
        value: C,
        getSnapshot: i
      };
      return y.queue = z, Fx(vM.bind(null, p, z, r), [r]), p.flags |= hr, Sb(So | Wo, mM.bind(null, p, z, C, i), void 0, null), C;
    }
    function Dx(r, i, d) {
      var p = Zn, y = cs(), C = i();
      if (!iv) {
        var k = i();
        St(C, k) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), iv = !0);
      }
      var O = y.memoizedState, N = !St(O, C);
      N && (y.memoizedState = C, Ib());
      var z = y.queue;
      if (Cb(vM.bind(null, p, z, r), [r]), z.getSnapshot !== i || N || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      wo !== null && wo.memoizedState.tag & So) {
        p.flags |= hr, Sb(So | Wo, mM.bind(null, p, z, C, i), void 0, null);
        var j = uC();
        if (j === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        lp(j, Op) || hM(p, i, C);
      }
      return C;
    }
    function hM(r, i, d) {
      r.flags |= qf;
      var p = {
        getSnapshot: i,
        value: d
      }, y = Zn.updateQueue;
      if (y === null)
        y = pM(), Zn.updateQueue = y, y.stores = [p];
      else {
        var C = y.stores;
        C === null ? y.stores = [p] : C.push(p);
      }
    }
    function mM(r, i, d, p) {
      i.value = d, i.getSnapshot = p, gM(i) && yM(r);
    }
    function vM(r, i, d) {
      var p = function() {
        gM(i) && yM(r);
      };
      return d(p);
    }
    function gM(r) {
      var i = r.getSnapshot, d = r.value;
      try {
        var p = i();
        return !St(d, p);
      } catch {
        return !0;
      }
    }
    function yM(r) {
      var i = sa(r, Lt);
      i !== null && Ao(i, r, Lt, tr);
    }
    function Nx(r) {
      var i = ql();
      typeof r == "function" && (r = r()), i.memoizedState = i.baseState = r;
      var d = {
        pending: null,
        interleaved: null,
        lanes: Be,
        dispatch: null,
        lastRenderedReducer: FA,
        lastRenderedState: r
      };
      i.queue = d;
      var p = d.dispatch = u7.bind(null, Zn, d);
      return [i.memoizedState, p];
    }
    function HA(r) {
      return VA(FA);
    }
    function jA(r) {
      return $A(FA);
    }
    function Sb(r, i, d, p) {
      var y = {
        tag: r,
        create: i,
        destroy: d,
        deps: p,
        // Circular
        next: null
      }, C = Zn.updateQueue;
      if (C === null)
        C = pM(), Zn.updateQueue = C, C.lastEffect = y.next = y;
      else {
        var k = C.lastEffect;
        if (k === null)
          C.lastEffect = y.next = y;
        else {
          var O = k.next;
          k.next = y, y.next = O, C.lastEffect = y;
        }
      }
      return y;
    }
    function GA(r) {
      var i = ql();
      {
        var d = {
          current: r
        };
        return i.memoizedState = d, d;
      }
    }
    function Mx(r) {
      var i = cs();
      return i.memoizedState;
    }
    function xb(r, i, d, p) {
      var y = ql(), C = p === void 0 ? null : p;
      Zn.flags |= r, y.memoizedState = Sb(So | i, d, void 0, C);
    }
    function Lx(r, i, d, p) {
      var y = cs(), C = p === void 0 ? null : p, k = void 0;
      if (Co !== null) {
        var O = Co.memoizedState;
        if (k = O.destroy, C !== null) {
          var N = O.deps;
          if (LA(C, N)) {
            y.memoizedState = Sb(i, d, k, C);
            return;
          }
        }
      }
      Zn.flags |= r, y.memoizedState = Sb(So | i, d, k, C);
    }
    function Fx(r, i) {
      return (Zn.mode & ea) !== _t ? xb(Vu | hr | Ml, Wo, r, i) : xb(hr | Ml, Wo, r, i);
    }
    function Cb(r, i) {
      return Lx(hr, Wo, r, i);
    }
    function WA(r, i) {
      return xb(qt, Kl, r, i);
    }
    function Bx(r, i) {
      return Lx(qt, Kl, r, i);
    }
    function UA(r, i) {
      var d = qt;
      return d |= ui, (Zn.mode & ea) !== _t && (d |= ci), xb(d, xo, r, i);
    }
    function Vx(r, i) {
      return Lx(qt, xo, r, i);
    }
    function bM(r, i) {
      if (typeof i == "function") {
        var d = i, p = r();
        return d(p), function() {
          d(null);
        };
      } else if (i != null) {
        var y = i;
        y.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(y).join(", ") + "}");
        var C = r();
        return y.current = C, function() {
          y.current = null;
        };
      }
    }
    function XA(r, i, d) {
      typeof i != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", i !== null ? typeof i : "null");
      var p = d != null ? d.concat([r]) : null, y = qt;
      return y |= ui, (Zn.mode & ea) !== _t && (y |= ci), xb(y, xo, bM.bind(null, i, r), p);
    }
    function $x(r, i, d) {
      typeof i != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", i !== null ? typeof i : "null");
      var p = d != null ? d.concat([r]) : null;
      return Lx(qt, xo, bM.bind(null, i, r), p);
    }
    function i7(r, i) {
    }
    var zx = i7;
    function ZA(r, i) {
      var d = ql(), p = i === void 0 ? null : i;
      return d.memoizedState = [r, p], r;
    }
    function Hx(r, i) {
      var d = cs(), p = i === void 0 ? null : i, y = d.memoizedState;
      if (y !== null && p !== null) {
        var C = y[1];
        if (LA(p, C))
          return y[0];
      }
      return d.memoizedState = [r, p], r;
    }
    function YA(r, i) {
      var d = ql(), p = i === void 0 ? null : i, y = r();
      return d.memoizedState = [y, p], y;
    }
    function jx(r, i) {
      var d = cs(), p = i === void 0 ? null : i, y = d.memoizedState;
      if (y !== null && p !== null) {
        var C = y[1];
        if (LA(p, C))
          return y[0];
      }
      var k = r();
      return d.memoizedState = [k, p], k;
    }
    function JA(r) {
      var i = ql();
      return i.memoizedState = r, r;
    }
    function SM(r) {
      var i = cs(), d = Co, p = d.memoizedState;
      return CM(i, p, r);
    }
    function xM(r) {
      var i = cs();
      if (Co === null)
        return i.memoizedState = r, r;
      var d = Co.memoizedState;
      return CM(i, d, r);
    }
    function CM(r, i, d) {
      var p = !nI(Op);
      if (p) {
        if (!St(d, i)) {
          var y = wy();
          Zn.lanes = en(Zn.lanes, y), Bb(y), r.baseState = !0;
        }
        return i;
      } else
        return r.baseState && (r.baseState = !1, Ib()), r.memoizedState = d, d;
    }
    function a7(r, i, d) {
      var p = na();
      Zr(Lo(p, bo)), r(!0);
      var y = gb.transition;
      gb.transition = {};
      var C = gb.transition;
      gb.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        r(!1), i();
      } finally {
        if (Zr(p), gb.transition = y, y === null && C._updatedFibers) {
          var k = C._updatedFibers.size;
          k > 10 && l("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), C._updatedFibers.clear();
        }
      }
    }
    function QA() {
      var r = Nx(!1), i = r[0], d = r[1], p = a7.bind(null, d), y = ql();
      return y.memoizedState = p, [i, p];
    }
    function wM() {
      var r = HA(), i = r[0], d = cs(), p = d.memoizedState;
      return [i, p];
    }
    function EM() {
      var r = jA(), i = r[0], d = cs(), p = d.memoizedState;
      return [i, p];
    }
    var TM = !1;
    function s7() {
      return TM;
    }
    function KA() {
      var r = ql(), i = uC(), d = i.identifierPrefix, p;
      if (Go()) {
        var y = xX();
        p = ":" + d + "R" + y;
        var C = bb++;
        C > 0 && (p += "H" + C.toString(32)), p += ":";
      } else {
        var k = n7++;
        p = ":" + d + "r" + k.toString(32) + ":";
      }
      return r.memoizedState = p, p;
    }
    function Gx() {
      var r = cs(), i = r.memoizedState;
      return i;
    }
    function l7(r, i, d) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var p = Xd(r), y = {
        lane: p,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IM(r))
        AM(i, y);
      else {
        var C = GN(r, i, y, p);
        if (C !== null) {
          var k = Mi();
          Ao(C, r, p, k), kM(C, i, p);
        }
      }
      RM(r, p);
    }
    function u7(r, i, d) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var p = Xd(r), y = {
        lane: p,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IM(r))
        AM(i, y);
      else {
        var C = r.alternate;
        if (r.lanes === Be && (C === null || C.lanes === Be)) {
          var k = i.lastRenderedReducer;
          if (k !== null) {
            var O;
            O = ct.current, ct.current = ol;
            try {
              var N = i.lastRenderedState, z = k(N, d);
              if (y.hasEagerState = !0, y.eagerState = z, St(z, N)) {
                zX(r, i, y, p);
                return;
              }
            } catch {
            } finally {
              ct.current = O;
            }
          }
        }
        var j = GN(r, i, y, p);
        if (j !== null) {
          var ue = Mi();
          Ao(j, r, p, ue), kM(j, i, p);
        }
      }
      RM(r, p);
    }
    function IM(r) {
      var i = r.alternate;
      return r === Zn || i !== null && i === Zn;
    }
    function AM(r, i) {
      yb = _x = !0;
      var d = r.pending;
      d === null ? i.next = i : (i.next = d.next, d.next = i), r.pending = i;
    }
    function kM(r, i, d) {
      if (Cy(d)) {
        var p = i.lanes;
        p = Ey(p, r.pendingLanes);
        var y = en(p, d);
        i.lanes = y, bd(r, y);
      }
    }
    function RM(r, i, d) {
      zl(r, i);
    }
    var Wx = {
      readContext: so,
      useCallback: bi,
      useContext: bi,
      useEffect: bi,
      useImperativeHandle: bi,
      useInsertionEffect: bi,
      useLayoutEffect: bi,
      useMemo: bi,
      useReducer: bi,
      useRef: bi,
      useState: bi,
      useDebugValue: bi,
      useDeferredValue: bi,
      useTransition: bi,
      useMutableSource: bi,
      useSyncExternalStore: bi,
      useId: bi,
      unstable_isNewReconciler: Q
    }, PM = null, OM = null, _M = null, DM = null, eu = null, ol = null, Ux = null;
    {
      var qA = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Xt = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      PM = {
        readContext: function(r) {
          return so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", Bn(), av(i), ZA(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", Bn(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", Bn(), av(i), Fx(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", Bn(), av(d), XA(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", Bn(), av(i), WA(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", Bn(), av(i), UA(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", Bn(), av(i);
          var d = ct.current;
          ct.current = eu;
          try {
            return YA(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", Bn();
          var p = ct.current;
          ct.current = eu;
          try {
            return BA(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", Bn(), GA(r);
        },
        useState: function(r) {
          $e = "useState", Bn();
          var i = ct.current;
          ct.current = eu;
          try {
            return Nx(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", Bn(), void 0;
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", Bn(), JA(r);
        },
        useTransition: function() {
          return $e = "useTransition", Bn(), QA();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", Bn(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", Bn(), zA(r, i, d);
        },
        useId: function() {
          return $e = "useId", Bn(), KA();
        },
        unstable_isNewReconciler: Q
      }, OM = {
        readContext: function(r) {
          return so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", rt(), ZA(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", rt(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", rt(), Fx(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", rt(), XA(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", rt(), WA(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", rt(), UA(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", rt();
          var d = ct.current;
          ct.current = eu;
          try {
            return YA(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", rt();
          var p = ct.current;
          ct.current = eu;
          try {
            return BA(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", rt(), GA(r);
        },
        useState: function(r) {
          $e = "useState", rt();
          var i = ct.current;
          ct.current = eu;
          try {
            return Nx(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", rt(), void 0;
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", rt(), JA(r);
        },
        useTransition: function() {
          return $e = "useTransition", rt(), QA();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", rt(), zA(r, i, d);
        },
        useId: function() {
          return $e = "useId", rt(), KA();
        },
        unstable_isNewReconciler: Q
      }, _M = {
        readContext: function(r) {
          return so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", rt(), Hx(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", rt(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", rt(), Cb(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", rt(), $x(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", rt(), Bx(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", rt(), Vx(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", rt();
          var d = ct.current;
          ct.current = ol;
          try {
            return jx(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", rt();
          var p = ct.current;
          ct.current = ol;
          try {
            return VA(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", rt(), Mx();
        },
        useState: function(r) {
          $e = "useState", rt();
          var i = ct.current;
          ct.current = ol;
          try {
            return HA(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", rt(), zx();
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", rt(), SM(r);
        },
        useTransition: function() {
          return $e = "useTransition", rt(), wM();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", rt(), Dx(r, i);
        },
        useId: function() {
          return $e = "useId", rt(), Gx();
        },
        unstable_isNewReconciler: Q
      }, DM = {
        readContext: function(r) {
          return so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", rt(), Hx(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", rt(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", rt(), Cb(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", rt(), $x(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", rt(), Bx(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", rt(), Vx(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", rt();
          var d = ct.current;
          ct.current = Ux;
          try {
            return jx(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", rt();
          var p = ct.current;
          ct.current = Ux;
          try {
            return $A(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", rt(), Mx();
        },
        useState: function(r) {
          $e = "useState", rt();
          var i = ct.current;
          ct.current = Ux;
          try {
            return jA(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", rt(), zx();
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", rt(), xM(r);
        },
        useTransition: function() {
          return $e = "useTransition", rt(), EM();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", rt(), Dx(r, i);
        },
        useId: function() {
          return $e = "useId", rt(), Gx();
        },
        unstable_isNewReconciler: Q
      }, eu = {
        readContext: function(r) {
          return qA(), so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", Xt(), Bn(), ZA(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", Xt(), Bn(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", Xt(), Bn(), Fx(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", Xt(), Bn(), XA(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", Xt(), Bn(), WA(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", Xt(), Bn(), UA(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", Xt(), Bn();
          var d = ct.current;
          ct.current = eu;
          try {
            return YA(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", Xt(), Bn();
          var p = ct.current;
          ct.current = eu;
          try {
            return BA(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", Xt(), Bn(), GA(r);
        },
        useState: function(r) {
          $e = "useState", Xt(), Bn();
          var i = ct.current;
          ct.current = eu;
          try {
            return Nx(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", Xt(), Bn(), void 0;
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", Xt(), Bn(), JA(r);
        },
        useTransition: function() {
          return $e = "useTransition", Xt(), Bn(), QA();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", Xt(), Bn(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", Xt(), Bn(), zA(r, i, d);
        },
        useId: function() {
          return $e = "useId", Xt(), Bn(), KA();
        },
        unstable_isNewReconciler: Q
      }, ol = {
        readContext: function(r) {
          return qA(), so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", Xt(), rt(), Hx(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", Xt(), rt(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", Xt(), rt(), Cb(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", Xt(), rt(), $x(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", Xt(), rt(), Bx(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", Xt(), rt(), Vx(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", Xt(), rt();
          var d = ct.current;
          ct.current = ol;
          try {
            return jx(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", Xt(), rt();
          var p = ct.current;
          ct.current = ol;
          try {
            return VA(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", Xt(), rt(), Mx();
        },
        useState: function(r) {
          $e = "useState", Xt(), rt();
          var i = ct.current;
          ct.current = ol;
          try {
            return HA(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", Xt(), rt(), zx();
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", Xt(), rt(), SM(r);
        },
        useTransition: function() {
          return $e = "useTransition", Xt(), rt(), wM();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", Xt(), rt(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", Xt(), rt(), Dx(r, i);
        },
        useId: function() {
          return $e = "useId", Xt(), rt(), Gx();
        },
        unstable_isNewReconciler: Q
      }, Ux = {
        readContext: function(r) {
          return qA(), so(r);
        },
        useCallback: function(r, i) {
          return $e = "useCallback", Xt(), rt(), Hx(r, i);
        },
        useContext: function(r) {
          return $e = "useContext", Xt(), rt(), so(r);
        },
        useEffect: function(r, i) {
          return $e = "useEffect", Xt(), rt(), Cb(r, i);
        },
        useImperativeHandle: function(r, i, d) {
          return $e = "useImperativeHandle", Xt(), rt(), $x(r, i, d);
        },
        useInsertionEffect: function(r, i) {
          return $e = "useInsertionEffect", Xt(), rt(), Bx(r, i);
        },
        useLayoutEffect: function(r, i) {
          return $e = "useLayoutEffect", Xt(), rt(), Vx(r, i);
        },
        useMemo: function(r, i) {
          $e = "useMemo", Xt(), rt();
          var d = ct.current;
          ct.current = ol;
          try {
            return jx(r, i);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(r, i, d) {
          $e = "useReducer", Xt(), rt();
          var p = ct.current;
          ct.current = ol;
          try {
            return $A(r, i, d);
          } finally {
            ct.current = p;
          }
        },
        useRef: function(r) {
          return $e = "useRef", Xt(), rt(), Mx();
        },
        useState: function(r) {
          $e = "useState", Xt(), rt();
          var i = ct.current;
          ct.current = ol;
          try {
            return jA(r);
          } finally {
            ct.current = i;
          }
        },
        useDebugValue: function(r, i) {
          return $e = "useDebugValue", Xt(), rt(), zx();
        },
        useDeferredValue: function(r) {
          return $e = "useDeferredValue", Xt(), rt(), xM(r);
        },
        useTransition: function() {
          return $e = "useTransition", Xt(), rt(), EM();
        },
        useMutableSource: function(r, i, d) {
          return $e = "useMutableSource", Xt(), rt(), void 0;
        },
        useSyncExternalStore: function(r, i, d) {
          return $e = "useSyncExternalStore", Xt(), rt(), Dx(r, i);
        },
        useId: function() {
          return $e = "useId", Xt(), rt(), Gx();
        },
        unstable_isNewReconciler: Q
      };
    }
    var jd = t.unstable_now, NM = 0, Xx = -1, wb = -1, Zx = -1, ek = !1, Yx = !1;
    function MM() {
      return ek;
    }
    function c7() {
      Yx = !0;
    }
    function d7() {
      ek = !1, Yx = !1;
    }
    function f7() {
      ek = Yx, Yx = !1;
    }
    function LM() {
      return NM;
    }
    function FM() {
      NM = jd();
    }
    function tk(r) {
      wb = jd(), r.actualStartTime < 0 && (r.actualStartTime = jd());
    }
    function BM(r) {
      wb = -1;
    }
    function Jx(r, i) {
      if (wb >= 0) {
        var d = jd() - wb;
        r.actualDuration += d, i && (r.selfBaseDuration = d), wb = -1;
      }
    }
    function tu(r) {
      if (Xx >= 0) {
        var i = jd() - Xx;
        Xx = -1;
        for (var d = r.return; d !== null; ) {
          switch (d.tag) {
            case b:
              var p = d.stateNode;
              p.effectDuration += i;
              return;
            case L:
              var y = d.stateNode;
              y.effectDuration += i;
              return;
          }
          d = d.return;
        }
      }
    }
    function nk(r) {
      if (Zx >= 0) {
        var i = jd() - Zx;
        Zx = -1;
        for (var d = r.return; d !== null; ) {
          switch (d.tag) {
            case b:
              var p = d.stateNode;
              p !== null && (p.passiveEffectDuration += i);
              return;
            case L:
              var y = d.stateNode;
              y !== null && (y.passiveEffectDuration += i);
              return;
          }
          d = d.return;
        }
      }
    }
    function nu() {
      Xx = jd();
    }
    function rk() {
      Zx = jd();
    }
    function ok(r) {
      for (var i = r.child; i; )
        r.actualDuration += i.actualDuration, i = i.sibling;
    }
    function _p(r, i) {
      return {
        value: r,
        source: i,
        stack: Kc(i),
        digest: null
      };
    }
    function ik(r, i, d) {
      return {
        value: r,
        source: null,
        stack: d ?? null,
        digest: i ?? null
      };
    }
    function p7(r, i) {
      return !0;
    }
    function ak(r, i) {
      try {
        var d = p7(r, i);
        if (d === !1)
          return;
        var p = i.value, y = i.source, C = i.stack, k = C !== null ? C : "";
        if (p != null && p._suppressLogging) {
          if (r.tag === v)
            return;
          console.error(p);
        }
        var O = y ? Ut(y) : null, N = O ? "The above error occurred in the <" + O + "> component:" : "The above error occurred in one of your React components:", z;
        if (r.tag === b)
          z = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var j = Ut(r) || "Anonymous";
          z = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + j + ".");
        }
        var ue = N + `
` + k + `

` + ("" + z);
        console.error(ue);
      } catch (ae) {
        setTimeout(function() {
          throw ae;
        });
      }
    }
    var h7 = typeof WeakMap == "function" ? WeakMap : Map;
    function VM(r, i, d) {
      var p = dc(tr, d);
      p.tag = aA, p.payload = {
        element: null
      };
      var y = i.value;
      return p.callback = function() {
        aY(y), ak(r, i);
      }, p;
    }
    function sk(r, i, d) {
      var p = dc(tr, d);
      p.tag = aA;
      var y = r.type.getDerivedStateFromError;
      if (typeof y == "function") {
        var C = i.value;
        p.payload = function() {
          return y(C);
        }, p.callback = function() {
          JL(r), ak(r, i);
        };
      }
      var k = r.stateNode;
      return k !== null && typeof k.componentDidCatch == "function" && (p.callback = function() {
        JL(r), ak(r, i), typeof y != "function" && oY(this);
        var N = i.value, z = i.stack;
        this.componentDidCatch(N, {
          componentStack: z !== null ? z : ""
        }), typeof y != "function" && (mi(r.lanes, Lt) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ut(r) || "Unknown"));
      }), p;
    }
    function $M(r, i, d) {
      var p = r.pingCache, y;
      if (p === null ? (p = r.pingCache = new h7(), y = /* @__PURE__ */ new Set(), p.set(i, y)) : (y = p.get(i), y === void 0 && (y = /* @__PURE__ */ new Set(), p.set(i, y))), !y.has(d)) {
        y.add(d);
        var C = sY.bind(null, r, i, d);
        yo && Vb(r, d), i.then(C, C);
      }
    }
    function m7(r, i, d, p) {
      var y = r.updateQueue;
      if (y === null) {
        var C = /* @__PURE__ */ new Set();
        C.add(d), r.updateQueue = C;
      } else
        y.add(d);
    }
    function v7(r, i) {
      var d = r.tag;
      if ((r.mode & pn) === _t && (d === h || d === D || d === $)) {
        var p = r.alternate;
        p ? (r.updateQueue = p.updateQueue, r.memoizedState = p.memoizedState, r.lanes = p.lanes) : (r.updateQueue = null, r.memoizedState = null);
      }
    }
    function zM(r) {
      var i = r;
      do {
        if (i.tag === F && e7(i))
          return i;
        i = i.return;
      } while (i !== null);
      return null;
    }
    function HM(r, i, d, p, y) {
      if ((r.mode & pn) === _t) {
        if (r === i)
          r.flags |= no;
        else {
          if (r.flags |= jt, d.flags |= ep, d.flags &= ~(Xh | Ai), d.tag === v) {
            var C = d.alternate;
            if (C === null)
              d.tag = W;
            else {
              var k = dc(tr, Lt);
              k.tag = Sx, Vd(d, k, Lt);
            }
          }
          d.lanes = en(d.lanes, Lt);
        }
        return r;
      }
      return r.flags |= no, r.lanes = y, r;
    }
    function g7(r, i, d, p, y) {
      if (d.flags |= Ai, yo && Vb(r, y), p !== null && typeof p == "object" && typeof p.then == "function") {
        var C = p;
        v7(d), Go() && d.mode & pn && _N();
        var k = zM(i);
        if (k !== null) {
          k.flags &= ~Tr, HM(k, i, d, r, y), k.mode & pn && $M(r, C, y), m7(k, r, C);
          return;
        } else {
          if (!gd(y)) {
            $M(r, C, y), $k();
            return;
          }
          var O = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          p = O;
        }
      } else if (Go() && d.mode & pn) {
        _N();
        var N = zM(i);
        if (N !== null) {
          (N.flags & no) === At && (N.flags |= Tr), HM(N, i, d, r, y), qI(_p(p, d));
          return;
        }
      }
      p = _p(p, d), JZ(p);
      var z = i;
      do {
        switch (z.tag) {
          case b: {
            var j = p;
            z.flags |= no;
            var ue = Xr(y);
            z.lanes = en(z.lanes, ue);
            var ae = VM(z, j, ue);
            uA(z, ae);
            return;
          }
          case v:
            var Ae = p, ke = z.type, Ne = z.stateNode;
            if ((z.flags & jt) === At && (typeof ke.getDerivedStateFromError == "function" || Ne !== null && typeof Ne.componentDidCatch == "function" && !zL(Ne))) {
              z.flags |= no;
              var pt = Xr(y);
              z.lanes = en(z.lanes, pt);
              var Rt = sk(z, Ae, pt);
              uA(z, Rt);
              return;
            }
            break;
        }
        z = z.return;
      } while (z !== null);
    }
    function y7() {
      return null;
    }
    var Eb = n.ReactCurrentOwner, il = !1, lk, Tb, uk, ck, dk, Dp, fk, Qx;
    lk = {}, Tb = {}, uk = {}, ck = {}, dk = {}, Dp = !1, fk = {}, Qx = {};
    function Di(r, i, d, p) {
      r === null ? i.child = aM(i, null, d, p) : i.child = tv(i, r.child, d, p);
    }
    function b7(r, i, d, p) {
      i.child = tv(i, r.child, null, p), i.child = tv(i, null, d, p);
    }
    function jM(r, i, d, p, y) {
      if (i.type !== i.elementType) {
        var C = d.propTypes;
        C && qs(
          C,
          p,
          // Resolved props
          "prop",
          $n(d)
        );
      }
      var k = d.render, O = i.ref, N, z;
      ev(i, y), $l(i);
      {
        if (Eb.current = i, ii(!0), N = sv(r, i, k, p, O, y), z = lv(), i.mode & br) {
          Ur(!0);
          try {
            N = sv(r, i, k, p, O, y), z = lv();
          } finally {
            Ur(!1);
          }
        }
        ii(!1);
      }
      return $u(), r !== null && !il ? (dM(r, i, y), fc(r, i, y)) : (Go() && z && XI(i), i.flags |= Dl, Di(r, i, N, y), i.child);
    }
    function GM(r, i, d, p, y) {
      if (r === null) {
        var C = d.type;
        if (EY(C) && d.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        d.defaultProps === void 0) {
          var k = C;
          return k = vv(C), i.tag = $, i.type = k, mk(i, C), WM(r, i, k, p, y);
        }
        {
          var O = C.propTypes;
          O && qs(
            O,
            p,
            // Resolved props
            "prop",
            $n(C)
          );
        }
        var N = Qk(d.type, null, p, i, i.mode, y);
        return N.ref = i.ref, N.return = i, i.child = N, N;
      }
      {
        var z = d.type, j = z.propTypes;
        j && qs(
          j,
          p,
          // Resolved props
          "prop",
          $n(z)
        );
      }
      var ue = r.child, ae = xk(r, y);
      if (!ae) {
        var Ae = ue.memoizedProps, ke = d.compare;
        if (ke = ke !== null ? ke : It, ke(Ae, p) && r.ref === i.ref)
          return fc(r, i, y);
      }
      i.flags |= Dl;
      var Ne = Bp(ue, p);
      return Ne.ref = i.ref, Ne.return = i, i.child = Ne, Ne;
    }
    function WM(r, i, d, p, y) {
      if (i.type !== i.elementType) {
        var C = i.elementType;
        if (C.$$typeof === mo) {
          var k = C, O = k._payload, N = k._init;
          try {
            C = N(O);
          } catch {
            C = null;
          }
          var z = C && C.propTypes;
          z && qs(
            z,
            p,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            $n(C)
          );
        }
      }
      if (r !== null) {
        var j = r.memoizedProps;
        if (It(j, p) && r.ref === i.ref && // Prevent bailout if the implementation changed due to hot reload.
        i.type === r.type)
          if (il = !1, i.pendingProps = p = j, xk(r, y))
            (r.flags & ep) !== At && (il = !0);
          else
            return i.lanes = r.lanes, fc(r, i, y);
      }
      return pk(r, i, d, p, y);
    }
    function UM(r, i, d) {
      var p = i.pendingProps, y = p.children, C = r !== null ? r.memoizedState : null;
      if (p.mode === "hidden" || Y)
        if ((i.mode & pn) === _t) {
          var k = {
            baseLanes: Be,
            cachePool: null,
            transitions: null
          };
          i.memoizedState = k, cC(i, d);
        } else if (mi(d, hi)) {
          var ue = {
            baseLanes: Be,
            cachePool: null,
            transitions: null
          };
          i.memoizedState = ue;
          var ae = C !== null ? C.baseLanes : d;
          cC(i, ae);
        } else {
          var O = null, N;
          if (C !== null) {
            var z = C.baseLanes;
            N = en(z, d);
          } else
            N = d;
          i.lanes = i.childLanes = hi;
          var j = {
            baseLanes: N,
            cachePool: O,
            transitions: null
          };
          return i.memoizedState = j, i.updateQueue = null, cC(i, N), null;
        }
      else {
        var Ae;
        C !== null ? (Ae = en(C.baseLanes, d), i.memoizedState = null) : Ae = d, cC(i, Ae);
      }
      return Di(r, i, y, d), i.child;
    }
    function S7(r, i, d) {
      var p = i.pendingProps;
      return Di(r, i, p, d), i.child;
    }
    function x7(r, i, d) {
      var p = i.pendingProps.children;
      return Di(r, i, p, d), i.child;
    }
    function C7(r, i, d) {
      {
        i.flags |= qt;
        {
          var p = i.stateNode;
          p.effectDuration = 0, p.passiveEffectDuration = 0;
        }
      }
      var y = i.pendingProps, C = y.children;
      return Di(r, i, C, d), i.child;
    }
    function XM(r, i) {
      var d = i.ref;
      (r === null && d !== null || r !== null && r.ref !== d) && (i.flags |= li, i.flags |= sy);
    }
    function pk(r, i, d, p, y) {
      if (i.type !== i.elementType) {
        var C = d.propTypes;
        C && qs(
          C,
          p,
          // Resolved props
          "prop",
          $n(d)
        );
      }
      var k;
      {
        var O = Zm(i, d, !0);
        k = Ym(i, O);
      }
      var N, z;
      ev(i, y), $l(i);
      {
        if (Eb.current = i, ii(!0), N = sv(r, i, d, p, k, y), z = lv(), i.mode & br) {
          Ur(!0);
          try {
            N = sv(r, i, d, p, k, y), z = lv();
          } finally {
            Ur(!1);
          }
        }
        ii(!1);
      }
      return $u(), r !== null && !il ? (dM(r, i, y), fc(r, i, y)) : (Go() && z && XI(i), i.flags |= Dl, Di(r, i, N, y), i.child);
    }
    function ZM(r, i, d, p, y) {
      {
        switch (VY(i)) {
          case !1: {
            var C = i.stateNode, k = i.type, O = new k(i.memoizedProps, C.context), N = O.state;
            C.updater.enqueueSetState(C, N, null);
            break;
          }
          case !0: {
            i.flags |= jt, i.flags |= no;
            var z = new Error("Simulated error coming from DevTools"), j = Xr(y);
            i.lanes = en(i.lanes, j);
            var ue = sk(i, _p(z, i), j);
            uA(i, ue);
            break;
          }
        }
        if (i.type !== i.elementType) {
          var ae = d.propTypes;
          ae && qs(
            ae,
            p,
            // Resolved props
            "prop",
            $n(d)
          );
        }
      }
      var Ae;
      Ql(d) ? (Ae = !0, ux(i)) : Ae = !1, ev(i, y);
      var ke = i.stateNode, Ne;
      ke === null ? (qx(r, i), tM(i, d, p), xA(i, d, p, y), Ne = !0) : r === null ? Ne = ZX(i, d, p, y) : Ne = YX(r, i, d, p, y);
      var pt = hk(r, i, d, Ne, Ae, y);
      {
        var Rt = i.stateNode;
        Ne && Rt.props !== p && (Dp || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ut(i) || "a component"), Dp = !0);
      }
      return pt;
    }
    function hk(r, i, d, p, y, C) {
      XM(r, i);
      var k = (i.flags & jt) !== At;
      if (!p && !k)
        return y && kN(i, d, !1), fc(r, i, C);
      var O = i.stateNode;
      Eb.current = i;
      var N;
      if (k && typeof d.getDerivedStateFromError != "function")
        N = null, BM();
      else {
        $l(i);
        {
          if (ii(!0), N = O.render(), i.mode & br) {
            Ur(!0);
            try {
              O.render();
            } finally {
              Ur(!1);
            }
          }
          ii(!1);
        }
        $u();
      }
      return i.flags |= Dl, r !== null && k ? b7(r, i, N, C) : Di(r, i, N, C), i.memoizedState = O.state, y && kN(i, d, !0), i.child;
    }
    function YM(r) {
      var i = r.stateNode;
      i.pendingContext ? IN(r, i.pendingContext, i.pendingContext !== i.context) : i.context && IN(r, i.context, !1), AA(r, i.containerInfo);
    }
    function w7(r, i, d) {
      if (YM(i), r === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var p = i.pendingProps, y = i.memoizedState, C = y.element;
      XN(r, i), Ex(i, p, null, d);
      var k = i.memoizedState;
      i.stateNode;
      var O = k.element;
      if (y.isDehydrated) {
        var N = {
          element: O,
          isDehydrated: !1,
          cache: k.cache,
          pendingSuspenseBoundaries: k.pendingSuspenseBoundaries,
          transitions: k.transitions
        }, z = i.updateQueue;
        if (z.baseState = N, i.memoizedState = N, i.flags & Tr) {
          var j = _p(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), i);
          return JM(r, i, O, d, j);
        } else if (O !== C) {
          var ue = _p(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), i);
          return JM(r, i, O, d, ue);
        } else {
          AX(i);
          var ae = aM(i, null, O, d);
          i.child = ae;
          for (var Ae = ae; Ae; )
            Ae.flags = Ae.flags & ~ir | Qi, Ae = Ae.sibling;
        }
      } else {
        if (Km(), O === C)
          return fc(r, i, d);
        Di(r, i, O, d);
      }
      return i.child;
    }
    function JM(r, i, d, p, y) {
      return Km(), qI(y), i.flags |= Tr, Di(r, i, d, p), i.child;
    }
    function E7(r, i, d) {
      lM(i), r === null && KI(i);
      var p = i.type, y = i.pendingProps, C = r !== null ? r.memoizedProps : null, k = y.children, O = DI(p, y);
      return O ? k = null : C !== null && DI(p, C) && (i.flags |= Fn), XM(r, i), Di(r, i, k, d), i.child;
    }
    function T7(r, i) {
      return r === null && KI(i), null;
    }
    function I7(r, i, d, p) {
      qx(r, i);
      var y = i.pendingProps, C = d, k = C._payload, O = C._init, N = O(k);
      i.type = N;
      var z = i.tag = TY(N), j = nl(N, y), ue;
      switch (z) {
        case h:
          return mk(i, N), i.type = N = vv(N), ue = pk(null, i, N, j, p), ue;
        case v:
          return i.type = N = Wk(N), ue = ZM(null, i, N, j, p), ue;
        case D:
          return i.type = N = Uk(N), ue = jM(null, i, N, j, p), ue;
        case V: {
          if (i.type !== i.elementType) {
            var ae = N.propTypes;
            ae && qs(
              ae,
              j,
              // Resolved for outer only
              "prop",
              $n(N)
            );
          }
          return ue = GM(
            null,
            i,
            N,
            nl(N.type, j),
            // The inner type can have defaults too
            p
          ), ue;
        }
      }
      var Ae = "";
      throw N !== null && typeof N == "object" && N.$$typeof === mo && (Ae = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + N + ". " + ("Lazy element type must resolve to a class or function." + Ae));
    }
    function A7(r, i, d, p, y) {
      qx(r, i), i.tag = v;
      var C;
      return Ql(d) ? (C = !0, ux(i)) : C = !1, ev(i, y), tM(i, d, p), xA(i, d, p, y), hk(null, i, d, !0, C, y);
    }
    function k7(r, i, d, p) {
      qx(r, i);
      var y = i.pendingProps, C;
      {
        var k = Zm(i, d, !1);
        C = Ym(i, k);
      }
      ev(i, p);
      var O, N;
      $l(i);
      {
        if (d.prototype && typeof d.prototype.render == "function") {
          var z = $n(d) || "Unknown";
          lk[z] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", z, z), lk[z] = !0);
        }
        i.mode & br && tl.recordLegacyContextWarning(i, null), ii(!0), Eb.current = i, O = sv(null, i, d, y, C, p), N = lv(), ii(!1);
      }
      if ($u(), i.flags |= Dl, typeof O == "object" && O !== null && typeof O.render == "function" && O.$$typeof === void 0) {
        var j = $n(d) || "Unknown";
        Tb[j] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", j, j, j), Tb[j] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof O == "object" && O !== null && typeof O.render == "function" && O.$$typeof === void 0
      ) {
        {
          var ue = $n(d) || "Unknown";
          Tb[ue] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ue, ue, ue), Tb[ue] = !0);
        }
        i.tag = v, i.memoizedState = null, i.updateQueue = null;
        var ae = !1;
        return Ql(d) ? (ae = !0, ux(i)) : ae = !1, i.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null, lA(i), eM(i, O), xA(i, d, y, p), hk(null, i, d, !0, ae, p);
      } else {
        if (i.tag = h, i.mode & br) {
          Ur(!0);
          try {
            O = sv(null, i, d, y, C, p), N = lv();
          } finally {
            Ur(!1);
          }
        }
        return Go() && N && XI(i), Di(null, i, O, p), mk(i, d), i.child;
      }
    }
    function mk(r, i) {
      {
        if (i && i.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", i.displayName || i.name || "Component"), r.ref !== null) {
          var d = "", p = _o();
          p && (d += `

Check the render method of \`` + p + "`.");
          var y = p || "", C = r._debugSource;
          C && (y = C.fileName + ":" + C.lineNumber), dk[y] || (dk[y] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", d));
        }
        if (typeof i.getDerivedStateFromProps == "function") {
          var k = $n(i) || "Unknown";
          ck[k] || (u("%s: Function components do not support getDerivedStateFromProps.", k), ck[k] = !0);
        }
        if (typeof i.contextType == "object" && i.contextType !== null) {
          var O = $n(i) || "Unknown";
          uk[O] || (u("%s: Function components do not support contextType.", O), uk[O] = !0);
        }
      }
    }
    var vk = {
      dehydrated: null,
      treeContext: null,
      retryLane: bn
    };
    function gk(r) {
      return {
        baseLanes: r,
        cachePool: y7(),
        transitions: null
      };
    }
    function R7(r, i) {
      var d = null;
      return {
        baseLanes: en(r.baseLanes, i),
        cachePool: d,
        transitions: r.transitions
      };
    }
    function P7(r, i, d, p) {
      if (i !== null) {
        var y = i.memoizedState;
        if (y === null)
          return !1;
      }
      return PA(r, vb);
    }
    function O7(r, i) {
      return yd(r.childLanes, i);
    }
    function QM(r, i, d) {
      var p = i.pendingProps;
      $Y(i) && (i.flags |= jt);
      var y = rl.current, C = !1, k = (i.flags & jt) !== At;
      if (k || P7(y, r) ? (C = !0, i.flags &= ~jt) : (r === null || r.memoizedState !== null) && (y = qX(y, cM)), y = rv(y), zd(i, y), r === null) {
        KI(i);
        var O = i.memoizedState;
        if (O !== null) {
          var N = O.dehydrated;
          if (N !== null)
            return L7(i, N);
        }
        var z = p.children, j = p.fallback;
        if (C) {
          var ue = _7(i, z, j, d), ae = i.child;
          return ae.memoizedState = gk(d), i.memoizedState = vk, ue;
        } else
          return yk(i, z);
      } else {
        var Ae = r.memoizedState;
        if (Ae !== null) {
          var ke = Ae.dehydrated;
          if (ke !== null)
            return F7(r, i, k, p, ke, Ae, d);
        }
        if (C) {
          var Ne = p.fallback, pt = p.children, Rt = N7(r, i, pt, Ne, d), Et = i.child, xn = r.child.memoizedState;
          return Et.memoizedState = xn === null ? gk(d) : R7(xn, d), Et.childLanes = O7(r, d), i.memoizedState = vk, Rt;
        } else {
          var yn = p.children, be = D7(r, i, yn, d);
          return i.memoizedState = null, be;
        }
      }
    }
    function yk(r, i, d) {
      var p = r.mode, y = {
        mode: "visible",
        children: i
      }, C = bk(y, p);
      return C.return = r, r.child = C, C;
    }
    function _7(r, i, d, p) {
      var y = r.mode, C = r.child, k = {
        mode: "hidden",
        children: i
      }, O, N;
      return (y & pn) === _t && C !== null ? (O = C, O.childLanes = Be, O.pendingProps = k, r.mode & Mt && (O.actualDuration = 0, O.actualStartTime = -1, O.selfBaseDuration = 0, O.treeBaseDuration = 0), N = Yd(d, y, p, null)) : (O = bk(k, y), N = Yd(d, y, p, null)), O.return = r, N.return = r, O.sibling = N, r.child = O, N;
    }
    function bk(r, i, d) {
      return KL(r, i, Be, null);
    }
    function KM(r, i) {
      return Bp(r, i);
    }
    function D7(r, i, d, p) {
      var y = r.child, C = y.sibling, k = KM(y, {
        mode: "visible",
        children: d
      });
      if ((i.mode & pn) === _t && (k.lanes = p), k.return = i, k.sibling = null, C !== null) {
        var O = i.deletions;
        O === null ? (i.deletions = [C], i.flags |= Nn) : O.push(C);
      }
      return i.child = k, k;
    }
    function N7(r, i, d, p, y) {
      var C = i.mode, k = r.child, O = k.sibling, N = {
        mode: "hidden",
        children: d
      }, z;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (C & pn) === _t && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        i.child !== k
      ) {
        var j = i.child;
        z = j, z.childLanes = Be, z.pendingProps = N, i.mode & Mt && (z.actualDuration = 0, z.actualStartTime = -1, z.selfBaseDuration = k.selfBaseDuration, z.treeBaseDuration = k.treeBaseDuration), i.deletions = null;
      } else
        z = KM(k, N), z.subtreeFlags = k.subtreeFlags & go;
      var ue;
      return O !== null ? ue = Bp(O, p) : (ue = Yd(p, C, y, null), ue.flags |= ir), ue.return = i, z.return = i, z.sibling = ue, i.child = z, ue;
    }
    function Kx(r, i, d, p) {
      p !== null && qI(p), tv(i, r.child, null, d);
      var y = i.pendingProps, C = y.children, k = yk(i, C);
      return k.flags |= ir, i.memoizedState = null, k;
    }
    function M7(r, i, d, p, y) {
      var C = i.mode, k = {
        mode: "visible",
        children: d
      }, O = bk(k, C), N = Yd(p, C, y, null);
      return N.flags |= ir, O.return = i, N.return = i, O.sibling = N, i.child = O, (i.mode & pn) !== _t && tv(i, r.child, null, y), N;
    }
    function L7(r, i, d) {
      return (r.mode & pn) === _t ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), r.lanes = Lt) : FI(i) ? r.lanes = ju : r.lanes = hi, null;
    }
    function F7(r, i, d, p, y, C, k) {
      if (d)
        if (i.flags & Tr) {
          i.flags &= ~Tr;
          var be = ik(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Kx(r, i, k, be);
        } else {
          if (i.memoizedState !== null)
            return i.child = r.child, i.flags |= jt, null;
          var Me = p.children, Se = p.fallback, Ye = M7(r, i, Me, Se, k), ht = i.child;
          return ht.memoizedState = gk(k), i.memoizedState = vk, Ye;
        }
      else {
        if (TX(), (i.mode & pn) === _t)
          return Kx(
            r,
            i,
            k,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (FI(y)) {
          var O, N, z;
          {
            var j = H8(y);
            O = j.digest, N = j.message, z = j.stack;
          }
          var ue;
          N ? ue = new Error(N) : ue = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var ae = ik(ue, O, z);
          return Kx(r, i, k, ae);
        }
        var Ae = mi(k, r.childLanes);
        if (il || Ae) {
          var ke = uC();
          if (ke !== null) {
            var Ne = oI(ke, k);
            if (Ne !== bn && Ne !== C.retryLane) {
              C.retryLane = Ne;
              var pt = tr;
              sa(r, Ne), Ao(ke, r, Ne, pt);
            }
          }
          $k();
          var Rt = ik(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Kx(r, i, k, Rt);
        } else if (SN(y)) {
          i.flags |= jt, i.child = r.child;
          var Et = lY.bind(null, r);
          return j8(y, Et), null;
        } else {
          kX(i, y, C.treeContext);
          var xn = p.children, yn = yk(i, xn);
          return yn.flags |= Qi, yn;
        }
      }
    }
    function qM(r, i, d) {
      r.lanes = en(r.lanes, i);
      var p = r.alternate;
      p !== null && (p.lanes = en(p.lanes, i)), oA(r.return, i, d);
    }
    function B7(r, i, d) {
      for (var p = i; p !== null; ) {
        if (p.tag === F) {
          var y = p.memoizedState;
          y !== null && qM(p, d, r);
        } else if (p.tag === G)
          qM(p, d, r);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === r)
          return;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === r)
            return;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    function V7(r) {
      for (var i = r, d = null; i !== null; ) {
        var p = i.alternate;
        p !== null && Ox(p) === null && (d = i), i = i.sibling;
      }
      return d;
    }
    function $7(r) {
      if (r !== void 0 && r !== "forwards" && r !== "backwards" && r !== "together" && !fk[r])
        if (fk[r] = !0, typeof r == "string")
          switch (r.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', r, r.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', r, r.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', r);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', r);
    }
    function z7(r, i) {
      r !== void 0 && !Qx[r] && (r !== "collapsed" && r !== "hidden" ? (Qx[r] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', r)) : i !== "forwards" && i !== "backwards" && (Qx[r] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', r)));
    }
    function eL(r, i) {
      {
        var d = eo(r), p = !d && typeof ka(r) == "function";
        if (d || p) {
          var y = d ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", y, i, y), !1;
        }
      }
      return !0;
    }
    function H7(r, i) {
      if ((i === "forwards" || i === "backwards") && r !== void 0 && r !== null && r !== !1)
        if (eo(r)) {
          for (var d = 0; d < r.length; d++)
            if (!eL(r[d], d))
              return;
        } else {
          var p = ka(r);
          if (typeof p == "function") {
            var y = p.call(r);
            if (y)
              for (var C = y.next(), k = 0; !C.done; C = y.next()) {
                if (!eL(C.value, k))
                  return;
                k++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', i);
        }
    }
    function Sk(r, i, d, p, y) {
      var C = r.memoizedState;
      C === null ? r.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: p,
        tail: d,
        tailMode: y
      } : (C.isBackwards = i, C.rendering = null, C.renderingStartTime = 0, C.last = p, C.tail = d, C.tailMode = y);
    }
    function tL(r, i, d) {
      var p = i.pendingProps, y = p.revealOrder, C = p.tail, k = p.children;
      $7(y), z7(C, y), H7(k, y), Di(r, i, k, d);
      var O = rl.current, N = PA(O, vb);
      if (N)
        O = OA(O, vb), i.flags |= jt;
      else {
        var z = r !== null && (r.flags & jt) !== At;
        z && B7(i, i.child, d), O = rv(O);
      }
      if (zd(i, O), (i.mode & pn) === _t)
        i.memoizedState = null;
      else
        switch (y) {
          case "forwards": {
            var j = V7(i.child), ue;
            j === null ? (ue = i.child, i.child = null) : (ue = j.sibling, j.sibling = null), Sk(
              i,
              !1,
              // isBackwards
              ue,
              j,
              C
            );
            break;
          }
          case "backwards": {
            var ae = null, Ae = i.child;
            for (i.child = null; Ae !== null; ) {
              var ke = Ae.alternate;
              if (ke !== null && Ox(ke) === null) {
                i.child = Ae;
                break;
              }
              var Ne = Ae.sibling;
              Ae.sibling = ae, ae = Ae, Ae = Ne;
            }
            Sk(
              i,
              !0,
              // isBackwards
              ae,
              null,
              // last
              C
            );
            break;
          }
          case "together": {
            Sk(
              i,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            i.memoizedState = null;
        }
      return i.child;
    }
    function j7(r, i, d) {
      AA(i, i.stateNode.containerInfo);
      var p = i.pendingProps;
      return r === null ? i.child = tv(i, null, p, d) : Di(r, i, p, d), i.child;
    }
    var nL = !1;
    function G7(r, i, d) {
      var p = i.type, y = p._context, C = i.pendingProps, k = i.memoizedProps, O = C.value;
      {
        "value" in C || nL || (nL = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var N = i.type.propTypes;
        N && qs(N, C, "prop", "Context.Provider");
      }
      if (jN(i, y, O), k !== null) {
        var z = k.value;
        if (St(z, O)) {
          if (k.children === C.children && !sx())
            return fc(r, i, d);
        } else
          BX(i, y, d);
      }
      var j = C.children;
      return Di(r, i, j, d), i.child;
    }
    var rL = !1;
    function W7(r, i, d) {
      var p = i.type;
      p._context === void 0 ? p !== p.Consumer && (rL || (rL = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : p = p._context;
      var y = i.pendingProps, C = y.children;
      typeof C != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), ev(i, d);
      var k = so(p);
      $l(i);
      var O;
      return Eb.current = i, ii(!0), O = C(k), ii(!1), $u(), i.flags |= Dl, Di(r, i, O, d), i.child;
    }
    function Ib() {
      il = !0;
    }
    function qx(r, i) {
      (i.mode & pn) === _t && r !== null && (r.alternate = null, i.alternate = null, i.flags |= ir);
    }
    function fc(r, i, d) {
      return r !== null && (i.dependencies = r.dependencies), BM(), Bb(i.lanes), mi(d, i.childLanes) ? (JX(r, i), i.child) : null;
    }
    function U7(r, i, d) {
      {
        var p = i.return;
        if (p === null)
          throw new Error("Cannot swap the root fiber.");
        if (r.alternate = null, i.alternate = null, d.index = i.index, d.sibling = i.sibling, d.return = i.return, d.ref = i.ref, i === p.child)
          p.child = d;
        else {
          var y = p.child;
          if (y === null)
            throw new Error("Expected parent to have a child.");
          for (; y.sibling !== i; )
            if (y = y.sibling, y === null)
              throw new Error("Expected to find the previous sibling.");
          y.sibling = d;
        }
        var C = p.deletions;
        return C === null ? (p.deletions = [r], p.flags |= Nn) : C.push(r), d.flags |= ir, d;
      }
    }
    function xk(r, i) {
      var d = r.lanes;
      return !!mi(d, i);
    }
    function X7(r, i, d) {
      switch (i.tag) {
        case b:
          YM(i), i.stateNode, Km();
          break;
        case w:
          lM(i);
          break;
        case v: {
          var p = i.type;
          Ql(p) && ux(i);
          break;
        }
        case S:
          AA(i, i.stateNode.containerInfo);
          break;
        case _: {
          var y = i.memoizedProps.value, C = i.type._context;
          jN(i, C, y);
          break;
        }
        case L:
          {
            var k = mi(d, i.childLanes);
            k && (i.flags |= qt);
            {
              var O = i.stateNode;
              O.effectDuration = 0, O.passiveEffectDuration = 0;
            }
          }
          break;
        case F: {
          var N = i.memoizedState;
          if (N !== null) {
            if (N.dehydrated !== null)
              return zd(i, rv(rl.current)), i.flags |= jt, null;
            var z = i.child, j = z.childLanes;
            if (mi(d, j))
              return QM(r, i, d);
            zd(i, rv(rl.current));
            var ue = fc(r, i, d);
            return ue !== null ? ue.sibling : null;
          } else
            zd(i, rv(rl.current));
          break;
        }
        case G: {
          var ae = (r.flags & jt) !== At, Ae = mi(d, i.childLanes);
          if (ae) {
            if (Ae)
              return tL(r, i, d);
            i.flags |= jt;
          }
          var ke = i.memoizedState;
          if (ke !== null && (ke.rendering = null, ke.tail = null, ke.lastEffect = null), zd(i, rl.current), Ae)
            break;
          return null;
        }
        case ce:
        case te:
          return i.lanes = Be, UM(r, i, d);
      }
      return fc(r, i, d);
    }
    function oL(r, i, d) {
      if (i._debugNeedsRemount && r !== null)
        return U7(r, i, Qk(i.type, i.key, i.pendingProps, i._debugOwner || null, i.mode, i.lanes));
      if (r !== null) {
        var p = r.memoizedProps, y = i.pendingProps;
        if (p !== y || sx() || // Force a re-render if the implementation changed due to hot reload:
        i.type !== r.type)
          il = !0;
        else {
          var C = xk(r, d);
          if (!C && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (i.flags & jt) === At)
            return il = !1, X7(r, i, d);
          (r.flags & ep) !== At ? il = !0 : il = !1;
        }
      } else if (il = !1, Go() && bX(i)) {
        var k = i.index, O = SX();
        ON(i, O, k);
      }
      switch (i.lanes = Be, i.tag) {
        case g:
          return k7(r, i, i.type, d);
        case U: {
          var N = i.elementType;
          return I7(r, i, N, d);
        }
        case h: {
          var z = i.type, j = i.pendingProps, ue = i.elementType === z ? j : nl(z, j);
          return pk(r, i, z, ue, d);
        }
        case v: {
          var ae = i.type, Ae = i.pendingProps, ke = i.elementType === ae ? Ae : nl(ae, Ae);
          return ZM(r, i, ae, ke, d);
        }
        case b:
          return w7(r, i, d);
        case w:
          return E7(r, i, d);
        case E:
          return T7(r, i);
        case F:
          return QM(r, i, d);
        case S:
          return j7(r, i, d);
        case D: {
          var Ne = i.type, pt = i.pendingProps, Rt = i.elementType === Ne ? pt : nl(Ne, pt);
          return jM(r, i, Ne, Rt, d);
        }
        case T:
          return S7(r, i, d);
        case A:
          return x7(r, i, d);
        case L:
          return C7(r, i, d);
        case _:
          return G7(r, i, d);
        case P:
          return W7(r, i, d);
        case V: {
          var Et = i.type, xn = i.pendingProps, yn = nl(Et, xn);
          if (i.type !== i.elementType) {
            var be = Et.propTypes;
            be && qs(
              be,
              yn,
              // Resolved for outer only
              "prop",
              $n(Et)
            );
          }
          return yn = nl(Et.type, yn), GM(r, i, Et, yn, d);
        }
        case $:
          return WM(r, i, i.type, i.pendingProps, d);
        case W: {
          var Me = i.type, Se = i.pendingProps, Ye = i.elementType === Me ? Se : nl(Me, Se);
          return A7(r, i, Me, Ye, d);
        }
        case G:
          return tL(r, i, d);
        case oe:
          break;
        case ce:
          return UM(r, i, d);
      }
      throw new Error("Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function uv(r) {
      r.flags |= qt;
    }
    function iL(r) {
      r.flags |= li, r.flags |= sy;
    }
    var aL, Ck, sL, lL;
    aL = function(r, i, d, p) {
      for (var y = i.child; y !== null; ) {
        if (y.tag === w || y.tag === E)
          v8(r, y.stateNode);
        else if (y.tag !== S) {
          if (y.child !== null) {
            y.child.return = y, y = y.child;
            continue;
          }
        }
        if (y === i)
          return;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === i)
            return;
          y = y.return;
        }
        y.sibling.return = y.return, y = y.sibling;
      }
    }, Ck = function(r, i) {
    }, sL = function(r, i, d, p, y) {
      var C = r.memoizedProps;
      if (C !== p) {
        var k = i.stateNode, O = kA(), N = y8(k, d, C, p, y, O);
        i.updateQueue = N, N && uv(i);
      }
    }, lL = function(r, i, d, p) {
      d !== p && uv(i);
    };
    function Ab(r, i) {
      if (!Go())
        switch (r.tailMode) {
          case "hidden": {
            for (var d = r.tail, p = null; d !== null; )
              d.alternate !== null && (p = d), d = d.sibling;
            p === null ? r.tail = null : p.sibling = null;
            break;
          }
          case "collapsed": {
            for (var y = r.tail, C = null; y !== null; )
              y.alternate !== null && (C = y), y = y.sibling;
            C === null ? !i && r.tail !== null ? r.tail.sibling = null : r.tail = null : C.sibling = null;
            break;
          }
        }
    }
    function Uo(r) {
      var i = r.alternate !== null && r.alternate.child === r.child, d = Be, p = At;
      if (i) {
        if ((r.mode & Mt) !== _t) {
          for (var N = r.selfBaseDuration, z = r.child; z !== null; )
            d = en(d, en(z.lanes, z.childLanes)), p |= z.subtreeFlags & go, p |= z.flags & go, N += z.treeBaseDuration, z = z.sibling;
          r.treeBaseDuration = N;
        } else
          for (var j = r.child; j !== null; )
            d = en(d, en(j.lanes, j.childLanes)), p |= j.subtreeFlags & go, p |= j.flags & go, j.return = r, j = j.sibling;
        r.subtreeFlags |= p;
      } else {
        if ((r.mode & Mt) !== _t) {
          for (var y = r.actualDuration, C = r.selfBaseDuration, k = r.child; k !== null; )
            d = en(d, en(k.lanes, k.childLanes)), p |= k.subtreeFlags, p |= k.flags, y += k.actualDuration, C += k.treeBaseDuration, k = k.sibling;
          r.actualDuration = y, r.treeBaseDuration = C;
        } else
          for (var O = r.child; O !== null; )
            d = en(d, en(O.lanes, O.childLanes)), p |= O.subtreeFlags, p |= O.flags, O.return = r, O = O.sibling;
        r.subtreeFlags |= p;
      }
      return r.childLanes = d, i;
    }
    function Z7(r, i, d) {
      if (DX() && (i.mode & pn) !== _t && (i.flags & jt) === At)
        return BN(i), Km(), i.flags |= Tr | Ai | no, !1;
      var p = hx(i);
      if (d !== null && d.dehydrated !== null)
        if (r === null) {
          if (!p)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (OX(i), Uo(i), (i.mode & Mt) !== _t) {
            var y = d !== null;
            if (y) {
              var C = i.child;
              C !== null && (i.treeBaseDuration -= C.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Km(), (i.flags & jt) === At && (i.memoizedState = null), i.flags |= qt, Uo(i), (i.mode & Mt) !== _t) {
            var k = d !== null;
            if (k) {
              var O = i.child;
              O !== null && (i.treeBaseDuration -= O.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return VN(), !0;
    }
    function uL(r, i, d) {
      var p = i.pendingProps;
      switch (ZI(i), i.tag) {
        case g:
        case U:
        case $:
        case h:
        case D:
        case T:
        case A:
        case L:
        case P:
        case V:
          return Uo(i), null;
        case v: {
          var y = i.type;
          return Ql(y) && lx(i), Uo(i), null;
        }
        case b: {
          var C = i.stateNode;
          if (nv(i), GI(i), DA(), C.pendingContext && (C.context = C.pendingContext, C.pendingContext = null), r === null || r.child === null) {
            var k = hx(i);
            if (k)
              uv(i);
            else if (r !== null) {
              var O = r.memoizedState;
              // Check if this is a client root
              (!O.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (i.flags & Tr) !== At) && (i.flags |= Ji, VN());
            }
          }
          return Ck(r, i), Uo(i), null;
        }
        case w: {
          RA(i);
          var N = sM(), z = i.type;
          if (r !== null && i.stateNode != null)
            sL(r, i, z, p, N), r.ref !== i.ref && iL(i);
          else {
            if (!p) {
              if (i.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Uo(i), null;
            }
            var j = kA(), ue = hx(i);
            if (ue)
              RX(i, N, j) && uv(i);
            else {
              var ae = m8(z, p, N, j, i);
              aL(ae, i, !1, !1), i.stateNode = ae, g8(ae, z, p, N) && uv(i);
            }
            i.ref !== null && iL(i);
          }
          return Uo(i), null;
        }
        case E: {
          var Ae = p;
          if (r && i.stateNode != null) {
            var ke = r.memoizedProps;
            lL(r, i, ke, Ae);
          } else {
            if (typeof Ae != "string" && i.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Ne = sM(), pt = kA(), Rt = hx(i);
            Rt ? PX(i) && uv(i) : i.stateNode = b8(Ae, Ne, pt, i);
          }
          return Uo(i), null;
        }
        case F: {
          ov(i);
          var Et = i.memoizedState;
          if (r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
            var xn = Z7(r, i, Et);
            if (!xn)
              return i.flags & no ? i : null;
          }
          if ((i.flags & jt) !== At)
            return i.lanes = d, (i.mode & Mt) !== _t && ok(i), i;
          var yn = Et !== null, be = r !== null && r.memoizedState !== null;
          if (yn !== be && yn) {
            var Me = i.child;
            if (Me.flags |= Nl, (i.mode & pn) !== _t) {
              var Se = r === null && (i.memoizedProps.unstable_avoidThisFallback !== !0 || !q);
              Se || PA(rl.current, cM) ? YZ() : $k();
            }
          }
          var Ye = i.updateQueue;
          if (Ye !== null && (i.flags |= qt), Uo(i), (i.mode & Mt) !== _t && yn) {
            var ht = i.child;
            ht !== null && (i.treeBaseDuration -= ht.treeBaseDuration);
          }
          return null;
        }
        case S:
          return nv(i), Ck(r, i), r === null && fX(i.stateNode.containerInfo), Uo(i), null;
        case _:
          var at = i.type._context;
          return rA(at, i), Uo(i), null;
        case W: {
          var zt = i.type;
          return Ql(zt) && lx(i), Uo(i), null;
        }
        case G: {
          ov(i);
          var Jt = i.memoizedState;
          if (Jt === null)
            return Uo(i), null;
          var Yn = (i.flags & jt) !== At, kn = Jt.rendering;
          if (kn === null)
            if (Yn)
              Ab(Jt, !1);
            else {
              var Qr = QZ() && (r === null || (r.flags & jt) === At);
              if (!Qr)
                for (var Rn = i.child; Rn !== null; ) {
                  var Br = Ox(Rn);
                  if (Br !== null) {
                    Yn = !0, i.flags |= jt, Ab(Jt, !1);
                    var Si = Br.updateQueue;
                    return Si !== null && (i.updateQueue = Si, i.flags |= qt), i.subtreeFlags = At, QX(i, d), zd(i, OA(rl.current, vb)), i.child;
                  }
                  Rn = Rn.sibling;
                }
              Jt.tail !== null && yr() > PL() && (i.flags |= jt, Yn = !0, Ab(Jt, !1), i.lanes = Sy);
            }
          else {
            if (!Yn) {
              var Qo = Ox(kn);
              if (Qo !== null) {
                i.flags |= jt, Yn = !0;
                var Va = Qo.updateQueue;
                if (Va !== null && (i.updateQueue = Va, i.flags |= qt), Ab(Jt, !0), Jt.tail === null && Jt.tailMode === "hidden" && !kn.alternate && !Go())
                  return Uo(i), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                yr() * 2 - Jt.renderingStartTime > PL() && d !== hi && (i.flags |= jt, Yn = !0, Ab(Jt, !1), i.lanes = Sy);
            }
            if (Jt.isBackwards)
              kn.sibling = i.child, i.child = kn;
            else {
              var Li = Jt.last;
              Li !== null ? Li.sibling = kn : i.child = kn, Jt.last = kn;
            }
          }
          if (Jt.tail !== null) {
            var Fi = Jt.tail;
            Jt.rendering = Fi, Jt.tail = Fi.sibling, Jt.renderingStartTime = yr(), Fi.sibling = null;
            var xi = rl.current;
            return Yn ? xi = OA(xi, vb) : xi = rv(xi), zd(i, xi), Fi;
          }
          return Uo(i), null;
        }
        case oe:
          break;
        case ce:
        case te: {
          Vk(i);
          var gc = i.memoizedState, gv = gc !== null;
          if (r !== null) {
            var jb = r.memoizedState, iu = jb !== null;
            iu !== gv && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !Y && (i.flags |= Nl);
          }
          return !gv || (i.mode & pn) === _t ? Uo(i) : mi(ou, hi) && (Uo(i), i.subtreeFlags & (ir | qt) && (i.flags |= Nl)), null;
        }
        case Ee:
          return null;
        case me:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Y7(r, i, d) {
      switch (ZI(i), i.tag) {
        case v: {
          var p = i.type;
          Ql(p) && lx(i);
          var y = i.flags;
          return y & no ? (i.flags = y & ~no | jt, (i.mode & Mt) !== _t && ok(i), i) : null;
        }
        case b: {
          i.stateNode, nv(i), GI(i), DA();
          var C = i.flags;
          return (C & no) !== At && (C & jt) === At ? (i.flags = C & ~no | jt, i) : null;
        }
        case w:
          return RA(i), null;
        case F: {
          ov(i);
          var k = i.memoizedState;
          if (k !== null && k.dehydrated !== null) {
            if (i.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Km();
          }
          var O = i.flags;
          return O & no ? (i.flags = O & ~no | jt, (i.mode & Mt) !== _t && ok(i), i) : null;
        }
        case G:
          return ov(i), null;
        case S:
          return nv(i), null;
        case _:
          var N = i.type._context;
          return rA(N, i), null;
        case ce:
        case te:
          return Vk(i), null;
        case Ee:
          return null;
        default:
          return null;
      }
    }
    function cL(r, i, d) {
      switch (ZI(i), i.tag) {
        case v: {
          var p = i.type.childContextTypes;
          p != null && lx(i);
          break;
        }
        case b: {
          i.stateNode, nv(i), GI(i), DA();
          break;
        }
        case w: {
          RA(i);
          break;
        }
        case S:
          nv(i);
          break;
        case F:
          ov(i);
          break;
        case G:
          ov(i);
          break;
        case _:
          var y = i.type._context;
          rA(y, i);
          break;
        case ce:
        case te:
          Vk(i);
          break;
      }
    }
    var dL = null;
    dL = /* @__PURE__ */ new Set();
    var eC = !1, Xo = !1, J7 = typeof WeakSet == "function" ? WeakSet : Set, xt = null, cv = null, dv = null;
    function Q7(r) {
      Bu(null, function() {
        throw r;
      }), iy();
    }
    var K7 = function(r, i) {
      if (i.props = r.memoizedProps, i.state = r.memoizedState, r.mode & Mt)
        try {
          nu(), i.componentWillUnmount();
        } finally {
          tu(r);
        }
      else
        i.componentWillUnmount();
    };
    function fL(r, i) {
      try {
        Gd(xo, r);
      } catch (d) {
        ur(r, i, d);
      }
    }
    function wk(r, i, d) {
      try {
        K7(r, d);
      } catch (p) {
        ur(r, i, p);
      }
    }
    function q7(r, i, d) {
      try {
        d.componentDidMount();
      } catch (p) {
        ur(r, i, p);
      }
    }
    function pL(r, i) {
      try {
        mL(r);
      } catch (d) {
        ur(r, i, d);
      }
    }
    function fv(r, i) {
      var d = r.ref;
      if (d !== null)
        if (typeof d == "function") {
          var p;
          try {
            if (Oe && Ce && r.mode & Mt)
              try {
                nu(), p = d(null);
              } finally {
                tu(r);
              }
            else
              p = d(null);
          } catch (y) {
            ur(r, i, y);
          }
          typeof p == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ut(r));
        } else
          d.current = null;
    }
    function tC(r, i, d) {
      try {
        d();
      } catch (p) {
        ur(r, i, p);
      }
    }
    var hL = !1;
    function eZ(r, i) {
      p8(r.containerInfo), xt = i, tZ();
      var d = hL;
      return hL = !1, d;
    }
    function tZ() {
      for (; xt !== null; ) {
        var r = xt, i = r.child;
        (r.subtreeFlags & cd) !== At && i !== null ? (i.return = r, xt = i) : nZ();
      }
    }
    function nZ() {
      for (; xt !== null; ) {
        var r = xt;
        _n(r);
        try {
          rZ(r);
        } catch (d) {
          ur(r, r.return, d);
        }
        kr();
        var i = r.sibling;
        if (i !== null) {
          i.return = r.return, xt = i;
          return;
        }
        xt = r.return;
      }
    }
    function rZ(r) {
      var i = r.alternate, d = r.flags;
      if ((d & Ji) !== At) {
        switch (_n(r), r.tag) {
          case h:
          case D:
          case $:
            break;
          case v: {
            if (i !== null) {
              var p = i.memoizedProps, y = i.memoizedState, C = r.stateNode;
              r.type === r.elementType && !Dp && (C.props !== r.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(r) || "instance"), C.state !== r.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(r) || "instance"));
              var k = C.getSnapshotBeforeUpdate(r.elementType === r.type ? p : nl(r.type, p), y);
              {
                var O = dL;
                k === void 0 && !O.has(r.type) && (O.add(r.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ut(r)));
              }
              C.__reactInternalSnapshotBeforeUpdate = k;
            }
            break;
          }
          case b: {
            {
              var N = r.stateNode;
              B8(N.containerInfo);
            }
            break;
          }
          case w:
          case E:
          case S:
          case W:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        kr();
      }
    }
    function al(r, i, d) {
      var p = i.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var C = y.next, k = C;
        do {
          if ((k.tag & r) === r) {
            var O = k.destroy;
            k.destroy = void 0, O !== void 0 && ((r & Wo) !== la ? tm(i) : (r & xo) !== la && nm(i), (r & Kl) !== la && $b(!0), tC(i, d, O), (r & Kl) !== la && $b(!1), (r & Wo) !== la ? p1() : (r & xo) !== la && dd());
          }
          k = k.next;
        } while (k !== C);
      }
    }
    function Gd(r, i) {
      var d = i.updateQueue, p = d !== null ? d.lastEffect : null;
      if (p !== null) {
        var y = p.next, C = y;
        do {
          if ((C.tag & r) === r) {
            (r & Wo) !== la ? f1(i) : (r & xo) !== la && h1(i);
            var k = C.create;
            (r & Kl) !== la && $b(!0), C.destroy = k(), (r & Kl) !== la && $b(!1), (r & Wo) !== la ? gy() : (r & xo) !== la && m1();
            {
              var O = C.destroy;
              if (O !== void 0 && typeof O != "function") {
                var N = void 0;
                (C.tag & xo) !== At ? N = "useLayoutEffect" : (C.tag & Kl) !== At ? N = "useInsertionEffect" : N = "useEffect";
                var z = void 0;
                O === null ? z = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof O.then == "function" ? z = `

It looks like you wrote ` + N + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + N + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : z = " You returned: " + O, u("%s must not return anything besides a function, which is used for clean-up.%s", N, z);
              }
            }
          }
          C = C.next;
        } while (C !== y);
      }
    }
    function oZ(r, i) {
      if ((i.flags & qt) !== At)
        switch (i.tag) {
          case L: {
            var d = i.stateNode.passiveEffectDuration, p = i.memoizedProps, y = p.id, C = p.onPostCommit, k = LM(), O = i.alternate === null ? "mount" : "update";
            MM() && (O = "nested-update"), typeof C == "function" && C(y, O, d, k);
            var N = i.return;
            e:
              for (; N !== null; ) {
                switch (N.tag) {
                  case b:
                    var z = N.stateNode;
                    z.passiveEffectDuration += d;
                    break e;
                  case L:
                    var j = N.stateNode;
                    j.passiveEffectDuration += d;
                    break e;
                }
                N = N.return;
              }
            break;
          }
        }
    }
    function iZ(r, i, d, p) {
      if ((d.flags & No) !== At)
        switch (d.tag) {
          case h:
          case D:
          case $: {
            if (!Xo)
              if (d.mode & Mt)
                try {
                  nu(), Gd(xo | So, d);
                } finally {
                  tu(d);
                }
              else
                Gd(xo | So, d);
            break;
          }
          case v: {
            var y = d.stateNode;
            if (d.flags & qt && !Xo)
              if (i === null)
                if (d.type === d.elementType && !Dp && (y.props !== d.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(d) || "instance"), y.state !== d.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(d) || "instance")), d.mode & Mt)
                  try {
                    nu(), y.componentDidMount();
                  } finally {
                    tu(d);
                  }
                else
                  y.componentDidMount();
              else {
                var C = d.elementType === d.type ? i.memoizedProps : nl(d.type, i.memoizedProps), k = i.memoizedState;
                if (d.type === d.elementType && !Dp && (y.props !== d.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(d) || "instance"), y.state !== d.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(d) || "instance")), d.mode & Mt)
                  try {
                    nu(), y.componentDidUpdate(C, k, y.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    tu(d);
                  }
                else
                  y.componentDidUpdate(C, k, y.__reactInternalSnapshotBeforeUpdate);
              }
            var O = d.updateQueue;
            O !== null && (d.type === d.elementType && !Dp && (y.props !== d.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(d) || "instance"), y.state !== d.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(d) || "instance")), YN(d, O, y));
            break;
          }
          case b: {
            var N = d.updateQueue;
            if (N !== null) {
              var z = null;
              if (d.child !== null)
                switch (d.child.tag) {
                  case w:
                    z = d.child.stateNode;
                    break;
                  case v:
                    z = d.child.stateNode;
                    break;
                }
              YN(d, N, z);
            }
            break;
          }
          case w: {
            var j = d.stateNode;
            if (i === null && d.flags & qt) {
              var ue = d.type, ae = d.memoizedProps;
              E8(j, ue, ae);
            }
            break;
          }
          case E:
            break;
          case S:
            break;
          case L: {
            {
              var Ae = d.memoizedProps, ke = Ae.onCommit, Ne = Ae.onRender, pt = d.stateNode.effectDuration, Rt = LM(), Et = i === null ? "mount" : "update";
              MM() && (Et = "nested-update"), typeof Ne == "function" && Ne(d.memoizedProps.id, Et, d.actualDuration, d.treeBaseDuration, d.actualStartTime, Rt);
              {
                typeof ke == "function" && ke(d.memoizedProps.id, Et, pt, Rt), nY(d);
                var xn = d.return;
                e:
                  for (; xn !== null; ) {
                    switch (xn.tag) {
                      case b:
                        var yn = xn.stateNode;
                        yn.effectDuration += pt;
                        break e;
                      case L:
                        var be = xn.stateNode;
                        be.effectDuration += pt;
                        break e;
                    }
                    xn = xn.return;
                  }
              }
            }
            break;
          }
          case F: {
            pZ(r, d);
            break;
          }
          case G:
          case W:
          case oe:
          case ce:
          case te:
          case me:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Xo || d.flags & li && mL(d);
    }
    function aZ(r) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          if (r.mode & Mt)
            try {
              nu(), fL(r, r.return);
            } finally {
              tu(r);
            }
          else
            fL(r, r.return);
          break;
        }
        case v: {
          var i = r.stateNode;
          typeof i.componentDidMount == "function" && q7(r, r.return, i), pL(r, r.return);
          break;
        }
        case w: {
          pL(r, r.return);
          break;
        }
      }
    }
    function sZ(r, i) {
      for (var d = null, p = r; ; ) {
        if (p.tag === w) {
          if (d === null) {
            d = p;
            try {
              var y = p.stateNode;
              i ? N8(y) : L8(p.stateNode, p.memoizedProps);
            } catch (k) {
              ur(r, r.return, k);
            }
          }
        } else if (p.tag === E) {
          if (d === null)
            try {
              var C = p.stateNode;
              i ? M8(C) : F8(C, p.memoizedProps);
            } catch (k) {
              ur(r, r.return, k);
            }
        } else if (!((p.tag === ce || p.tag === te) && p.memoizedState !== null && p !== r)) {
          if (p.child !== null) {
            p.child.return = p, p = p.child;
            continue;
          }
        }
        if (p === r)
          return;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === r)
            return;
          d === p && (d = null), p = p.return;
        }
        d === p && (d = null), p.sibling.return = p.return, p = p.sibling;
      }
    }
    function mL(r) {
      var i = r.ref;
      if (i !== null) {
        var d = r.stateNode, p;
        switch (r.tag) {
          case w:
            p = d;
            break;
          default:
            p = d;
        }
        if (typeof i == "function") {
          var y;
          if (r.mode & Mt)
            try {
              nu(), y = i(p);
            } finally {
              tu(r);
            }
          else
            y = i(p);
          typeof y == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ut(r));
        } else
          i.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ut(r)), i.current = p;
      }
    }
    function lZ(r) {
      var i = r.alternate;
      i !== null && (i.return = null), r.return = null;
    }
    function vL(r) {
      var i = r.alternate;
      i !== null && (r.alternate = null, vL(i));
      {
        if (r.child = null, r.deletions = null, r.sibling = null, r.tag === w) {
          var d = r.stateNode;
          d !== null && mX(d);
        }
        r.stateNode = null, r._debugOwner = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
      }
    }
    function uZ(r) {
      for (var i = r.return; i !== null; ) {
        if (gL(i))
          return i;
        i = i.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function gL(r) {
      return r.tag === w || r.tag === b || r.tag === S;
    }
    function yL(r) {
      var i = r;
      e:
        for (; ; ) {
          for (; i.sibling === null; ) {
            if (i.return === null || gL(i.return))
              return null;
            i = i.return;
          }
          for (i.sibling.return = i.return, i = i.sibling; i.tag !== w && i.tag !== E && i.tag !== H; ) {
            if (i.flags & ir || i.child === null || i.tag === S)
              continue e;
            i.child.return = i, i = i.child;
          }
          if (!(i.flags & ir))
            return i.stateNode;
        }
    }
    function cZ(r) {
      var i = uZ(r);
      switch (i.tag) {
        case w: {
          var d = i.stateNode;
          i.flags & Fn && (bN(d), i.flags &= ~Fn);
          var p = yL(r);
          Tk(r, p, d);
          break;
        }
        case b:
        case S: {
          var y = i.stateNode.containerInfo, C = yL(r);
          Ek(r, C, y);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Ek(r, i, d) {
      var p = r.tag, y = p === w || p === E;
      if (y) {
        var C = r.stateNode;
        i ? P8(d, C, i) : k8(d, C);
      } else if (p !== S) {
        var k = r.child;
        if (k !== null) {
          Ek(k, i, d);
          for (var O = k.sibling; O !== null; )
            Ek(O, i, d), O = O.sibling;
        }
      }
    }
    function Tk(r, i, d) {
      var p = r.tag, y = p === w || p === E;
      if (y) {
        var C = r.stateNode;
        i ? R8(d, C, i) : A8(d, C);
      } else if (p !== S) {
        var k = r.child;
        if (k !== null) {
          Tk(k, i, d);
          for (var O = k.sibling; O !== null; )
            Tk(O, i, d), O = O.sibling;
        }
      }
    }
    var Zo = null, sl = !1;
    function dZ(r, i, d) {
      {
        var p = i;
        e:
          for (; p !== null; ) {
            switch (p.tag) {
              case w: {
                Zo = p.stateNode, sl = !1;
                break e;
              }
              case b: {
                Zo = p.stateNode.containerInfo, sl = !0;
                break e;
              }
              case S: {
                Zo = p.stateNode.containerInfo, sl = !0;
                break e;
              }
            }
            p = p.return;
          }
        if (Zo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        bL(r, i, d), Zo = null, sl = !1;
      }
      lZ(d);
    }
    function Wd(r, i, d) {
      for (var p = d.child; p !== null; )
        bL(r, i, p), p = p.sibling;
    }
    function bL(r, i, d) {
      switch (my(d), d.tag) {
        case w:
          Xo || fv(d, i);
        case E: {
          {
            var p = Zo, y = sl;
            Zo = null, Wd(r, i, d), Zo = p, sl = y, Zo !== null && (sl ? _8(Zo, d.stateNode) : O8(Zo, d.stateNode));
          }
          return;
        }
        case H: {
          Zo !== null && (sl ? D8(Zo, d.stateNode) : LI(Zo, d.stateNode));
          return;
        }
        case S: {
          {
            var C = Zo, k = sl;
            Zo = d.stateNode.containerInfo, sl = !0, Wd(r, i, d), Zo = C, sl = k;
          }
          return;
        }
        case h:
        case D:
        case V:
        case $: {
          if (!Xo) {
            var O = d.updateQueue;
            if (O !== null) {
              var N = O.lastEffect;
              if (N !== null) {
                var z = N.next, j = z;
                do {
                  var ue = j, ae = ue.destroy, Ae = ue.tag;
                  ae !== void 0 && ((Ae & Kl) !== la ? tC(d, i, ae) : (Ae & xo) !== la && (nm(d), d.mode & Mt ? (nu(), tC(d, i, ae), tu(d)) : tC(d, i, ae), dd())), j = j.next;
                } while (j !== z);
              }
            }
          }
          Wd(r, i, d);
          return;
        }
        case v: {
          if (!Xo) {
            fv(d, i);
            var ke = d.stateNode;
            typeof ke.componentWillUnmount == "function" && wk(d, i, ke);
          }
          Wd(r, i, d);
          return;
        }
        case oe: {
          Wd(r, i, d);
          return;
        }
        case ce: {
          if (
            // TODO: Remove this dead flag
            d.mode & pn
          ) {
            var Ne = Xo;
            Xo = Ne || d.memoizedState !== null, Wd(r, i, d), Xo = Ne;
          } else
            Wd(r, i, d);
          break;
        }
        default: {
          Wd(r, i, d);
          return;
        }
      }
    }
    function fZ(r) {
      r.memoizedState;
    }
    function pZ(r, i) {
      var d = i.memoizedState;
      if (d === null) {
        var p = i.alternate;
        if (p !== null) {
          var y = p.memoizedState;
          if (y !== null) {
            var C = y.dehydrated;
            C !== null && K8(C);
          }
        }
      }
    }
    function SL(r) {
      var i = r.updateQueue;
      if (i !== null) {
        r.updateQueue = null;
        var d = r.stateNode;
        d === null && (d = r.stateNode = new J7()), i.forEach(function(p) {
          var y = uY.bind(null, r, p);
          if (!d.has(p)) {
            if (d.add(p), yo)
              if (cv !== null && dv !== null)
                Vb(dv, cv);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            p.then(y, y);
          }
        });
      }
    }
    function hZ(r, i, d) {
      cv = d, dv = r, _n(i), xL(i, r), _n(i), cv = null, dv = null;
    }
    function ll(r, i, d) {
      var p = i.deletions;
      if (p !== null)
        for (var y = 0; y < p.length; y++) {
          var C = p[y];
          try {
            dZ(r, i, C);
          } catch (N) {
            ur(C, i, N);
          }
        }
      var k = Bf();
      if (i.subtreeFlags & di)
        for (var O = i.child; O !== null; )
          _n(O), xL(O, r), O = O.sibling;
      _n(k);
    }
    function xL(r, i, d) {
      var p = r.alternate, y = r.flags;
      switch (r.tag) {
        case h:
        case D:
        case V:
        case $: {
          if (ll(i, r), ru(r), y & qt) {
            try {
              al(Kl | So, r, r.return), Gd(Kl | So, r);
            } catch (zt) {
              ur(r, r.return, zt);
            }
            if (r.mode & Mt) {
              try {
                nu(), al(xo | So, r, r.return);
              } catch (zt) {
                ur(r, r.return, zt);
              }
              tu(r);
            } else
              try {
                al(xo | So, r, r.return);
              } catch (zt) {
                ur(r, r.return, zt);
              }
          }
          return;
        }
        case v: {
          ll(i, r), ru(r), y & li && p !== null && fv(p, p.return);
          return;
        }
        case w: {
          ll(i, r), ru(r), y & li && p !== null && fv(p, p.return);
          {
            if (r.flags & Fn) {
              var C = r.stateNode;
              try {
                bN(C);
              } catch (zt) {
                ur(r, r.return, zt);
              }
            }
            if (y & qt) {
              var k = r.stateNode;
              if (k != null) {
                var O = r.memoizedProps, N = p !== null ? p.memoizedProps : O, z = r.type, j = r.updateQueue;
                if (r.updateQueue = null, j !== null)
                  try {
                    T8(k, j, z, N, O, r);
                  } catch (zt) {
                    ur(r, r.return, zt);
                  }
              }
            }
          }
          return;
        }
        case E: {
          if (ll(i, r), ru(r), y & qt) {
            if (r.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ue = r.stateNode, ae = r.memoizedProps, Ae = p !== null ? p.memoizedProps : ae;
            try {
              I8(ue, Ae, ae);
            } catch (zt) {
              ur(r, r.return, zt);
            }
          }
          return;
        }
        case b: {
          if (ll(i, r), ru(r), y & qt && p !== null) {
            var ke = p.memoizedState;
            if (ke.isDehydrated)
              try {
                Q8(i.containerInfo);
              } catch (zt) {
                ur(r, r.return, zt);
              }
          }
          return;
        }
        case S: {
          ll(i, r), ru(r);
          return;
        }
        case F: {
          ll(i, r), ru(r);
          var Ne = r.child;
          if (Ne.flags & Nl) {
            var pt = Ne.stateNode, Rt = Ne.memoizedState, Et = Rt !== null;
            if (pt.isHidden = Et, Et) {
              var xn = Ne.alternate !== null && Ne.alternate.memoizedState !== null;
              xn || ZZ();
            }
          }
          if (y & qt) {
            try {
              fZ(r);
            } catch (zt) {
              ur(r, r.return, zt);
            }
            SL(r);
          }
          return;
        }
        case ce: {
          var yn = p !== null && p.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            r.mode & pn
          ) {
            var be = Xo;
            Xo = be || yn, ll(i, r), Xo = be;
          } else
            ll(i, r);
          if (ru(r), y & Nl) {
            var Me = r.stateNode, Se = r.memoizedState, Ye = Se !== null, ht = r;
            if (Me.isHidden = Ye, Ye && !yn && (ht.mode & pn) !== _t) {
              xt = ht;
              for (var at = ht.child; at !== null; )
                xt = at, vZ(at), at = at.sibling;
            }
            sZ(ht, Ye);
          }
          return;
        }
        case G: {
          ll(i, r), ru(r), y & qt && SL(r);
          return;
        }
        case oe:
          return;
        default: {
          ll(i, r), ru(r);
          return;
        }
      }
    }
    function ru(r) {
      var i = r.flags;
      if (i & ir) {
        try {
          cZ(r);
        } catch (d) {
          ur(r, r.return, d);
        }
        r.flags &= ~ir;
      }
      i & Qi && (r.flags &= ~Qi);
    }
    function mZ(r, i, d) {
      cv = d, dv = i, xt = r, CL(r, i, d), cv = null, dv = null;
    }
    function CL(r, i, d) {
      for (var p = (r.mode & pn) !== _t; xt !== null; ) {
        var y = xt, C = y.child;
        if (y.tag === ce && p) {
          var k = y.memoizedState !== null, O = k || eC;
          if (O) {
            Ik(r, i, d);
            continue;
          } else {
            var N = y.alternate, z = N !== null && N.memoizedState !== null, j = z || Xo, ue = eC, ae = Xo;
            eC = O, Xo = j, Xo && !ae && (xt = y, gZ(y));
            for (var Ae = C; Ae !== null; )
              xt = Ae, CL(
                Ae,
                // New root; bubble back up to here and stop.
                i,
                d
              ), Ae = Ae.sibling;
            xt = y, eC = ue, Xo = ae, Ik(r, i, d);
            continue;
          }
        }
        (y.subtreeFlags & No) !== At && C !== null ? (C.return = y, xt = C) : Ik(r, i, d);
      }
    }
    function Ik(r, i, d) {
      for (; xt !== null; ) {
        var p = xt;
        if ((p.flags & No) !== At) {
          var y = p.alternate;
          _n(p);
          try {
            iZ(i, y, p, d);
          } catch (k) {
            ur(p, p.return, k);
          }
          kr();
        }
        if (p === r) {
          xt = null;
          return;
        }
        var C = p.sibling;
        if (C !== null) {
          C.return = p.return, xt = C;
          return;
        }
        xt = p.return;
      }
    }
    function vZ(r) {
      for (; xt !== null; ) {
        var i = xt, d = i.child;
        switch (i.tag) {
          case h:
          case D:
          case V:
          case $: {
            if (i.mode & Mt)
              try {
                nu(), al(xo, i, i.return);
              } finally {
                tu(i);
              }
            else
              al(xo, i, i.return);
            break;
          }
          case v: {
            fv(i, i.return);
            var p = i.stateNode;
            typeof p.componentWillUnmount == "function" && wk(i, i.return, p);
            break;
          }
          case w: {
            fv(i, i.return);
            break;
          }
          case ce: {
            var y = i.memoizedState !== null;
            if (y) {
              wL(r);
              continue;
            }
            break;
          }
        }
        d !== null ? (d.return = i, xt = d) : wL(r);
      }
    }
    function wL(r) {
      for (; xt !== null; ) {
        var i = xt;
        if (i === r) {
          xt = null;
          return;
        }
        var d = i.sibling;
        if (d !== null) {
          d.return = i.return, xt = d;
          return;
        }
        xt = i.return;
      }
    }
    function gZ(r) {
      for (; xt !== null; ) {
        var i = xt, d = i.child;
        if (i.tag === ce) {
          var p = i.memoizedState !== null;
          if (p) {
            EL(r);
            continue;
          }
        }
        d !== null ? (d.return = i, xt = d) : EL(r);
      }
    }
    function EL(r) {
      for (; xt !== null; ) {
        var i = xt;
        _n(i);
        try {
          aZ(i);
        } catch (p) {
          ur(i, i.return, p);
        }
        if (kr(), i === r) {
          xt = null;
          return;
        }
        var d = i.sibling;
        if (d !== null) {
          d.return = i.return, xt = d;
          return;
        }
        xt = i.return;
      }
    }
    function yZ(r, i, d, p) {
      xt = i, bZ(i, r, d, p);
    }
    function bZ(r, i, d, p) {
      for (; xt !== null; ) {
        var y = xt, C = y.child;
        (y.subtreeFlags & Ki) !== At && C !== null ? (C.return = y, xt = C) : SZ(r, i, d, p);
      }
    }
    function SZ(r, i, d, p) {
      for (; xt !== null; ) {
        var y = xt;
        if ((y.flags & hr) !== At) {
          _n(y);
          try {
            xZ(i, y, d, p);
          } catch (k) {
            ur(y, y.return, k);
          }
          kr();
        }
        if (y === r) {
          xt = null;
          return;
        }
        var C = y.sibling;
        if (C !== null) {
          C.return = y.return, xt = C;
          return;
        }
        xt = y.return;
      }
    }
    function xZ(r, i, d, p) {
      switch (i.tag) {
        case h:
        case D:
        case $: {
          if (i.mode & Mt) {
            rk();
            try {
              Gd(Wo | So, i);
            } finally {
              nk(i);
            }
          } else
            Gd(Wo | So, i);
          break;
        }
      }
    }
    function CZ(r) {
      xt = r, wZ();
    }
    function wZ() {
      for (; xt !== null; ) {
        var r = xt, i = r.child;
        if ((xt.flags & Nn) !== At) {
          var d = r.deletions;
          if (d !== null) {
            for (var p = 0; p < d.length; p++) {
              var y = d[p];
              xt = y, IZ(y, r);
            }
            {
              var C = r.alternate;
              if (C !== null) {
                var k = C.child;
                if (k !== null) {
                  C.child = null;
                  do {
                    var O = k.sibling;
                    k.sibling = null, k = O;
                  } while (k !== null);
                }
              }
            }
            xt = r;
          }
        }
        (r.subtreeFlags & Ki) !== At && i !== null ? (i.return = r, xt = i) : EZ();
      }
    }
    function EZ() {
      for (; xt !== null; ) {
        var r = xt;
        (r.flags & hr) !== At && (_n(r), TZ(r), kr());
        var i = r.sibling;
        if (i !== null) {
          i.return = r.return, xt = i;
          return;
        }
        xt = r.return;
      }
    }
    function TZ(r) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          r.mode & Mt ? (rk(), al(Wo | So, r, r.return), nk(r)) : al(Wo | So, r, r.return);
          break;
        }
      }
    }
    function IZ(r, i) {
      for (; xt !== null; ) {
        var d = xt;
        _n(d), kZ(d, i), kr();
        var p = d.child;
        p !== null ? (p.return = d, xt = p) : AZ(r);
      }
    }
    function AZ(r) {
      for (; xt !== null; ) {
        var i = xt, d = i.sibling, p = i.return;
        if (vL(i), i === r) {
          xt = null;
          return;
        }
        if (d !== null) {
          d.return = p, xt = d;
          return;
        }
        xt = p;
      }
    }
    function kZ(r, i) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          r.mode & Mt ? (rk(), al(Wo, r, i), nk(r)) : al(Wo, r, i);
          break;
        }
      }
    }
    function RZ(r) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          try {
            Gd(xo | So, r);
          } catch (d) {
            ur(r, r.return, d);
          }
          break;
        }
        case v: {
          var i = r.stateNode;
          try {
            i.componentDidMount();
          } catch (d) {
            ur(r, r.return, d);
          }
          break;
        }
      }
    }
    function PZ(r) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          try {
            Gd(Wo | So, r);
          } catch (i) {
            ur(r, r.return, i);
          }
          break;
        }
      }
    }
    function OZ(r) {
      switch (r.tag) {
        case h:
        case D:
        case $: {
          try {
            al(xo | So, r, r.return);
          } catch (d) {
            ur(r, r.return, d);
          }
          break;
        }
        case v: {
          var i = r.stateNode;
          typeof i.componentWillUnmount == "function" && wk(r, r.return, i);
          break;
        }
      }
    }
    function _Z(r) {
      switch (r.tag) {
        case h:
        case D:
        case $:
          try {
            al(Wo | So, r, r.return);
          } catch (i) {
            ur(r, r.return, i);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var kb = Symbol.for;
      kb("selector.component"), kb("selector.has_pseudo_class"), kb("selector.role"), kb("selector.test_id"), kb("selector.text");
    }
    var DZ = [];
    function NZ() {
      DZ.forEach(function(r) {
        return r();
      });
    }
    var MZ = n.ReactCurrentActQueue;
    function LZ(r) {
      {
        var i = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), d = typeof jest < "u";
        return d && i !== !1;
      }
    }
    function TL() {
      {
        var r = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !r && MZ.current !== null && u("The current testing environment is not configured to support act(...)"), r;
      }
    }
    var FZ = Math.ceil, Ak = n.ReactCurrentDispatcher, kk = n.ReactCurrentOwner, Yo = n.ReactCurrentBatchConfig, ul = n.ReactCurrentActQueue, Eo = (
      /*             */
      0
    ), IL = (
      /*               */
      1
    ), Jo = (
      /*                */
      2
    ), ds = (
      /*                */
      4
    ), pc = 0, Rb = 1, Np = 2, nC = 3, Pb = 4, AL = 5, Rk = 6, Sn = Eo, Ni = null, Or = null, To = Be, ou = Be, Pk = Md(Be), Io = pc, Ob = null, rC = Be, _b = Be, oC = Be, Db = null, ua = null, Ok = 0, kL = 500, RL = 1 / 0, BZ = 500, hc = null;
    function Nb() {
      RL = yr() + BZ;
    }
    function PL() {
      return RL;
    }
    var iC = !1, _k = null, pv = null, Mp = !1, Ud = null, Mb = Be, Dk = [], Nk = null, VZ = 50, Lb = 0, Mk = null, Lk = !1, aC = !1, $Z = 50, hv = 0, sC = null, Fb = tr, lC = Be, OL = !1;
    function uC() {
      return Ni;
    }
    function Mi() {
      return (Sn & (Jo | ds)) !== Eo ? yr() : (Fb !== tr || (Fb = yr()), Fb);
    }
    function Xd(r) {
      var i = r.mode;
      if ((i & pn) === _t)
        return Lt;
      if ((Sn & Jo) !== Eo && To !== Be)
        return Xr(To);
      var d = LX() !== MX;
      if (d) {
        if (Yo.transition !== null) {
          var p = Yo.transition;
          p._updatedFibers || (p._updatedFibers = /* @__PURE__ */ new Set()), p._updatedFibers.add(r);
        }
        return lC === bn && (lC = wy()), lC;
      }
      var y = na();
      if (y !== bn)
        return y;
      var C = S8();
      return C;
    }
    function zZ(r) {
      var i = r.mode;
      return (i & pn) === _t ? Lt : rI();
    }
    function Ao(r, i, d, p) {
      dY(), OL && u("useInsertionEffect must not schedule updates."), Lk && (aC = !0), Ju(r, d, p), (Sn & Jo) !== Be && r === Ni ? hY(i) : (yo && ky(r, i, d), mY(i), r === Ni && ((Sn & Jo) === Eo && (_b = en(_b, d)), Io === Pb && Zd(r, To)), ca(r, p), d === Lt && Sn === Eo && (i.mode & pn) === _t && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ul.isBatchingLegacy && (Nb(), PN()));
    }
    function HZ(r, i, d) {
      var p = r.current;
      p.lanes = i, Ju(r, i, d), ca(r, d);
    }
    function jZ(r) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Sn & Jo) !== Eo
      );
    }
    function ca(r, i) {
      var d = r.callbackNode;
      eI(r, i);
      var p = ap(r, r === Ni ? To : Be);
      if (p === Be) {
        d !== null && XL(d), r.callbackNode = null, r.callbackPriority = bn;
        return;
      }
      var y = Lr(p), C = r.callbackPriority;
      if (C === y && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ul.current !== null && d !== jk)) {
        d == null && C !== Lt && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      d != null && XL(d);
      var k;
      if (y === Lt)
        r.tag === Ld ? (ul.isBatchingLegacy !== null && (ul.didScheduleLegacyUpdate = !0), yX(NL.bind(null, r))) : RN(NL.bind(null, r)), ul.current !== null ? ul.current.push(Fd) : C8(function() {
          (Sn & (Jo | ds)) === Eo && Fd();
        }), k = null;
      else {
        var O;
        switch (dp(p)) {
          case Mo:
            O = Kh;
            break;
          case bo:
            O = Pi;
            break;
          case Zs:
            O = ts;
            break;
          case up:
            O = Ll;
            break;
          default:
            O = ts;
            break;
        }
        k = Gk(O, _L.bind(null, r));
      }
      r.callbackPriority = y, r.callbackNode = k;
    }
    function _L(r, i) {
      if (d7(), Fb = tr, lC = Be, (Sn & (Jo | ds)) !== Eo)
        throw new Error("Should not already be working.");
      var d = r.callbackNode, p = vc();
      if (p && r.callbackNode !== d)
        return null;
      var y = ap(r, r === Ni ? To : Be);
      if (y === Be)
        return null;
      var C = !lp(r, y) && !x1(r, y) && !i, k = C ? qZ(r, y) : dC(r, y);
      if (k !== pc) {
        if (k === Np) {
          var O = xy(r);
          O !== Be && (y = O, k = Fk(r, O));
        }
        if (k === Rb) {
          var N = Ob;
          throw Lp(r, Be), Zd(r, y), ca(r, yr()), N;
        }
        if (k === Rk)
          Zd(r, y);
        else {
          var z = !lp(r, y), j = r.current.alternate;
          if (z && !WZ(j)) {
            if (k = dC(r, y), k === Np) {
              var ue = xy(r);
              ue !== Be && (y = ue, k = Fk(r, ue));
            }
            if (k === Rb) {
              var ae = Ob;
              throw Lp(r, Be), Zd(r, y), ca(r, yr()), ae;
            }
          }
          r.finishedWork = j, r.finishedLanes = y, GZ(r, k, y);
        }
      }
      return ca(r, yr()), r.callbackNode === d ? _L.bind(null, r) : null;
    }
    function Fk(r, i) {
      var d = Db;
      if (Yr(r)) {
        var p = Lp(r, i);
        p.flags |= Tr, dX(r.containerInfo);
      }
      var y = dC(r, i);
      if (y !== Np) {
        var C = ua;
        ua = d, C !== null && DL(C);
      }
      return y;
    }
    function DL(r) {
      ua === null ? ua = r : ua.push.apply(ua, r);
    }
    function GZ(r, i, d) {
      switch (i) {
        case pc:
        case Rb:
          throw new Error("Root did not complete. This is a bug in React.");
        case Np: {
          Fp(r, ua, hc);
          break;
        }
        case nC: {
          if (Zd(r, d), Cm(d) && // do not delay if we're inside an act() scope
          !ZL()) {
            var p = Ok + kL - yr();
            if (p > 10) {
              var y = ap(r, Be);
              if (y !== Be)
                break;
              var C = r.suspendedLanes;
              if (!Yu(C, d)) {
                Mi(), Iy(r, C);
                break;
              }
              r.timeoutHandle = NI(Fp.bind(null, r, ua, hc), p);
              break;
            }
          }
          Fp(r, ua, hc);
          break;
        }
        case Pb: {
          if (Zd(r, d), S1(d))
            break;
          if (!ZL()) {
            var k = b1(r, d), O = k, N = yr() - O, z = cY(N) - N;
            if (z > 10) {
              r.timeoutHandle = NI(Fp.bind(null, r, ua, hc), z);
              break;
            }
          }
          Fp(r, ua, hc);
          break;
        }
        case AL: {
          Fp(r, ua, hc);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function WZ(r) {
      for (var i = r; ; ) {
        if (i.flags & qf) {
          var d = i.updateQueue;
          if (d !== null) {
            var p = d.stores;
            if (p !== null)
              for (var y = 0; y < p.length; y++) {
                var C = p[y], k = C.getSnapshot, O = C.value;
                try {
                  if (!St(k(), O))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var N = i.child;
        if (i.subtreeFlags & qf && N !== null) {
          N.return = i, i = N;
          continue;
        }
        if (i === r)
          return !0;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === r)
            return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return !0;
    }
    function Zd(r, i) {
      i = yd(i, oC), i = yd(i, _b), Ty(r, i);
    }
    function NL(r) {
      if (f7(), (Sn & (Jo | ds)) !== Eo)
        throw new Error("Should not already be working.");
      vc();
      var i = ap(r, Be);
      if (!mi(i, Lt))
        return ca(r, yr()), null;
      var d = dC(r, i);
      if (r.tag !== Ld && d === Np) {
        var p = xy(r);
        p !== Be && (i = p, d = Fk(r, p));
      }
      if (d === Rb) {
        var y = Ob;
        throw Lp(r, Be), Zd(r, i), ca(r, yr()), y;
      }
      if (d === Rk)
        throw new Error("Root did not complete. This is a bug in React.");
      var C = r.current.alternate;
      return r.finishedWork = C, r.finishedLanes = i, Fp(r, ua, hc), ca(r, yr()), null;
    }
    function UZ(r, i) {
      i !== Be && (bd(r, en(i, Lt)), ca(r, yr()), (Sn & (Jo | ds)) === Eo && (Nb(), Fd()));
    }
    function Bk(r, i) {
      var d = Sn;
      Sn |= IL;
      try {
        return r(i);
      } finally {
        Sn = d, Sn === Eo && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ul.isBatchingLegacy && (Nb(), PN());
      }
    }
    function XZ(r, i, d, p, y) {
      var C = na(), k = Yo.transition;
      try {
        return Yo.transition = null, Zr(Mo), r(i, d, p, y);
      } finally {
        Zr(C), Yo.transition = k, Sn === Eo && Nb();
      }
    }
    function mc(r) {
      Ud !== null && Ud.tag === Ld && (Sn & (Jo | ds)) === Eo && vc();
      var i = Sn;
      Sn |= IL;
      var d = Yo.transition, p = na();
      try {
        return Yo.transition = null, Zr(Mo), r ? r() : void 0;
      } finally {
        Zr(p), Yo.transition = d, Sn = i, (Sn & (Jo | ds)) === Eo && Fd();
      }
    }
    function ML() {
      return (Sn & (Jo | ds)) !== Eo;
    }
    function cC(r, i) {
      yi(Pk, ou, r), ou = en(ou, i);
    }
    function Vk(r) {
      ou = Pk.current, gi(Pk, r);
    }
    function Lp(r, i) {
      r.finishedWork = null, r.finishedLanes = Be;
      var d = r.timeoutHandle;
      if (d !== MI && (r.timeoutHandle = MI, x8(d)), Or !== null)
        for (var p = Or.return; p !== null; ) {
          var y = p.alternate;
          cL(y, p), p = p.return;
        }
      Ni = r;
      var C = Bp(r.current, null);
      return Or = C, To = ou = i, Io = pc, Ob = null, rC = Be, _b = Be, oC = Be, Db = null, ua = null, $X(), tl.discardPendingWarnings(), C;
    }
    function LL(r, i) {
      do {
        var d = Or;
        try {
          if (yx(), fM(), kr(), kk.current = null, d === null || d.return === null) {
            Io = Rb, Ob = i, Or = null;
            return;
          }
          if (Oe && d.mode & Mt && Jx(d, !0), pe)
            if ($u(), i !== null && typeof i == "object" && typeof i.then == "function") {
              var p = i;
              v1(d, p, To);
            } else
              rm(d, i, To);
          g7(r, d.return, d, i, To), $L(d);
        } catch (y) {
          i = y, Or === d && d !== null ? (d = d.return, Or = d) : d = Or;
          continue;
        }
        return;
      } while (!0);
    }
    function FL() {
      var r = Ak.current;
      return Ak.current = Wx, r === null ? Wx : r;
    }
    function BL(r) {
      Ak.current = r;
    }
    function ZZ() {
      Ok = yr();
    }
    function Bb(r) {
      rC = en(r, rC);
    }
    function YZ() {
      Io === pc && (Io = nC);
    }
    function $k() {
      (Io === pc || Io === nC || Io === Np) && (Io = Pb), Ni !== null && (sp(rC) || sp(_b)) && Zd(Ni, To);
    }
    function JZ(r) {
      Io !== Pb && (Io = Np), Db === null ? Db = [r] : Db.push(r);
    }
    function QZ() {
      return Io === pc;
    }
    function dC(r, i) {
      var d = Sn;
      Sn |= Jo;
      var p = FL();
      if (Ni !== r || To !== i) {
        if (yo) {
          var y = r.memoizedUpdaters;
          y.size > 0 && (Vb(r, To), y.clear()), Tm(r, i);
        }
        hc = Ry(), Lp(r, i);
      }
      Ma(i);
      do
        try {
          KZ();
          break;
        } catch (C) {
          LL(r, C);
        }
      while (!0);
      if (yx(), Sn = d, BL(p), Or !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return pd(), Ni = null, To = Be, Io;
    }
    function KZ() {
      for (; Or !== null; )
        VL(Or);
    }
    function qZ(r, i) {
      var d = Sn;
      Sn |= Jo;
      var p = FL();
      if (Ni !== r || To !== i) {
        if (yo) {
          var y = r.memoizedUpdaters;
          y.size > 0 && (Vb(r, To), y.clear()), Tm(r, i);
        }
        hc = Ry(), Nb(), Lp(r, i);
      }
      Ma(i);
      do
        try {
          eY();
          break;
        } catch (C) {
          LL(r, C);
        }
      while (!0);
      return yx(), BL(p), Sn = d, Or !== null ? (np(), pc) : (pd(), Ni = null, To = Be, Io);
    }
    function eY() {
      for (; Or !== null && !Qh(); )
        VL(Or);
    }
    function VL(r) {
      var i = r.alternate;
      _n(r);
      var d;
      (r.mode & Mt) !== _t ? (tk(r), d = zk(i, r, ou), Jx(r, !0)) : d = zk(i, r, ou), kr(), r.memoizedProps = r.pendingProps, d === null ? $L(r) : Or = d, kk.current = null;
    }
    function $L(r) {
      var i = r;
      do {
        var d = i.alternate, p = i.return;
        if ((i.flags & Ai) === At) {
          _n(i);
          var y = void 0;
          if ((i.mode & Mt) === _t ? y = uL(d, i, ou) : (tk(i), y = uL(d, i, ou), Jx(i, !1)), kr(), y !== null) {
            Or = y;
            return;
          }
        } else {
          var C = Y7(d, i);
          if (C !== null) {
            C.flags &= s1, Or = C;
            return;
          }
          if ((i.mode & Mt) !== _t) {
            Jx(i, !1);
            for (var k = i.actualDuration, O = i.child; O !== null; )
              k += O.actualDuration, O = O.sibling;
            i.actualDuration = k;
          }
          if (p !== null)
            p.flags |= Ai, p.subtreeFlags = At, p.deletions = null;
          else {
            Io = Rk, Or = null;
            return;
          }
        }
        var N = i.sibling;
        if (N !== null) {
          Or = N;
          return;
        }
        i = p, Or = i;
      } while (i !== null);
      Io === pc && (Io = AL);
    }
    function Fp(r, i, d) {
      var p = na(), y = Yo.transition;
      try {
        Yo.transition = null, Zr(Mo), tY(r, i, d, p);
      } finally {
        Yo.transition = y, Zr(p);
      }
      return null;
    }
    function tY(r, i, d, p) {
      do
        vc();
      while (Ud !== null);
      if (fY(), (Sn & (Jo | ds)) !== Eo)
        throw new Error("Should not already be working.");
      var y = r.finishedWork, C = r.finishedLanes;
      if (em(C), y === null)
        return vy(), null;
      if (C === Be && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), r.finishedWork = null, r.finishedLanes = Be, y === r.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      r.callbackNode = null, r.callbackPriority = bn;
      var k = en(y.lanes, y.childLanes);
      Ay(r, k), r === Ni && (Ni = null, Or = null, To = Be), ((y.subtreeFlags & Ki) !== At || (y.flags & Ki) !== At) && (Mp || (Mp = !0, Nk = d, Gk(ts, function() {
        return vc(), null;
      })));
      var O = (y.subtreeFlags & (cd | di | No | Ki)) !== At, N = (y.flags & (cd | di | No | Ki)) !== At;
      if (O || N) {
        var z = Yo.transition;
        Yo.transition = null;
        var j = na();
        Zr(Mo);
        var ue = Sn;
        Sn |= ds, kk.current = null, eZ(r, y), FM(), hZ(r, y, C), h8(r.containerInfo), r.current = y, g1(C), mZ(y, r, C), fd(), c1(), Sn = ue, Zr(j), Yo.transition = z;
      } else
        r.current = y, FM();
      var ae = Mp;
      if (Mp ? (Mp = !1, Ud = r, Mb = C) : (hv = 0, sC = null), k = r.pendingLanes, k === Be && (pv = null), ae || GL(r.current, !1), Ws(y.stateNode, p), yo && r.memoizedUpdaters.clear(), NZ(), ca(r, yr()), i !== null)
        for (var Ae = r.onRecoverableError, ke = 0; ke < i.length; ke++) {
          var Ne = i[ke], pt = Ne.stack, Rt = Ne.digest;
          Ae(Ne.value, {
            componentStack: pt,
            digest: Rt
          });
        }
      if (iC) {
        iC = !1;
        var Et = _k;
        throw _k = null, Et;
      }
      return mi(Mb, Lt) && r.tag !== Ld && vc(), k = r.pendingLanes, mi(k, Lt) ? (c7(), r === Mk ? Lb++ : (Lb = 0, Mk = r)) : Lb = 0, Fd(), vy(), null;
    }
    function vc() {
      if (Ud !== null) {
        var r = dp(Mb), i = iI(Zs, r), d = Yo.transition, p = na();
        try {
          return Yo.transition = null, Zr(i), rY();
        } finally {
          Zr(p), Yo.transition = d;
        }
      }
      return !1;
    }
    function nY(r) {
      Dk.push(r), Mp || (Mp = !0, Gk(ts, function() {
        return vc(), null;
      }));
    }
    function rY() {
      if (Ud === null)
        return !1;
      var r = Nk;
      Nk = null;
      var i = Ud, d = Mb;
      if (Ud = null, Mb = Be, (Sn & (Jo | ds)) !== Eo)
        throw new Error("Cannot flush passive effects while already rendering.");
      Lk = !0, aC = !1, y1(d);
      var p = Sn;
      Sn |= ds, CZ(i.current), yZ(i, i.current, d, r);
      {
        var y = Dk;
        Dk = [];
        for (var C = 0; C < y.length; C++) {
          var k = y[C];
          oZ(i, k);
        }
      }
      tp(), GL(i.current, !0), Sn = p, Fd(), aC ? i === sC ? hv++ : (hv = 0, sC = i) : hv = 0, Lk = !1, aC = !1, Bl(i);
      {
        var O = i.current.stateNode;
        O.effectDuration = 0, O.passiveEffectDuration = 0;
      }
      return !0;
    }
    function zL(r) {
      return pv !== null && pv.has(r);
    }
    function oY(r) {
      pv === null ? pv = /* @__PURE__ */ new Set([r]) : pv.add(r);
    }
    function iY(r) {
      iC || (iC = !0, _k = r);
    }
    var aY = iY;
    function HL(r, i, d) {
      var p = _p(d, i), y = VM(r, p, Lt), C = Vd(r, y, Lt), k = Mi();
      C !== null && (Ju(C, Lt, k), ca(C, k));
    }
    function ur(r, i, d) {
      if (Q7(d), $b(!1), r.tag === b) {
        HL(r, r, d);
        return;
      }
      var p = null;
      for (p = i; p !== null; ) {
        if (p.tag === b) {
          HL(p, r, d);
          return;
        } else if (p.tag === v) {
          var y = p.type, C = p.stateNode;
          if (typeof y.getDerivedStateFromError == "function" || typeof C.componentDidCatch == "function" && !zL(C)) {
            var k = _p(d, r), O = sk(p, k, Lt), N = Vd(p, O, Lt), z = Mi();
            N !== null && (Ju(N, Lt, z), ca(N, z));
            return;
          }
        }
        p = p.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, d);
    }
    function sY(r, i, d) {
      var p = r.pingCache;
      p !== null && p.delete(i);
      var y = Mi();
      Iy(r, d), vY(r), Ni === r && Yu(To, d) && (Io === Pb || Io === nC && Cm(To) && yr() - Ok < kL ? Lp(r, Be) : oC = en(oC, d)), ca(r, y);
    }
    function jL(r, i) {
      i === bn && (i = zZ(r));
      var d = Mi(), p = sa(r, i);
      p !== null && (Ju(p, i, d), ca(p, d));
    }
    function lY(r) {
      var i = r.memoizedState, d = bn;
      i !== null && (d = i.retryLane), jL(r, d);
    }
    function uY(r, i) {
      var d = bn, p;
      switch (r.tag) {
        case F:
          p = r.stateNode;
          var y = r.memoizedState;
          y !== null && (d = y.retryLane);
          break;
        case G:
          p = r.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      p !== null && p.delete(i), jL(r, d);
    }
    function cY(r) {
      return r < 120 ? 120 : r < 480 ? 480 : r < 1080 ? 1080 : r < 1920 ? 1920 : r < 3e3 ? 3e3 : r < 4320 ? 4320 : FZ(r / 1960) * 1960;
    }
    function dY() {
      if (Lb > VZ)
        throw Lb = 0, Mk = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      hv > $Z && (hv = 0, sC = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function fY() {
      tl.flushLegacyContextWarning(), tl.flushPendingUnsafeLifecycleWarnings();
    }
    function GL(r, i) {
      _n(r), fC(r, ci, OZ), i && fC(r, Vu, _Z), fC(r, ci, RZ), i && fC(r, Vu, PZ), kr();
    }
    function fC(r, i, d) {
      for (var p = r, y = null; p !== null; ) {
        var C = p.subtreeFlags & i;
        p !== y && p.child !== null && C !== At ? p = p.child : ((p.flags & i) !== At && d(p), p.sibling !== null ? p = p.sibling : p = y = p.return);
      }
    }
    var pC = null;
    function WL(r) {
      {
        if ((Sn & Jo) !== Eo || !(r.mode & pn))
          return;
        var i = r.tag;
        if (i !== g && i !== b && i !== v && i !== h && i !== D && i !== V && i !== $)
          return;
        var d = Ut(r) || "ReactComponent";
        if (pC !== null) {
          if (pC.has(d))
            return;
          pC.add(d);
        } else
          pC = /* @__PURE__ */ new Set([d]);
        var p = or;
        try {
          _n(r), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          p ? _n(r) : kr();
        }
      }
    }
    var zk;
    {
      var pY = null;
      zk = function(r, i, d) {
        var p = qL(pY, i);
        try {
          return oL(r, i, d);
        } catch (C) {
          if (IX() || C !== null && typeof C == "object" && typeof C.then == "function")
            throw C;
          if (yx(), fM(), cL(r, i), qL(i, p), i.mode & Mt && tk(i), Bu(null, oL, null, r, i, d), KT()) {
            var y = iy();
            typeof y == "object" && y !== null && y._suppressLogging && typeof C == "object" && C !== null && !C._suppressLogging && (C._suppressLogging = !0);
          }
          throw C;
        }
      };
    }
    var UL = !1, Hk;
    Hk = /* @__PURE__ */ new Set();
    function hY(r) {
      if (Oo && !s7())
        switch (r.tag) {
          case h:
          case D:
          case $: {
            var i = Or && Ut(Or) || "Unknown", d = i;
            if (!Hk.has(d)) {
              Hk.add(d);
              var p = Ut(r) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", p, i, i);
            }
            break;
          }
          case v: {
            UL || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), UL = !0);
            break;
          }
        }
    }
    function Vb(r, i) {
      if (yo) {
        var d = r.memoizedUpdaters;
        d.forEach(function(p) {
          ky(r, p, i);
        });
      }
    }
    var jk = {};
    function Gk(r, i) {
      {
        var d = ul.current;
        return d !== null ? (d.push(i), jk) : Jh(r, i);
      }
    }
    function XL(r) {
      if (r !== jk)
        return u1(r);
    }
    function ZL() {
      return ul.current !== null;
    }
    function mY(r) {
      {
        if (r.mode & pn) {
          if (!TL())
            return;
        } else if (!LZ() || Sn !== Eo || r.tag !== h && r.tag !== D && r.tag !== $)
          return;
        if (ul.current === null) {
          var i = or;
          try {
            _n(r), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ut(r));
          } finally {
            i ? _n(r) : kr();
          }
        }
      }
    }
    function vY(r) {
      r.tag !== Ld && TL() && ul.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function $b(r) {
      OL = r;
    }
    var fs = null, mv = null, gY = function(r) {
      fs = r;
    };
    function vv(r) {
      {
        if (fs === null)
          return r;
        var i = fs(r);
        return i === void 0 ? r : i.current;
      }
    }
    function Wk(r) {
      return vv(r);
    }
    function Uk(r) {
      {
        if (fs === null)
          return r;
        var i = fs(r);
        if (i === void 0) {
          if (r != null && typeof r.render == "function") {
            var d = vv(r.render);
            if (r.render !== d) {
              var p = {
                $$typeof: Il,
                render: d
              };
              return r.displayName !== void 0 && (p.displayName = r.displayName), p;
            }
          }
          return r;
        }
        return i.current;
      }
    }
    function YL(r, i) {
      {
        if (fs === null)
          return !1;
        var d = r.elementType, p = i.type, y = !1, C = typeof p == "object" && p !== null ? p.$$typeof : null;
        switch (r.tag) {
          case v: {
            typeof p == "function" && (y = !0);
            break;
          }
          case h: {
            (typeof p == "function" || C === mo) && (y = !0);
            break;
          }
          case D: {
            (C === Il || C === mo) && (y = !0);
            break;
          }
          case V:
          case $: {
            (C === Al || C === mo) && (y = !0);
            break;
          }
          default:
            return !1;
        }
        if (y) {
          var k = fs(d);
          if (k !== void 0 && k === fs(p))
            return !0;
        }
        return !1;
      }
    }
    function JL(r) {
      {
        if (fs === null || typeof WeakSet != "function")
          return;
        mv === null && (mv = /* @__PURE__ */ new WeakSet()), mv.add(r);
      }
    }
    var yY = function(r, i) {
      {
        if (fs === null)
          return;
        var d = i.staleFamilies, p = i.updatedFamilies;
        vc(), mc(function() {
          Xk(r.current, p, d);
        });
      }
    }, bY = function(r, i) {
      {
        if (r.context !== Fa)
          return;
        vc(), mc(function() {
          zb(i, r, null, null);
        });
      }
    };
    function Xk(r, i, d) {
      {
        var p = r.alternate, y = r.child, C = r.sibling, k = r.tag, O = r.type, N = null;
        switch (k) {
          case h:
          case $:
          case v:
            N = O;
            break;
          case D:
            N = O.render;
            break;
        }
        if (fs === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var z = !1, j = !1;
        if (N !== null) {
          var ue = fs(N);
          ue !== void 0 && (d.has(ue) ? j = !0 : i.has(ue) && (k === v ? j = !0 : z = !0));
        }
        if (mv !== null && (mv.has(r) || p !== null && mv.has(p)) && (j = !0), j && (r._debugNeedsRemount = !0), j || z) {
          var ae = sa(r, Lt);
          ae !== null && Ao(ae, r, Lt, tr);
        }
        y !== null && !j && Xk(y, i, d), C !== null && Xk(C, i, d);
      }
    }
    var SY = function(r, i) {
      {
        var d = /* @__PURE__ */ new Set(), p = new Set(i.map(function(y) {
          return y.current;
        }));
        return Zk(r.current, p, d), d;
      }
    };
    function Zk(r, i, d) {
      {
        var p = r.child, y = r.sibling, C = r.tag, k = r.type, O = null;
        switch (C) {
          case h:
          case $:
          case v:
            O = k;
            break;
          case D:
            O = k.render;
            break;
        }
        var N = !1;
        O !== null && i.has(O) && (N = !0), N ? xY(r, d) : p !== null && Zk(p, i, d), y !== null && Zk(y, i, d);
      }
    }
    function xY(r, i) {
      {
        var d = CY(r, i);
        if (d)
          return;
        for (var p = r; ; ) {
          switch (p.tag) {
            case w:
              i.add(p.stateNode);
              return;
            case S:
              i.add(p.stateNode.containerInfo);
              return;
            case b:
              i.add(p.stateNode.containerInfo);
              return;
          }
          if (p.return === null)
            throw new Error("Expected to reach root first.");
          p = p.return;
        }
      }
    }
    function CY(r, i) {
      for (var d = r, p = !1; ; ) {
        if (d.tag === w)
          p = !0, i.add(d.stateNode);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === r)
          return p;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === r)
            return p;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !1;
    }
    var Yk;
    {
      Yk = !1;
      try {
        var QL = Object.preventExtensions({});
      } catch {
        Yk = !0;
      }
    }
    function wY(r, i, d, p) {
      this.tag = r, this.key = d, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = i, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = p, this.flags = At, this.subtreeFlags = At, this.deletions = null, this.lanes = Be, this.childLanes = Be, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Yk && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ba = function(r, i, d, p) {
      return new wY(r, i, d, p);
    };
    function Jk(r) {
      var i = r.prototype;
      return !!(i && i.isReactComponent);
    }
    function EY(r) {
      return typeof r == "function" && !Jk(r) && r.defaultProps === void 0;
    }
    function TY(r) {
      if (typeof r == "function")
        return Jk(r) ? v : h;
      if (r != null) {
        var i = r.$$typeof;
        if (i === Il)
          return D;
        if (i === Al)
          return V;
      }
      return g;
    }
    function Bp(r, i) {
      var d = r.alternate;
      d === null ? (d = Ba(r.tag, i, r.key, r.mode), d.elementType = r.elementType, d.type = r.type, d.stateNode = r.stateNode, d._debugSource = r._debugSource, d._debugOwner = r._debugOwner, d._debugHookTypes = r._debugHookTypes, d.alternate = r, r.alternate = d) : (d.pendingProps = i, d.type = r.type, d.flags = At, d.subtreeFlags = At, d.deletions = null, d.actualDuration = 0, d.actualStartTime = -1), d.flags = r.flags & go, d.childLanes = r.childLanes, d.lanes = r.lanes, d.child = r.child, d.memoizedProps = r.memoizedProps, d.memoizedState = r.memoizedState, d.updateQueue = r.updateQueue;
      var p = r.dependencies;
      switch (d.dependencies = p === null ? null : {
        lanes: p.lanes,
        firstContext: p.firstContext
      }, d.sibling = r.sibling, d.index = r.index, d.ref = r.ref, d.selfBaseDuration = r.selfBaseDuration, d.treeBaseDuration = r.treeBaseDuration, d._debugNeedsRemount = r._debugNeedsRemount, d.tag) {
        case g:
        case h:
        case $:
          d.type = vv(r.type);
          break;
        case v:
          d.type = Wk(r.type);
          break;
        case D:
          d.type = Uk(r.type);
          break;
      }
      return d;
    }
    function IY(r, i) {
      r.flags &= go | ir;
      var d = r.alternate;
      if (d === null)
        r.childLanes = Be, r.lanes = i, r.child = null, r.subtreeFlags = At, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null, r.selfBaseDuration = 0, r.treeBaseDuration = 0;
      else {
        r.childLanes = d.childLanes, r.lanes = d.lanes, r.child = d.child, r.subtreeFlags = At, r.deletions = null, r.memoizedProps = d.memoizedProps, r.memoizedState = d.memoizedState, r.updateQueue = d.updateQueue, r.type = d.type;
        var p = d.dependencies;
        r.dependencies = p === null ? null : {
          lanes: p.lanes,
          firstContext: p.firstContext
        }, r.selfBaseDuration = d.selfBaseDuration, r.treeBaseDuration = d.treeBaseDuration;
      }
      return r;
    }
    function AY(r, i, d) {
      var p;
      return r === cx ? (p = pn, i === !0 && (p |= br, p |= ea)) : p = _t, yo && (p |= Mt), Ba(b, null, null, p);
    }
    function Qk(r, i, d, p, y, C) {
      var k = g, O = r;
      if (typeof r == "function")
        Jk(r) ? (k = v, O = Wk(O)) : O = vv(O);
      else if (typeof r == "string")
        k = w;
      else
        e:
          switch (r) {
            case Aa:
              return Yd(d.children, y, C, i);
            case Ti:
              k = A, y |= br, (y & pn) !== _t && (y |= ea);
              break;
            case Tu:
              return kY(d, y, C, i);
            case Ui:
              return RY(d, y, C, i);
            case Xi:
              return PY(d, y, C, i);
            case Of:
              return KL(d, y, C, i);
            case Ih:
            case Eh:
            case _f:
            case Ng:
            case Th:
            default: {
              if (typeof r == "object" && r !== null)
                switch (r.$$typeof) {
                  case Rf:
                    k = _;
                    break e;
                  case Pf:
                    k = P;
                    break e;
                  case Il:
                    k = D, O = Uk(O);
                    break e;
                  case Al:
                    k = V;
                    break e;
                  case mo:
                    k = U, O = null;
                    break e;
                }
              var N = "";
              {
                (r === void 0 || typeof r == "object" && r !== null && Object.keys(r).length === 0) && (N += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var z = p ? Ut(p) : null;
                z && (N += `

Check the render method of \`` + z + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (r == null ? r : typeof r) + "." + N));
            }
          }
      var j = Ba(k, d, i, y);
      return j.elementType = r, j.type = O, j.lanes = C, j._debugOwner = p, j;
    }
    function Kk(r, i, d) {
      var p = null;
      p = r._owner;
      var y = r.type, C = r.key, k = r.props, O = Qk(y, C, k, p, i, d);
      return O._debugSource = r._source, O._debugOwner = r._owner, O;
    }
    function Yd(r, i, d, p) {
      var y = Ba(T, r, p, i);
      return y.lanes = d, y;
    }
    function kY(r, i, d, p) {
      typeof r.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof r.id);
      var y = Ba(L, r, p, i | Mt);
      return y.elementType = Tu, y.lanes = d, y.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, y;
    }
    function RY(r, i, d, p) {
      var y = Ba(F, r, p, i);
      return y.elementType = Ui, y.lanes = d, y;
    }
    function PY(r, i, d, p) {
      var y = Ba(G, r, p, i);
      return y.elementType = Xi, y.lanes = d, y;
    }
    function KL(r, i, d, p) {
      var y = Ba(ce, r, p, i);
      y.elementType = Of, y.lanes = d;
      var C = {
        isHidden: !1
      };
      return y.stateNode = C, y;
    }
    function qk(r, i, d) {
      var p = Ba(E, r, null, i);
      return p.lanes = d, p;
    }
    function OY() {
      var r = Ba(w, null, null, _t);
      return r.elementType = "DELETED", r;
    }
    function _Y(r) {
      var i = Ba(H, null, null, _t);
      return i.stateNode = r, i;
    }
    function eR(r, i, d) {
      var p = r.children !== null ? r.children : [], y = Ba(S, p, r.key, i);
      return y.lanes = d, y.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: r.implementation
      }, y;
    }
    function qL(r, i) {
      return r === null && (r = Ba(g, null, null, _t)), r.tag = i.tag, r.key = i.key, r.elementType = i.elementType, r.type = i.type, r.stateNode = i.stateNode, r.return = i.return, r.child = i.child, r.sibling = i.sibling, r.index = i.index, r.ref = i.ref, r.pendingProps = i.pendingProps, r.memoizedProps = i.memoizedProps, r.updateQueue = i.updateQueue, r.memoizedState = i.memoizedState, r.dependencies = i.dependencies, r.mode = i.mode, r.flags = i.flags, r.subtreeFlags = i.subtreeFlags, r.deletions = i.deletions, r.lanes = i.lanes, r.childLanes = i.childLanes, r.alternate = i.alternate, r.actualDuration = i.actualDuration, r.actualStartTime = i.actualStartTime, r.selfBaseDuration = i.selfBaseDuration, r.treeBaseDuration = i.treeBaseDuration, r._debugSource = i._debugSource, r._debugOwner = i._debugOwner, r._debugNeedsRemount = i._debugNeedsRemount, r._debugHookTypes = i._debugHookTypes, r;
    }
    function DY(r, i, d, p, y) {
      this.tag = i, this.containerInfo = r, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = MI, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = bn, this.eventTimes = Em(Be), this.expirationTimes = Em(tr), this.pendingLanes = Be, this.suspendedLanes = Be, this.pingedLanes = Be, this.expiredLanes = Be, this.mutableReadLanes = Be, this.finishedLanes = Be, this.entangledLanes = Be, this.entanglements = Em(Be), this.identifierPrefix = p, this.onRecoverableError = y, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var C = this.pendingUpdatersLaneMap = [], k = 0; k < sr; k++)
          C.push(/* @__PURE__ */ new Set());
      }
      switch (i) {
        case cx:
          this._debugRootType = d ? "hydrateRoot()" : "createRoot()";
          break;
        case Ld:
          this._debugRootType = d ? "hydrate()" : "render()";
          break;
      }
    }
    function eF(r, i, d, p, y, C, k, O, N, z) {
      var j = new DY(r, i, d, O, N), ue = AY(i, C);
      j.current = ue, ue.stateNode = j;
      {
        var ae = {
          element: p,
          isDehydrated: d,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ue.memoizedState = ae;
      }
      return lA(ue), j;
    }
    var tR = "18.2.0";
    function NY(r, i, d) {
      var p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return tn(p), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Po,
        key: p == null ? null : "" + p,
        children: r,
        containerInfo: i,
        implementation: d
      };
    }
    var nR, rR;
    nR = !1, rR = {};
    function tF(r) {
      if (!r)
        return Fa;
      var i = Yi(r), d = gX(i);
      if (i.tag === v) {
        var p = i.type;
        if (Ql(p))
          return AN(i, p, d);
      }
      return d;
    }
    function MY(r, i) {
      {
        var d = Yi(r);
        if (d === void 0) {
          if (typeof r.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var p = Object.keys(r).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + p);
        }
        var y = qi(d);
        if (y === null)
          return null;
        if (y.mode & br) {
          var C = Ut(d) || "Component";
          if (!rR[C]) {
            rR[C] = !0;
            var k = or;
            try {
              _n(y), d.mode & br ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", i, i, C) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", i, i, C);
            } finally {
              k ? _n(k) : kr();
            }
          }
        }
        return y.stateNode;
      }
    }
    function nF(r, i, d, p, y, C, k, O) {
      var N = !1, z = null;
      return eF(r, i, N, z, d, p, y, C, k);
    }
    function rF(r, i, d, p, y, C, k, O, N, z) {
      var j = !0, ue = eF(d, p, j, r, y, C, k, O, N);
      ue.context = tF(null);
      var ae = ue.current, Ae = Mi(), ke = Xd(ae), Ne = dc(Ae, ke);
      return Ne.callback = i ?? null, Vd(ae, Ne, ke), HZ(ue, ke, Ae), ue;
    }
    function zb(r, i, d, p) {
      d1(i, r);
      var y = i.current, C = Mi(), k = Xd(y);
      zu(k);
      var O = tF(d);
      i.context === null ? i.context = O : i.pendingContext = O, Oo && or !== null && !nR && (nR = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ut(or) || "Unknown"));
      var N = dc(C, k);
      N.payload = {
        element: r
      }, p = p === void 0 ? null : p, p !== null && (typeof p != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", p), N.callback = p);
      var z = Vd(y, N, k);
      return z !== null && (Ao(z, y, k, C), wx(z, y, k)), k;
    }
    function hC(r) {
      var i = r.current;
      if (!i.child)
        return null;
      switch (i.child.tag) {
        case w:
          return i.child.stateNode;
        default:
          return i.child.stateNode;
      }
    }
    function LY(r) {
      switch (r.tag) {
        case b: {
          var i = r.stateNode;
          if (Yr(i)) {
            var d = tI(i);
            UZ(i, d);
          }
          break;
        }
        case F: {
          mc(function() {
            var y = sa(r, Lt);
            if (y !== null) {
              var C = Mi();
              Ao(y, r, Lt, C);
            }
          });
          var p = Lt;
          oR(r, p);
          break;
        }
      }
    }
    function oF(r, i) {
      var d = r.memoizedState;
      d !== null && d.dehydrated !== null && (d.retryLane = w1(d.retryLane, i));
    }
    function oR(r, i) {
      oF(r, i);
      var d = r.alternate;
      d && oF(d, i);
    }
    function FY(r) {
      if (r.tag === F) {
        var i = hd, d = sa(r, i);
        if (d !== null) {
          var p = Mi();
          Ao(d, r, i, p);
        }
        oR(r, i);
      }
    }
    function BY(r) {
      if (r.tag === F) {
        var i = Xd(r), d = sa(r, i);
        if (d !== null) {
          var p = Mi();
          Ao(d, r, i, p);
        }
        oR(r, i);
      }
    }
    function iF(r) {
      var i = l1(r);
      return i === null ? null : i.stateNode;
    }
    var aF = function(r) {
      return null;
    };
    function VY(r) {
      return aF(r);
    }
    var sF = function(r) {
      return !1;
    };
    function $Y(r) {
      return sF(r);
    }
    var lF = null, uF = null, cF = null, dF = null, fF = null, pF = null, hF = null, mF = null, vF = null;
    {
      var gF = function(r, i, d) {
        var p = i[d], y = eo(r) ? r.slice() : on({}, r);
        return d + 1 === i.length ? (eo(y) ? y.splice(p, 1) : delete y[p], y) : (y[p] = gF(r[p], i, d + 1), y);
      }, yF = function(r, i) {
        return gF(r, i, 0);
      }, bF = function(r, i, d, p) {
        var y = i[p], C = eo(r) ? r.slice() : on({}, r);
        if (p + 1 === i.length) {
          var k = d[p];
          C[k] = C[y], eo(C) ? C.splice(y, 1) : delete C[y];
        } else
          C[y] = bF(
            // $FlowFixMe number or string is fine here
            r[y],
            i,
            d,
            p + 1
          );
        return C;
      }, SF = function(r, i, d) {
        if (i.length !== d.length) {
          l("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var p = 0; p < d.length - 1; p++)
            if (i[p] !== d[p]) {
              l("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return bF(r, i, d, 0);
      }, xF = function(r, i, d, p) {
        if (d >= i.length)
          return p;
        var y = i[d], C = eo(r) ? r.slice() : on({}, r);
        return C[y] = xF(r[y], i, d + 1, p), C;
      }, CF = function(r, i, d) {
        return xF(r, i, 0, d);
      }, iR = function(r, i) {
        for (var d = r.memoizedState; d !== null && i > 0; )
          d = d.next, i--;
        return d;
      };
      lF = function(r, i, d, p) {
        var y = iR(r, i);
        if (y !== null) {
          var C = CF(y.memoizedState, d, p);
          y.memoizedState = C, y.baseState = C, r.memoizedProps = on({}, r.memoizedProps);
          var k = sa(r, Lt);
          k !== null && Ao(k, r, Lt, tr);
        }
      }, uF = function(r, i, d) {
        var p = iR(r, i);
        if (p !== null) {
          var y = yF(p.memoizedState, d);
          p.memoizedState = y, p.baseState = y, r.memoizedProps = on({}, r.memoizedProps);
          var C = sa(r, Lt);
          C !== null && Ao(C, r, Lt, tr);
        }
      }, cF = function(r, i, d, p) {
        var y = iR(r, i);
        if (y !== null) {
          var C = SF(y.memoizedState, d, p);
          y.memoizedState = C, y.baseState = C, r.memoizedProps = on({}, r.memoizedProps);
          var k = sa(r, Lt);
          k !== null && Ao(k, r, Lt, tr);
        }
      }, dF = function(r, i, d) {
        r.pendingProps = CF(r.memoizedProps, i, d), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var p = sa(r, Lt);
        p !== null && Ao(p, r, Lt, tr);
      }, fF = function(r, i) {
        r.pendingProps = yF(r.memoizedProps, i), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var d = sa(r, Lt);
        d !== null && Ao(d, r, Lt, tr);
      }, pF = function(r, i, d) {
        r.pendingProps = SF(r.memoizedProps, i, d), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var p = sa(r, Lt);
        p !== null && Ao(p, r, Lt, tr);
      }, hF = function(r) {
        var i = sa(r, Lt);
        i !== null && Ao(i, r, Lt, tr);
      }, mF = function(r) {
        aF = r;
      }, vF = function(r) {
        sF = r;
      };
    }
    function zY(r) {
      var i = qi(r);
      return i === null ? null : i.stateNode;
    }
    function HY(r) {
      return null;
    }
    function jY() {
      return or;
    }
    function GY(r) {
      var i = r.findFiberByHostInstance, d = n.ReactCurrentDispatcher;
      return hy({
        bundleType: r.bundleType,
        version: r.version,
        rendererPackageName: r.rendererPackageName,
        rendererConfig: r.rendererConfig,
        overrideHookState: lF,
        overrideHookStateDeletePath: uF,
        overrideHookStateRenamePath: cF,
        overrideProps: dF,
        overridePropsDeletePath: fF,
        overridePropsRenamePath: pF,
        setErrorHandler: mF,
        setSuspenseHandler: vF,
        scheduleUpdate: hF,
        currentDispatcherRef: d,
        findHostInstanceByFiber: zY,
        findFiberByHostInstance: i || HY,
        // React Refresh
        findHostInstancesForRefresh: SY,
        scheduleRefresh: yY,
        scheduleRoot: bY,
        setRefreshHandler: gY,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: jY,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: tR
      });
    }
    var wF = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(r) {
      console.error(r);
    };
    function aR(r) {
      this._internalRoot = r;
    }
    mC.prototype.render = aR.prototype.render = function(r) {
      var i = this._internalRoot;
      if (i === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : vC(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var d = i.containerInfo;
        if (d.nodeType !== Mr) {
          var p = iF(i.current);
          p && p.parentNode !== d && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      zb(r, i, null, null);
    }, mC.prototype.unmount = aR.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var r = this._internalRoot;
      if (r !== null) {
        this._internalRoot = null;
        var i = r.containerInfo;
        ML() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), mc(function() {
          zb(null, r, null, null);
        }), CN(i);
      }
    };
    function WY(r, i) {
      if (!vC(r))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      EF(r);
      var d = !1, p = !1, y = "", C = wF;
      i != null && (i.hydrate ? l("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof i == "object" && i !== null && i.$$typeof === Qa && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), i.unstable_strictMode === !0 && (d = !0), i.identifierPrefix !== void 0 && (y = i.identifierPrefix), i.onRecoverableError !== void 0 && (C = i.onRecoverableError), i.transitionCallbacks !== void 0 && i.transitionCallbacks);
      var k = nF(r, cx, null, d, p, y, C);
      rx(k.current, r);
      var O = r.nodeType === Mr ? r.parentNode : r;
      return Yy(O), new aR(k);
    }
    function mC(r) {
      this._internalRoot = r;
    }
    function UY(r) {
      r && O1(r);
    }
    mC.prototype.unstable_scheduleHydration = UY;
    function XY(r, i, d) {
      if (!vC(r))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      EF(r), i === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var p = d ?? null, y = d != null && d.hydratedSources || null, C = !1, k = !1, O = "", N = wF;
      d != null && (d.unstable_strictMode === !0 && (C = !0), d.identifierPrefix !== void 0 && (O = d.identifierPrefix), d.onRecoverableError !== void 0 && (N = d.onRecoverableError));
      var z = rF(i, null, r, cx, p, C, k, O, N);
      if (rx(z.current, r), Yy(r), y)
        for (var j = 0; j < y.length; j++) {
          var ue = y[j];
          t7(z, ue);
        }
      return new mC(z);
    }
    function vC(r) {
      return !!(r && (r.nodeType === si || r.nodeType === _a || r.nodeType === _u || !de));
    }
    function Hb(r) {
      return !!(r && (r.nodeType === si || r.nodeType === _a || r.nodeType === _u || r.nodeType === Mr && r.nodeValue === " react-mount-point-unstable "));
    }
    function EF(r) {
      r.nodeType === si && r.tagName && r.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), ab(r) && (r._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var ZY = n.ReactCurrentOwner, TF;
    TF = function(r) {
      if (r._reactRootContainer && r.nodeType !== Mr) {
        var i = iF(r._reactRootContainer.current);
        i && i.parentNode !== r && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var d = !!r._reactRootContainer, p = sR(r), y = !!(p && Nd(p));
      y && !d && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), r.nodeType === si && r.tagName && r.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function sR(r) {
      return r ? r.nodeType === _a ? r.documentElement : r.firstChild : null;
    }
    function IF() {
    }
    function YY(r, i, d, p, y) {
      if (y) {
        if (typeof p == "function") {
          var C = p;
          p = function() {
            var ae = hC(k);
            C.call(ae);
          };
        }
        var k = rF(
          i,
          p,
          r,
          Ld,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          IF
        );
        r._reactRootContainer = k, rx(k.current, r);
        var O = r.nodeType === Mr ? r.parentNode : r;
        return Yy(O), mc(), k;
      } else {
        for (var N; N = r.lastChild; )
          r.removeChild(N);
        if (typeof p == "function") {
          var z = p;
          p = function() {
            var ae = hC(j);
            z.call(ae);
          };
        }
        var j = nF(
          r,
          Ld,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          IF
        );
        r._reactRootContainer = j, rx(j.current, r);
        var ue = r.nodeType === Mr ? r.parentNode : r;
        return Yy(ue), mc(function() {
          zb(i, j, d, p);
        }), j;
      }
    }
    function JY(r, i) {
      r !== null && typeof r != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", i, r);
    }
    function gC(r, i, d, p, y) {
      TF(d), JY(y === void 0 ? null : y, "render");
      var C = d._reactRootContainer, k;
      if (!C)
        k = YY(d, i, r, y, p);
      else {
        if (k = C, typeof y == "function") {
          var O = y;
          y = function() {
            var N = hC(k);
            O.call(N);
          };
        }
        zb(i, k, r, y);
      }
      return hC(k);
    }
    function QY(r) {
      {
        var i = ZY.current;
        if (i !== null && i.stateNode !== null) {
          var d = i.stateNode._warnedAboutRefsInRender;
          d || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", $n(i.type) || "A component"), i.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return r == null ? null : r.nodeType === si ? r : MY(r, "findDOMNode");
    }
    function KY(r, i, d) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hb(i))
        throw new Error("Target container is not a DOM element.");
      {
        var p = ab(i) && i._reactRootContainer === void 0;
        p && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return gC(null, r, i, !0, d);
    }
    function qY(r, i, d) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hb(i))
        throw new Error("Target container is not a DOM element.");
      {
        var p = ab(i) && i._reactRootContainer === void 0;
        p && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return gC(null, r, i, !1, d);
    }
    function eJ(r, i, d, p) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Hb(d))
        throw new Error("Target container is not a DOM element.");
      if (r == null || !Kf(r))
        throw new Error("parentComponent must be a valid React Component");
      return gC(r, i, d, !1, p);
    }
    function tJ(r) {
      if (!Hb(r))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var i = ab(r) && r._reactRootContainer === void 0;
        i && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (r._reactRootContainer) {
        {
          var d = sR(r), p = d && !Nd(d);
          p && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return mc(function() {
          gC(null, null, r, !1, function() {
            r._reactRootContainer = null, CN(r);
          });
        }), !0;
      } else {
        {
          var y = sR(r), C = !!(y && Nd(y)), k = r.nodeType === si && Hb(r.parentNode) && !!r.parentNode._reactRootContainer;
          C && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", k ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    yt(LY), T1(FY), pp(BY), Oy(na), A1(cp), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), i1(o8), Wh(Bk, XZ, mc);
    function nJ(r, i) {
      var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!vC(i))
        throw new Error("Target container is not a DOM element.");
      return NY(r, i, null, d);
    }
    function rJ(r, i, d, p) {
      return eJ(r, i, d, p);
    }
    var lR = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Nd, Xm, ox, Gh, Yf, Bk]
    };
    function oJ(r, i) {
      return lR.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), WY(r, i);
    }
    function iJ(r, i, d) {
      return lR.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), XY(r, i, d);
    }
    function aJ(r) {
      return ML() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), mc(r);
    }
    var sJ = GY({
      findFiberByHostInstance: wp,
      bundleType: 1,
      version: tR,
      rendererPackageName: "react-dom"
    });
    if (!sJ && ze && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var AF = window.location.protocol;
      /^(https?|file):$/.test(AF) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (AF === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    da.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lR, da.createPortal = nJ, da.createRoot = oJ, da.findDOMNode = QY, da.flushSync = aJ, da.hydrate = KY, da.hydrateRoot = iJ, da.render = qY, da.unmountComponentAtNode = tJ, da.unstable_batchedUpdates = Bk, da.unstable_renderSubtreeIntoContainer = rJ, da.version = tR, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), da;
}
var fa = {};
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YF;
function NQ() {
  if (YF)
    return fa;
  YF = 1;
  var e = Tt, t = u4();
  function n(s) {
    for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, m = 1; m < arguments.length; m++)
      c += "&args[]=" + encodeURIComponent(arguments[m]);
    return "Minified React error #" + s + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var o = /* @__PURE__ */ new Set(), a = {};
  function l(s, c) {
    u(s, c), u(s + "Capture", c);
  }
  function u(s, c) {
    for (a[s] = c, s = 0; s < c.length; s++)
      o.add(c[s]);
  }
  var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, g = {}, b = {};
  function S(s) {
    return h.call(b, s) ? !0 : h.call(g, s) ? !1 : v.test(s) ? b[s] = !0 : (g[s] = !0, !1);
  }
  function w(s, c, m, x) {
    if (m !== null && m.type === 0)
      return !1;
    switch (typeof c) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return x ? !1 : m !== null ? !m.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
      default:
        return !1;
    }
  }
  function E(s, c, m, x) {
    if (c === null || typeof c > "u" || w(s, c, m, x))
      return !0;
    if (x)
      return !1;
    if (m !== null)
      switch (m.type) {
        case 3:
          return !c;
        case 4:
          return c === !1;
        case 5:
          return isNaN(c);
        case 6:
          return isNaN(c) || 1 > c;
      }
    return !1;
  }
  function T(s, c, m, x, I, R, B) {
    this.acceptsBooleans = c === 2 || c === 3 || c === 4, this.attributeName = x, this.attributeNamespace = I, this.mustUseProperty = m, this.propertyName = s, this.type = c, this.sanitizeURL = R, this.removeEmptyString = B;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    A[s] = new T(s, 0, !1, s, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var c = s[0];
    A[c] = new T(c, 1, !1, s[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    A[s] = new T(s, 2, !1, s.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    A[s] = new T(s, 2, !1, s, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    A[s] = new T(s, 3, !1, s.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(s) {
    A[s] = new T(s, 3, !0, s, null, !1, !1);
  }), ["capture", "download"].forEach(function(s) {
    A[s] = new T(s, 4, !1, s, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(s) {
    A[s] = new T(s, 6, !1, s, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(s) {
    A[s] = new T(s, 5, !1, s.toLowerCase(), null, !1, !1);
  });
  var P = /[\-:]([a-z])/g;
  function _(s) {
    return s[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var c = s.replace(
      P,
      _
    );
    A[c] = new T(c, 1, !1, s, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var c = s.replace(P, _);
    A[c] = new T(c, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var c = s.replace(P, _);
    A[c] = new T(c, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(s) {
    A[s] = new T(s, 1, !1, s.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(s) {
    A[s] = new T(s, 1, !1, s.toLowerCase(), null, !0, !0);
  });
  function D(s, c, m, x) {
    var I = A.hasOwnProperty(c) ? A[c] : null;
    (I !== null ? I.type !== 0 : x || !(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (E(c, m, I, x) && (m = null), x || I === null ? S(c) && (m === null ? s.removeAttribute(c) : s.setAttribute(c, "" + m)) : I.mustUseProperty ? s[I.propertyName] = m === null ? I.type === 3 ? !1 : "" : m : (c = I.attributeName, x = I.attributeNamespace, m === null ? s.removeAttribute(c) : (I = I.type, m = I === 3 || I === 4 && m === !0 ? "" : "" + m, x ? s.setAttributeNS(x, c, m) : s.setAttribute(c, m))));
  }
  var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, F = Symbol.for("react.element"), V = Symbol.for("react.portal"), $ = Symbol.for("react.fragment"), U = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), H = Symbol.for("react.provider"), G = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), ce = Symbol.for("react.suspense"), te = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), me = Symbol.for("react.lazy"), J = Symbol.for("react.offscreen"), Q = Symbol.iterator;
  function ge(s) {
    return s === null || typeof s != "object" ? null : (s = Q && s[Q] || s["@@iterator"], typeof s == "function" ? s : null);
  }
  var Y = Object.assign, q;
  function de(s) {
    if (q === void 0)
      try {
        throw Error();
      } catch (m) {
        var c = m.stack.trim().match(/\n( *(at )?)/);
        q = c && c[1] || "";
      }
    return `
` + q + s;
  }
  var K = !1;
  function ne(s, c) {
    if (!s || K)
      return "";
    K = !0;
    var m = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (c = function() {
          throw Error();
        }, Object.defineProperty(c.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(c, []);
          } catch (Pe) {
            var x = Pe;
          }
          Reflect.construct(s, [], c);
        } else {
          try {
            c.call();
          } catch (Pe) {
            x = Pe;
          }
          s.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Pe) {
          x = Pe;
        }
        s();
      }
    } catch (Pe) {
      if (Pe && x && typeof Pe.stack == "string") {
        for (var I = Pe.stack.split(`
`), R = x.stack.split(`
`), B = I.length - 1, Z = R.length - 1; 1 <= B && 0 <= Z && I[B] !== R[Z]; )
          Z--;
        for (; 1 <= B && 0 <= Z; B--, Z--)
          if (I[B] !== R[Z]) {
            if (B !== 1 || Z !== 1)
              do
                if (B--, Z--, 0 > Z || I[B] !== R[Z]) {
                  var ee = `
` + I[B].replace(" at new ", " at ");
                  return s.displayName && ee.includes("<anonymous>") && (ee = ee.replace("<anonymous>", s.displayName)), ee;
                }
              while (1 <= B && 0 <= Z);
            break;
          }
      }
    } finally {
      K = !1, Error.prepareStackTrace = m;
    }
    return (s = s ? s.displayName || s.name : "") ? de(s) : "";
  }
  function pe(s) {
    switch (s.tag) {
      case 5:
        return de(s.type);
      case 16:
        return de("Lazy");
      case 13:
        return de("Suspense");
      case 19:
        return de("SuspenseList");
      case 0:
      case 2:
      case 15:
        return s = ne(s.type, !1), s;
      case 11:
        return s = ne(s.type.render, !1), s;
      case 1:
        return s = ne(s.type, !0), s;
      default:
        return "";
    }
  }
  function Oe(s) {
    if (s == null)
      return null;
    if (typeof s == "function")
      return s.displayName || s.name || null;
    if (typeof s == "string")
      return s;
    switch (s) {
      case $:
        return "Fragment";
      case V:
        return "Portal";
      case W:
        return "Profiler";
      case U:
        return "StrictMode";
      case ce:
        return "Suspense";
      case te:
        return "SuspenseList";
    }
    if (typeof s == "object")
      switch (s.$$typeof) {
        case G:
          return (s.displayName || "Context") + ".Consumer";
        case H:
          return (s._context.displayName || "Context") + ".Provider";
        case oe:
          var c = s.render;
          return s = s.displayName, s || (s = c.displayName || c.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
        case Ee:
          return c = s.displayName || null, c !== null ? c : Oe(s.type) || "Memo";
        case me:
          c = s._payload, s = s._init;
          try {
            return Oe(s(c));
          } catch {
          }
      }
    return null;
  }
  function Ce(s) {
    var c = s.type;
    switch (s.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return s = c.render, s = s.displayName || s.name || "", c.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Oe(c);
      case 8:
        return c === U ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function")
          return c.displayName || c.name || null;
        if (typeof c == "string")
          return c;
    }
    return null;
  }
  function xe(s) {
    switch (typeof s) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function ie(s) {
    var c = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (c === "checkbox" || c === "radio");
  }
  function ye(s) {
    var c = ie(s) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(s.constructor.prototype, c), x = "" + s[c];
    if (!s.hasOwnProperty(c) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
      var I = m.get, R = m.set;
      return Object.defineProperty(s, c, { configurable: !0, get: function() {
        return I.call(this);
      }, set: function(B) {
        x = "" + B, R.call(this, B);
      } }), Object.defineProperty(s, c, { enumerable: m.enumerable }), { getValue: function() {
        return x;
      }, setValue: function(B) {
        x = "" + B;
      }, stopTracking: function() {
        s._valueTracker = null, delete s[c];
      } };
    }
  }
  function we(s) {
    s._valueTracker || (s._valueTracker = ye(s));
  }
  function fe(s) {
    if (!s)
      return !1;
    var c = s._valueTracker;
    if (!c)
      return !0;
    var m = c.getValue(), x = "";
    return s && (x = ie(s) ? s.checked ? "true" : "false" : s.value), s = x, s !== m ? (c.setValue(s), !0) : !1;
  }
  function ze(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u")
      return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function Ve(s, c) {
    var m = c.checked;
    return Y({}, c, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? s._wrapperState.initialChecked });
  }
  function Ie(s, c) {
    var m = c.defaultValue == null ? "" : c.defaultValue, x = c.checked != null ? c.checked : c.defaultChecked;
    m = xe(c.value != null ? c.value : m), s._wrapperState = { initialChecked: x, initialValue: m, controlled: c.type === "checkbox" || c.type === "radio" ? c.checked != null : c.value != null };
  }
  function qe(s, c) {
    c = c.checked, c != null && D(s, "checked", c, !1);
  }
  function Qe(s, c) {
    qe(s, c);
    var m = xe(c.value), x = c.type;
    if (m != null)
      x === "number" ? (m === 0 && s.value === "" || s.value != m) && (s.value = "" + m) : s.value !== "" + m && (s.value = "" + m);
    else if (x === "submit" || x === "reset") {
      s.removeAttribute("value");
      return;
    }
    c.hasOwnProperty("value") ? tn(s, c.type, m) : c.hasOwnProperty("defaultValue") && tn(s, c.type, xe(c.defaultValue)), c.checked == null && c.defaultChecked != null && (s.defaultChecked = !!c.defaultChecked);
  }
  function lt(s, c, m) {
    if (c.hasOwnProperty("value") || c.hasOwnProperty("defaultValue")) {
      var x = c.type;
      if (!(x !== "submit" && x !== "reset" || c.value !== void 0 && c.value !== null))
        return;
      c = "" + s._wrapperState.initialValue, m || c === s.value || (s.value = c), s.defaultValue = c;
    }
    m = s.name, m !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, m !== "" && (s.name = m);
  }
  function tn(s, c, m) {
    (c !== "number" || ze(s.ownerDocument) !== s) && (m == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + m && (s.defaultValue = "" + m));
  }
  var Yt = Array.isArray;
  function hn(s, c, m, x) {
    if (s = s.options, c) {
      c = {};
      for (var I = 0; I < m.length; I++)
        c["$" + m[I]] = !0;
      for (m = 0; m < s.length; m++)
        I = c.hasOwnProperty("$" + s[m].value), s[m].selected !== I && (s[m].selected = I), I && x && (s[m].defaultSelected = !0);
    } else {
      for (m = "" + xe(m), c = null, I = 0; I < s.length; I++) {
        if (s[I].value === m) {
          s[I].selected = !0, x && (s[I].defaultSelected = !0);
          return;
        }
        c !== null || s[I].disabled || (c = s[I]);
      }
      c !== null && (c.selected = !0);
    }
  }
  function vn(s, c) {
    if (c.dangerouslySetInnerHTML != null)
      throw Error(n(91));
    return Y({}, c, { value: void 0, defaultValue: void 0, children: "" + s._wrapperState.initialValue });
  }
  function nn(s, c) {
    var m = c.value;
    if (m == null) {
      if (m = c.children, c = c.defaultValue, m != null) {
        if (c != null)
          throw Error(n(92));
        if (Yt(m)) {
          if (1 < m.length)
            throw Error(n(93));
          m = m[0];
        }
        c = m;
      }
      c == null && (c = ""), m = c;
    }
    s._wrapperState = { initialValue: xe(m) };
  }
  function rn(s, c) {
    var m = xe(c.value), x = xe(c.defaultValue);
    m != null && (m = "" + m, m !== s.value && (s.value = m), c.defaultValue == null && s.defaultValue !== m && (s.defaultValue = m)), x != null && (s.defaultValue = "" + x);
  }
  function mn(s) {
    var c = s.textContent;
    c === s._wrapperState.initialValue && c !== "" && c !== null && (s.value = c);
  }
  function un(s) {
    switch (s) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Tn(s, c) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? un(c) : s === "http://www.w3.org/2000/svg" && c === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s;
  }
  var je, Ot = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(c, m, x, I) {
      MSApp.execUnsafeLocalFunction(function() {
        return s(c, m, x, I);
      });
    } : s;
  }(function(s, c) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s)
      s.innerHTML = c;
    else {
      for (je = je || document.createElement("div"), je.innerHTML = "<svg>" + c.valueOf().toString() + "</svg>", c = je.firstChild; s.firstChild; )
        s.removeChild(s.firstChild);
      for (; c.firstChild; )
        s.appendChild(c.firstChild);
    }
  });
  function an(s, c) {
    if (c) {
      var m = s.firstChild;
      if (m && m === s.lastChild && m.nodeType === 3) {
        m.nodeValue = c;
        return;
      }
    }
    s.textContent = c;
  }
  var Xe = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, _e = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Xe).forEach(function(s) {
    _e.forEach(function(c) {
      c = c + s.charAt(0).toUpperCase() + s.substring(1), Xe[c] = Xe[s];
    });
  });
  function Je(s, c, m) {
    return c == null || typeof c == "boolean" || c === "" ? "" : m || typeof c != "number" || c === 0 || Xe.hasOwnProperty(s) && Xe[s] ? ("" + c).trim() : c + "px";
  }
  function Kt(s, c) {
    s = s.style;
    for (var m in c)
      if (c.hasOwnProperty(m)) {
        var x = m.indexOf("--") === 0, I = Je(m, c[m], x);
        m === "float" && (m = "cssFloat"), x ? s.setProperty(m, I) : s[m] = I;
      }
  }
  var He = Y({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function tt(s, c) {
    if (c) {
      if (He[s] && (c.children != null || c.dangerouslySetInnerHTML != null))
        throw Error(n(137, s));
      if (c.dangerouslySetInnerHTML != null) {
        if (c.children != null)
          throw Error(n(60));
        if (typeof c.dangerouslySetInnerHTML != "object" || !("__html" in c.dangerouslySetInnerHTML))
          throw Error(n(61));
      }
      if (c.style != null && typeof c.style != "object")
        throw Error(n(62));
    }
  }
  function ft(s, c) {
    if (s.indexOf("-") === -1)
      return typeof c.is == "string";
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var mt = null;
  function kt(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
  }
  var Mn = null, sn = null, Qt = null;
  function Ro(s) {
    if (s = Kf(s)) {
      if (typeof Mn != "function")
        throw Error(n(280));
      var c = s.stateNode;
      c && (c = At(c), Mn(s.stateNode, s.type, c));
    }
  }
  function Gr(s) {
    sn ? Qt ? Qt.push(s) : Qt = [s] : sn = s;
  }
  function ni() {
    if (sn) {
      var s = sn, c = Qt;
      if (Qt = sn = null, Ro(s), c)
        for (s = 0; s < c.length; s++)
          Ro(c[s]);
    }
  }
  function Yc(s, c) {
    return s(c);
  }
  function Ia() {
  }
  var Tl = !1;
  function Os(s, c, m) {
    if (Tl)
      return s(c, m);
    Tl = !0;
    try {
      return Yc(s, c, m);
    } finally {
      Tl = !1, (sn !== null || Qt !== null) && (Ia(), ni());
    }
  }
  function Wr(s, c) {
    var m = s.stateNode;
    if (m === null)
      return null;
    var x = At(m);
    if (x === null)
      return null;
    m = x[c];
    e:
      switch (c) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (x = !x.disabled) || (s = s.type, x = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !x;
          break e;
        default:
          s = !1;
      }
    if (s)
      return null;
    if (m && typeof m != "function")
      throw Error(n(231, c, typeof m));
    return m;
  }
  var Ja = !1;
  if (f)
    try {
      var Wi = {};
      Object.defineProperty(Wi, "passive", { get: function() {
        Ja = !0;
      } }), window.addEventListener("test", Wi, Wi), window.removeEventListener("test", Wi, Wi);
    } catch {
      Ja = !1;
    }
  function Qa(s, c, m, x, I, R, B, Z, ee) {
    var Pe = Array.prototype.slice.call(arguments, 3);
    try {
      c.apply(m, Pe);
    } catch (We) {
      this.onError(We);
    }
  }
  var Po = !1, Aa = null, Ti = !1, Tu = null, Rf = { onError: function(s) {
    Po = !0, Aa = s;
  } };
  function Pf(s, c, m, x, I, R, B, Z, ee) {
    Po = !1, Aa = null, Qa.apply(Rf, arguments);
  }
  function Il(s, c, m, x, I, R, B, Z, ee) {
    if (Pf.apply(this, arguments), Po) {
      if (Po) {
        var Pe = Aa;
        Po = !1, Aa = null;
      } else
        throw Error(n(198));
      Ti || (Ti = !0, Tu = Pe);
    }
  }
  function Ui(s) {
    var c = s, m = s;
    if (s.alternate)
      for (; c.return; )
        c = c.return;
    else {
      s = c;
      do
        c = s, c.flags & 4098 && (m = c.return), s = c.return;
      while (s);
    }
    return c.tag === 3 ? m : null;
  }
  function Xi(s) {
    if (s.tag === 13) {
      var c = s.memoizedState;
      if (c === null && (s = s.alternate, s !== null && (c = s.memoizedState)), c !== null)
        return c.dehydrated;
    }
    return null;
  }
  function Al(s) {
    if (Ui(s) !== s)
      throw Error(n(188));
  }
  function mo(s) {
    var c = s.alternate;
    if (!c) {
      if (c = Ui(s), c === null)
        throw Error(n(188));
      return c !== s ? null : s;
    }
    for (var m = s, x = c; ; ) {
      var I = m.return;
      if (I === null)
        break;
      var R = I.alternate;
      if (R === null) {
        if (x = I.return, x !== null) {
          m = x;
          continue;
        }
        break;
      }
      if (I.child === R.child) {
        for (R = I.child; R; ) {
          if (R === m)
            return Al(I), s;
          if (R === x)
            return Al(I), c;
          R = R.sibling;
        }
        throw Error(n(188));
      }
      if (m.return !== x.return)
        m = I, x = R;
      else {
        for (var B = !1, Z = I.child; Z; ) {
          if (Z === m) {
            B = !0, m = I, x = R;
            break;
          }
          if (Z === x) {
            B = !0, x = I, m = R;
            break;
          }
          Z = Z.sibling;
        }
        if (!B) {
          for (Z = R.child; Z; ) {
            if (Z === m) {
              B = !0, m = R, x = I;
              break;
            }
            if (Z === x) {
              B = !0, x = R, m = I;
              break;
            }
            Z = Z.sibling;
          }
          if (!B)
            throw Error(n(189));
        }
      }
      if (m.alternate !== x)
        throw Error(n(190));
    }
    if (m.tag !== 3)
      throw Error(n(188));
    return m.stateNode.current === m ? s : c;
  }
  function Eh(s) {
    return s = mo(s), s !== null ? Th(s) : null;
  }
  function Th(s) {
    if (s.tag === 5 || s.tag === 6)
      return s;
    for (s = s.child; s !== null; ) {
      var c = Th(s);
      if (c !== null)
        return c;
      s = s.sibling;
    }
    return null;
  }
  var Of = t.unstable_scheduleCallback, Ih = t.unstable_cancelCallback, _f = t.unstable_shouldYield, Ng = t.unstable_requestPaint, qn = t.unstable_now, Df = t.unstable_getCurrentPriorityLevel, ka = t.unstable_ImmediatePriority, on = t.unstable_UserBlockingPriority, Ra = t.unstable_NormalPriority, Ah = t.unstable_LowPriority, Nf = t.unstable_IdlePriority, Iu = null, ri = null;
  function kh(s) {
    if (ri && typeof ri.onCommitFiberRoot == "function")
      try {
        ri.onCommitFiberRoot(Iu, s, void 0, (s.current.flags & 128) === 128);
      } catch {
      }
  }
  var oi = Math.clz32 ? Math.clz32 : Mg, Rh = Math.log, Ph = Math.LN2;
  function Mg(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (Rh(s) / Ph | 0) | 0;
  }
  var Jc = 64, kl = 4194304;
  function _s(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function Ii(s, c) {
    var m = s.pendingLanes;
    if (m === 0)
      return 0;
    var x = 0, I = s.suspendedLanes, R = s.pingedLanes, B = m & 268435455;
    if (B !== 0) {
      var Z = B & ~I;
      Z !== 0 ? x = _s(Z) : (R &= B, R !== 0 && (x = _s(R)));
    } else
      B = m & ~I, B !== 0 ? x = _s(B) : R !== 0 && (x = _s(R));
    if (x === 0)
      return 0;
    if (c !== 0 && c !== x && !(c & I) && (I = x & -x, R = c & -c, I >= R || I === 16 && (R & 4194240) !== 0))
      return c;
    if (x & 4 && (x |= m & 16), c = s.entangledLanes, c !== 0)
      for (s = s.entanglements, c &= x; 0 < c; )
        m = 31 - oi(c), I = 1 << m, x |= s[m], c &= ~I;
    return x;
  }
  function Mf(s, c) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ds(s, c) {
    for (var m = s.suspendedLanes, x = s.pingedLanes, I = s.expirationTimes, R = s.pendingLanes; 0 < R; ) {
      var B = 31 - oi(R), Z = 1 << B, ee = I[B];
      ee === -1 ? (!(Z & m) || Z & x) && (I[B] = Mf(Z, c)) : ee <= c && (s.expiredLanes |= Z), R &= ~Z;
    }
  }
  function Au(s) {
    return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0;
  }
  function Qc() {
    var s = Jc;
    return Jc <<= 1, !(Jc & 4194240) && (Jc = 64), s;
  }
  function Lf(s) {
    for (var c = [], m = 0; 31 > m; m++)
      c.push(s);
    return c;
  }
  function Ka(s, c, m) {
    s.pendingLanes |= c, c !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, c = 31 - oi(c), s[c] = m;
  }
  function Lg(s, c) {
    var m = s.pendingLanes & ~c;
    s.pendingLanes = c, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= c, s.mutableReadLanes &= c, s.entangledLanes &= c, c = s.entanglements;
    var x = s.eventTimes;
    for (s = s.expirationTimes; 0 < m; ) {
      var I = 31 - oi(m), R = 1 << I;
      c[I] = 0, x[I] = -1, s[I] = -1, m &= ~R;
    }
  }
  function ku(s, c) {
    var m = s.entangledLanes |= c;
    for (s = s.entanglements; m; ) {
      var x = 31 - oi(m), I = 1 << x;
      I & c | s[x] & c && (s[x] |= c), m &= ~I;
    }
  }
  var On = 0;
  function Kc(s) {
    return s &= -s, 1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Oh, qc, $n, ed, Ff, Ut = !1, Ru = [], or = null, Oo = null, _o = null, Ns = /* @__PURE__ */ new Map(), kr = /* @__PURE__ */ new Map(), _n = [], Bf = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function ii(s, c) {
    switch (s) {
      case "focusin":
      case "focusout":
        or = null;
        break;
      case "dragenter":
      case "dragleave":
        Oo = null;
        break;
      case "mouseover":
      case "mouseout":
        _o = null;
        break;
      case "pointerover":
      case "pointerout":
        Ns.delete(c.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        kr.delete(c.pointerId);
    }
  }
  function pr(s, c, m, x, I, R) {
    return s === null || s.nativeEvent !== R ? (s = { blockedOn: c, domEventName: m, eventSystemFlags: x, nativeEvent: R, targetContainers: [I] }, c !== null && (c = Kf(c), c !== null && qc(c)), s) : (s.eventSystemFlags |= x, c = s.targetContainers, I !== null && c.indexOf(I) === -1 && c.push(I), s);
  }
  function ai(s, c, m, x, I) {
    switch (c) {
      case "focusin":
        return or = pr(or, s, c, m, x, I), !0;
      case "dragenter":
        return Oo = pr(Oo, s, c, m, x, I), !0;
      case "mouseover":
        return _o = pr(_o, s, c, m, x, I), !0;
      case "pointerover":
        var R = I.pointerId;
        return Ns.set(R, pr(Ns.get(R) || null, s, c, m, x, I)), !0;
      case "gotpointercapture":
        return R = I.pointerId, kr.set(R, pr(kr.get(R) || null, s, c, m, x, I)), !0;
    }
    return !1;
  }
  function _h(s) {
    var c = Yi(s.target);
    if (c !== null) {
      var m = Ui(c);
      if (m !== null) {
        if (c = m.tag, c === 13) {
          if (c = Xi(m), c !== null) {
            s.blockedOn = c, Ff(s.priority, function() {
              $n(m);
            });
            return;
          }
        } else if (c === 3 && m.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function Ms(s) {
    if (s.blockedOn !== null)
      return !1;
    for (var c = s.targetContainers; 0 < c.length; ) {
      var m = fn(s.domEventName, s.eventSystemFlags, c[0], s.nativeEvent);
      if (m === null) {
        m = s.nativeEvent;
        var x = new m.constructor(m.type, m);
        mt = x, m.target.dispatchEvent(x), mt = null;
      } else
        return c = Kf(m), c !== null && qc(c), s.blockedOn = m, !1;
      c.shift();
    }
    return !0;
  }
  function Vf(s, c, m) {
    Ms(s) && m.delete(c);
  }
  function $f() {
    Ut = !1, or !== null && Ms(or) && (or = null), Oo !== null && Ms(Oo) && (Oo = null), _o !== null && Ms(_o) && (_o = null), Ns.forEach(Vf), kr.forEach(Vf);
  }
  function Pu(s, c) {
    s.blockedOn === c && (s.blockedOn = null, Ut || (Ut = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, $f)));
  }
  function Ou(s) {
    function c(I) {
      return Pu(I, s);
    }
    if (0 < Ru.length) {
      Pu(Ru[0], s);
      for (var m = 1; m < Ru.length; m++) {
        var x = Ru[m];
        x.blockedOn === s && (x.blockedOn = null);
      }
    }
    for (or !== null && Pu(or, s), Oo !== null && Pu(Oo, s), _o !== null && Pu(_o, s), Ns.forEach(c), kr.forEach(c), m = 0; m < _n.length; m++)
      x = _n[m], x.blockedOn === s && (x.blockedOn = null);
    for (; 0 < _n.length && (m = _n[0], m.blockedOn === null); )
      _h(m), m.blockedOn === null && _n.shift();
  }
  var Ls = L.ReactCurrentBatchConfig, Fs = !0;
  function X(s, c, m, x) {
    var I = On, R = Ls.transition;
    Ls.transition = null;
    try {
      On = 1, Re(s, c, m, x);
    } finally {
      On = I, Ls.transition = R;
    }
  }
  function se(s, c, m, x) {
    var I = On, R = Ls.transition;
    Ls.transition = null;
    try {
      On = 4, Re(s, c, m, x);
    } finally {
      On = I, Ls.transition = R;
    }
  }
  function Re(s, c, m, x) {
    if (Fs) {
      var I = fn(s, c, m, x);
      if (I === null)
        Gh(s, c, x, it, m), ii(s, x);
      else if (ai(I, s, c, m, x))
        x.stopPropagation();
      else if (ii(s, x), c & 4 && -1 < Bf.indexOf(s)) {
        for (; I !== null; ) {
          var R = Kf(I);
          if (R !== null && Oh(R), R = fn(s, c, m, x), R === null && Gh(s, c, x, it, m), R === I)
            break;
          I = R;
        }
        I !== null && x.stopPropagation();
      } else
        Gh(s, c, x, null, m);
    }
  }
  var it = null;
  function fn(s, c, m, x) {
    if (it = null, s = kt(x), s = Yi(s), s !== null)
      if (c = Ui(s), c === null)
        s = null;
      else if (m = c.tag, m === 13) {
        if (s = Xi(c), s !== null)
          return s;
        s = null;
      } else if (m === 3) {
        if (c.stateNode.current.memoizedState.isDehydrated)
          return c.tag === 3 ? c.stateNode.containerInfo : null;
        s = null;
      } else
        c !== s && (s = null);
    return it = s, null;
  }
  function Dn(s) {
    switch (s) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Df()) {
          case ka:
            return 1;
          case on:
            return 4;
          case Ra:
          case Ah:
            return 16;
          case Nf:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var wn = null, ln = null, Ln = null;
  function Do() {
    if (Ln)
      return Ln;
    var s, c = ln, m = c.length, x, I = "value" in wn ? wn.value : wn.textContent, R = I.length;
    for (s = 0; s < m && c[s] === I[s]; s++)
      ;
    var B = m - s;
    for (x = 1; x <= B && c[m - x] === I[R - x]; x++)
      ;
    return Ln = I.slice(s, 1 < x ? 1 - x : void 0);
  }
  function Nr(s) {
    var c = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && c === 13 && (s = 13)) : s = c, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
  }
  function Pa() {
    return !0;
  }
  function td() {
    return !1;
  }
  function vo(s) {
    function c(m, x, I, R, B) {
      this._reactName = m, this._targetInst = I, this.type = x, this.nativeEvent = R, this.target = B, this.currentTarget = null;
      for (var Z in s)
        s.hasOwnProperty(Z) && (m = s[Z], this[Z] = m ? m(R) : R[Z]);
      return this.isDefaultPrevented = (R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1) ? Pa : td, this.isPropagationStopped = td, this;
    }
    return Y(c.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var m = this.nativeEvent;
      m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Pa);
    }, stopPropagation: function() {
      var m = this.nativeEvent;
      m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Pa);
    }, persist: function() {
    }, isPersistent: Pa }), c;
  }
  var Oa = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(s) {
    return s.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Dh = vo(Oa), nd = Y({}, Oa, { view: 0, detail: 0 }), RS = vo(nd), Nh, Fg, zf, eo = Y({}, nd, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zg, button: 0, buttons: 0, relatedTarget: function(s) {
    return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
  }, movementX: function(s) {
    return "movementX" in s ? s.movementX : (s !== zf && (zf && s.type === "mousemove" ? (Nh = s.screenX - zf.screenX, Fg = s.screenY - zf.screenY) : Fg = Nh = 0, zf = s), Nh);
  }, movementY: function(s) {
    return "movementY" in s ? s.movementY : Fg;
  } }), Mh = vo(eo), PS = Y({}, eo, { dataTransfer: 0 }), OS = vo(PS), LT = Y({}, nd, { relatedTarget: 0 }), Rl = vo(LT), Bg = Y({}, Oa, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), _S = vo(Bg), FT = Y({}, Oa, { clipboardData: function(s) {
    return "clipboardData" in s ? s.clipboardData : window.clipboardData;
  } }), BT = vo(FT), VT = Y({}, Oa, { data: 0 }), Vg = vo(VT), $g = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, DS = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, NS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function MS(s) {
    var c = this.nativeEvent;
    return c.getModifierState ? c.getModifierState(s) : (s = NS[s]) ? !!c[s] : !1;
  }
  function zg() {
    return MS;
  }
  var Bs = Y({}, nd, { key: function(s) {
    if (s.key) {
      var c = $g[s.key] || s.key;
      if (c !== "Unidentified")
        return c;
    }
    return s.type === "keypress" ? (s = Nr(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? DS[s.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zg, charCode: function(s) {
    return s.type === "keypress" ? Nr(s) : 0;
  }, keyCode: function(s) {
    return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  }, which: function(s) {
    return s.type === "keypress" ? Nr(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
  } }), $T = vo(Bs), Hg = Y({}, eo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Lh = vo(Hg), jg = Y({}, nd, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zg }), zT = vo(jg), Fh = Y({}, Oa, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), LS = vo(Fh), si = Y({}, eo, {
    deltaX: function(s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function(s) {
      return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Vs = vo(si), Mr = [9, 13, 27, 32], _a = f && "CompositionEvent" in window, _u = null;
  f && "documentMode" in document && (_u = document.documentMode);
  var Bh = f && "TextEvent" in window && !_u, FS = f && (!_a || _u && 8 < _u && 11 >= _u), rd = " ", BS = !1;
  function VS(s, c) {
    switch (s) {
      case "keyup":
        return Mr.indexOf(c.keyCode) !== -1;
      case "keydown":
        return c.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Vh(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
  }
  var od = !1;
  function HT(s, c) {
    switch (s) {
      case "compositionend":
        return Vh(c);
      case "keypress":
        return c.which !== 32 ? null : (BS = !0, rd);
      case "textInput":
        return s = c.data, s === rd && BS ? null : s;
      default:
        return null;
    }
  }
  function jT(s, c) {
    if (od)
      return s === "compositionend" || !_a && VS(s, c) ? (s = Do(), Ln = ln = wn = null, od = !1, s) : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(c.ctrlKey || c.altKey || c.metaKey) || c.ctrlKey && c.altKey) {
          if (c.char && 1 < c.char.length)
            return c.char;
          if (c.which)
            return String.fromCharCode(c.which);
        }
        return null;
      case "compositionend":
        return FS && c.locale !== "ko" ? null : c.data;
      default:
        return null;
    }
  }
  var $S = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function zS(s) {
    var c = s && s.nodeName && s.nodeName.toLowerCase();
    return c === "input" ? !!$S[s.type] : c === "textarea";
  }
  function HS(s, c, m, x) {
    Gr(x), c = Yf(c, "onChange"), 0 < c.length && (m = new Dh("onChange", "change", null, m, x), s.push({ event: m, listeners: c }));
  }
  var Hf = null, id = null;
  function ad(s) {
    jh(s, 0);
  }
  function sd(s) {
    var c = ud(s);
    if (fe(c))
      return s;
  }
  function jS(s, c) {
    if (s === "change")
      return c;
  }
  var Gg = !1;
  if (f) {
    var Wg;
    if (f) {
      var Ug = "oninput" in document;
      if (!Ug) {
        var GS = document.createElement("div");
        GS.setAttribute("oninput", "return;"), Ug = typeof GS.oninput == "function";
      }
      Wg = Ug;
    } else
      Wg = !1;
    Gg = Wg && (!document.documentMode || 9 < document.documentMode);
  }
  function WS() {
    Hf && (Hf.detachEvent("onpropertychange", US), id = Hf = null);
  }
  function US(s) {
    if (s.propertyName === "value" && sd(id)) {
      var c = [];
      HS(c, id, s, kt(s)), Os(ad, c);
    }
  }
  function GT(s, c, m) {
    s === "focusin" ? (WS(), Hf = c, id = m, Hf.attachEvent("onpropertychange", US)) : s === "focusout" && WS();
  }
  function WT(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
      return sd(id);
  }
  function UT(s, c) {
    if (s === "click")
      return sd(c);
  }
  function XS(s, c) {
    if (s === "input" || s === "change")
      return sd(c);
  }
  function XT(s, c) {
    return s === c && (s !== 0 || 1 / s === 1 / c) || s !== s && c !== c;
  }
  var Zi = typeof Object.is == "function" ? Object.is : XT;
  function jf(s, c) {
    if (Zi(s, c))
      return !0;
    if (typeof s != "object" || s === null || typeof c != "object" || c === null)
      return !1;
    var m = Object.keys(s), x = Object.keys(c);
    if (m.length !== x.length)
      return !1;
    for (x = 0; x < m.length; x++) {
      var I = m[x];
      if (!h.call(c, I) || !Zi(s[I], c[I]))
        return !1;
    }
    return !0;
  }
  function ZS(s) {
    for (; s && s.firstChild; )
      s = s.firstChild;
    return s;
  }
  function YS(s, c) {
    var m = ZS(s);
    s = 0;
    for (var x; m; ) {
      if (m.nodeType === 3) {
        if (x = s + m.textContent.length, s <= c && x >= c)
          return { node: m, offset: c - s };
        s = x;
      }
      e: {
        for (; m; ) {
          if (m.nextSibling) {
            m = m.nextSibling;
            break e;
          }
          m = m.parentNode;
        }
        m = void 0;
      }
      m = ZS(m);
    }
  }
  function JS(s, c) {
    return s && c ? s === c ? !0 : s && s.nodeType === 3 ? !1 : c && c.nodeType === 3 ? JS(s, c.parentNode) : "contains" in s ? s.contains(c) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(c) & 16) : !1 : !1;
  }
  function $h() {
    for (var s = window, c = ze(); c instanceof s.HTMLIFrameElement; ) {
      try {
        var m = typeof c.contentWindow.location.href == "string";
      } catch {
        m = !1;
      }
      if (m)
        s = c.contentWindow;
      else
        break;
      c = ze(s.document);
    }
    return c;
  }
  function $s(s) {
    var c = s && s.nodeName && s.nodeName.toLowerCase();
    return c && (c === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || c === "textarea" || s.contentEditable === "true");
  }
  function zh(s) {
    var c = $h(), m = s.focusedElem, x = s.selectionRange;
    if (c !== m && m && m.ownerDocument && JS(m.ownerDocument.documentElement, m)) {
      if (x !== null && $s(m)) {
        if (c = x.start, s = x.end, s === void 0 && (s = c), "selectionStart" in m)
          m.selectionStart = c, m.selectionEnd = Math.min(s, m.value.length);
        else if (s = (c = m.ownerDocument || document) && c.defaultView || window, s.getSelection) {
          s = s.getSelection();
          var I = m.textContent.length, R = Math.min(x.start, I);
          x = x.end === void 0 ? R : Math.min(x.end, I), !s.extend && R > x && (I = x, x = R, R = I), I = YS(m, R);
          var B = YS(
            m,
            x
          );
          I && B && (s.rangeCount !== 1 || s.anchorNode !== I.node || s.anchorOffset !== I.offset || s.focusNode !== B.node || s.focusOffset !== B.offset) && (c = c.createRange(), c.setStart(I.node, I.offset), s.removeAllRanges(), R > x ? (s.addRange(c), s.extend(B.node, B.offset)) : (c.setEnd(B.node, B.offset), s.addRange(c)));
        }
      }
      for (c = [], s = m; s = s.parentNode; )
        s.nodeType === 1 && c.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof m.focus == "function" && m.focus(), m = 0; m < c.length; m++)
        s = c[m], s.element.scrollLeft = s.left, s.element.scrollTop = s.top;
    }
  }
  var QS = f && "documentMode" in document && 11 >= document.documentMode, Da = null, Xg = null, Gf = null, Zg = !1;
  function KS(s, c, m) {
    var x = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
    Zg || Da == null || Da !== ze(x) || (x = Da, "selectionStart" in x && $s(x) ? x = { start: x.selectionStart, end: x.selectionEnd } : (x = (x.ownerDocument && x.ownerDocument.defaultView || window).getSelection(), x = { anchorNode: x.anchorNode, anchorOffset: x.anchorOffset, focusNode: x.focusNode, focusOffset: x.focusOffset }), Gf && jf(Gf, x) || (Gf = x, x = Yf(Xg, "onSelect"), 0 < x.length && (c = new Dh("onSelect", "select", null, c, m), s.push({ event: c, listeners: x }), c.target = Da)));
  }
  function Hh(s, c) {
    var m = {};
    return m[s.toLowerCase()] = c.toLowerCase(), m["Webkit" + s] = "webkit" + c, m["Moz" + s] = "moz" + c, m;
  }
  var Du = { animationend: Hh("Animation", "AnimationEnd"), animationiteration: Hh("Animation", "AnimationIteration"), animationstart: Hh("Animation", "AnimationStart"), transitionend: Hh("Transition", "TransitionEnd") }, Yg = {}, Jg = {};
  f && (Jg = document.createElement("div").style, "AnimationEvent" in window || (delete Du.animationend.animation, delete Du.animationiteration.animation, delete Du.animationstart.animation), "TransitionEvent" in window || delete Du.transitionend.transition);
  function to(s) {
    if (Yg[s])
      return Yg[s];
    if (!Du[s])
      return s;
    var c = Du[s], m;
    for (m in c)
      if (c.hasOwnProperty(m) && m in Jg)
        return Yg[s] = c[m];
    return s;
  }
  var Qg = to("animationend"), qS = to("animationiteration"), e1 = to("animationstart"), t1 = to("transitionend"), n1 = /* @__PURE__ */ new Map(), r1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function zs(s, c) {
    n1.set(s, c), l(c, [s]);
  }
  for (var Wf = 0; Wf < r1.length; Wf++) {
    var Nu = r1[Wf], ZT = Nu.toLowerCase(), Uf = Nu[0].toUpperCase() + Nu.slice(1);
    zs(ZT, "on" + Uf);
  }
  zs(Qg, "onAnimationEnd"), zs(qS, "onAnimationIteration"), zs(e1, "onAnimationStart"), zs("dblclick", "onDoubleClick"), zs("focusin", "onFocus"), zs("focusout", "onBlur"), zs(t1, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), YT = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xf));
  function o1(s, c, m) {
    var x = s.type || "unknown-event";
    s.currentTarget = m, Il(x, c, void 0, s), s.currentTarget = null;
  }
  function jh(s, c) {
    c = (c & 4) !== 0;
    for (var m = 0; m < s.length; m++) {
      var x = s[m], I = x.event;
      x = x.listeners;
      e: {
        var R = void 0;
        if (c)
          for (var B = x.length - 1; 0 <= B; B--) {
            var Z = x[B], ee = Z.instance, Pe = Z.currentTarget;
            if (Z = Z.listener, ee !== R && I.isPropagationStopped())
              break e;
            o1(I, Z, Pe), R = ee;
          }
        else
          for (B = 0; B < x.length; B++) {
            if (Z = x[B], ee = Z.instance, Pe = Z.currentTarget, Z = Z.listener, ee !== R && I.isPropagationStopped())
              break e;
            o1(I, Z, Pe), R = ee;
          }
      }
    }
    if (Ti)
      throw s = Tu, Ti = !1, Tu = null, s;
  }
  function er(s, c) {
    var m = c[oy];
    m === void 0 && (m = c[oy] = /* @__PURE__ */ new Set());
    var x = s + "__bubble";
    m.has(x) || (i1(c, s, 2, !1), m.add(x));
  }
  function Pl(s, c, m) {
    var x = 0;
    c && (x |= 4), i1(m, s, x, c);
  }
  var Hs = "_reactListening" + Math.random().toString(36).slice(2);
  function ld(s) {
    if (!s[Hs]) {
      s[Hs] = !0, o.forEach(function(m) {
        m !== "selectionchange" && (YT.has(m) || Pl(m, !1, s), Pl(m, !0, s));
      });
      var c = s.nodeType === 9 ? s : s.ownerDocument;
      c === null || c[Hs] || (c[Hs] = !0, Pl("selectionchange", !1, c));
    }
  }
  function i1(s, c, m, x) {
    switch (Dn(c)) {
      case 1:
        var I = X;
        break;
      case 4:
        I = se;
        break;
      default:
        I = Re;
    }
    m = I.bind(null, c, m, s), I = void 0, !Ja || c !== "touchstart" && c !== "touchmove" && c !== "wheel" || (I = !0), x ? I !== void 0 ? s.addEventListener(c, m, { capture: !0, passive: I }) : s.addEventListener(c, m, !0) : I !== void 0 ? s.addEventListener(c, m, { passive: I }) : s.addEventListener(c, m, !1);
  }
  function Gh(s, c, m, x, I) {
    var R = x;
    if (!(c & 1) && !(c & 2) && x !== null)
      e:
        for (; ; ) {
          if (x === null)
            return;
          var B = x.tag;
          if (B === 3 || B === 4) {
            var Z = x.stateNode.containerInfo;
            if (Z === I || Z.nodeType === 8 && Z.parentNode === I)
              break;
            if (B === 4)
              for (B = x.return; B !== null; ) {
                var ee = B.tag;
                if ((ee === 3 || ee === 4) && (ee = B.stateNode.containerInfo, ee === I || ee.nodeType === 8 && ee.parentNode === I))
                  return;
                B = B.return;
              }
            for (; Z !== null; ) {
              if (B = Yi(Z), B === null)
                return;
              if (ee = B.tag, ee === 5 || ee === 6) {
                x = R = B;
                continue e;
              }
              Z = Z.parentNode;
            }
          }
          x = x.return;
        }
    Os(function() {
      var Pe = R, We = kt(m), Ze = [];
      e: {
        var Ge = n1.get(s);
        if (Ge !== void 0) {
          var ut = Dh, bt = s;
          switch (s) {
            case "keypress":
              if (Nr(m) === 0)
                break e;
            case "keydown":
            case "keyup":
              ut = $T;
              break;
            case "focusin":
              bt = "focus", ut = Rl;
              break;
            case "focusout":
              bt = "blur", ut = Rl;
              break;
            case "beforeblur":
            case "afterblur":
              ut = Rl;
              break;
            case "click":
              if (m.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ut = Mh;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ut = OS;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ut = zT;
              break;
            case Qg:
            case qS:
            case e1:
              ut = _S;
              break;
            case t1:
              ut = LS;
              break;
            case "scroll":
              ut = RS;
              break;
            case "wheel":
              ut = Vs;
              break;
            case "copy":
            case "cut":
            case "paste":
              ut = BT;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ut = Lh;
          }
          var Ct = (c & 4) !== 0, Pr = !Ct && s === "scroll", ve = Ct ? Ge !== null ? Ge + "Capture" : null : Ge;
          Ct = [];
          for (var le = Pe, Te; le !== null; ) {
            Te = le;
            var Ke = Te.stateNode;
            if (Te.tag === 5 && Ke !== null && (Te = Ke, ve !== null && (Ke = Wr(le, ve), Ke != null && Ct.push(Zf(le, Ke, Te)))), Pr)
              break;
            le = le.return;
          }
          0 < Ct.length && (Ge = new ut(Ge, bt, null, m, We), Ze.push({ event: Ge, listeners: Ct }));
        }
      }
      if (!(c & 7)) {
        e: {
          if (Ge = s === "mouseover" || s === "pointerover", ut = s === "mouseout" || s === "pointerout", Ge && m !== mt && (bt = m.relatedTarget || m.fromElement) && (Yi(bt) || bt[js]))
            break e;
          if ((ut || Ge) && (Ge = We.window === We ? We : (Ge = We.ownerDocument) ? Ge.defaultView || Ge.parentWindow : window, ut ? (bt = m.relatedTarget || m.toElement, ut = Pe, bt = bt ? Yi(bt) : null, bt !== null && (Pr = Ui(bt), bt !== Pr || bt.tag !== 5 && bt.tag !== 6) && (bt = null)) : (ut = null, bt = Pe), ut !== bt)) {
            if (Ct = Mh, Ke = "onMouseLeave", ve = "onMouseEnter", le = "mouse", (s === "pointerout" || s === "pointerover") && (Ct = Lh, Ke = "onPointerLeave", ve = "onPointerEnter", le = "pointer"), Pr = ut == null ? Ge : ud(ut), Te = bt == null ? Ge : ud(bt), Ge = new Ct(Ke, le + "leave", ut, m, We), Ge.target = Pr, Ge.relatedTarget = Te, Ke = null, Yi(We) === Pe && (Ct = new Ct(ve, le + "enter", bt, m, We), Ct.target = Te, Ct.relatedTarget = Pr, Ke = Ct), Pr = Ke, ut && bt)
              t: {
                for (Ct = ut, ve = bt, le = 0, Te = Ct; Te; Te = Mu(Te))
                  le++;
                for (Te = 0, Ke = ve; Ke; Ke = Mu(Ke))
                  Te++;
                for (; 0 < le - Te; )
                  Ct = Mu(Ct), le--;
                for (; 0 < Te - le; )
                  ve = Mu(ve), Te--;
                for (; le--; ) {
                  if (Ct === ve || ve !== null && Ct === ve.alternate)
                    break t;
                  Ct = Mu(Ct), ve = Mu(ve);
                }
                Ct = null;
              }
            else
              Ct = null;
            ut !== null && Kg(Ze, Ge, ut, Ct, !1), bt !== null && Pr !== null && Kg(Ze, Pr, bt, Ct, !0);
          }
        }
        e: {
          if (Ge = Pe ? ud(Pe) : window, ut = Ge.nodeName && Ge.nodeName.toLowerCase(), ut === "select" || ut === "input" && Ge.type === "file")
            var wt = jS;
          else if (zS(Ge))
            if (Gg)
              wt = XS;
            else {
              wt = WT;
              var St = GT;
            }
          else
            (ut = Ge.nodeName) && ut.toLowerCase() === "input" && (Ge.type === "checkbox" || Ge.type === "radio") && (wt = UT);
          if (wt && (wt = wt(s, Pe))) {
            HS(Ze, wt, m, We);
            break e;
          }
          St && St(s, Ge, Pe), s === "focusout" && (St = Ge._wrapperState) && St.controlled && Ge.type === "number" && tn(Ge, "number", Ge.value);
        }
        switch (St = Pe ? ud(Pe) : window, s) {
          case "focusin":
            (zS(St) || St.contentEditable === "true") && (Da = St, Xg = Pe, Gf = null);
            break;
          case "focusout":
            Gf = Xg = Da = null;
            break;
          case "mousedown":
            Zg = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Zg = !1, KS(Ze, m, We);
            break;
          case "selectionchange":
            if (QS)
              break;
          case "keydown":
          case "keyup":
            KS(Ze, m, We);
        }
        var It;
        if (_a)
          e: {
            switch (s) {
              case "compositionstart":
                var Gt = "onCompositionStart";
                break e;
              case "compositionend":
                Gt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Gt = "onCompositionUpdate";
                break e;
            }
            Gt = void 0;
          }
        else
          od ? VS(s, m) && (Gt = "onCompositionEnd") : s === "keydown" && m.keyCode === 229 && (Gt = "onCompositionStart");
        Gt && (FS && m.locale !== "ko" && (od || Gt !== "onCompositionStart" ? Gt === "onCompositionEnd" && od && (It = Do()) : (wn = We, ln = "value" in wn ? wn.value : wn.textContent, od = !0)), St = Yf(Pe, Gt), 0 < St.length && (Gt = new Vg(Gt, s, null, m, We), Ze.push({ event: Gt, listeners: St }), It ? Gt.data = It : (It = Vh(m), It !== null && (Gt.data = It)))), (It = Bh ? HT(s, m) : jT(s, m)) && (Pe = Yf(Pe, "onBeforeInput"), 0 < Pe.length && (We = new Vg("onBeforeInput", "beforeinput", null, m, We), Ze.push({ event: We, listeners: Pe }), We.data = It));
      }
      jh(Ze, c);
    });
  }
  function Zf(s, c, m) {
    return { instance: s, listener: c, currentTarget: m };
  }
  function Yf(s, c) {
    for (var m = c + "Capture", x = []; s !== null; ) {
      var I = s, R = I.stateNode;
      I.tag === 5 && R !== null && (I = R, R = Wr(s, m), R != null && x.unshift(Zf(s, R, I)), R = Wr(s, c), R != null && x.push(Zf(s, R, I))), s = s.return;
    }
    return x;
  }
  function Mu(s) {
    if (s === null)
      return null;
    do
      s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function Kg(s, c, m, x, I) {
    for (var R = c._reactName, B = []; m !== null && m !== x; ) {
      var Z = m, ee = Z.alternate, Pe = Z.stateNode;
      if (ee !== null && ee === x)
        break;
      Z.tag === 5 && Pe !== null && (Z = Pe, I ? (ee = Wr(m, R), ee != null && B.unshift(Zf(m, ee, Z))) : I || (ee = Wr(m, R), ee != null && B.push(Zf(m, ee, Z)))), m = m.return;
    }
    B.length !== 0 && s.push({ event: c, listeners: B });
  }
  var qg = /\r\n?/g, JT = /\u0000|\uFFFD/g;
  function ey(s) {
    return (typeof s == "string" ? s : "" + s).replace(qg, `
`).replace(JT, "");
  }
  function Wh(s, c, m) {
    if (c = ey(c), ey(s) !== c && m)
      throw Error(n(425));
  }
  function Uh() {
  }
  var ty = null, Lu = null;
  function Jf(s, c) {
    return s === "textarea" || s === "noscript" || typeof c.children == "string" || typeof c.children == "number" || typeof c.dangerouslySetInnerHTML == "object" && c.dangerouslySetInnerHTML !== null && c.dangerouslySetInnerHTML.__html != null;
  }
  var Fu = typeof setTimeout == "function" ? setTimeout : void 0, a1 = typeof clearTimeout == "function" ? clearTimeout : void 0, ny = typeof Promise == "function" ? Promise : void 0, ry = typeof queueMicrotask == "function" ? queueMicrotask : typeof ny < "u" ? function(s) {
    return ny.resolve(null).then(s).catch(QT);
  } : Fu;
  function QT(s) {
    setTimeout(function() {
      throw s;
    });
  }
  function Ol(s, c) {
    var m = c, x = 0;
    do {
      var I = m.nextSibling;
      if (s.removeChild(m), I && I.nodeType === 8)
        if (m = I.data, m === "/$") {
          if (x === 0) {
            s.removeChild(I), Ou(c);
            return;
          }
          x--;
        } else
          m !== "$" && m !== "$?" && m !== "$!" || x++;
      m = I;
    } while (m);
    Ou(c);
  }
  function Na(s) {
    for (; s != null; s = s.nextSibling) {
      var c = s.nodeType;
      if (c === 1 || c === 3)
        break;
      if (c === 8) {
        if (c = s.data, c === "$" || c === "$!" || c === "$?")
          break;
        if (c === "/$")
          return null;
      }
    }
    return s;
  }
  function Qf(s) {
    s = s.previousSibling;
    for (var c = 0; s; ) {
      if (s.nodeType === 8) {
        var m = s.data;
        if (m === "$" || m === "$!" || m === "$?") {
          if (c === 0)
            return s;
          c--;
        } else
          m === "/$" && c++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var _l = Math.random().toString(36).slice(2), qa = "__reactFiber$" + _l, Bu = "__reactProps$" + _l, js = "__reactContainer$" + _l, oy = "__reactEvents$" + _l, KT = "__reactListeners$" + _l, iy = "__reactHandles$" + _l;
  function Yi(s) {
    var c = s[qa];
    if (c)
      return c;
    for (var m = s.parentNode; m; ) {
      if (c = m[js] || m[qa]) {
        if (m = c.alternate, c.child !== null || m !== null && m.child !== null)
          for (s = Qf(s); s !== null; ) {
            if (m = s[qa])
              return m;
            s = Qf(s);
          }
        return c;
      }
      s = m, m = s.parentNode;
    }
    return null;
  }
  function Kf(s) {
    return s = s[qa] || s[js], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s;
  }
  function ud(s) {
    if (s.tag === 5 || s.tag === 6)
      return s.stateNode;
    throw Error(n(33));
  }
  function At(s) {
    return s[Bu] || null;
  }
  var Dl = [], ir = -1;
  function qt(s) {
    return { current: s };
  }
  function Nn(s) {
    0 > ir || (s.current = Dl[ir], Dl[ir] = null, ir--);
  }
  function Fn(s, c) {
    ir++, Dl[ir] = s.current, s.current = c;
  }
  var es = {}, jt = qt(es), Tr = qt(!1), li = es;
  function Ji(s, c) {
    var m = s.type.contextTypes;
    if (!m)
      return es;
    var x = s.stateNode;
    if (x && x.__reactInternalMemoizedUnmaskedChildContext === c)
      return x.__reactInternalMemoizedMaskedChildContext;
    var I = {}, R;
    for (R in m)
      I[R] = c[R];
    return x && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = c, s.__reactInternalMemoizedMaskedChildContext = I), I;
  }
  function hr(s) {
    return s = s.childContextTypes, s != null;
  }
  function Qi() {
    Nn(Tr), Nn(jt);
  }
  function Nl(s, c, m) {
    if (jt.current !== es)
      throw Error(n(168));
    Fn(jt, c), Fn(Tr, m);
  }
  function qf(s, c, m) {
    var x = s.stateNode;
    if (c = c.childContextTypes, typeof x.getChildContext != "function")
      return m;
    x = x.getChildContext();
    for (var I in x)
      if (!(I in c))
        throw Error(n(108, Ce(s) || "Unknown", I));
    return Y({}, m, x);
  }
  function Xh(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || es, li = jt.current, Fn(jt, s), Fn(Tr, Tr.current), !0;
  }
  function s1(s, c, m) {
    var x = s.stateNode;
    if (!x)
      throw Error(n(169));
    m ? (s = qf(s, c, li), x.__reactInternalMemoizedMergedChildContext = s, Nn(Tr), Nn(jt), Fn(jt, s)) : Nn(Tr), Fn(Tr, m);
  }
  var Ai = null, no = !1, ep = !1;
  function ay(s) {
    Ai === null ? Ai = [s] : Ai.push(s);
  }
  function sy(s) {
    no = !0, ay(s);
  }
  function ui() {
    if (!ep && Ai !== null) {
      ep = !0;
      var s = 0, c = On;
      try {
        var m = Ai;
        for (On = 1; s < m.length; s++) {
          var x = m[s];
          do
            x = x(!0);
          while (x !== null);
        }
        Ai = null, no = !1;
      } catch (I) {
        throw Ai !== null && (Ai = Ai.slice(s + 1)), Of(ka, ui), I;
      } finally {
        On = c, ep = !1;
      }
    }
    return null;
  }
  var Ml = [], ci = 0, Vu = null, cd = 0, di = [], No = 0, Ki = null, go = 1, Gs = "";
  function ki(s, c) {
    Ml[ci++] = cd, Ml[ci++] = Vu, Vu = s, cd = c;
  }
  function ly(s, c, m) {
    di[No++] = go, di[No++] = Gs, di[No++] = Ki, Ki = s;
    var x = go;
    s = Gs;
    var I = 32 - oi(x) - 1;
    x &= ~(1 << I), m += 1;
    var R = 32 - oi(c) + I;
    if (30 < R) {
      var B = I - I % 5;
      R = (x & (1 << B) - 1).toString(32), x >>= B, I -= B, go = 1 << 32 - oi(c) + I | m << I | x, Gs = R + s;
    } else
      go = 1 << R | m << I | x, Gs = s;
  }
  function Zh(s) {
    s.return !== null && (ki(s, 1), ly(s, 1, 0));
  }
  function uy(s) {
    for (; s === Vu; )
      Vu = Ml[--ci], Ml[ci] = null, cd = Ml[--ci], Ml[ci] = null;
    for (; s === Ki; )
      Ki = di[--No], di[No] = null, Gs = di[--No], di[No] = null, go = di[--No], di[No] = null;
  }
  var Ri = null, fi = null, ar = !1, qi = null;
  function cy(s, c) {
    var m = ia(5, null, null, 0);
    m.elementType = "DELETED", m.stateNode = c, m.return = s, c = s.deletions, c === null ? (s.deletions = [m], s.flags |= 16) : c.push(m);
  }
  function l1(s, c) {
    switch (s.tag) {
      case 5:
        var m = s.type;
        return c = c.nodeType !== 1 || m.toLowerCase() !== c.nodeName.toLowerCase() ? null : c, c !== null ? (s.stateNode = c, Ri = s, fi = Na(c.firstChild), !0) : !1;
      case 6:
        return c = s.pendingProps === "" || c.nodeType !== 3 ? null : c, c !== null ? (s.stateNode = c, Ri = s, fi = null, !0) : !1;
      case 13:
        return c = c.nodeType !== 8 ? null : c, c !== null ? (m = Ki !== null ? { id: go, overflow: Gs } : null, s.memoizedState = { dehydrated: c, treeContext: m, retryLane: 1073741824 }, m = ia(18, null, null, 0), m.stateNode = c, m.return = s, s.child = m, Ri = s, fi = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Yh(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function Jh(s) {
    if (ar) {
      var c = fi;
      if (c) {
        var m = c;
        if (!l1(s, c)) {
          if (Yh(s))
            throw Error(n(418));
          c = Na(m.nextSibling);
          var x = Ri;
          c && l1(s, c) ? cy(x, m) : (s.flags = s.flags & -4097 | 2, ar = !1, Ri = s);
        }
      } else {
        if (Yh(s))
          throw Error(n(418));
        s.flags = s.flags & -4097 | 2, ar = !1, Ri = s;
      }
    }
  }
  function u1(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; )
      s = s.return;
    Ri = s;
  }
  function Qh(s) {
    if (s !== Ri)
      return !1;
    if (!ar)
      return u1(s), ar = !0, !1;
    var c;
    if ((c = s.tag !== 3) && !(c = s.tag !== 5) && (c = s.type, c = c !== "head" && c !== "body" && !Jf(s.type, s.memoizedProps)), c && (c = fi)) {
      if (Yh(s))
        throw c1(), Error(n(418));
      for (; c; )
        cy(s, c), c = Na(c.nextSibling);
    }
    if (u1(s), s.tag === 13) {
      if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s)
        throw Error(n(317));
      e: {
        for (s = s.nextSibling, c = 0; s; ) {
          if (s.nodeType === 8) {
            var m = s.data;
            if (m === "/$") {
              if (c === 0) {
                fi = Na(s.nextSibling);
                break e;
              }
              c--;
            } else
              m !== "$" && m !== "$!" && m !== "$?" || c++;
          }
          s = s.nextSibling;
        }
        fi = null;
      }
    } else
      fi = Ri ? Na(s.stateNode.nextSibling) : null;
    return !0;
  }
  function c1() {
    for (var s = fi; s; )
      s = Na(s.nextSibling);
  }
  function yr() {
    fi = Ri = null, ar = !1;
  }
  function dy(s) {
    qi === null ? qi = [s] : qi.push(s);
  }
  var Kh = L.ReactCurrentBatchConfig;
  function Pi(s, c) {
    if (s && s.defaultProps) {
      c = Y({}, c), s = s.defaultProps;
      for (var m in s)
        c[m] === void 0 && (c[m] = s[m]);
      return c;
    }
    return c;
  }
  var ts = qt(null), qh = null, Ll = null, fy = null;
  function py() {
    fy = Ll = qh = null;
  }
  function Fl(s) {
    var c = ts.current;
    Nn(ts), s._currentValue = c;
  }
  function ro(s, c, m) {
    for (; s !== null; ) {
      var x = s.alternate;
      if ((s.childLanes & c) !== c ? (s.childLanes |= c, x !== null && (x.childLanes |= c)) : x !== null && (x.childLanes & c) !== c && (x.childLanes |= c), s === m)
        break;
      s = s.return;
    }
  }
  function nt(s, c) {
    qh = s, fy = Ll = null, s = s.dependencies, s !== null && s.firstContext !== null && (s.lanes & c && (Lr = !0), s.firstContext = null);
  }
  function Rr(s) {
    var c = s._currentValue;
    if (fy !== s)
      if (s = { context: s, memoizedValue: c, next: null }, Ll === null) {
        if (qh === null)
          throw Error(n(308));
        Ll = s, qh.dependencies = { lanes: 0, firstContext: s };
      } else
        Ll = Ll.next = s;
    return c;
  }
  var yo = null;
  function hy(s) {
    yo === null ? yo = [s] : yo.push(s);
  }
  function d1(s, c, m, x) {
    var I = c.interleaved;
    return I === null ? (m.next = m, hy(c)) : (m.next = I.next, I.next = m), c.interleaved = m, Ws(s, x);
  }
  function Ws(s, c) {
    s.lanes |= c;
    var m = s.alternate;
    for (m !== null && (m.lanes |= c), m = s, s = s.return; s !== null; )
      s.childLanes |= c, m = s.alternate, m !== null && (m.childLanes |= c), m = s, s = s.return;
    return m.tag === 3 ? m.stateNode : null;
  }
  var Bl = !1;
  function my(s) {
    s.updateQueue = { baseState: s.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Ur(s, c) {
    s = s.updateQueue, c.updateQueue === s && (c.updateQueue = { baseState: s.baseState, firstBaseUpdate: s.firstBaseUpdate, lastBaseUpdate: s.lastBaseUpdate, shared: s.shared, effects: s.effects });
  }
  function Us(s, c) {
    return { eventTime: s, lane: c, tag: 0, payload: null, callback: null, next: null };
  }
  function Vl(s, c, m) {
    var x = s.updateQueue;
    if (x === null)
      return null;
    if (x = x.shared, gn & 2) {
      var I = x.pending;
      return I === null ? c.next = c : (c.next = I.next, I.next = c), x.pending = c, Ws(s, m);
    }
    return I = x.interleaved, I === null ? (c.next = c, hy(x)) : (c.next = I.next, I.next = c), x.interleaved = c, Ws(s, m);
  }
  function em(s, c, m) {
    if (c = c.updateQueue, c !== null && (c = c.shared, (m & 4194240) !== 0)) {
      var x = c.lanes;
      x &= s.pendingLanes, m |= x, c.lanes = m, ku(s, m);
    }
  }
  function vy(s, c) {
    var m = s.updateQueue, x = s.alternate;
    if (x !== null && (x = x.updateQueue, m === x)) {
      var I = null, R = null;
      if (m = m.firstBaseUpdate, m !== null) {
        do {
          var B = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null };
          R === null ? I = R = B : R = R.next = B, m = m.next;
        } while (m !== null);
        R === null ? I = R = c : R = R.next = c;
      } else
        I = R = c;
      m = { baseState: x.baseState, firstBaseUpdate: I, lastBaseUpdate: R, shared: x.shared, effects: x.effects }, s.updateQueue = m;
      return;
    }
    s = m.lastBaseUpdate, s === null ? m.firstBaseUpdate = c : s.next = c, m.lastBaseUpdate = c;
  }
  function $l(s, c, m, x) {
    var I = s.updateQueue;
    Bl = !1;
    var R = I.firstBaseUpdate, B = I.lastBaseUpdate, Z = I.shared.pending;
    if (Z !== null) {
      I.shared.pending = null;
      var ee = Z, Pe = ee.next;
      ee.next = null, B === null ? R = Pe : B.next = Pe, B = ee;
      var We = s.alternate;
      We !== null && (We = We.updateQueue, Z = We.lastBaseUpdate, Z !== B && (Z === null ? We.firstBaseUpdate = Pe : Z.next = Pe, We.lastBaseUpdate = ee));
    }
    if (R !== null) {
      var Ze = I.baseState;
      B = 0, We = Pe = ee = null, Z = R;
      do {
        var Ge = Z.lane, ut = Z.eventTime;
        if ((x & Ge) === Ge) {
          We !== null && (We = We.next = {
            eventTime: ut,
            lane: 0,
            tag: Z.tag,
            payload: Z.payload,
            callback: Z.callback,
            next: null
          });
          e: {
            var bt = s, Ct = Z;
            switch (Ge = c, ut = m, Ct.tag) {
              case 1:
                if (bt = Ct.payload, typeof bt == "function") {
                  Ze = bt.call(ut, Ze, Ge);
                  break e;
                }
                Ze = bt;
                break e;
              case 3:
                bt.flags = bt.flags & -65537 | 128;
              case 0:
                if (bt = Ct.payload, Ge = typeof bt == "function" ? bt.call(ut, Ze, Ge) : bt, Ge == null)
                  break e;
                Ze = Y({}, Ze, Ge);
                break e;
              case 2:
                Bl = !0;
            }
          }
          Z.callback !== null && Z.lane !== 0 && (s.flags |= 64, Ge = I.effects, Ge === null ? I.effects = [Z] : Ge.push(Z));
        } else
          ut = { eventTime: ut, lane: Ge, tag: Z.tag, payload: Z.payload, callback: Z.callback, next: null }, We === null ? (Pe = We = ut, ee = Ze) : We = We.next = ut, B |= Ge;
        if (Z = Z.next, Z === null) {
          if (Z = I.shared.pending, Z === null)
            break;
          Ge = Z, Z = Ge.next, Ge.next = null, I.lastBaseUpdate = Ge, I.shared.pending = null;
        }
      } while (!0);
      if (We === null && (ee = Ze), I.baseState = ee, I.firstBaseUpdate = Pe, I.lastBaseUpdate = We, c = I.shared.interleaved, c !== null) {
        I = c;
        do
          B |= I.lane, I = I.next;
        while (I !== c);
      } else
        R === null && (I.shared.lanes = 0);
      Js |= B, s.lanes = B, s.memoizedState = Ze;
    }
  }
  function $u(s, c, m) {
    if (s = c.effects, c.effects = null, s !== null)
      for (c = 0; c < s.length; c++) {
        var x = s[c], I = x.callback;
        if (I !== null) {
          if (x.callback = null, x = m, typeof I != "function")
            throw Error(n(191, I));
          I.call(x);
        }
      }
  }
  var f1 = new e.Component().refs;
  function gy(s, c, m, x) {
    c = s.memoizedState, m = m(x, c), m = m == null ? c : Y({}, c, m), s.memoizedState = m, s.lanes === 0 && (s.updateQueue.baseState = m);
  }
  var tm = { isMounted: function(s) {
    return (s = s._reactInternals) ? Ui(s) === s : !1;
  }, enqueueSetState: function(s, c, m) {
    s = s._reactInternals;
    var x = Bo(), I = Fr(s), R = Us(x, I);
    R.payload = c, m != null && (R.callback = m), c = Vl(s, R, I), c !== null && (Vo(c, s, I, x), em(c, s, I));
  }, enqueueReplaceState: function(s, c, m) {
    s = s._reactInternals;
    var x = Bo(), I = Fr(s), R = Us(x, I);
    R.tag = 1, R.payload = c, m != null && (R.callback = m), c = Vl(s, R, I), c !== null && (Vo(c, s, I, x), em(c, s, I));
  }, enqueueForceUpdate: function(s, c) {
    s = s._reactInternals;
    var m = Bo(), x = Fr(s), I = Us(m, x);
    I.tag = 2, c != null && (I.callback = c), c = Vl(s, I, x), c !== null && (Vo(c, s, x, m), em(c, s, x));
  } };
  function p1(s, c, m, x, I, R, B) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(x, R, B) : c.prototype && c.prototype.isPureReactComponent ? !jf(m, x) || !jf(I, R) : !0;
  }
  function h1(s, c, m) {
    var x = !1, I = es, R = c.contextType;
    return typeof R == "object" && R !== null ? R = Rr(R) : (I = hr(c) ? li : jt.current, x = c.contextTypes, R = (x = x != null) ? Ji(s, I) : es), c = new c(m, R), s.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, c.updater = tm, s.stateNode = c, c._reactInternals = s, x && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = I, s.__reactInternalMemoizedMaskedChildContext = R), c;
  }
  function m1(s, c, m, x) {
    s = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(m, x), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(m, x), c.state !== s && tm.enqueueReplaceState(c, c.state, null);
  }
  function nm(s, c, m, x) {
    var I = s.stateNode;
    I.props = m, I.state = s.memoizedState, I.refs = f1, my(s);
    var R = c.contextType;
    typeof R == "object" && R !== null ? I.context = Rr(R) : (R = hr(c) ? li : jt.current, I.context = Ji(s, R)), I.state = s.memoizedState, R = c.getDerivedStateFromProps, typeof R == "function" && (gy(s, c, R, m), I.state = s.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (c = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), c !== I.state && tm.enqueueReplaceState(I, I.state, null), $l(s, m, I, x), I.state = s.memoizedState), typeof I.componentDidMount == "function" && (s.flags |= 4194308);
  }
  function dd(s, c, m) {
    if (s = m.ref, s !== null && typeof s != "function" && typeof s != "object") {
      if (m._owner) {
        if (m = m._owner, m) {
          if (m.tag !== 1)
            throw Error(n(309));
          var x = m.stateNode;
        }
        if (!x)
          throw Error(n(147, s));
        var I = x, R = "" + s;
        return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === R ? c.ref : (c = function(B) {
          var Z = I.refs;
          Z === f1 && (Z = I.refs = {}), B === null ? delete Z[R] : Z[R] = B;
        }, c._stringRef = R, c);
      }
      if (typeof s != "string")
        throw Error(n(284));
      if (!m._owner)
        throw Error(n(290, s));
    }
    return s;
  }
  function rm(s, c) {
    throw s = Object.prototype.toString.call(c), Error(n(31, s === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : s));
  }
  function v1(s) {
    var c = s._init;
    return c(s._payload);
  }
  function g1(s) {
    function c(ve, le) {
      if (s) {
        var Te = ve.deletions;
        Te === null ? (ve.deletions = [le], ve.flags |= 16) : Te.push(le);
      }
    }
    function m(ve, le) {
      if (!s)
        return null;
      for (; le !== null; )
        c(ve, le), le = le.sibling;
      return null;
    }
    function x(ve, le) {
      for (ve = /* @__PURE__ */ new Map(); le !== null; )
        le.key !== null ? ve.set(le.key, le) : ve.set(le.index, le), le = le.sibling;
      return ve;
    }
    function I(ve, le) {
      return ve = Zl(ve, le), ve.index = 0, ve.sibling = null, ve;
    }
    function R(ve, le, Te) {
      return ve.index = Te, s ? (Te = ve.alternate, Te !== null ? (Te = Te.index, Te < le ? (ve.flags |= 2, le) : Te) : (ve.flags |= 2, le)) : (ve.flags |= 1048576, le);
    }
    function B(ve) {
      return s && ve.alternate === null && (ve.flags |= 2), ve;
    }
    function Z(ve, le, Te, Ke) {
      return le === null || le.tag !== 6 ? (le = bp(Te, ve.mode, Ke), le.return = ve, le) : (le = I(le, Te), le.return = ve, le);
    }
    function ee(ve, le, Te, Ke) {
      var wt = Te.type;
      return wt === $ ? We(ve, le, Te.props.children, Ke, Te.key) : le !== null && (le.elementType === wt || typeof wt == "object" && wt !== null && wt.$$typeof === me && v1(wt) === le.type) ? (Ke = I(le, Te.props), Ke.ref = dd(ve, le, Te), Ke.return = ve, Ke) : (Ke = Mm(Te.type, Te.key, Te.props, null, ve.mode, Ke), Ke.ref = dd(ve, le, Te), Ke.return = ve, Ke);
    }
    function Pe(ve, le, Te, Ke) {
      return le === null || le.tag !== 4 || le.stateNode.containerInfo !== Te.containerInfo || le.stateNode.implementation !== Te.implementation ? (le = ic(Te, ve.mode, Ke), le.return = ve, le) : (le = I(le, Te.children || []), le.return = ve, le);
    }
    function We(ve, le, Te, Ke, wt) {
      return le === null || le.tag !== 7 ? (le = oc(Te, ve.mode, Ke, wt), le.return = ve, le) : (le = I(le, Te), le.return = ve, le);
    }
    function Ze(ve, le, Te) {
      if (typeof le == "string" && le !== "" || typeof le == "number")
        return le = bp("" + le, ve.mode, Te), le.return = ve, le;
      if (typeof le == "object" && le !== null) {
        switch (le.$$typeof) {
          case F:
            return Te = Mm(le.type, le.key, le.props, null, ve.mode, Te), Te.ref = dd(ve, null, le), Te.return = ve, Te;
          case V:
            return le = ic(le, ve.mode, Te), le.return = ve, le;
          case me:
            var Ke = le._init;
            return Ze(ve, Ke(le._payload), Te);
        }
        if (Yt(le) || ge(le))
          return le = oc(le, ve.mode, Te, null), le.return = ve, le;
        rm(ve, le);
      }
      return null;
    }
    function Ge(ve, le, Te, Ke) {
      var wt = le !== null ? le.key : null;
      if (typeof Te == "string" && Te !== "" || typeof Te == "number")
        return wt !== null ? null : Z(ve, le, "" + Te, Ke);
      if (typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case F:
            return Te.key === wt ? ee(ve, le, Te, Ke) : null;
          case V:
            return Te.key === wt ? Pe(ve, le, Te, Ke) : null;
          case me:
            return wt = Te._init, Ge(
              ve,
              le,
              wt(Te._payload),
              Ke
            );
        }
        if (Yt(Te) || ge(Te))
          return wt !== null ? null : We(ve, le, Te, Ke, null);
        rm(ve, Te);
      }
      return null;
    }
    function ut(ve, le, Te, Ke, wt) {
      if (typeof Ke == "string" && Ke !== "" || typeof Ke == "number")
        return ve = ve.get(Te) || null, Z(le, ve, "" + Ke, wt);
      if (typeof Ke == "object" && Ke !== null) {
        switch (Ke.$$typeof) {
          case F:
            return ve = ve.get(Ke.key === null ? Te : Ke.key) || null, ee(le, ve, Ke, wt);
          case V:
            return ve = ve.get(Ke.key === null ? Te : Ke.key) || null, Pe(le, ve, Ke, wt);
          case me:
            var St = Ke._init;
            return ut(ve, le, Te, St(Ke._payload), wt);
        }
        if (Yt(Ke) || ge(Ke))
          return ve = ve.get(Te) || null, We(le, ve, Ke, wt, null);
        rm(le, Ke);
      }
      return null;
    }
    function bt(ve, le, Te, Ke) {
      for (var wt = null, St = null, It = le, Gt = le = 0, ao = null; It !== null && Gt < Te.length; Gt++) {
        It.index > Gt ? (ao = It, It = null) : ao = It.sibling;
        var In = Ge(ve, It, Te[Gt], Ke);
        if (In === null) {
          It === null && (It = ao);
          break;
        }
        s && It && In.alternate === null && c(ve, It), le = R(In, le, Gt), St === null ? wt = In : St.sibling = In, St = In, It = ao;
      }
      if (Gt === Te.length)
        return m(ve, It), ar && ki(ve, Gt), wt;
      if (It === null) {
        for (; Gt < Te.length; Gt++)
          It = Ze(ve, Te[Gt], Ke), It !== null && (le = R(It, le, Gt), St === null ? wt = It : St.sibling = It, St = It);
        return ar && ki(ve, Gt), wt;
      }
      for (It = x(ve, It); Gt < Te.length; Gt++)
        ao = ut(It, ve, Gt, Te[Gt], Ke), ao !== null && (s && ao.alternate !== null && It.delete(ao.key === null ? Gt : ao.key), le = R(ao, le, Gt), St === null ? wt = ao : St.sibling = ao, St = ao);
      return s && It.forEach(function(Yl) {
        return c(ve, Yl);
      }), ar && ki(ve, Gt), wt;
    }
    function Ct(ve, le, Te, Ke) {
      var wt = ge(Te);
      if (typeof wt != "function")
        throw Error(n(150));
      if (Te = wt.call(Te), Te == null)
        throw Error(n(151));
      for (var St = wt = null, It = le, Gt = le = 0, ao = null, In = Te.next(); It !== null && !In.done; Gt++, In = Te.next()) {
        It.index > Gt ? (ao = It, It = null) : ao = It.sibling;
        var Yl = Ge(ve, It, In.value, Ke);
        if (Yl === null) {
          It === null && (It = ao);
          break;
        }
        s && It && Yl.alternate === null && c(ve, It), le = R(Yl, le, Gt), St === null ? wt = Yl : St.sibling = Yl, St = Yl, It = ao;
      }
      if (In.done)
        return m(
          ve,
          It
        ), ar && ki(ve, Gt), wt;
      if (It === null) {
        for (; !In.done; Gt++, In = Te.next())
          In = Ze(ve, In.value, Ke), In !== null && (le = R(In, le, Gt), St === null ? wt = In : St.sibling = In, St = In);
        return ar && ki(ve, Gt), wt;
      }
      for (It = x(ve, It); !In.done; Gt++, In = Te.next())
        In = ut(It, ve, Gt, In.value, Ke), In !== null && (s && In.alternate !== null && It.delete(In.key === null ? Gt : In.key), le = R(In, le, Gt), St === null ? wt = In : St.sibling = In, St = In);
      return s && It.forEach(function(yI) {
        return c(ve, yI);
      }), ar && ki(ve, Gt), wt;
    }
    function Pr(ve, le, Te, Ke) {
      if (typeof Te == "object" && Te !== null && Te.type === $ && Te.key === null && (Te = Te.props.children), typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case F:
            e: {
              for (var wt = Te.key, St = le; St !== null; ) {
                if (St.key === wt) {
                  if (wt = Te.type, wt === $) {
                    if (St.tag === 7) {
                      m(ve, St.sibling), le = I(St, Te.props.children), le.return = ve, ve = le;
                      break e;
                    }
                  } else if (St.elementType === wt || typeof wt == "object" && wt !== null && wt.$$typeof === me && v1(wt) === St.type) {
                    m(ve, St.sibling), le = I(St, Te.props), le.ref = dd(ve, St, Te), le.return = ve, ve = le;
                    break e;
                  }
                  m(ve, St);
                  break;
                } else
                  c(ve, St);
                St = St.sibling;
              }
              Te.type === $ ? (le = oc(Te.props.children, ve.mode, Ke, Te.key), le.return = ve, ve = le) : (Ke = Mm(Te.type, Te.key, Te.props, null, ve.mode, Ke), Ke.ref = dd(ve, le, Te), Ke.return = ve, ve = Ke);
            }
            return B(ve);
          case V:
            e: {
              for (St = Te.key; le !== null; ) {
                if (le.key === St)
                  if (le.tag === 4 && le.stateNode.containerInfo === Te.containerInfo && le.stateNode.implementation === Te.implementation) {
                    m(ve, le.sibling), le = I(le, Te.children || []), le.return = ve, ve = le;
                    break e;
                  } else {
                    m(ve, le);
                    break;
                  }
                else
                  c(ve, le);
                le = le.sibling;
              }
              le = ic(Te, ve.mode, Ke), le.return = ve, ve = le;
            }
            return B(ve);
          case me:
            return St = Te._init, Pr(ve, le, St(Te._payload), Ke);
        }
        if (Yt(Te))
          return bt(ve, le, Te, Ke);
        if (ge(Te))
          return Ct(ve, le, Te, Ke);
        rm(ve, Te);
      }
      return typeof Te == "string" && Te !== "" || typeof Te == "number" ? (Te = "" + Te, le !== null && le.tag === 6 ? (m(ve, le.sibling), le = I(le, Te), le.return = ve, ve = le) : (m(ve, le), le = bp(Te, ve.mode, Ke), le.return = ve, ve = le), B(ve)) : m(ve, le);
    }
    return Pr;
  }
  var fd = g1(!0), y1 = g1(!1), tp = {}, Ma = qt(tp), np = qt(tp), pd = qt(tp);
  function zu(s) {
    if (s === tp)
      throw Error(n(174));
    return s;
  }
  function yy(s, c) {
    switch (Fn(pd, c), Fn(np, s), Fn(Ma, tp), s = c.nodeType, s) {
      case 9:
      case 11:
        c = (c = c.documentElement) ? c.namespaceURI : Tn(null, "");
        break;
      default:
        s = s === 8 ? c.parentNode : c, c = s.namespaceURI || null, s = s.tagName, c = Tn(c, s);
    }
    Nn(Ma), Fn(Ma, c);
  }
  function zl() {
    Nn(Ma), Nn(np), Nn(pd);
  }
  function _t(s) {
    zu(pd.current);
    var c = zu(Ma.current), m = Tn(c, s.type);
    c !== m && (Fn(np, s), Fn(Ma, m));
  }
  function pn(s) {
    np.current === s && (Nn(Ma), Nn(np));
  }
  var Mt = qt(0);
  function br(s) {
    for (var c = s; c !== null; ) {
      if (c.tag === 13) {
        var m = c.memoizedState;
        if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!"))
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128)
          return c;
      } else if (c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === s)
        break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === s)
          return null;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
    return null;
  }
  var ea = [];
  function om() {
    for (var s = 0; s < ea.length; s++)
      ea[s]._workInProgressVersionPrimary = null;
    ea.length = 0;
  }
  var im = L.ReactCurrentDispatcher, by = L.ReactCurrentBatchConfig, Hu = 0, sr = null, Be = null, bn = null, Lt = !1, ns = !1, Oi = 0, ju = 0;
  function lr() {
    throw Error(n(321));
  }
  function Gu(s, c) {
    if (c === null)
      return !1;
    for (var m = 0; m < c.length && m < s.length; m++)
      if (!Zi(s[m], c[m]))
        return !1;
    return !0;
  }
  function Hl(s, c, m, x, I, R) {
    if (Hu = R, sr = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, im.current = s === null || s.memoizedState === null ? eI : tI, s = m(x, I), ns) {
      R = 0;
      do {
        if (ns = !1, Oi = 0, 25 <= R)
          throw Error(n(301));
        R += 1, bn = Be = null, c.updateQueue = null, im.current = xy, s = m(x, I);
      } while (ns);
    }
    if (im.current = xm, c = Be !== null && Be.next !== null, Hu = 0, bn = Be = sr = null, Lt = !1, c)
      throw Error(n(300));
    return s;
  }
  function Wu() {
    var s = Oi !== 0;
    return Oi = 0, s;
  }
  function ta() {
    var s = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return bn === null ? sr.memoizedState = bn = s : bn = bn.next = s, bn;
  }
  function pi() {
    if (Be === null) {
      var s = sr.alternate;
      s = s !== null ? s.memoizedState : null;
    } else
      s = Be.next;
    var c = bn === null ? sr.memoizedState : bn.next;
    if (c !== null)
      bn = c, Be = s;
    else {
      if (s === null)
        throw Error(n(310));
      Be = s, s = { memoizedState: Be.memoizedState, baseState: Be.baseState, baseQueue: Be.baseQueue, queue: Be.queue, next: null }, bn === null ? sr.memoizedState = bn = s : bn = bn.next = s;
    }
    return bn;
  }
  function Uu(s, c) {
    return typeof c == "function" ? c(s) : c;
  }
  function rp(s) {
    var c = pi(), m = c.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = s;
    var x = Be, I = x.baseQueue, R = m.pending;
    if (R !== null) {
      if (I !== null) {
        var B = I.next;
        I.next = R.next, R.next = B;
      }
      x.baseQueue = I = R, m.pending = null;
    }
    if (I !== null) {
      R = I.next, x = x.baseState;
      var Z = B = null, ee = null, Pe = R;
      do {
        var We = Pe.lane;
        if ((Hu & We) === We)
          ee !== null && (ee = ee.next = { lane: 0, action: Pe.action, hasEagerState: Pe.hasEagerState, eagerState: Pe.eagerState, next: null }), x = Pe.hasEagerState ? Pe.eagerState : s(x, Pe.action);
        else {
          var Ze = {
            lane: We,
            action: Pe.action,
            hasEagerState: Pe.hasEagerState,
            eagerState: Pe.eagerState,
            next: null
          };
          ee === null ? (Z = ee = Ze, B = x) : ee = ee.next = Ze, sr.lanes |= We, Js |= We;
        }
        Pe = Pe.next;
      } while (Pe !== null && Pe !== R);
      ee === null ? B = x : ee.next = Z, Zi(x, c.memoizedState) || (Lr = !0), c.memoizedState = x, c.baseState = B, c.baseQueue = ee, m.lastRenderedState = x;
    }
    if (s = m.interleaved, s !== null) {
      I = s;
      do
        R = I.lane, sr.lanes |= R, Js |= R, I = I.next;
      while (I !== s);
    } else
      I === null && (m.lanes = 0);
    return [c.memoizedState, m.dispatch];
  }
  function op(s) {
    var c = pi(), m = c.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = s;
    var x = m.dispatch, I = m.pending, R = c.memoizedState;
    if (I !== null) {
      m.pending = null;
      var B = I = I.next;
      do
        R = s(R, B.action), B = B.next;
      while (B !== I);
      Zi(R, c.memoizedState) || (Lr = !0), c.memoizedState = R, c.baseQueue === null && (c.baseState = R), m.lastRenderedState = R;
    }
    return [R, x];
  }
  function am() {
  }
  function sm(s, c) {
    var m = sr, x = pi(), I = c(), R = !Zi(x.memoizedState, I);
    if (R && (x.memoizedState = I, Lr = !0), x = x.queue, ip(cm.bind(null, m, x, s), [s]), x.getSnapshot !== c || R || bn !== null && bn.memoizedState.tag & 1) {
      if (m.flags |= 2048, Xu(9, um.bind(null, m, x, I, c), void 0, null), Sr === null)
        throw Error(n(349));
      Hu & 30 || lm(m, c, I);
    }
    return I;
  }
  function lm(s, c, m) {
    s.flags |= 16384, s = { getSnapshot: c, value: m }, c = sr.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, sr.updateQueue = c, c.stores = [s]) : (m = c.stores, m === null ? c.stores = [s] : m.push(s));
  }
  function um(s, c, m, x) {
    c.value = m, c.getSnapshot = x, dm(c) && fm(s);
  }
  function cm(s, c, m) {
    return m(function() {
      dm(c) && fm(s);
    });
  }
  function dm(s) {
    var c = s.getSnapshot;
    s = s.value;
    try {
      var m = c();
      return !Zi(s, m);
    } catch {
      return !0;
    }
  }
  function fm(s) {
    var c = Ws(s, 1);
    c !== null && Vo(c, s, 1, -1);
  }
  function pm(s) {
    var c = ta();
    return typeof s == "function" && (s = s()), c.memoizedState = c.baseState = s, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Uu, lastRenderedState: s }, c.queue = s, s = s.dispatch = Sm.bind(null, sr, s), [c.memoizedState, s];
  }
  function Xu(s, c, m, x) {
    return s = { tag: s, create: c, destroy: m, deps: x, next: null }, c = sr.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, sr.updateQueue = c, c.lastEffect = s.next = s) : (m = c.lastEffect, m === null ? c.lastEffect = s.next = s : (x = m.next, m.next = s, s.next = x, c.lastEffect = s)), s;
  }
  function hm() {
    return pi().memoizedState;
  }
  function Zu(s, c, m, x) {
    var I = ta();
    sr.flags |= s, I.memoizedState = Xu(1 | c, m, void 0, x === void 0 ? null : x);
  }
  function Xs(s, c, m, x) {
    var I = pi();
    x = x === void 0 ? null : x;
    var R = void 0;
    if (Be !== null) {
      var B = Be.memoizedState;
      if (R = B.destroy, x !== null && Gu(x, B.deps)) {
        I.memoizedState = Xu(c, m, R, x);
        return;
      }
    }
    sr.flags |= s, I.memoizedState = Xu(1 | c, m, R, x);
  }
  function mm(s, c) {
    return Zu(8390656, 8, s, c);
  }
  function ip(s, c) {
    return Xs(2048, 8, s, c);
  }
  function vm(s, c) {
    return Xs(4, 2, s, c);
  }
  function gm(s, c) {
    return Xs(4, 4, s, c);
  }
  function Sy(s, c) {
    if (typeof c == "function")
      return s = s(), c(s), function() {
        c(null);
      };
    if (c != null)
      return s = s(), c.current = s, function() {
        c.current = null;
      };
  }
  function hd(s, c, m) {
    return m = m != null ? m.concat([s]) : null, Xs(4, 4, Sy.bind(null, c, s), m);
  }
  function ym() {
  }
  function md(s, c) {
    var m = pi();
    c = c === void 0 ? null : c;
    var x = m.memoizedState;
    return x !== null && c !== null && Gu(c, x[1]) ? x[0] : (m.memoizedState = [s, c], s);
  }
  function jl(s, c) {
    var m = pi();
    c = c === void 0 ? null : c;
    var x = m.memoizedState;
    return x !== null && c !== null && Gu(c, x[1]) ? x[0] : (s = s(), m.memoizedState = [s, c], s);
  }
  function hi(s, c, m) {
    return Hu & 21 ? (Zi(m, c) || (m = Qc(), sr.lanes |= m, Js |= m, s.baseState = !0), c) : (s.baseState && (s.baseState = !1, Lr = !0), s.memoizedState = m);
  }
  function qT(s, c) {
    var m = On;
    On = m !== 0 && 4 > m ? m : 4, s(!0);
    var x = by.transition;
    by.transition = {};
    try {
      s(!1), c();
    } finally {
      On = m, by.transition = x;
    }
  }
  function tr() {
    return pi().memoizedState;
  }
  function bm(s, c, m) {
    var x = Fr(s);
    if (m = { lane: x, action: m, hasEagerState: !1, eagerState: null, next: null }, vd(s))
      ap(c, m);
    else if (m = d1(s, c, m, x), m !== null) {
      var I = Bo();
      Vo(m, s, x, I), b1(m, c, x);
    }
  }
  function Sm(s, c, m) {
    var x = Fr(s), I = { lane: x, action: m, hasEagerState: !1, eagerState: null, next: null };
    if (vd(s))
      ap(c, I);
    else {
      var R = s.alternate;
      if (s.lanes === 0 && (R === null || R.lanes === 0) && (R = c.lastRenderedReducer, R !== null))
        try {
          var B = c.lastRenderedState, Z = R(B, m);
          if (I.hasEagerState = !0, I.eagerState = Z, Zi(Z, B)) {
            var ee = c.interleaved;
            ee === null ? (I.next = I, hy(c)) : (I.next = ee.next, ee.next = I), c.interleaved = I;
            return;
          }
        } catch {
        } finally {
        }
      m = d1(s, c, I, x), m !== null && (I = Bo(), Vo(m, s, x, I), b1(m, c, x));
    }
  }
  function vd(s) {
    var c = s.alternate;
    return s === sr || c !== null && c === sr;
  }
  function ap(s, c) {
    ns = Lt = !0;
    var m = s.pending;
    m === null ? c.next = c : (c.next = m.next, m.next = c), s.pending = c;
  }
  function b1(s, c, m) {
    if (m & 4194240) {
      var x = c.lanes;
      x &= s.pendingLanes, m |= x, c.lanes = m, ku(s, m);
    }
  }
  var xm = { readContext: Rr, useCallback: lr, useContext: lr, useEffect: lr, useImperativeHandle: lr, useInsertionEffect: lr, useLayoutEffect: lr, useMemo: lr, useReducer: lr, useRef: lr, useState: lr, useDebugValue: lr, useDeferredValue: lr, useTransition: lr, useMutableSource: lr, useSyncExternalStore: lr, useId: lr, unstable_isNewReconciler: !1 }, eI = { readContext: Rr, useCallback: function(s, c) {
    return ta().memoizedState = [s, c === void 0 ? null : c], s;
  }, useContext: Rr, useEffect: mm, useImperativeHandle: function(s, c, m) {
    return m = m != null ? m.concat([s]) : null, Zu(
      4194308,
      4,
      Sy.bind(null, c, s),
      m
    );
  }, useLayoutEffect: function(s, c) {
    return Zu(4194308, 4, s, c);
  }, useInsertionEffect: function(s, c) {
    return Zu(4, 2, s, c);
  }, useMemo: function(s, c) {
    var m = ta();
    return c = c === void 0 ? null : c, s = s(), m.memoizedState = [s, c], s;
  }, useReducer: function(s, c, m) {
    var x = ta();
    return c = m !== void 0 ? m(c) : c, x.memoizedState = x.baseState = c, s = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: s, lastRenderedState: c }, x.queue = s, s = s.dispatch = bm.bind(null, sr, s), [x.memoizedState, s];
  }, useRef: function(s) {
    var c = ta();
    return s = { current: s }, c.memoizedState = s;
  }, useState: pm, useDebugValue: ym, useDeferredValue: function(s) {
    return ta().memoizedState = s;
  }, useTransition: function() {
    var s = pm(!1), c = s[0];
    return s = qT.bind(null, s[1]), ta().memoizedState = s, [c, s];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(s, c, m) {
    var x = sr, I = ta();
    if (ar) {
      if (m === void 0)
        throw Error(n(407));
      m = m();
    } else {
      if (m = c(), Sr === null)
        throw Error(n(349));
      Hu & 30 || lm(x, c, m);
    }
    I.memoizedState = m;
    var R = { value: m, getSnapshot: c };
    return I.queue = R, mm(cm.bind(
      null,
      x,
      R,
      s
    ), [s]), x.flags |= 2048, Xu(9, um.bind(null, x, R, m, c), void 0, null), m;
  }, useId: function() {
    var s = ta(), c = Sr.identifierPrefix;
    if (ar) {
      var m = Gs, x = go;
      m = (x & ~(1 << 32 - oi(x) - 1)).toString(32) + m, c = ":" + c + "R" + m, m = Oi++, 0 < m && (c += "H" + m.toString(32)), c += ":";
    } else
      m = ju++, c = ":" + c + "r" + m.toString(32) + ":";
    return s.memoizedState = c;
  }, unstable_isNewReconciler: !1 }, tI = {
    readContext: Rr,
    useCallback: md,
    useContext: Rr,
    useEffect: ip,
    useImperativeHandle: hd,
    useInsertionEffect: vm,
    useLayoutEffect: gm,
    useMemo: jl,
    useReducer: rp,
    useRef: hm,
    useState: function() {
      return rp(Uu);
    },
    useDebugValue: ym,
    useDeferredValue: function(s) {
      var c = pi();
      return hi(c, Be.memoizedState, s);
    },
    useTransition: function() {
      var s = rp(Uu)[0], c = pi().memoizedState;
      return [s, c];
    },
    useMutableSource: am,
    useSyncExternalStore: sm,
    useId: tr,
    unstable_isNewReconciler: !1
  }, xy = { readContext: Rr, useCallback: md, useContext: Rr, useEffect: ip, useImperativeHandle: hd, useInsertionEffect: vm, useLayoutEffect: gm, useMemo: jl, useReducer: op, useRef: hm, useState: function() {
    return op(Uu);
  }, useDebugValue: ym, useDeferredValue: function(s) {
    var c = pi();
    return Be === null ? c.memoizedState = s : hi(c, Be.memoizedState, s);
  }, useTransition: function() {
    var s = op(Uu)[0], c = pi().memoizedState;
    return [s, c];
  }, useMutableSource: am, useSyncExternalStore: sm, useId: tr, unstable_isNewReconciler: !1 };
  function gd(s, c) {
    try {
      var m = "", x = c;
      do
        m += pe(x), x = x.return;
      while (x);
      var I = m;
    } catch (R) {
      I = `
Error generating stack: ` + R.message + `
` + R.stack;
    }
    return { value: s, source: c, stack: I, digest: null };
  }
  function sp(s, c, m) {
    return { value: s, source: null, stack: m ?? null, digest: c ?? null };
  }
  function Cm(s, c) {
    try {
      console.error(c.value);
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  var nI = typeof WeakMap == "function" ? WeakMap : Map;
  function S1(s, c, m) {
    m = Us(-1, m), m.tag = 3, m.payload = { element: null };
    var x = c.value;
    return m.callback = function() {
      Rm || (Rm = !0, qu = x), Cm(s, c);
    }, m;
  }
  function lp(s, c, m) {
    m = Us(-1, m), m.tag = 3;
    var x = s.type.getDerivedStateFromError;
    if (typeof x == "function") {
      var I = c.value;
      m.payload = function() {
        return x(I);
      }, m.callback = function() {
        Cm(s, c);
      };
    }
    var R = s.stateNode;
    return R !== null && typeof R.componentDidCatch == "function" && (m.callback = function() {
      Cm(s, c), typeof x != "function" && (is === null ? is = /* @__PURE__ */ new Set([this]) : is.add(this));
      var B = c.stack;
      this.componentDidCatch(c.value, { componentStack: B !== null ? B : "" });
    }), m;
  }
  function x1(s, c, m) {
    var x = s.pingCache;
    if (x === null) {
      x = s.pingCache = new nI();
      var I = /* @__PURE__ */ new Set();
      x.set(c, I);
    } else
      I = x.get(c), I === void 0 && (I = /* @__PURE__ */ new Set(), x.set(c, I));
    I.has(m) || (I.add(m), s = uI.bind(null, s, c, m), c.then(s, s));
  }
  function Cy(s) {
    do {
      var c;
      if ((c = s.tag === 13) && (c = s.memoizedState, c = c !== null ? c.dehydrated !== null : !0), c)
        return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function wy(s, c, m, x, I) {
    return s.mode & 1 ? (s.flags |= 65536, s.lanes = I, s) : (s === c ? s.flags |= 65536 : (s.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (c = Us(-1, 1), c.tag = 2, Vl(m, c, 1))), m.lanes |= 1), s);
  }
  var rI = L.ReactCurrentOwner, Lr = !1;
  function Xr(s, c, m, x) {
    c.child = s === null ? y1(c, null, m, x) : fd(c, s.child, m, x);
  }
  function Gl(s, c, m, x, I) {
    m = m.render;
    var R = c.ref;
    return nt(c, I), x = Hl(s, c, m, x, R, I), m = Wu(), s !== null && !Lr ? (c.updateQueue = s.updateQueue, c.flags &= -2053, s.lanes &= ~I, bo(s, c, I)) : (ar && m && Zh(c), c.flags |= 1, Xr(s, c, x, I), c.child);
  }
  function wm(s, c, m, x, I) {
    if (s === null) {
      var R = m.type;
      return typeof R == "function" && !Hy(R) && R.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (c.tag = 15, c.type = R, mi(s, c, R, x, I)) : (s = Mm(m.type, null, x, c, c.mode, I), s.ref = c.ref, s.return = c, c.child = s);
    }
    if (R = s.child, !(s.lanes & I)) {
      var B = R.memoizedProps;
      if (m = m.compare, m = m !== null ? m : jf, m(B, x) && s.ref === c.ref)
        return bo(s, c, I);
    }
    return c.flags |= 1, s = Zl(R, x), s.ref = c.ref, s.return = c, c.child = s;
  }
  function mi(s, c, m, x, I) {
    if (s !== null) {
      var R = s.memoizedProps;
      if (jf(R, x) && s.ref === c.ref)
        if (Lr = !1, c.pendingProps = x = R, (s.lanes & I) !== 0)
          s.flags & 131072 && (Lr = !0);
        else
          return c.lanes = s.lanes, bo(s, c, I);
    }
    return yd(s, c, m, x, I);
  }
  function Yu(s, c, m) {
    var x = c.pendingProps, I = x.children, R = s !== null ? s.memoizedState : null;
    if (x.mode === "hidden")
      if (!(c.mode & 1))
        c.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Fn(Ed, _i), _i |= m;
      else {
        if (!(m & 1073741824))
          return s = R !== null ? R.baseLanes | m : m, c.lanes = c.childLanes = 1073741824, c.memoizedState = { baseLanes: s, cachePool: null, transitions: null }, c.updateQueue = null, Fn(Ed, _i), _i |= s, null;
        c.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, x = R !== null ? R.baseLanes : m, Fn(Ed, _i), _i |= x;
      }
    else
      R !== null ? (x = R.baseLanes | m, c.memoizedState = null) : x = m, Fn(Ed, _i), _i |= x;
    return Xr(s, c, I, m), c.child;
  }
  function en(s, c) {
    var m = c.ref;
    (s === null && m !== null || s !== null && s.ref !== m) && (c.flags |= 512, c.flags |= 2097152);
  }
  function yd(s, c, m, x, I) {
    var R = hr(m) ? li : jt.current;
    return R = Ji(c, R), nt(c, I), m = Hl(s, c, m, x, R, I), x = Wu(), s !== null && !Lr ? (c.updateQueue = s.updateQueue, c.flags &= -2053, s.lanes &= ~I, bo(s, c, I)) : (ar && x && Zh(c), c.flags |= 1, Xr(s, c, m, I), c.child);
  }
  function Ey(s, c, m, x, I) {
    if (hr(m)) {
      var R = !0;
      Xh(c);
    } else
      R = !1;
    if (nt(c, I), c.stateNode === null)
      Mo(s, c), h1(c, m, x), nm(c, m, x, I), x = !0;
    else if (s === null) {
      var B = c.stateNode, Z = c.memoizedProps;
      B.props = Z;
      var ee = B.context, Pe = m.contextType;
      typeof Pe == "object" && Pe !== null ? Pe = Rr(Pe) : (Pe = hr(m) ? li : jt.current, Pe = Ji(c, Pe));
      var We = m.getDerivedStateFromProps, Ze = typeof We == "function" || typeof B.getSnapshotBeforeUpdate == "function";
      Ze || typeof B.UNSAFE_componentWillReceiveProps != "function" && typeof B.componentWillReceiveProps != "function" || (Z !== x || ee !== Pe) && m1(c, B, x, Pe), Bl = !1;
      var Ge = c.memoizedState;
      B.state = Ge, $l(c, x, B, I), ee = c.memoizedState, Z !== x || Ge !== ee || Tr.current || Bl ? (typeof We == "function" && (gy(c, m, We, x), ee = c.memoizedState), (Z = Bl || p1(c, m, Z, x, Ge, ee, Pe)) ? (Ze || typeof B.UNSAFE_componentWillMount != "function" && typeof B.componentWillMount != "function" || (typeof B.componentWillMount == "function" && B.componentWillMount(), typeof B.UNSAFE_componentWillMount == "function" && B.UNSAFE_componentWillMount()), typeof B.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof B.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = x, c.memoizedState = ee), B.props = x, B.state = ee, B.context = Pe, x = Z) : (typeof B.componentDidMount == "function" && (c.flags |= 4194308), x = !1);
    } else {
      B = c.stateNode, Ur(s, c), Z = c.memoizedProps, Pe = c.type === c.elementType ? Z : Pi(c.type, Z), B.props = Pe, Ze = c.pendingProps, Ge = B.context, ee = m.contextType, typeof ee == "object" && ee !== null ? ee = Rr(ee) : (ee = hr(m) ? li : jt.current, ee = Ji(c, ee));
      var ut = m.getDerivedStateFromProps;
      (We = typeof ut == "function" || typeof B.getSnapshotBeforeUpdate == "function") || typeof B.UNSAFE_componentWillReceiveProps != "function" && typeof B.componentWillReceiveProps != "function" || (Z !== Ze || Ge !== ee) && m1(c, B, x, ee), Bl = !1, Ge = c.memoizedState, B.state = Ge, $l(c, x, B, I);
      var bt = c.memoizedState;
      Z !== Ze || Ge !== bt || Tr.current || Bl ? (typeof ut == "function" && (gy(c, m, ut, x), bt = c.memoizedState), (Pe = Bl || p1(c, m, Pe, x, Ge, bt, ee) || !1) ? (We || typeof B.UNSAFE_componentWillUpdate != "function" && typeof B.componentWillUpdate != "function" || (typeof B.componentWillUpdate == "function" && B.componentWillUpdate(x, bt, ee), typeof B.UNSAFE_componentWillUpdate == "function" && B.UNSAFE_componentWillUpdate(x, bt, ee)), typeof B.componentDidUpdate == "function" && (c.flags |= 4), typeof B.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof B.componentDidUpdate != "function" || Z === s.memoizedProps && Ge === s.memoizedState || (c.flags |= 4), typeof B.getSnapshotBeforeUpdate != "function" || Z === s.memoizedProps && Ge === s.memoizedState || (c.flags |= 1024), c.memoizedProps = x, c.memoizedState = bt), B.props = x, B.state = bt, B.context = ee, x = Pe) : (typeof B.componentDidUpdate != "function" || Z === s.memoizedProps && Ge === s.memoizedState || (c.flags |= 4), typeof B.getSnapshotBeforeUpdate != "function" || Z === s.memoizedProps && Ge === s.memoizedState || (c.flags |= 1024), x = !1);
    }
    return C1(s, c, m, x, R, I);
  }
  function C1(s, c, m, x, I, R) {
    en(s, c);
    var B = (c.flags & 128) !== 0;
    if (!x && !B)
      return I && s1(c, m, !1), bo(s, c, R);
    x = c.stateNode, rI.current = c;
    var Z = B && typeof m.getDerivedStateFromError != "function" ? null : x.render();
    return c.flags |= 1, s !== null && B ? (c.child = fd(c, s.child, null, R), c.child = fd(c, null, Z, R)) : Xr(s, c, Z, R), c.memoizedState = x.state, I && s1(c, m, !0), c.child;
  }
  function w1(s) {
    var c = s.stateNode;
    c.pendingContext ? Nl(s, c.pendingContext, c.pendingContext !== c.context) : c.context && Nl(s, c.context, !1), yy(s, c.containerInfo);
  }
  function Em(s, c, m, x, I) {
    return yr(), dy(I), c.flags |= 256, Xr(s, c, m, x), c.child;
  }
  var Ju = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ty(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function Iy(s, c, m) {
    var x = c.pendingProps, I = Mt.current, R = !1, B = (c.flags & 128) !== 0, Z;
    if ((Z = B) || (Z = s !== null && s.memoizedState === null ? !1 : (I & 2) !== 0), Z ? (R = !0, c.flags &= -129) : (s === null || s.memoizedState !== null) && (I |= 1), Fn(Mt, I & 1), s === null)
      return Jh(c), s = c.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? (c.mode & 1 ? s.data === "$!" ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1, null) : (B = x.children, s = x.fallback, R ? (x = c.mode, R = c.child, B = { mode: "hidden", children: B }, !(x & 1) && R !== null ? (R.childLanes = 0, R.pendingProps = B) : R = yp(B, x, 0, null), s = oc(s, x, m, null), R.return = c, s.return = c, R.sibling = s, c.child = R, c.child.memoizedState = Ty(m), c.memoizedState = Ju, s) : Ay(c, B));
    if (I = s.memoizedState, I !== null && (Z = I.dehydrated, Z !== null))
      return oI(s, c, B, x, Z, I, m);
    if (R) {
      R = x.fallback, B = c.mode, I = s.child, Z = I.sibling;
      var ee = { mode: "hidden", children: x.children };
      return !(B & 1) && c.child !== I ? (x = c.child, x.childLanes = 0, x.pendingProps = ee, c.deletions = null) : (x = Zl(I, ee), x.subtreeFlags = I.subtreeFlags & 14680064), Z !== null ? R = Zl(Z, R) : (R = oc(R, B, m, null), R.flags |= 2), R.return = c, x.return = c, x.sibling = R, c.child = x, x = R, R = c.child, B = s.child.memoizedState, B = B === null ? Ty(m) : { baseLanes: B.baseLanes | m, cachePool: null, transitions: B.transitions }, R.memoizedState = B, R.childLanes = s.childLanes & ~m, c.memoizedState = Ju, x;
    }
    return R = s.child, s = R.sibling, x = Zl(R, { mode: "visible", children: x.children }), !(c.mode & 1) && (x.lanes = m), x.return = c, x.sibling = null, s !== null && (m = c.deletions, m === null ? (c.deletions = [s], c.flags |= 16) : m.push(s)), c.child = x, c.memoizedState = null, x;
  }
  function Ay(s, c) {
    return c = yp({ mode: "visible", children: c }, s.mode, 0, null), c.return = s, s.child = c;
  }
  function bd(s, c, m, x) {
    return x !== null && dy(x), fd(c, s.child, null, m), s = Ay(c, c.pendingProps.children), s.flags |= 2, c.memoizedState = null, s;
  }
  function oI(s, c, m, x, I, R, B) {
    if (m)
      return c.flags & 256 ? (c.flags &= -257, x = sp(Error(n(422))), bd(s, c, B, x)) : c.memoizedState !== null ? (c.child = s.child, c.flags |= 128, null) : (R = x.fallback, I = c.mode, x = yp({ mode: "visible", children: x.children }, I, 0, null), R = oc(R, I, B, null), R.flags |= 2, x.return = c, R.return = c, x.sibling = R, c.child = x, c.mode & 1 && fd(c, s.child, null, B), c.child.memoizedState = Ty(B), c.memoizedState = Ju, R);
    if (!(c.mode & 1))
      return bd(s, c, B, null);
    if (I.data === "$!") {
      if (x = I.nextSibling && I.nextSibling.dataset, x)
        var Z = x.dgst;
      return x = Z, R = Error(n(419)), x = sp(R, x, void 0), bd(s, c, B, x);
    }
    if (Z = (B & s.childLanes) !== 0, Lr || Z) {
      if (x = Sr, x !== null) {
        switch (B & -B) {
          case 4:
            I = 2;
            break;
          case 16:
            I = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            I = 32;
            break;
          case 536870912:
            I = 268435456;
            break;
          default:
            I = 0;
        }
        I = I & (x.suspendedLanes | B) ? 0 : I, I !== 0 && I !== R.retryLane && (R.retryLane = I, Ws(s, I), Vo(x, s, I, -1));
      }
      return Vy(), x = sp(Error(n(421))), bd(s, c, B, x);
    }
    return I.data === "$?" ? (c.flags |= 128, c.child = s.child, c = cI.bind(null, s), I._reactRetry = c, null) : (s = R.treeContext, fi = Na(I.nextSibling), Ri = c, ar = !0, qi = null, s !== null && (di[No++] = go, di[No++] = Gs, di[No++] = Ki, go = s.id, Gs = s.overflow, Ki = c), c = Ay(c, x.children), c.flags |= 4096, c);
  }
  function ky(s, c, m) {
    s.lanes |= c;
    var x = s.alternate;
    x !== null && (x.lanes |= c), ro(s.return, c, m);
  }
  function Tm(s, c, m, x, I) {
    var R = s.memoizedState;
    R === null ? s.memoizedState = { isBackwards: c, rendering: null, renderingStartTime: 0, last: x, tail: m, tailMode: I } : (R.isBackwards = c, R.rendering = null, R.renderingStartTime = 0, R.last = x, R.tail = m, R.tailMode = I);
  }
  function Ry(s, c, m) {
    var x = c.pendingProps, I = x.revealOrder, R = x.tail;
    if (Xr(s, c, x.children, m), x = Mt.current, x & 2)
      x = x & 1 | 2, c.flags |= 128;
    else {
      if (s !== null && s.flags & 128)
        e:
          for (s = c.child; s !== null; ) {
            if (s.tag === 13)
              s.memoizedState !== null && ky(s, m, c);
            else if (s.tag === 19)
              ky(s, m, c);
            else if (s.child !== null) {
              s.child.return = s, s = s.child;
              continue;
            }
            if (s === c)
              break e;
            for (; s.sibling === null; ) {
              if (s.return === null || s.return === c)
                break e;
              s = s.return;
            }
            s.sibling.return = s.return, s = s.sibling;
          }
      x &= 1;
    }
    if (Fn(Mt, x), !(c.mode & 1))
      c.memoizedState = null;
    else
      switch (I) {
        case "forwards":
          for (m = c.child, I = null; m !== null; )
            s = m.alternate, s !== null && br(s) === null && (I = m), m = m.sibling;
          m = I, m === null ? (I = c.child, c.child = null) : (I = m.sibling, m.sibling = null), Tm(c, !1, I, m, R);
          break;
        case "backwards":
          for (m = null, I = c.child, c.child = null; I !== null; ) {
            if (s = I.alternate, s !== null && br(s) === null) {
              c.child = I;
              break;
            }
            s = I.sibling, I.sibling = m, m = I, I = s;
          }
          Tm(c, !0, m, null, R);
          break;
        case "together":
          Tm(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function Mo(s, c) {
    !(c.mode & 1) && s !== null && (s.alternate = null, c.alternate = null, c.flags |= 2);
  }
  function bo(s, c, m) {
    if (s !== null && (c.dependencies = s.dependencies), Js |= c.lanes, !(m & c.childLanes))
      return null;
    if (s !== null && c.child !== s.child)
      throw Error(n(153));
    if (c.child !== null) {
      for (s = c.child, m = Zl(s, s.pendingProps), c.child = m, m.return = c; s.sibling !== null; )
        s = s.sibling, m = m.sibling = Zl(s, s.pendingProps), m.return = c;
      m.sibling = null;
    }
    return c.child;
  }
  function Zs(s, c, m) {
    switch (c.tag) {
      case 3:
        w1(c), yr();
        break;
      case 5:
        _t(c);
        break;
      case 1:
        hr(c.type) && Xh(c);
        break;
      case 4:
        yy(c, c.stateNode.containerInfo);
        break;
      case 10:
        var x = c.type._context, I = c.memoizedProps.value;
        Fn(ts, x._currentValue), x._currentValue = I;
        break;
      case 13:
        if (x = c.memoizedState, x !== null)
          return x.dehydrated !== null ? (Fn(Mt, Mt.current & 1), c.flags |= 128, null) : m & c.child.childLanes ? Iy(s, c, m) : (Fn(Mt, Mt.current & 1), s = bo(s, c, m), s !== null ? s.sibling : null);
        Fn(Mt, Mt.current & 1);
        break;
      case 19:
        if (x = (m & c.childLanes) !== 0, s.flags & 128) {
          if (x)
            return Ry(s, c, m);
          c.flags |= 128;
        }
        if (I = c.memoizedState, I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), Fn(Mt, Mt.current), x)
          break;
        return null;
      case 22:
      case 23:
        return c.lanes = 0, Yu(s, c, m);
    }
    return bo(s, c, m);
  }
  var up, Qu, na, Zr;
  up = function(s, c) {
    for (var m = c.child; m !== null; ) {
      if (m.tag === 5 || m.tag === 6)
        s.appendChild(m.stateNode);
      else if (m.tag !== 4 && m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === c)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === c)
          return;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
  }, Qu = function() {
  }, na = function(s, c, m, x) {
    var I = s.memoizedProps;
    if (I !== x) {
      s = c.stateNode, zu(Ma.current);
      var R = null;
      switch (m) {
        case "input":
          I = Ve(s, I), x = Ve(s, x), R = [];
          break;
        case "select":
          I = Y({}, I, { value: void 0 }), x = Y({}, x, { value: void 0 }), R = [];
          break;
        case "textarea":
          I = vn(s, I), x = vn(s, x), R = [];
          break;
        default:
          typeof I.onClick != "function" && typeof x.onClick == "function" && (s.onclick = Uh);
      }
      tt(m, x);
      var B;
      m = null;
      for (Pe in I)
        if (!x.hasOwnProperty(Pe) && I.hasOwnProperty(Pe) && I[Pe] != null)
          if (Pe === "style") {
            var Z = I[Pe];
            for (B in Z)
              Z.hasOwnProperty(B) && (m || (m = {}), m[B] = "");
          } else
            Pe !== "dangerouslySetInnerHTML" && Pe !== "children" && Pe !== "suppressContentEditableWarning" && Pe !== "suppressHydrationWarning" && Pe !== "autoFocus" && (a.hasOwnProperty(Pe) ? R || (R = []) : (R = R || []).push(Pe, null));
      for (Pe in x) {
        var ee = x[Pe];
        if (Z = I != null ? I[Pe] : void 0, x.hasOwnProperty(Pe) && ee !== Z && (ee != null || Z != null))
          if (Pe === "style")
            if (Z) {
              for (B in Z)
                !Z.hasOwnProperty(B) || ee && ee.hasOwnProperty(B) || (m || (m = {}), m[B] = "");
              for (B in ee)
                ee.hasOwnProperty(B) && Z[B] !== ee[B] && (m || (m = {}), m[B] = ee[B]);
            } else
              m || (R || (R = []), R.push(
                Pe,
                m
              )), m = ee;
          else
            Pe === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, Z = Z ? Z.__html : void 0, ee != null && Z !== ee && (R = R || []).push(Pe, ee)) : Pe === "children" ? typeof ee != "string" && typeof ee != "number" || (R = R || []).push(Pe, "" + ee) : Pe !== "suppressContentEditableWarning" && Pe !== "suppressHydrationWarning" && (a.hasOwnProperty(Pe) ? (ee != null && Pe === "onScroll" && er("scroll", s), R || Z === ee || (R = [])) : (R = R || []).push(Pe, ee));
      }
      m && (R = R || []).push("style", m);
      var Pe = R;
      (c.updateQueue = Pe) && (c.flags |= 4);
    }
  }, Zr = function(s, c, m, x) {
    m !== x && (c.flags |= 4);
  };
  function cp(s, c) {
    if (!ar)
      switch (s.tailMode) {
        case "hidden":
          c = s.tail;
          for (var m = null; c !== null; )
            c.alternate !== null && (m = c), c = c.sibling;
          m === null ? s.tail = null : m.sibling = null;
          break;
        case "collapsed":
          m = s.tail;
          for (var x = null; m !== null; )
            m.alternate !== null && (x = m), m = m.sibling;
          x === null ? c || s.tail === null ? s.tail = null : s.tail.sibling = null : x.sibling = null;
      }
  }
  function Lo(s) {
    var c = s.alternate !== null && s.alternate.child === s.child, m = 0, x = 0;
    if (c)
      for (var I = s.child; I !== null; )
        m |= I.lanes | I.childLanes, x |= I.subtreeFlags & 14680064, x |= I.flags & 14680064, I.return = s, I = I.sibling;
    else
      for (I = s.child; I !== null; )
        m |= I.lanes | I.childLanes, x |= I.subtreeFlags, x |= I.flags, I.return = s, I = I.sibling;
    return s.subtreeFlags |= x, s.childLanes = m, c;
  }
  function iI(s, c, m) {
    var x = c.pendingProps;
    switch (uy(c), c.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Lo(c), null;
      case 1:
        return hr(c.type) && Qi(), Lo(c), null;
      case 3:
        return x = c.stateNode, zl(), Nn(Tr), Nn(jt), om(), x.pendingContext && (x.context = x.pendingContext, x.pendingContext = null), (s === null || s.child === null) && (Qh(c) ? c.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024, qi !== null && (gp(qi), qi = null))), Qu(s, c), Lo(c), null;
      case 5:
        pn(c);
        var I = zu(pd.current);
        if (m = c.type, s !== null && c.stateNode != null)
          na(s, c, m, x, I), s.ref !== c.ref && (c.flags |= 512, c.flags |= 2097152);
        else {
          if (!x) {
            if (c.stateNode === null)
              throw Error(n(166));
            return Lo(c), null;
          }
          if (s = zu(Ma.current), Qh(c)) {
            x = c.stateNode, m = c.type;
            var R = c.memoizedProps;
            switch (x[qa] = c, x[Bu] = R, s = (c.mode & 1) !== 0, m) {
              case "dialog":
                er("cancel", x), er("close", x);
                break;
              case "iframe":
              case "object":
              case "embed":
                er("load", x);
                break;
              case "video":
              case "audio":
                for (I = 0; I < Xf.length; I++)
                  er(Xf[I], x);
                break;
              case "source":
                er("error", x);
                break;
              case "img":
              case "image":
              case "link":
                er(
                  "error",
                  x
                ), er("load", x);
                break;
              case "details":
                er("toggle", x);
                break;
              case "input":
                Ie(x, R), er("invalid", x);
                break;
              case "select":
                x._wrapperState = { wasMultiple: !!R.multiple }, er("invalid", x);
                break;
              case "textarea":
                nn(x, R), er("invalid", x);
            }
            tt(m, R), I = null;
            for (var B in R)
              if (R.hasOwnProperty(B)) {
                var Z = R[B];
                B === "children" ? typeof Z == "string" ? x.textContent !== Z && (R.suppressHydrationWarning !== !0 && Wh(x.textContent, Z, s), I = ["children", Z]) : typeof Z == "number" && x.textContent !== "" + Z && (R.suppressHydrationWarning !== !0 && Wh(
                  x.textContent,
                  Z,
                  s
                ), I = ["children", "" + Z]) : a.hasOwnProperty(B) && Z != null && B === "onScroll" && er("scroll", x);
              }
            switch (m) {
              case "input":
                we(x), lt(x, R, !0);
                break;
              case "textarea":
                we(x), mn(x);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof R.onClick == "function" && (x.onclick = Uh);
            }
            x = I, c.updateQueue = x, x !== null && (c.flags |= 4);
          } else {
            B = I.nodeType === 9 ? I : I.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = un(m)), s === "http://www.w3.org/1999/xhtml" ? m === "script" ? (s = B.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof x.is == "string" ? s = B.createElement(m, { is: x.is }) : (s = B.createElement(m), m === "select" && (B = s, x.multiple ? B.multiple = !0 : x.size && (B.size = x.size))) : s = B.createElementNS(s, m), s[qa] = c, s[Bu] = x, up(s, c, !1, !1), c.stateNode = s;
            e: {
              switch (B = ft(m, x), m) {
                case "dialog":
                  er("cancel", s), er("close", s), I = x;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  er("load", s), I = x;
                  break;
                case "video":
                case "audio":
                  for (I = 0; I < Xf.length; I++)
                    er(Xf[I], s);
                  I = x;
                  break;
                case "source":
                  er("error", s), I = x;
                  break;
                case "img":
                case "image":
                case "link":
                  er(
                    "error",
                    s
                  ), er("load", s), I = x;
                  break;
                case "details":
                  er("toggle", s), I = x;
                  break;
                case "input":
                  Ie(s, x), I = Ve(s, x), er("invalid", s);
                  break;
                case "option":
                  I = x;
                  break;
                case "select":
                  s._wrapperState = { wasMultiple: !!x.multiple }, I = Y({}, x, { value: void 0 }), er("invalid", s);
                  break;
                case "textarea":
                  nn(s, x), I = vn(s, x), er("invalid", s);
                  break;
                default:
                  I = x;
              }
              tt(m, I), Z = I;
              for (R in Z)
                if (Z.hasOwnProperty(R)) {
                  var ee = Z[R];
                  R === "style" ? Kt(s, ee) : R === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, ee != null && Ot(s, ee)) : R === "children" ? typeof ee == "string" ? (m !== "textarea" || ee !== "") && an(s, ee) : typeof ee == "number" && an(s, "" + ee) : R !== "suppressContentEditableWarning" && R !== "suppressHydrationWarning" && R !== "autoFocus" && (a.hasOwnProperty(R) ? ee != null && R === "onScroll" && er("scroll", s) : ee != null && D(s, R, ee, B));
                }
              switch (m) {
                case "input":
                  we(s), lt(s, x, !1);
                  break;
                case "textarea":
                  we(s), mn(s);
                  break;
                case "option":
                  x.value != null && s.setAttribute("value", "" + xe(x.value));
                  break;
                case "select":
                  s.multiple = !!x.multiple, R = x.value, R != null ? hn(s, !!x.multiple, R, !1) : x.defaultValue != null && hn(
                    s,
                    !!x.multiple,
                    x.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof I.onClick == "function" && (s.onclick = Uh);
              }
              switch (m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  x = !!x.autoFocus;
                  break e;
                case "img":
                  x = !0;
                  break e;
                default:
                  x = !1;
              }
            }
            x && (c.flags |= 4);
          }
          c.ref !== null && (c.flags |= 512, c.flags |= 2097152);
        }
        return Lo(c), null;
      case 6:
        if (s && c.stateNode != null)
          Zr(s, c, s.memoizedProps, x);
        else {
          if (typeof x != "string" && c.stateNode === null)
            throw Error(n(166));
          if (m = zu(pd.current), zu(Ma.current), Qh(c)) {
            if (x = c.stateNode, m = c.memoizedProps, x[qa] = c, (R = x.nodeValue !== m) && (s = Ri, s !== null))
              switch (s.tag) {
                case 3:
                  Wh(x.nodeValue, m, (s.mode & 1) !== 0);
                  break;
                case 5:
                  s.memoizedProps.suppressHydrationWarning !== !0 && Wh(x.nodeValue, m, (s.mode & 1) !== 0);
              }
            R && (c.flags |= 4);
          } else
            x = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(x), x[qa] = c, c.stateNode = x;
        }
        return Lo(c), null;
      case 13:
        if (Nn(Mt), x = c.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
          if (ar && fi !== null && c.mode & 1 && !(c.flags & 128))
            c1(), yr(), c.flags |= 98560, R = !1;
          else if (R = Qh(c), x !== null && x.dehydrated !== null) {
            if (s === null) {
              if (!R)
                throw Error(n(318));
              if (R = c.memoizedState, R = R !== null ? R.dehydrated : null, !R)
                throw Error(n(317));
              R[qa] = c;
            } else
              yr(), !(c.flags & 128) && (c.memoizedState = null), c.flags |= 4;
            Lo(c), R = !1;
          } else
            qi !== null && (gp(qi), qi = null), R = !0;
          if (!R)
            return c.flags & 65536 ? c : null;
        }
        return c.flags & 128 ? (c.lanes = m, c) : (x = x !== null, x !== (s !== null && s.memoizedState !== null) && x && (c.child.flags |= 8192, c.mode & 1 && (s === null || Mt.current & 1 ? Jr === 0 && (Jr = 3) : Vy())), c.updateQueue !== null && (c.flags |= 4), Lo(c), null);
      case 4:
        return zl(), Qu(s, c), s === null && ld(c.stateNode.containerInfo), Lo(c), null;
      case 10:
        return Fl(c.type._context), Lo(c), null;
      case 17:
        return hr(c.type) && Qi(), Lo(c), null;
      case 19:
        if (Nn(Mt), R = c.memoizedState, R === null)
          return Lo(c), null;
        if (x = (c.flags & 128) !== 0, B = R.rendering, B === null)
          if (x)
            cp(R, !1);
          else {
            if (Jr !== 0 || s !== null && s.flags & 128)
              for (s = c.child; s !== null; ) {
                if (B = br(s), B !== null) {
                  for (c.flags |= 128, cp(R, !1), x = B.updateQueue, x !== null && (c.updateQueue = x, c.flags |= 4), c.subtreeFlags = 0, x = m, m = c.child; m !== null; )
                    R = m, s = x, R.flags &= 14680066, B = R.alternate, B === null ? (R.childLanes = 0, R.lanes = s, R.child = null, R.subtreeFlags = 0, R.memoizedProps = null, R.memoizedState = null, R.updateQueue = null, R.dependencies = null, R.stateNode = null) : (R.childLanes = B.childLanes, R.lanes = B.lanes, R.child = B.child, R.subtreeFlags = 0, R.deletions = null, R.memoizedProps = B.memoizedProps, R.memoizedState = B.memoizedState, R.updateQueue = B.updateQueue, R.type = B.type, s = B.dependencies, R.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }), m = m.sibling;
                  return Fn(Mt, Mt.current & 1 | 2), c.child;
                }
                s = s.sibling;
              }
            R.tail !== null && qn() > Id && (c.flags |= 128, x = !0, cp(R, !1), c.lanes = 4194304);
          }
        else {
          if (!x)
            if (s = br(B), s !== null) {
              if (c.flags |= 128, x = !0, m = s.updateQueue, m !== null && (c.updateQueue = m, c.flags |= 4), cp(R, !0), R.tail === null && R.tailMode === "hidden" && !B.alternate && !ar)
                return Lo(c), null;
            } else
              2 * qn() - R.renderingStartTime > Id && m !== 1073741824 && (c.flags |= 128, x = !0, cp(R, !1), c.lanes = 4194304);
          R.isBackwards ? (B.sibling = c.child, c.child = B) : (m = R.last, m !== null ? m.sibling = B : c.child = B, R.last = B);
        }
        return R.tail !== null ? (c = R.tail, R.rendering = c, R.tail = c.sibling, R.renderingStartTime = qn(), c.sibling = null, m = Mt.current, Fn(Mt, x ? m & 1 | 2 : m & 1), c) : (Lo(c), null);
      case 22:
      case 23:
        return By(), x = c.memoizedState !== null, s !== null && s.memoizedState !== null !== x && (c.flags |= 8192), x && c.mode & 1 ? _i & 1073741824 && (Lo(c), c.subtreeFlags & 6 && (c.flags |= 8192)) : Lo(c), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, c.tag));
  }
  function Py(s, c) {
    switch (uy(c), c.tag) {
      case 1:
        return hr(c.type) && Qi(), s = c.flags, s & 65536 ? (c.flags = s & -65537 | 128, c) : null;
      case 3:
        return zl(), Nn(Tr), Nn(jt), om(), s = c.flags, s & 65536 && !(s & 128) ? (c.flags = s & -65537 | 128, c) : null;
      case 5:
        return pn(c), null;
      case 13:
        if (Nn(Mt), s = c.memoizedState, s !== null && s.dehydrated !== null) {
          if (c.alternate === null)
            throw Error(n(340));
          yr();
        }
        return s = c.flags, s & 65536 ? (c.flags = s & -65537 | 128, c) : null;
      case 19:
        return Nn(Mt), null;
      case 4:
        return zl(), null;
      case 10:
        return Fl(c.type._context), null;
      case 22:
      case 23:
        return By(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var dp = !1, Yr = !1, E1 = typeof WeakSet == "function" ? WeakSet : Set, yt = null;
  function Sd(s, c) {
    var m = s.ref;
    if (m !== null)
      if (typeof m == "function")
        try {
          m(null);
        } catch (x) {
          Ar(s, c, x);
        }
      else
        m.current = null;
  }
  function fp(s, c, m) {
    try {
      m();
    } catch (x) {
      Ar(s, c, x);
    }
  }
  var T1 = !1;
  function I1(s, c) {
    if (ty = Fs, s = $h(), $s(s)) {
      if ("selectionStart" in s)
        var m = { start: s.selectionStart, end: s.selectionEnd };
      else
        e: {
          m = (m = s.ownerDocument) && m.defaultView || window;
          var x = m.getSelection && m.getSelection();
          if (x && x.rangeCount !== 0) {
            m = x.anchorNode;
            var I = x.anchorOffset, R = x.focusNode;
            x = x.focusOffset;
            try {
              m.nodeType, R.nodeType;
            } catch {
              m = null;
              break e;
            }
            var B = 0, Z = -1, ee = -1, Pe = 0, We = 0, Ze = s, Ge = null;
            t:
              for (; ; ) {
                for (var ut; Ze !== m || I !== 0 && Ze.nodeType !== 3 || (Z = B + I), Ze !== R || x !== 0 && Ze.nodeType !== 3 || (ee = B + x), Ze.nodeType === 3 && (B += Ze.nodeValue.length), (ut = Ze.firstChild) !== null; )
                  Ge = Ze, Ze = ut;
                for (; ; ) {
                  if (Ze === s)
                    break t;
                  if (Ge === m && ++Pe === I && (Z = B), Ge === R && ++We === x && (ee = B), (ut = Ze.nextSibling) !== null)
                    break;
                  Ze = Ge, Ge = Ze.parentNode;
                }
                Ze = ut;
              }
            m = Z === -1 || ee === -1 ? null : { start: Z, end: ee };
          } else
            m = null;
        }
      m = m || { start: 0, end: 0 };
    } else
      m = null;
    for (Lu = { focusedElem: s, selectionRange: m }, Fs = !1, yt = c; yt !== null; )
      if (c = yt, s = c.child, (c.subtreeFlags & 1028) !== 0 && s !== null)
        s.return = c, yt = s;
      else
        for (; yt !== null; ) {
          c = yt;
          try {
            var bt = c.alternate;
            if (c.flags & 1024)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (bt !== null) {
                    var Ct = bt.memoizedProps, Pr = bt.memoizedState, ve = c.stateNode, le = ve.getSnapshotBeforeUpdate(c.elementType === c.type ? Ct : Pi(c.type, Ct), Pr);
                    ve.__reactInternalSnapshotBeforeUpdate = le;
                  }
                  break;
                case 3:
                  var Te = c.stateNode.containerInfo;
                  Te.nodeType === 1 ? Te.textContent = "" : Te.nodeType === 9 && Te.documentElement && Te.removeChild(Te.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (Ke) {
            Ar(c, c.return, Ke);
          }
          if (s = c.sibling, s !== null) {
            s.return = c.return, yt = s;
            break;
          }
          yt = c.return;
        }
    return bt = T1, T1 = !1, bt;
  }
  function pp(s, c, m) {
    var x = c.updateQueue;
    if (x = x !== null ? x.lastEffect : null, x !== null) {
      var I = x = x.next;
      do {
        if ((I.tag & s) === s) {
          var R = I.destroy;
          I.destroy = void 0, R !== void 0 && fp(c, m, R);
        }
        I = I.next;
      } while (I !== x);
    }
  }
  function hp(s, c) {
    if (c = c.updateQueue, c = c !== null ? c.lastEffect : null, c !== null) {
      var m = c = c.next;
      do {
        if ((m.tag & s) === s) {
          var x = m.create;
          m.destroy = x();
        }
        m = m.next;
      } while (m !== c);
    }
  }
  function Oy(s) {
    var c = s.ref;
    if (c !== null) {
      var m = s.stateNode;
      switch (s.tag) {
        case 5:
          s = m;
          break;
        default:
          s = m;
      }
      typeof c == "function" ? c(s) : c.current = s;
    }
  }
  function _y(s) {
    var c = s.alternate;
    c !== null && (s.alternate = null, _y(c)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (c = s.stateNode, c !== null && (delete c[qa], delete c[Bu], delete c[oy], delete c[KT], delete c[iy])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
  }
  function A1(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function Im(s) {
    e:
      for (; ; ) {
        for (; s.sibling === null; ) {
          if (s.return === null || A1(s.return))
            return null;
          s = s.return;
        }
        for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
          if (s.flags & 2 || s.child === null || s.tag === 4)
            continue e;
          s.child.return = s, s = s.child;
        }
        if (!(s.flags & 2))
          return s.stateNode;
      }
  }
  function xd(s, c, m) {
    var x = s.tag;
    if (x === 5 || x === 6)
      s = s.stateNode, c ? m.nodeType === 8 ? m.parentNode.insertBefore(s, c) : m.insertBefore(s, c) : (m.nodeType === 8 ? (c = m.parentNode, c.insertBefore(s, m)) : (c = m, c.appendChild(s)), m = m._reactRootContainer, m != null || c.onclick !== null || (c.onclick = Uh));
    else if (x !== 4 && (s = s.child, s !== null))
      for (xd(s, c, m), s = s.sibling; s !== null; )
        xd(s, c, m), s = s.sibling;
  }
  function rs(s, c, m) {
    var x = s.tag;
    if (x === 5 || x === 6)
      s = s.stateNode, c ? m.insertBefore(s, c) : m.appendChild(s);
    else if (x !== 4 && (s = s.child, s !== null))
      for (rs(s, c, m), s = s.sibling; s !== null; )
        rs(s, c, m), s = s.sibling;
  }
  var mr = null, oo = !1;
  function ra(s, c, m) {
    for (m = m.child; m !== null; )
      Cd(s, c, m), m = m.sibling;
  }
  function Cd(s, c, m) {
    if (ri && typeof ri.onCommitFiberUnmount == "function")
      try {
        ri.onCommitFiberUnmount(Iu, m);
      } catch {
      }
    switch (m.tag) {
      case 5:
        Yr || Sd(m, c);
      case 6:
        var x = mr, I = oo;
        mr = null, ra(s, c, m), mr = x, oo = I, mr !== null && (oo ? (s = mr, m = m.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(m) : s.removeChild(m)) : mr.removeChild(m.stateNode));
        break;
      case 18:
        mr !== null && (oo ? (s = mr, m = m.stateNode, s.nodeType === 8 ? Ol(s.parentNode, m) : s.nodeType === 1 && Ol(s, m), Ou(s)) : Ol(mr, m.stateNode));
        break;
      case 4:
        x = mr, I = oo, mr = m.stateNode.containerInfo, oo = !0, ra(s, c, m), mr = x, oo = I;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Yr && (x = m.updateQueue, x !== null && (x = x.lastEffect, x !== null))) {
          I = x = x.next;
          do {
            var R = I, B = R.destroy;
            R = R.tag, B !== void 0 && (R & 2 || R & 4) && fp(m, c, B), I = I.next;
          } while (I !== x);
        }
        ra(s, c, m);
        break;
      case 1:
        if (!Yr && (Sd(m, c), x = m.stateNode, typeof x.componentWillUnmount == "function"))
          try {
            x.props = m.memoizedProps, x.state = m.memoizedState, x.componentWillUnmount();
          } catch (Z) {
            Ar(m, c, Z);
          }
        ra(s, c, m);
        break;
      case 21:
        ra(s, c, m);
        break;
      case 22:
        m.mode & 1 ? (Yr = (x = Yr) || m.memoizedState !== null, ra(s, c, m), Yr = x) : ra(s, c, m);
        break;
      default:
        ra(s, c, m);
    }
  }
  function Ys(s) {
    var c = s.updateQueue;
    if (c !== null) {
      s.updateQueue = null;
      var m = s.stateNode;
      m === null && (m = s.stateNode = new E1()), c.forEach(function(x) {
        var I = dI.bind(null, s, x);
        m.has(x) || (m.add(x), x.then(I, I));
      });
    }
  }
  function La(s, c) {
    var m = c.deletions;
    if (m !== null)
      for (var x = 0; x < m.length; x++) {
        var I = m[x];
        try {
          var R = s, B = c, Z = B;
          e:
            for (; Z !== null; ) {
              switch (Z.tag) {
                case 5:
                  mr = Z.stateNode, oo = !1;
                  break e;
                case 3:
                  mr = Z.stateNode.containerInfo, oo = !0;
                  break e;
                case 4:
                  mr = Z.stateNode.containerInfo, oo = !0;
                  break e;
              }
              Z = Z.return;
            }
          if (mr === null)
            throw Error(n(160));
          Cd(R, B, I), mr = null, oo = !1;
          var ee = I.alternate;
          ee !== null && (ee.return = null), I.return = null;
        } catch (Pe) {
          Ar(I, c, Pe);
        }
      }
    if (c.subtreeFlags & 12854)
      for (c = c.child; c !== null; )
        k1(c, s), c = c.sibling;
  }
  function k1(s, c) {
    var m = s.alternate, x = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (La(c, s), os(s), x & 4) {
          try {
            pp(3, s, s.return), hp(3, s);
          } catch (Ct) {
            Ar(s, s.return, Ct);
          }
          try {
            pp(5, s, s.return);
          } catch (Ct) {
            Ar(s, s.return, Ct);
          }
        }
        break;
      case 1:
        La(c, s), os(s), x & 512 && m !== null && Sd(m, m.return);
        break;
      case 5:
        if (La(c, s), os(s), x & 512 && m !== null && Sd(m, m.return), s.flags & 32) {
          var I = s.stateNode;
          try {
            an(I, "");
          } catch (Ct) {
            Ar(s, s.return, Ct);
          }
        }
        if (x & 4 && (I = s.stateNode, I != null)) {
          var R = s.memoizedProps, B = m !== null ? m.memoizedProps : R, Z = s.type, ee = s.updateQueue;
          if (s.updateQueue = null, ee !== null)
            try {
              Z === "input" && R.type === "radio" && R.name != null && qe(I, R), ft(Z, B);
              var Pe = ft(Z, R);
              for (B = 0; B < ee.length; B += 2) {
                var We = ee[B], Ze = ee[B + 1];
                We === "style" ? Kt(I, Ze) : We === "dangerouslySetInnerHTML" ? Ot(I, Ze) : We === "children" ? an(I, Ze) : D(I, We, Ze, Pe);
              }
              switch (Z) {
                case "input":
                  Qe(I, R);
                  break;
                case "textarea":
                  rn(I, R);
                  break;
                case "select":
                  var Ge = I._wrapperState.wasMultiple;
                  I._wrapperState.wasMultiple = !!R.multiple;
                  var ut = R.value;
                  ut != null ? hn(I, !!R.multiple, ut, !1) : Ge !== !!R.multiple && (R.defaultValue != null ? hn(
                    I,
                    !!R.multiple,
                    R.defaultValue,
                    !0
                  ) : hn(I, !!R.multiple, R.multiple ? [] : "", !1));
              }
              I[Bu] = R;
            } catch (Ct) {
              Ar(s, s.return, Ct);
            }
        }
        break;
      case 6:
        if (La(c, s), os(s), x & 4) {
          if (s.stateNode === null)
            throw Error(n(162));
          I = s.stateNode, R = s.memoizedProps;
          try {
            I.nodeValue = R;
          } catch (Ct) {
            Ar(s, s.return, Ct);
          }
        }
        break;
      case 3:
        if (La(c, s), os(s), x & 4 && m !== null && m.memoizedState.isDehydrated)
          try {
            Ou(c.containerInfo);
          } catch (Ct) {
            Ar(s, s.return, Ct);
          }
        break;
      case 4:
        La(c, s), os(s);
        break;
      case 13:
        La(c, s), os(s), I = s.child, I.flags & 8192 && (R = I.memoizedState !== null, I.stateNode.isHidden = R, !R || I.alternate !== null && I.alternate.memoizedState !== null || (My = qn())), x & 4 && Ys(s);
        break;
      case 22:
        if (We = m !== null && m.memoizedState !== null, s.mode & 1 ? (Yr = (Pe = Yr) || We, La(c, s), Yr = Pe) : La(c, s), os(s), x & 8192) {
          if (Pe = s.memoizedState !== null, (s.stateNode.isHidden = Pe) && !We && s.mode & 1)
            for (yt = s, We = s.child; We !== null; ) {
              for (Ze = yt = We; yt !== null; ) {
                switch (Ge = yt, ut = Ge.child, Ge.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    pp(4, Ge, Ge.return);
                    break;
                  case 1:
                    Sd(Ge, Ge.return);
                    var bt = Ge.stateNode;
                    if (typeof bt.componentWillUnmount == "function") {
                      x = Ge, m = Ge.return;
                      try {
                        c = x, bt.props = c.memoizedProps, bt.state = c.memoizedState, bt.componentWillUnmount();
                      } catch (Ct) {
                        Ar(x, m, Ct);
                      }
                    }
                    break;
                  case 5:
                    Sd(Ge, Ge.return);
                    break;
                  case 22:
                    if (Ge.memoizedState !== null) {
                      Dy(Ze);
                      continue;
                    }
                }
                ut !== null ? (ut.return = Ge, yt = ut) : Dy(Ze);
              }
              We = We.sibling;
            }
          e:
            for (We = null, Ze = s; ; ) {
              if (Ze.tag === 5) {
                if (We === null) {
                  We = Ze;
                  try {
                    I = Ze.stateNode, Pe ? (R = I.style, typeof R.setProperty == "function" ? R.setProperty("display", "none", "important") : R.display = "none") : (Z = Ze.stateNode, ee = Ze.memoizedProps.style, B = ee != null && ee.hasOwnProperty("display") ? ee.display : null, Z.style.display = Je("display", B));
                  } catch (Ct) {
                    Ar(s, s.return, Ct);
                  }
                }
              } else if (Ze.tag === 6) {
                if (We === null)
                  try {
                    Ze.stateNode.nodeValue = Pe ? "" : Ze.memoizedProps;
                  } catch (Ct) {
                    Ar(s, s.return, Ct);
                  }
              } else if ((Ze.tag !== 22 && Ze.tag !== 23 || Ze.memoizedState === null || Ze === s) && Ze.child !== null) {
                Ze.child.return = Ze, Ze = Ze.child;
                continue;
              }
              if (Ze === s)
                break e;
              for (; Ze.sibling === null; ) {
                if (Ze.return === null || Ze.return === s)
                  break e;
                We === Ze && (We = null), Ze = Ze.return;
              }
              We === Ze && (We = null), Ze.sibling.return = Ze.return, Ze = Ze.sibling;
            }
        }
        break;
      case 19:
        La(c, s), os(s), x & 4 && Ys(s);
        break;
      case 21:
        break;
      default:
        La(
          c,
          s
        ), os(s);
    }
  }
  function os(s) {
    var c = s.flags;
    if (c & 2) {
      try {
        e: {
          for (var m = s.return; m !== null; ) {
            if (A1(m)) {
              var x = m;
              break e;
            }
            m = m.return;
          }
          throw Error(n(160));
        }
        switch (x.tag) {
          case 5:
            var I = x.stateNode;
            x.flags & 32 && (an(I, ""), x.flags &= -33);
            var R = Im(s);
            rs(s, R, I);
            break;
          case 3:
          case 4:
            var B = x.stateNode.containerInfo, Z = Im(s);
            xd(s, Z, B);
            break;
          default:
            throw Error(n(161));
        }
      } catch (ee) {
        Ar(s, s.return, ee);
      }
      s.flags &= -3;
    }
    c & 4096 && (s.flags &= -4097);
  }
  function R1(s, c, m) {
    yt = s, wd(s);
  }
  function wd(s, c, m) {
    for (var x = (s.mode & 1) !== 0; yt !== null; ) {
      var I = yt, R = I.child;
      if (I.tag === 22 && x) {
        var B = I.memoizedState !== null || dp;
        if (!B) {
          var Z = I.alternate, ee = Z !== null && Z.memoizedState !== null || Yr;
          Z = dp;
          var Pe = Yr;
          if (dp = B, (Yr = ee) && !Pe)
            for (yt = I; yt !== null; )
              B = yt, ee = B.child, B.tag === 22 && B.memoizedState !== null ? O1(I) : ee !== null ? (ee.return = B, yt = ee) : O1(I);
          for (; R !== null; )
            yt = R, wd(R), R = R.sibling;
          yt = I, dp = Z, Yr = Pe;
        }
        P1(s);
      } else
        I.subtreeFlags & 8772 && R !== null ? (R.return = I, yt = R) : P1(s);
    }
  }
  function P1(s) {
    for (; yt !== null; ) {
      var c = yt;
      if (c.flags & 8772) {
        var m = c.alternate;
        try {
          if (c.flags & 8772)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                Yr || hp(5, c);
                break;
              case 1:
                var x = c.stateNode;
                if (c.flags & 4 && !Yr)
                  if (m === null)
                    x.componentDidMount();
                  else {
                    var I = c.elementType === c.type ? m.memoizedProps : Pi(c.type, m.memoizedProps);
                    x.componentDidUpdate(I, m.memoizedState, x.__reactInternalSnapshotBeforeUpdate);
                  }
                var R = c.updateQueue;
                R !== null && $u(c, R, x);
                break;
              case 3:
                var B = c.updateQueue;
                if (B !== null) {
                  if (m = null, c.child !== null)
                    switch (c.child.tag) {
                      case 5:
                        m = c.child.stateNode;
                        break;
                      case 1:
                        m = c.child.stateNode;
                    }
                  $u(c, B, m);
                }
                break;
              case 5:
                var Z = c.stateNode;
                if (m === null && c.flags & 4) {
                  m = Z;
                  var ee = c.memoizedProps;
                  switch (c.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ee.autoFocus && m.focus();
                      break;
                    case "img":
                      ee.src && (m.src = ee.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (c.memoizedState === null) {
                  var Pe = c.alternate;
                  if (Pe !== null) {
                    var We = Pe.memoizedState;
                    if (We !== null) {
                      var Ze = We.dehydrated;
                      Ze !== null && Ou(Ze);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          Yr || c.flags & 512 && Oy(c);
        } catch (Ge) {
          Ar(c, c.return, Ge);
        }
      }
      if (c === s) {
        yt = null;
        break;
      }
      if (m = c.sibling, m !== null) {
        m.return = c.return, yt = m;
        break;
      }
      yt = c.return;
    }
  }
  function Dy(s) {
    for (; yt !== null; ) {
      var c = yt;
      if (c === s) {
        yt = null;
        break;
      }
      var m = c.sibling;
      if (m !== null) {
        m.return = c.return, yt = m;
        break;
      }
      yt = c.return;
    }
  }
  function O1(s) {
    for (; yt !== null; ) {
      var c = yt;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var m = c.return;
            try {
              hp(4, c);
            } catch (ee) {
              Ar(c, m, ee);
            }
            break;
          case 1:
            var x = c.stateNode;
            if (typeof x.componentDidMount == "function") {
              var I = c.return;
              try {
                x.componentDidMount();
              } catch (ee) {
                Ar(c, I, ee);
              }
            }
            var R = c.return;
            try {
              Oy(c);
            } catch (ee) {
              Ar(c, R, ee);
            }
            break;
          case 5:
            var B = c.return;
            try {
              Oy(c);
            } catch (ee) {
              Ar(c, B, ee);
            }
        }
      } catch (ee) {
        Ar(c, c.return, ee);
      }
      if (c === s) {
        yt = null;
        break;
      }
      var Z = c.sibling;
      if (Z !== null) {
        Z.return = c.return, yt = Z;
        break;
      }
      yt = c.return;
    }
  }
  var Am = Math.ceil, mp = L.ReactCurrentDispatcher, Ny = L.ReactCurrentOwner, Fo = L.ReactCurrentBatchConfig, gn = 0, Sr = null, Ir = null, io = 0, _i = 0, Ed = qt(0), Jr = 0, vp = null, Js = 0, km = 0, Td = 0, Ku = null, Ho = null, My = 0, Id = 1 / 0, Qs = null, Rm = !1, qu = null, is = null, Wl = !1, Ul = null, Pm = 0, Ad = 0, Om = null, ec = -1, tc = 0;
  function Bo() {
    return gn & 6 ? qn() : ec !== -1 ? ec : ec = qn();
  }
  function Fr(s) {
    return s.mode & 1 ? gn & 2 && io !== 0 ? io & -io : Kh.transition !== null ? (tc === 0 && (tc = Qc()), tc) : (s = On, s !== 0 || (s = window.event, s = s === void 0 ? 16 : Dn(s.type)), s) : 1;
  }
  function Vo(s, c, m, x) {
    if (50 < Ad)
      throw Ad = 0, Om = null, Error(n(185));
    Ka(s, m, x), (!(gn & 2) || s !== Sr) && (s === Sr && (!(gn & 2) && (km |= m), Jr === 4 && oa(s, io)), $o(s, x), m === 1 && gn === 0 && !(c.mode & 1) && (Id = qn() + 500, no && ui()));
  }
  function $o(s, c) {
    var m = s.callbackNode;
    Ds(s, c);
    var x = Ii(s, s === Sr ? io : 0);
    if (x === 0)
      m !== null && Ih(m), s.callbackNode = null, s.callbackPriority = 0;
    else if (c = x & -x, s.callbackPriority !== c) {
      if (m != null && Ih(m), c === 1)
        s.tag === 0 ? sy(_1.bind(null, s)) : ay(_1.bind(null, s)), ry(function() {
          !(gn & 6) && ui();
        }), m = null;
      else {
        switch (Kc(x)) {
          case 1:
            m = ka;
            break;
          case 4:
            m = on;
            break;
          case 16:
            m = Ra;
            break;
          case 536870912:
            m = Nf;
            break;
          default:
            m = Ra;
        }
        m = zy(m, kd.bind(null, s));
      }
      s.callbackPriority = c, s.callbackNode = m;
    }
  }
  function kd(s, c) {
    if (ec = -1, tc = 0, gn & 6)
      throw Error(n(327));
    var m = s.callbackNode;
    if (Pd() && s.callbackNode !== m)
      return null;
    var x = Ii(s, s === Sr ? io : 0);
    if (x === 0)
      return null;
    if (x & 30 || x & s.expiredLanes || c)
      c = Dm(s, x);
    else {
      c = x;
      var I = gn;
      gn |= 2;
      var R = _m();
      (Sr !== s || io !== c) && (Qs = null, Id = qn() + 500, nc(s, c));
      do
        try {
          sI();
          break;
        } catch (Z) {
          D1(s, Z);
        }
      while (!0);
      py(), mp.current = R, gn = I, Ir !== null ? c = 0 : (Sr = null, io = 0, c = Jr);
    }
    if (c !== 0) {
      if (c === 2 && (I = Au(s), I !== 0 && (x = I, c = Ly(s, I))), c === 1)
        throw m = vp, nc(s, 0), oa(s, x), $o(s, qn()), m;
      if (c === 6)
        oa(s, x);
      else {
        if (I = s.current.alternate, !(x & 30) && !Fy(I) && (c = Dm(s, x), c === 2 && (R = Au(s), R !== 0 && (x = R, c = Ly(s, R))), c === 1))
          throw m = vp, nc(s, 0), oa(s, x), $o(s, qn()), m;
        switch (s.finishedWork = I, s.finishedLanes = x, c) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            rc(s, Ho, Qs);
            break;
          case 3:
            if (oa(s, x), (x & 130023424) === x && (c = My + 500 - qn(), 10 < c)) {
              if (Ii(s, 0) !== 0)
                break;
              if (I = s.suspendedLanes, (I & x) !== x) {
                Bo(), s.pingedLanes |= s.suspendedLanes & I;
                break;
              }
              s.timeoutHandle = Fu(rc.bind(null, s, Ho, Qs), c);
              break;
            }
            rc(s, Ho, Qs);
            break;
          case 4:
            if (oa(s, x), (x & 4194240) === x)
              break;
            for (c = s.eventTimes, I = -1; 0 < x; ) {
              var B = 31 - oi(x);
              R = 1 << B, B = c[B], B > I && (I = B), x &= ~R;
            }
            if (x = I, x = qn() - x, x = (120 > x ? 120 : 480 > x ? 480 : 1080 > x ? 1080 : 1920 > x ? 1920 : 3e3 > x ? 3e3 : 4320 > x ? 4320 : 1960 * Am(x / 1960)) - x, 10 < x) {
              s.timeoutHandle = Fu(rc.bind(null, s, Ho, Qs), x);
              break;
            }
            rc(s, Ho, Qs);
            break;
          case 5:
            rc(s, Ho, Qs);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return $o(s, qn()), s.callbackNode === m ? kd.bind(null, s) : null;
  }
  function Ly(s, c) {
    var m = Ku;
    return s.current.memoizedState.isDehydrated && (nc(s, c).flags |= 256), s = Dm(s, c), s !== 2 && (c = Ho, Ho = m, c !== null && gp(c)), s;
  }
  function gp(s) {
    Ho === null ? Ho = s : Ho.push.apply(Ho, s);
  }
  function Fy(s) {
    for (var c = s; ; ) {
      if (c.flags & 16384) {
        var m = c.updateQueue;
        if (m !== null && (m = m.stores, m !== null))
          for (var x = 0; x < m.length; x++) {
            var I = m[x], R = I.getSnapshot;
            I = I.value;
            try {
              if (!Zi(R(), I))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (m = c.child, c.subtreeFlags & 16384 && m !== null)
        m.return = c, c = m;
      else {
        if (c === s)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === s)
            return !0;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    }
    return !0;
  }
  function oa(s, c) {
    for (c &= ~Td, c &= ~km, s.suspendedLanes |= c, s.pingedLanes &= ~c, s = s.expirationTimes; 0 < c; ) {
      var m = 31 - oi(c), x = 1 << m;
      s[m] = -1, c &= ~x;
    }
  }
  function _1(s) {
    if (gn & 6)
      throw Error(n(327));
    Pd();
    var c = Ii(s, 0);
    if (!(c & 1))
      return $o(s, qn()), null;
    var m = Dm(s, c);
    if (s.tag !== 0 && m === 2) {
      var x = Au(s);
      x !== 0 && (c = x, m = Ly(s, x));
    }
    if (m === 1)
      throw m = vp, nc(s, 0), oa(s, c), $o(s, qn()), m;
    if (m === 6)
      throw Error(n(345));
    return s.finishedWork = s.current.alternate, s.finishedLanes = c, rc(s, Ho, Qs), $o(s, qn()), null;
  }
  function Rd(s, c) {
    var m = gn;
    gn |= 1;
    try {
      return s(c);
    } finally {
      gn = m, gn === 0 && (Id = qn() + 500, no && ui());
    }
  }
  function Xl(s) {
    Ul !== null && Ul.tag === 0 && !(gn & 6) && Pd();
    var c = gn;
    gn |= 1;
    var m = Fo.transition, x = On;
    try {
      if (Fo.transition = null, On = 1, s)
        return s();
    } finally {
      On = x, Fo.transition = m, gn = c, !(gn & 6) && ui();
    }
  }
  function By() {
    _i = Ed.current, Nn(Ed);
  }
  function nc(s, c) {
    s.finishedWork = null, s.finishedLanes = 0;
    var m = s.timeoutHandle;
    if (m !== -1 && (s.timeoutHandle = -1, a1(m)), Ir !== null)
      for (m = Ir.return; m !== null; ) {
        var x = m;
        switch (uy(x), x.tag) {
          case 1:
            x = x.type.childContextTypes, x != null && Qi();
            break;
          case 3:
            zl(), Nn(Tr), Nn(jt), om();
            break;
          case 5:
            pn(x);
            break;
          case 4:
            zl();
            break;
          case 13:
            Nn(Mt);
            break;
          case 19:
            Nn(Mt);
            break;
          case 10:
            Fl(x.type._context);
            break;
          case 22:
          case 23:
            By();
        }
        m = m.return;
      }
    if (Sr = s, Ir = s = Zl(s.current, null), io = _i = c, Jr = 0, vp = null, Td = km = Js = 0, Ho = Ku = null, yo !== null) {
      for (c = 0; c < yo.length; c++)
        if (m = yo[c], x = m.interleaved, x !== null) {
          m.interleaved = null;
          var I = x.next, R = m.pending;
          if (R !== null) {
            var B = R.next;
            R.next = I, x.next = B;
          }
          m.pending = x;
        }
      yo = null;
    }
    return s;
  }
  function D1(s, c) {
    do {
      var m = Ir;
      try {
        if (py(), im.current = xm, Lt) {
          for (var x = sr.memoizedState; x !== null; ) {
            var I = x.queue;
            I !== null && (I.pending = null), x = x.next;
          }
          Lt = !1;
        }
        if (Hu = 0, bn = Be = sr = null, ns = !1, Oi = 0, Ny.current = null, m === null || m.return === null) {
          Jr = 1, vp = c, Ir = null;
          break;
        }
        e: {
          var R = s, B = m.return, Z = m, ee = c;
          if (c = io, Z.flags |= 32768, ee !== null && typeof ee == "object" && typeof ee.then == "function") {
            var Pe = ee, We = Z, Ze = We.tag;
            if (!(We.mode & 1) && (Ze === 0 || Ze === 11 || Ze === 15)) {
              var Ge = We.alternate;
              Ge ? (We.updateQueue = Ge.updateQueue, We.memoizedState = Ge.memoizedState, We.lanes = Ge.lanes) : (We.updateQueue = null, We.memoizedState = null);
            }
            var ut = Cy(B);
            if (ut !== null) {
              ut.flags &= -257, wy(ut, B, Z, R, c), ut.mode & 1 && x1(R, Pe, c), c = ut, ee = Pe;
              var bt = c.updateQueue;
              if (bt === null) {
                var Ct = /* @__PURE__ */ new Set();
                Ct.add(ee), c.updateQueue = Ct;
              } else
                bt.add(ee);
              break e;
            } else {
              if (!(c & 1)) {
                x1(R, Pe, c), Vy();
                break e;
              }
              ee = Error(n(426));
            }
          } else if (ar && Z.mode & 1) {
            var Pr = Cy(B);
            if (Pr !== null) {
              !(Pr.flags & 65536) && (Pr.flags |= 256), wy(Pr, B, Z, R, c), dy(gd(ee, Z));
              break e;
            }
          }
          R = ee = gd(ee, Z), Jr !== 4 && (Jr = 2), Ku === null ? Ku = [R] : Ku.push(R), R = B;
          do {
            switch (R.tag) {
              case 3:
                R.flags |= 65536, c &= -c, R.lanes |= c;
                var ve = S1(R, ee, c);
                vy(R, ve);
                break e;
              case 1:
                Z = ee;
                var le = R.type, Te = R.stateNode;
                if (!(R.flags & 128) && (typeof le.getDerivedStateFromError == "function" || Te !== null && typeof Te.componentDidCatch == "function" && (is === null || !is.has(Te)))) {
                  R.flags |= 65536, c &= -c, R.lanes |= c;
                  var Ke = lp(R, Z, c);
                  vy(R, Ke);
                  break e;
                }
            }
            R = R.return;
          } while (R !== null);
        }
        $y(m);
      } catch (wt) {
        c = wt, Ir === m && m !== null && (Ir = m = m.return);
        continue;
      }
      break;
    } while (!0);
  }
  function _m() {
    var s = mp.current;
    return mp.current = xm, s === null ? xm : s;
  }
  function Vy() {
    (Jr === 0 || Jr === 3 || Jr === 2) && (Jr = 4), Sr === null || !(Js & 268435455) && !(km & 268435455) || oa(Sr, io);
  }
  function Dm(s, c) {
    var m = gn;
    gn |= 2;
    var x = _m();
    (Sr !== s || io !== c) && (Qs = null, nc(s, c));
    do
      try {
        aI();
        break;
      } catch (I) {
        D1(s, I);
      }
    while (!0);
    if (py(), gn = m, mp.current = x, Ir !== null)
      throw Error(n(261));
    return Sr = null, io = 0, Jr;
  }
  function aI() {
    for (; Ir !== null; )
      N1(Ir);
  }
  function sI() {
    for (; Ir !== null && !_f(); )
      N1(Ir);
  }
  function N1(s) {
    var c = L1(s.alternate, s, _i);
    s.memoizedProps = s.pendingProps, c === null ? $y(s) : Ir = c, Ny.current = null;
  }
  function $y(s) {
    var c = s;
    do {
      var m = c.alternate;
      if (s = c.return, c.flags & 32768) {
        if (m = Py(m, c), m !== null) {
          m.flags &= 32767, Ir = m;
          return;
        }
        if (s !== null)
          s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null;
        else {
          Jr = 6, Ir = null;
          return;
        }
      } else if (m = iI(m, c, _i), m !== null) {
        Ir = m;
        return;
      }
      if (c = c.sibling, c !== null) {
        Ir = c;
        return;
      }
      Ir = c = s;
    } while (c !== null);
    Jr === 0 && (Jr = 5);
  }
  function rc(s, c, m) {
    var x = On, I = Fo.transition;
    try {
      Fo.transition = null, On = 1, lI(s, c, m, x);
    } finally {
      Fo.transition = I, On = x;
    }
    return null;
  }
  function lI(s, c, m, x) {
    do
      Pd();
    while (Ul !== null);
    if (gn & 6)
      throw Error(n(327));
    m = s.finishedWork;
    var I = s.finishedLanes;
    if (m === null)
      return null;
    if (s.finishedWork = null, s.finishedLanes = 0, m === s.current)
      throw Error(n(177));
    s.callbackNode = null, s.callbackPriority = 0;
    var R = m.lanes | m.childLanes;
    if (Lg(s, R), s === Sr && (Ir = Sr = null, io = 0), !(m.subtreeFlags & 2064) && !(m.flags & 2064) || Wl || (Wl = !0, zy(Ra, function() {
      return Pd(), null;
    })), R = (m.flags & 15990) !== 0, m.subtreeFlags & 15990 || R) {
      R = Fo.transition, Fo.transition = null;
      var B = On;
      On = 1;
      var Z = gn;
      gn |= 4, Ny.current = null, I1(s, m), k1(m, s), zh(Lu), Fs = !!ty, Lu = ty = null, s.current = m, R1(m), Ng(), gn = Z, On = B, Fo.transition = R;
    } else
      s.current = m;
    if (Wl && (Wl = !1, Ul = s, Pm = I), R = s.pendingLanes, R === 0 && (is = null), kh(m.stateNode), $o(s, qn()), c !== null)
      for (x = s.onRecoverableError, m = 0; m < c.length; m++)
        I = c[m], x(I.value, { componentStack: I.stack, digest: I.digest });
    if (Rm)
      throw Rm = !1, s = qu, qu = null, s;
    return Pm & 1 && s.tag !== 0 && Pd(), R = s.pendingLanes, R & 1 ? s === Om ? Ad++ : (Ad = 0, Om = s) : Ad = 0, ui(), null;
  }
  function Pd() {
    if (Ul !== null) {
      var s = Kc(Pm), c = Fo.transition, m = On;
      try {
        if (Fo.transition = null, On = 16 > s ? 16 : s, Ul === null)
          var x = !1;
        else {
          if (s = Ul, Ul = null, Pm = 0, gn & 6)
            throw Error(n(331));
          var I = gn;
          for (gn |= 4, yt = s.current; yt !== null; ) {
            var R = yt, B = R.child;
            if (yt.flags & 16) {
              var Z = R.deletions;
              if (Z !== null) {
                for (var ee = 0; ee < Z.length; ee++) {
                  var Pe = Z[ee];
                  for (yt = Pe; yt !== null; ) {
                    var We = yt;
                    switch (We.tag) {
                      case 0:
                      case 11:
                      case 15:
                        pp(8, We, R);
                    }
                    var Ze = We.child;
                    if (Ze !== null)
                      Ze.return = We, yt = Ze;
                    else
                      for (; yt !== null; ) {
                        We = yt;
                        var Ge = We.sibling, ut = We.return;
                        if (_y(We), We === Pe) {
                          yt = null;
                          break;
                        }
                        if (Ge !== null) {
                          Ge.return = ut, yt = Ge;
                          break;
                        }
                        yt = ut;
                      }
                  }
                }
                var bt = R.alternate;
                if (bt !== null) {
                  var Ct = bt.child;
                  if (Ct !== null) {
                    bt.child = null;
                    do {
                      var Pr = Ct.sibling;
                      Ct.sibling = null, Ct = Pr;
                    } while (Ct !== null);
                  }
                }
                yt = R;
              }
            }
            if (R.subtreeFlags & 2064 && B !== null)
              B.return = R, yt = B;
            else
              e:
                for (; yt !== null; ) {
                  if (R = yt, R.flags & 2048)
                    switch (R.tag) {
                      case 0:
                      case 11:
                      case 15:
                        pp(9, R, R.return);
                    }
                  var ve = R.sibling;
                  if (ve !== null) {
                    ve.return = R.return, yt = ve;
                    break e;
                  }
                  yt = R.return;
                }
          }
          var le = s.current;
          for (yt = le; yt !== null; ) {
            B = yt;
            var Te = B.child;
            if (B.subtreeFlags & 2064 && Te !== null)
              Te.return = B, yt = Te;
            else
              e:
                for (B = le; yt !== null; ) {
                  if (Z = yt, Z.flags & 2048)
                    try {
                      switch (Z.tag) {
                        case 0:
                        case 11:
                        case 15:
                          hp(9, Z);
                      }
                    } catch (wt) {
                      Ar(Z, Z.return, wt);
                    }
                  if (Z === B) {
                    yt = null;
                    break e;
                  }
                  var Ke = Z.sibling;
                  if (Ke !== null) {
                    Ke.return = Z.return, yt = Ke;
                    break e;
                  }
                  yt = Z.return;
                }
          }
          if (gn = I, ui(), ri && typeof ri.onPostCommitFiberRoot == "function")
            try {
              ri.onPostCommitFiberRoot(Iu, s);
            } catch {
            }
          x = !0;
        }
        return x;
      } finally {
        On = m, Fo.transition = c;
      }
    }
    return !1;
  }
  function M1(s, c, m) {
    c = gd(m, c), c = S1(s, c, 1), s = Vl(s, c, 1), c = Bo(), s !== null && (Ka(s, 1, c), $o(s, c));
  }
  function Ar(s, c, m) {
    if (s.tag === 3)
      M1(s, s, m);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          M1(c, s, m);
          break;
        } else if (c.tag === 1) {
          var x = c.stateNode;
          if (typeof c.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (is === null || !is.has(x))) {
            s = gd(m, s), s = lp(c, s, 1), c = Vl(c, s, 1), s = Bo(), c !== null && (Ka(c, 1, s), $o(c, s));
            break;
          }
        }
        c = c.return;
      }
  }
  function uI(s, c, m) {
    var x = s.pingCache;
    x !== null && x.delete(c), c = Bo(), s.pingedLanes |= s.suspendedLanes & m, Sr === s && (io & m) === m && (Jr === 4 || Jr === 3 && (io & 130023424) === io && 500 > qn() - My ? nc(s, 0) : Td |= m), $o(s, c);
  }
  function Nm(s, c) {
    c === 0 && (s.mode & 1 ? (c = kl, kl <<= 1, !(kl & 130023424) && (kl = 4194304)) : c = 1);
    var m = Bo();
    s = Ws(s, c), s !== null && (Ka(s, c, m), $o(s, m));
  }
  function cI(s) {
    var c = s.memoizedState, m = 0;
    c !== null && (m = c.retryLane), Nm(s, m);
  }
  function dI(s, c) {
    var m = 0;
    switch (s.tag) {
      case 13:
        var x = s.stateNode, I = s.memoizedState;
        I !== null && (m = I.retryLane);
        break;
      case 19:
        x = s.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    x !== null && x.delete(c), Nm(s, m);
  }
  var L1;
  L1 = function(s, c, m) {
    if (s !== null)
      if (s.memoizedProps !== c.pendingProps || Tr.current)
        Lr = !0;
      else {
        if (!(s.lanes & m) && !(c.flags & 128))
          return Lr = !1, Zs(s, c, m);
        Lr = !!(s.flags & 131072);
      }
    else
      Lr = !1, ar && c.flags & 1048576 && ly(c, cd, c.index);
    switch (c.lanes = 0, c.tag) {
      case 2:
        var x = c.type;
        Mo(s, c), s = c.pendingProps;
        var I = Ji(c, jt.current);
        nt(c, m), I = Hl(null, c, x, s, I, m);
        var R = Wu();
        return c.flags |= 1, typeof I == "object" && I !== null && typeof I.render == "function" && I.$$typeof === void 0 ? (c.tag = 1, c.memoizedState = null, c.updateQueue = null, hr(x) ? (R = !0, Xh(c)) : R = !1, c.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, my(c), I.updater = tm, c.stateNode = I, I._reactInternals = c, nm(c, x, s, m), c = C1(null, c, x, !0, R, m)) : (c.tag = 0, ar && R && Zh(c), Xr(null, c, I, m), c = c.child), c;
      case 16:
        x = c.elementType;
        e: {
          switch (Mo(s, c), s = c.pendingProps, I = x._init, x = I(x._payload), c.type = x, I = c.tag = pI(x), s = Pi(x, s), I) {
            case 0:
              c = yd(null, c, x, s, m);
              break e;
            case 1:
              c = Ey(null, c, x, s, m);
              break e;
            case 11:
              c = Gl(null, c, x, s, m);
              break e;
            case 14:
              c = wm(null, c, x, Pi(x.type, s), m);
              break e;
          }
          throw Error(n(
            306,
            x,
            ""
          ));
        }
        return c;
      case 0:
        return x = c.type, I = c.pendingProps, I = c.elementType === x ? I : Pi(x, I), yd(s, c, x, I, m);
      case 1:
        return x = c.type, I = c.pendingProps, I = c.elementType === x ? I : Pi(x, I), Ey(s, c, x, I, m);
      case 3:
        e: {
          if (w1(c), s === null)
            throw Error(n(387));
          x = c.pendingProps, R = c.memoizedState, I = R.element, Ur(s, c), $l(c, x, null, m);
          var B = c.memoizedState;
          if (x = B.element, R.isDehydrated)
            if (R = { element: x, isDehydrated: !1, cache: B.cache, pendingSuspenseBoundaries: B.pendingSuspenseBoundaries, transitions: B.transitions }, c.updateQueue.baseState = R, c.memoizedState = R, c.flags & 256) {
              I = gd(Error(n(423)), c), c = Em(s, c, x, m, I);
              break e;
            } else if (x !== I) {
              I = gd(Error(n(424)), c), c = Em(s, c, x, m, I);
              break e;
            } else
              for (fi = Na(c.stateNode.containerInfo.firstChild), Ri = c, ar = !0, qi = null, m = y1(c, null, x, m), c.child = m; m; )
                m.flags = m.flags & -3 | 4096, m = m.sibling;
          else {
            if (yr(), x === I) {
              c = bo(s, c, m);
              break e;
            }
            Xr(s, c, x, m);
          }
          c = c.child;
        }
        return c;
      case 5:
        return _t(c), s === null && Jh(c), x = c.type, I = c.pendingProps, R = s !== null ? s.memoizedProps : null, B = I.children, Jf(x, I) ? B = null : R !== null && Jf(x, R) && (c.flags |= 32), en(s, c), Xr(s, c, B, m), c.child;
      case 6:
        return s === null && Jh(c), null;
      case 13:
        return Iy(s, c, m);
      case 4:
        return yy(c, c.stateNode.containerInfo), x = c.pendingProps, s === null ? c.child = fd(c, null, x, m) : Xr(s, c, x, m), c.child;
      case 11:
        return x = c.type, I = c.pendingProps, I = c.elementType === x ? I : Pi(x, I), Gl(s, c, x, I, m);
      case 7:
        return Xr(s, c, c.pendingProps, m), c.child;
      case 8:
        return Xr(s, c, c.pendingProps.children, m), c.child;
      case 12:
        return Xr(s, c, c.pendingProps.children, m), c.child;
      case 10:
        e: {
          if (x = c.type._context, I = c.pendingProps, R = c.memoizedProps, B = I.value, Fn(ts, x._currentValue), x._currentValue = B, R !== null)
            if (Zi(R.value, B)) {
              if (R.children === I.children && !Tr.current) {
                c = bo(s, c, m);
                break e;
              }
            } else
              for (R = c.child, R !== null && (R.return = c); R !== null; ) {
                var Z = R.dependencies;
                if (Z !== null) {
                  B = R.child;
                  for (var ee = Z.firstContext; ee !== null; ) {
                    if (ee.context === x) {
                      if (R.tag === 1) {
                        ee = Us(-1, m & -m), ee.tag = 2;
                        var Pe = R.updateQueue;
                        if (Pe !== null) {
                          Pe = Pe.shared;
                          var We = Pe.pending;
                          We === null ? ee.next = ee : (ee.next = We.next, We.next = ee), Pe.pending = ee;
                        }
                      }
                      R.lanes |= m, ee = R.alternate, ee !== null && (ee.lanes |= m), ro(
                        R.return,
                        m,
                        c
                      ), Z.lanes |= m;
                      break;
                    }
                    ee = ee.next;
                  }
                } else if (R.tag === 10)
                  B = R.type === c.type ? null : R.child;
                else if (R.tag === 18) {
                  if (B = R.return, B === null)
                    throw Error(n(341));
                  B.lanes |= m, Z = B.alternate, Z !== null && (Z.lanes |= m), ro(B, m, c), B = R.sibling;
                } else
                  B = R.child;
                if (B !== null)
                  B.return = R;
                else
                  for (B = R; B !== null; ) {
                    if (B === c) {
                      B = null;
                      break;
                    }
                    if (R = B.sibling, R !== null) {
                      R.return = B.return, B = R;
                      break;
                    }
                    B = B.return;
                  }
                R = B;
              }
          Xr(s, c, I.children, m), c = c.child;
        }
        return c;
      case 9:
        return I = c.type, x = c.pendingProps.children, nt(c, m), I = Rr(I), x = x(I), c.flags |= 1, Xr(s, c, x, m), c.child;
      case 14:
        return x = c.type, I = Pi(x, c.pendingProps), I = Pi(x.type, I), wm(s, c, x, I, m);
      case 15:
        return mi(s, c, c.type, c.pendingProps, m);
      case 17:
        return x = c.type, I = c.pendingProps, I = c.elementType === x ? I : Pi(x, I), Mo(s, c), c.tag = 1, hr(x) ? (s = !0, Xh(c)) : s = !1, nt(c, m), h1(c, x, I), nm(c, x, I, m), C1(null, c, x, !0, s, m);
      case 19:
        return Ry(s, c, m);
      case 22:
        return Yu(s, c, m);
    }
    throw Error(n(156, c.tag));
  };
  function zy(s, c) {
    return Of(s, c);
  }
  function fI(s, c, m, x) {
    this.tag = s, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = x, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ia(s, c, m, x) {
    return new fI(s, c, m, x);
  }
  function Hy(s) {
    return s = s.prototype, !(!s || !s.isReactComponent);
  }
  function pI(s) {
    if (typeof s == "function")
      return Hy(s) ? 1 : 0;
    if (s != null) {
      if (s = s.$$typeof, s === oe)
        return 11;
      if (s === Ee)
        return 14;
    }
    return 2;
  }
  function Zl(s, c) {
    var m = s.alternate;
    return m === null ? (m = ia(s.tag, c, s.key, s.mode), m.elementType = s.elementType, m.type = s.type, m.stateNode = s.stateNode, m.alternate = s, s.alternate = m) : (m.pendingProps = c, m.type = s.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = s.flags & 14680064, m.childLanes = s.childLanes, m.lanes = s.lanes, m.child = s.child, m.memoizedProps = s.memoizedProps, m.memoizedState = s.memoizedState, m.updateQueue = s.updateQueue, c = s.dependencies, m.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }, m.sibling = s.sibling, m.index = s.index, m.ref = s.ref, m;
  }
  function Mm(s, c, m, x, I, R) {
    var B = 2;
    if (x = s, typeof s == "function")
      Hy(s) && (B = 1);
    else if (typeof s == "string")
      B = 5;
    else
      e:
        switch (s) {
          case $:
            return oc(m.children, I, R, c);
          case U:
            B = 8, I |= 8;
            break;
          case W:
            return s = ia(12, m, c, I | 2), s.elementType = W, s.lanes = R, s;
          case ce:
            return s = ia(13, m, c, I), s.elementType = ce, s.lanes = R, s;
          case te:
            return s = ia(19, m, c, I), s.elementType = te, s.lanes = R, s;
          case J:
            return yp(m, I, R, c);
          default:
            if (typeof s == "object" && s !== null)
              switch (s.$$typeof) {
                case H:
                  B = 10;
                  break e;
                case G:
                  B = 9;
                  break e;
                case oe:
                  B = 11;
                  break e;
                case Ee:
                  B = 14;
                  break e;
                case me:
                  B = 16, x = null;
                  break e;
              }
            throw Error(n(130, s == null ? s : typeof s, ""));
        }
    return c = ia(B, m, c, I), c.elementType = s, c.type = x, c.lanes = R, c;
  }
  function oc(s, c, m, x) {
    return s = ia(7, s, x, c), s.lanes = m, s;
  }
  function yp(s, c, m, x) {
    return s = ia(22, s, x, c), s.elementType = J, s.lanes = m, s.stateNode = { isHidden: !1 }, s;
  }
  function bp(s, c, m) {
    return s = ia(6, s, null, c), s.lanes = m, s;
  }
  function ic(s, c, m) {
    return c = ia(4, s.children !== null ? s.children : [], s.key, c), c.lanes = m, c.stateNode = { containerInfo: s.containerInfo, pendingChildren: null, implementation: s.implementation }, c;
  }
  function hI(s, c, m, x, I) {
    this.tag = c, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Lf(0), this.expirationTimes = Lf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Lf(0), this.identifierPrefix = x, this.onRecoverableError = I, this.mutableSourceEagerHydrationData = null;
  }
  function Lm(s, c, m, x, I, R, B, Z, ee) {
    return s = new hI(s, c, m, Z, ee), c === 1 ? (c = 1, R === !0 && (c |= 8)) : c = 0, R = ia(3, null, null, c), s.current = R, R.stateNode = s, R.memoizedState = { element: x, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, my(R), s;
  }
  function F1(s, c, m) {
    var x = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: V, key: x == null ? null : "" + x, children: s, containerInfo: c, implementation: m };
  }
  function jy(s) {
    if (!s)
      return es;
    s = s._reactInternals;
    e: {
      if (Ui(s) !== s || s.tag !== 1)
        throw Error(n(170));
      var c = s;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (hr(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(n(171));
    }
    if (s.tag === 1) {
      var m = s.type;
      if (hr(m))
        return qf(s, m, c);
    }
    return c;
  }
  function B1(s, c, m, x, I, R, B, Z, ee) {
    return s = Lm(m, x, !0, s, I, R, B, Z, ee), s.context = jy(null), m = s.current, x = Bo(), I = Fr(m), R = Us(x, I), R.callback = c ?? null, Vl(m, R, I), s.current.lanes = I, Ka(s, I, x), $o(s, x), s;
  }
  function Sp(s, c, m, x) {
    var I = c.current, R = Bo(), B = Fr(I);
    return m = jy(m), c.context === null ? c.context = m : c.pendingContext = m, c = Us(R, B), c.payload = { element: s }, x = x === void 0 ? null : x, x !== null && (c.callback = x), s = Vl(I, c, B), s !== null && (Vo(s, I, B, R), em(s, I, B)), B;
  }
  function Fm(s) {
    if (s = s.current, !s.child)
      return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function V1(s, c) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
      var m = s.retryLane;
      s.retryLane = m !== 0 && m < c ? m : c;
    }
  }
  function Gy(s, c) {
    V1(s, c), (s = s.alternate) && V1(s, c);
  }
  function $1() {
    return null;
  }
  var Wy = typeof reportError == "function" ? reportError : function(s) {
    console.error(s);
  };
  function Bm(s) {
    this._internalRoot = s;
  }
  Ks.prototype.render = Bm.prototype.render = function(s) {
    var c = this._internalRoot;
    if (c === null)
      throw Error(n(409));
    Sp(s, c, null, null);
  }, Ks.prototype.unmount = Bm.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
      this._internalRoot = null;
      var c = s.containerInfo;
      Xl(function() {
        Sp(null, s, null, null);
      }), c[js] = null;
    }
  };
  function Ks(s) {
    this._internalRoot = s;
  }
  Ks.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
      var c = ed();
      s = { blockedOn: null, target: s, priority: c };
      for (var m = 0; m < _n.length && c !== 0 && c < _n[m].priority; m++)
        ;
      _n.splice(m, 0, s), m === 0 && _h(s);
    }
  };
  function Uy(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
  }
  function Vm(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "));
  }
  function z1() {
  }
  function mI(s, c, m, x, I) {
    if (I) {
      if (typeof x == "function") {
        var R = x;
        x = function() {
          var Pe = Fm(B);
          R.call(Pe);
        };
      }
      var B = B1(c, x, s, 0, null, !1, !1, "", z1);
      return s._reactRootContainer = B, s[js] = B.current, ld(s.nodeType === 8 ? s.parentNode : s), Xl(), B;
    }
    for (; I = s.lastChild; )
      s.removeChild(I);
    if (typeof x == "function") {
      var Z = x;
      x = function() {
        var Pe = Fm(ee);
        Z.call(Pe);
      };
    }
    var ee = Lm(s, 0, !1, null, null, !1, !1, "", z1);
    return s._reactRootContainer = ee, s[js] = ee.current, ld(s.nodeType === 8 ? s.parentNode : s), Xl(function() {
      Sp(c, ee, m, x);
    }), ee;
  }
  function $m(s, c, m, x, I) {
    var R = m._reactRootContainer;
    if (R) {
      var B = R;
      if (typeof I == "function") {
        var Z = I;
        I = function() {
          var ee = Fm(B);
          Z.call(ee);
        };
      }
      Sp(c, B, s, I);
    } else
      B = mI(m, c, s, I, x);
    return Fm(B);
  }
  Oh = function(s) {
    switch (s.tag) {
      case 3:
        var c = s.stateNode;
        if (c.current.memoizedState.isDehydrated) {
          var m = _s(c.pendingLanes);
          m !== 0 && (ku(c, m | 1), $o(c, qn()), !(gn & 6) && (Id = qn() + 500, ui()));
        }
        break;
      case 13:
        Xl(function() {
          var x = Ws(s, 1);
          if (x !== null) {
            var I = Bo();
            Vo(x, s, 1, I);
          }
        }), Gy(s, 1);
    }
  }, qc = function(s) {
    if (s.tag === 13) {
      var c = Ws(s, 134217728);
      if (c !== null) {
        var m = Bo();
        Vo(c, s, 134217728, m);
      }
      Gy(s, 134217728);
    }
  }, $n = function(s) {
    if (s.tag === 13) {
      var c = Fr(s), m = Ws(s, c);
      if (m !== null) {
        var x = Bo();
        Vo(m, s, c, x);
      }
      Gy(s, c);
    }
  }, ed = function() {
    return On;
  }, Ff = function(s, c) {
    var m = On;
    try {
      return On = s, c();
    } finally {
      On = m;
    }
  }, Mn = function(s, c, m) {
    switch (c) {
      case "input":
        if (Qe(s, m), c = m.name, m.type === "radio" && c != null) {
          for (m = s; m.parentNode; )
            m = m.parentNode;
          for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + c) + '][type="radio"]'), c = 0; c < m.length; c++) {
            var x = m[c];
            if (x !== s && x.form === s.form) {
              var I = At(x);
              if (!I)
                throw Error(n(90));
              fe(x), Qe(x, I);
            }
          }
        }
        break;
      case "textarea":
        rn(s, m);
        break;
      case "select":
        c = m.value, c != null && hn(s, !!m.multiple, c, !1);
    }
  }, Yc = Rd, Ia = Xl;
  var vI = { usingClientEntryPoint: !1, Events: [Kf, ud, At, Gr, ni, Rd] }, Od = { findFiberByHostInstance: Yi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, gI = { bundleType: Od.bundleType, version: Od.version, rendererPackageName: Od.rendererPackageName, rendererConfig: Od.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: L.ReactCurrentDispatcher, findHostInstanceByFiber: function(s) {
    return s = Eh(s), s === null ? null : s.stateNode;
  }, findFiberByHostInstance: Od.findFiberByHostInstance || $1, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var zm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!zm.isDisabled && zm.supportsFiber)
      try {
        Iu = zm.inject(gI), ri = zm;
      } catch {
      }
  }
  return fa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vI, fa.createPortal = function(s, c) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Uy(c))
      throw Error(n(200));
    return F1(s, c, null, m);
  }, fa.createRoot = function(s, c) {
    if (!Uy(s))
      throw Error(n(299));
    var m = !1, x = "", I = Wy;
    return c != null && (c.unstable_strictMode === !0 && (m = !0), c.identifierPrefix !== void 0 && (x = c.identifierPrefix), c.onRecoverableError !== void 0 && (I = c.onRecoverableError)), c = Lm(s, 1, !1, null, null, m, !1, x, I), s[js] = c.current, ld(s.nodeType === 8 ? s.parentNode : s), new Bm(c);
  }, fa.findDOMNode = function(s) {
    if (s == null)
      return null;
    if (s.nodeType === 1)
      return s;
    var c = s._reactInternals;
    if (c === void 0)
      throw typeof s.render == "function" ? Error(n(188)) : (s = Object.keys(s).join(","), Error(n(268, s)));
    return s = Eh(c), s = s === null ? null : s.stateNode, s;
  }, fa.flushSync = function(s) {
    return Xl(s);
  }, fa.hydrate = function(s, c, m) {
    if (!Vm(c))
      throw Error(n(200));
    return $m(null, s, c, !0, m);
  }, fa.hydrateRoot = function(s, c, m) {
    if (!Uy(s))
      throw Error(n(405));
    var x = m != null && m.hydratedSources || null, I = !1, R = "", B = Wy;
    if (m != null && (m.unstable_strictMode === !0 && (I = !0), m.identifierPrefix !== void 0 && (R = m.identifierPrefix), m.onRecoverableError !== void 0 && (B = m.onRecoverableError)), c = B1(c, null, s, 1, m ?? null, I, !1, R, B), s[js] = c.current, ld(s), x)
      for (s = 0; s < x.length; s++)
        m = x[s], I = m._getVersion, I = I(m._source), c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [m, I] : c.mutableSourceEagerHydrationData.push(
          m,
          I
        );
    return new Ks(c);
  }, fa.render = function(s, c, m) {
    if (!Vm(c))
      throw Error(n(200));
    return $m(null, s, c, !1, m);
  }, fa.unmountComponentAtNode = function(s) {
    if (!Vm(s))
      throw Error(n(40));
    return s._reactRootContainer ? (Xl(function() {
      $m(null, null, s, !1, function() {
        s._reactRootContainer = null, s[js] = null;
      });
    }), !0) : !1;
  }, fa.unstable_batchedUpdates = Rd, fa.unstable_renderSubtreeIntoContainer = function(s, c, m, x) {
    if (!Vm(m))
      throw Error(n(200));
    if (s == null || s._reactInternals === void 0)
      throw Error(n(38));
    return $m(s, c, m, !1, x);
  }, fa.version = "18.2.0-next-9e3b772b8-20220608", fa;
}
function c4() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c4);
    } catch (e) {
      console.error(e);
    }
  }
}
process.env.NODE_ENV === "production" ? (c4(), BP.exports = NQ()) : BP.exports = DQ();
var VE = BP.exports, [d4, MQ] = En({
  strict: !1,
  name: "PortalContext"
}), N_ = "chakra-portal", LQ = ".chakra-portal", FQ = (e) => /* @__PURE__ */ M(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: e.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: e.children
  }
), BQ = (e) => {
  const { appendToParentPortal: t, children: n } = e, [o, a] = ot(null), l = Ue(null), [, u] = ot({});
  dt(() => u({}), []);
  const f = MQ(), h = PQ();
  Ss(() => {
    if (!o)
      return;
    const g = o.ownerDocument, b = t ? f ?? g.body : g.body;
    if (!b)
      return;
    l.current = g.createElement("div"), l.current.className = N_, b.appendChild(l.current), u({});
    const S = l.current;
    return () => {
      b.contains(S) && b.removeChild(S);
    };
  }, [o]);
  const v = h != null && h.zIndex ? /* @__PURE__ */ M(FQ, { zIndex: h == null ? void 0 : h.zIndex, children: n }) : n;
  return l.current ? VE.createPortal(
    /* @__PURE__ */ M(d4, { value: l.current, children: v }),
    l.current
  ) : /* @__PURE__ */ M(
    "span",
    {
      ref: (g) => {
        g && a(g);
      }
    }
  );
}, VQ = (e) => {
  const { children: t, containerRef: n, appendToParentPortal: o } = e, a = n.current, l = a ?? (typeof window < "u" ? document.body : void 0), u = gt(() => {
    const h = a == null ? void 0 : a.ownerDocument.createElement("div");
    return h && (h.className = N_), h;
  }, [a]), [, f] = ot({});
  return Ss(() => f({}), []), Ss(() => {
    if (!(!u || !l))
      return l.appendChild(u), () => {
        l.removeChild(u);
      };
  }, [u, l]), l && u ? VE.createPortal(
    /* @__PURE__ */ M(d4, { value: o ? u : null, children: t }),
    u
  ) : null;
};
function wf(e) {
  const t = {
    appendToParentPortal: !0,
    ...e
  }, { containerRef: n, ...o } = t;
  return n ? /* @__PURE__ */ M(VQ, { containerRef: n, ...o }) : /* @__PURE__ */ M(BQ, { ...o });
}
wf.className = N_;
wf.selector = LQ;
wf.displayName = "Portal";
function wl() {
  const e = dr(
    df
  );
  if (!e)
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  return e;
}
var sS = wa({});
sS.displayName = "ColorModeContext";
function $E() {
  const e = dr(sS);
  if (e === void 0)
    throw new Error("useColorMode must be used within a ColorModeProvider");
  return e;
}
function JF(e, t) {
  const { colorMode: n } = $E();
  return n === "dark" ? t : e;
}
var xC = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function $Q(e = {}) {
  const { preventTransition: t = !0 } = e, n = {
    setDataset: (o) => {
      const a = t ? n.preventTransition() : void 0;
      document.documentElement.dataset.theme = o, document.documentElement.style.colorScheme = o, a == null || a();
    },
    setClassName(o) {
      document.body.classList.add(o ? xC.dark : xC.light), document.body.classList.remove(o ? xC.light : xC.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(o) {
      var a;
      return ((a = n.query().matches) != null ? a : o === "dark") ? "dark" : "light";
    },
    addListener(o) {
      const a = n.query(), l = (u) => {
        o(u.matches ? "dark" : "light");
      };
      return typeof a.addListener == "function" ? a.addListener(l) : a.addEventListener("change", l), () => {
        typeof a.removeListener == "function" ? a.removeListener(l) : a.removeEventListener("change", l);
      };
    },
    preventTransition() {
      const o = document.createElement("style");
      return o.appendChild(
        document.createTextNode(
          "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"
        )
      ), document.head.appendChild(o), () => {
        window.getComputedStyle(document.body), requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(o);
          });
        });
      };
    }
  };
  return n;
}
var zQ = "chakra-ui-color-mode";
function HQ(e) {
  return {
    ssr: !1,
    type: "localStorage",
    get(t) {
      if (!(globalThis != null && globalThis.document))
        return t;
      let n;
      try {
        n = localStorage.getItem(e) || t;
      } catch {
      }
      return n || t;
    },
    set(t) {
      try {
        localStorage.setItem(e, t);
      } catch {
      }
    }
  };
}
var jQ = HQ(zQ), Nw = () => {
};
function QF(e, t) {
  return e.type === "cookie" && e.ssr ? e.get(t) : t;
}
function f4(e) {
  const {
    value: t,
    children: n,
    options: {
      useSystemColorMode: o,
      initialColorMode: a,
      disableTransitionOnChange: l
    } = {},
    colorModeManager: u = jQ
  } = e, f = a === "dark" ? "dark" : "light", [h, v] = ot(
    () => QF(u, f)
  ), [g, b] = ot(
    () => QF(u)
  ), { getSystemTheme: S, setClassName: w, setDataset: E, addListener: T } = gt(
    () => $Q({ preventTransition: l }),
    [l]
  ), A = a === "system" && !h ? g : h, P = re(
    (L) => {
      const F = L === "system" ? S() : L;
      v(F), w(F === "dark"), E(F), u.set(F);
    },
    [u, S, w, E]
  );
  Ss(() => {
    a === "system" && b(S());
  }, []), dt(() => {
    const L = u.get();
    if (L) {
      P(L);
      return;
    }
    if (a === "system") {
      P("system");
      return;
    }
    P(f);
  }, [u, f, a, P]);
  const _ = re(() => {
    P(A === "dark" ? "light" : "dark");
  }, [A, P]);
  dt(() => {
    if (o)
      return T(P);
  }, [o, T, P]);
  const D = gt(
    () => ({
      colorMode: t ?? A,
      toggleColorMode: t ? Nw : _,
      setColorMode: t ? Nw : P,
      forced: t !== void 0
    }),
    [A, _, P, t]
  );
  return /* @__PURE__ */ M(sS.Provider, { value: D, children: n });
}
f4.displayName = "ColorModeProvider";
function GQ(e) {
  const t = gt(
    () => ({
      colorMode: "dark",
      toggleColorMode: Nw,
      setColorMode: Nw,
      forced: !0
    }),
    []
  );
  return /* @__PURE__ */ M(sS.Provider, { value: t, ...e });
}
GQ.displayName = "DarkMode";
function p4() {
  const e = $E(), t = wl();
  return { ...e, theme: t };
}
function WQ(e, t, n) {
  var o, a;
  if (t == null)
    return t;
  const l = (u) => {
    var f, h;
    return (h = (f = e.__breakpoints) == null ? void 0 : f.asArray) == null ? void 0 : h[u];
  };
  return (a = (o = l(t)) != null ? o : l(n)) != null ? a : n;
}
function UQ(e, t, n) {
  var o, a;
  if (t == null)
    return t;
  const l = (u) => {
    var f, h;
    return (h = (f = e.__cssMap) == null ? void 0 : f[u]) == null ? void 0 : h.value;
  };
  return (a = (o = l(t)) != null ? o : l(n)) != null ? a : n;
}
function XQ(e, t, n) {
  const o = wl();
  return ZQ(e, t, n)(o);
}
function ZQ(e, t, n) {
  const o = Array.isArray(t) ? t : [t], a = Array.isArray(n) ? n : [n];
  return (l) => {
    const u = a.filter(Boolean), f = o.map((h, v) => {
      var g, b;
      if (e === "breakpoints")
        return WQ(l, h, (g = u[v]) != null ? g : h);
      const S = `${e}.${h}`;
      return UQ(l, S, (b = u[v]) != null ? b : h);
    });
    return Array.isArray(t) ? f : f[0];
  };
}
var et = (...e) => e.filter(Boolean).join(" ");
function YQ() {
  return process.env.NODE_ENV !== "production";
}
function Ei(e) {
  const t = typeof e;
  return e != null && (t === "object" || t === "function") && !Array.isArray(e);
}
var lS = (e) => {
  const { condition: t, message: n } = e;
  t && YQ() && console.warn(n);
};
function Ha(e, ...t) {
  return JQ(e) ? e(...t) : e;
}
var JQ = (e) => typeof e == "function", Ft = (e) => e ? "" : void 0, xs = (e) => e ? !0 : void 0;
function st(...e) {
  return function(n) {
    e.some((o) => (o == null || o(n), n == null ? void 0 : n.defaultPrevented));
  };
}
function zE(...e) {
  return function(n) {
    e.forEach((o) => {
      o == null || o(n);
    });
  };
}
var Mw = { exports: {} };
Mw.exports;
(function(e, t) {
  var n = 200, o = "__lodash_hash_undefined__", a = 800, l = 16, u = 9007199254740991, f = "[object Arguments]", h = "[object Array]", v = "[object AsyncFunction]", g = "[object Boolean]", b = "[object Date]", S = "[object Error]", w = "[object Function]", E = "[object GeneratorFunction]", T = "[object Map]", A = "[object Number]", P = "[object Null]", _ = "[object Object]", D = "[object Proxy]", L = "[object RegExp]", F = "[object Set]", V = "[object String]", $ = "[object Undefined]", U = "[object WeakMap]", W = "[object ArrayBuffer]", H = "[object DataView]", G = "[object Float32Array]", oe = "[object Float64Array]", ce = "[object Int8Array]", te = "[object Int16Array]", Ee = "[object Int32Array]", me = "[object Uint8Array]", J = "[object Uint8ClampedArray]", Q = "[object Uint16Array]", ge = "[object Uint32Array]", Y = /[\\^$.*+?()[\]{}|]/g, q = /^\[object .+?Constructor\]$/, de = /^(?:0|[1-9]\d*)$/, K = {};
  K[G] = K[oe] = K[ce] = K[te] = K[Ee] = K[me] = K[J] = K[Q] = K[ge] = !0, K[f] = K[h] = K[W] = K[g] = K[H] = K[b] = K[S] = K[w] = K[T] = K[A] = K[_] = K[L] = K[F] = K[V] = K[U] = !1;
  var ne = typeof bC == "object" && bC && bC.Object === Object && bC, pe = typeof self == "object" && self && self.Object === Object && self, Oe = ne || pe || Function("return this")(), Ce = t && !t.nodeType && t, xe = Ce && !0 && e && !e.nodeType && e, ie = xe && xe.exports === Ce, ye = ie && ne.process, we = function() {
    try {
      var X = xe && xe.require && xe.require("util").types;
      return X || ye && ye.binding && ye.binding("util");
    } catch {
    }
  }(), fe = we && we.isTypedArray;
  function ze(X, se, Re) {
    switch (Re.length) {
      case 0:
        return X.call(se);
      case 1:
        return X.call(se, Re[0]);
      case 2:
        return X.call(se, Re[0], Re[1]);
      case 3:
        return X.call(se, Re[0], Re[1], Re[2]);
    }
    return X.apply(se, Re);
  }
  function Ve(X, se) {
    for (var Re = -1, it = Array(X); ++Re < X; )
      it[Re] = se(Re);
    return it;
  }
  function Ie(X) {
    return function(se) {
      return X(se);
    };
  }
  function qe(X, se) {
    return X == null ? void 0 : X[se];
  }
  function Qe(X, se) {
    return function(Re) {
      return X(se(Re));
    };
  }
  var lt = Array.prototype, tn = Function.prototype, Yt = Object.prototype, hn = Oe["__core-js_shared__"], vn = tn.toString, nn = Yt.hasOwnProperty, rn = function() {
    var X = /[^.]+$/.exec(hn && hn.keys && hn.keys.IE_PROTO || "");
    return X ? "Symbol(src)_1." + X : "";
  }(), mn = Yt.toString, un = vn.call(Object), Tn = RegExp(
    "^" + vn.call(nn).replace(Y, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), je = ie ? Oe.Buffer : void 0, Ot = Oe.Symbol, an = Oe.Uint8Array, Xe = je ? je.allocUnsafe : void 0, _e = Qe(Object.getPrototypeOf, Object), Je = Object.create, Kt = Yt.propertyIsEnumerable, He = lt.splice, tt = Ot ? Ot.toStringTag : void 0, ft = function() {
    try {
      var X = Au(Object, "defineProperty");
      return X({}, "", {}), X;
    } catch {
    }
  }(), mt = je ? je.isBuffer : void 0, kt = Math.max, Mn = Date.now, sn = Au(Oe, "Map"), Qt = Au(Object, "create"), Ro = /* @__PURE__ */ function() {
    function X() {
    }
    return function(se) {
      if (!pr(se))
        return {};
      if (Je)
        return Je(se);
      X.prototype = se;
      var Re = new X();
      return X.prototype = void 0, Re;
    };
  }();
  function Gr(X) {
    var se = -1, Re = X == null ? 0 : X.length;
    for (this.clear(); ++se < Re; ) {
      var it = X[se];
      this.set(it[0], it[1]);
    }
  }
  function ni() {
    this.__data__ = Qt ? Qt(null) : {}, this.size = 0;
  }
  function Yc(X) {
    var se = this.has(X) && delete this.__data__[X];
    return this.size -= se ? 1 : 0, se;
  }
  function Ia(X) {
    var se = this.__data__;
    if (Qt) {
      var Re = se[X];
      return Re === o ? void 0 : Re;
    }
    return nn.call(se, X) ? se[X] : void 0;
  }
  function Tl(X) {
    var se = this.__data__;
    return Qt ? se[X] !== void 0 : nn.call(se, X);
  }
  function Os(X, se) {
    var Re = this.__data__;
    return this.size += this.has(X) ? 0 : 1, Re[X] = Qt && se === void 0 ? o : se, this;
  }
  Gr.prototype.clear = ni, Gr.prototype.delete = Yc, Gr.prototype.get = Ia, Gr.prototype.has = Tl, Gr.prototype.set = Os;
  function Wr(X) {
    var se = -1, Re = X == null ? 0 : X.length;
    for (this.clear(); ++se < Re; ) {
      var it = X[se];
      this.set(it[0], it[1]);
    }
  }
  function Ja() {
    this.__data__ = [], this.size = 0;
  }
  function Wi(X) {
    var se = this.__data__, Re = qn(se, X);
    if (Re < 0)
      return !1;
    var it = se.length - 1;
    return Re == it ? se.pop() : He.call(se, Re, 1), --this.size, !0;
  }
  function Qa(X) {
    var se = this.__data__, Re = qn(se, X);
    return Re < 0 ? void 0 : se[Re][1];
  }
  function Po(X) {
    return qn(this.__data__, X) > -1;
  }
  function Aa(X, se) {
    var Re = this.__data__, it = qn(Re, X);
    return it < 0 ? (++this.size, Re.push([X, se])) : Re[it][1] = se, this;
  }
  Wr.prototype.clear = Ja, Wr.prototype.delete = Wi, Wr.prototype.get = Qa, Wr.prototype.has = Po, Wr.prototype.set = Aa;
  function Ti(X) {
    var se = -1, Re = X == null ? 0 : X.length;
    for (this.clear(); ++se < Re; ) {
      var it = X[se];
      this.set(it[0], it[1]);
    }
  }
  function Tu() {
    this.size = 0, this.__data__ = {
      hash: new Gr(),
      map: new (sn || Wr)(),
      string: new Gr()
    };
  }
  function Rf(X) {
    var se = Ds(this, X).delete(X);
    return this.size -= se ? 1 : 0, se;
  }
  function Pf(X) {
    return Ds(this, X).get(X);
  }
  function Il(X) {
    return Ds(this, X).has(X);
  }
  function Ui(X, se) {
    var Re = Ds(this, X), it = Re.size;
    return Re.set(X, se), this.size += Re.size == it ? 0 : 1, this;
  }
  Ti.prototype.clear = Tu, Ti.prototype.delete = Rf, Ti.prototype.get = Pf, Ti.prototype.has = Il, Ti.prototype.set = Ui;
  function Xi(X) {
    var se = this.__data__ = new Wr(X);
    this.size = se.size;
  }
  function Al() {
    this.__data__ = new Wr(), this.size = 0;
  }
  function mo(X) {
    var se = this.__data__, Re = se.delete(X);
    return this.size = se.size, Re;
  }
  function Eh(X) {
    return this.__data__.get(X);
  }
  function Th(X) {
    return this.__data__.has(X);
  }
  function Of(X, se) {
    var Re = this.__data__;
    if (Re instanceof Wr) {
      var it = Re.__data__;
      if (!sn || it.length < n - 1)
        return it.push([X, se]), this.size = ++Re.size, this;
      Re = this.__data__ = new Ti(it);
    }
    return Re.set(X, se), this.size = Re.size, this;
  }
  Xi.prototype.clear = Al, Xi.prototype.delete = mo, Xi.prototype.get = Eh, Xi.prototype.has = Th, Xi.prototype.set = Of;
  function Ih(X, se) {
    var Re = _o(X), it = !Re && Oo(X), fn = !Re && !it && _n(X), Dn = !Re && !it && !fn && Ms(X), wn = Re || it || fn || Dn, ln = wn ? Ve(X.length, String) : [], Ln = ln.length;
    for (var Do in X)
      (se || nn.call(X, Do)) && !(wn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Do == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      fn && (Do == "offset" || Do == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Dn && (Do == "buffer" || Do == "byteLength" || Do == "byteOffset") || // Skip index properties.
      Ka(Do, Ln))) && ln.push(Do);
    return ln;
  }
  function _f(X, se, Re) {
    (Re !== void 0 && !or(X[se], Re) || Re === void 0 && !(se in X)) && Df(X, se, Re);
  }
  function Ng(X, se, Re) {
    var it = X[se];
    (!(nn.call(X, se) && or(it, Re)) || Re === void 0 && !(se in X)) && Df(X, se, Re);
  }
  function qn(X, se) {
    for (var Re = X.length; Re--; )
      if (or(X[Re][0], se))
        return Re;
    return -1;
  }
  function Df(X, se, Re) {
    se == "__proto__" && ft ? ft(X, se, {
      configurable: !0,
      enumerable: !0,
      value: Re,
      writable: !0
    }) : X[se] = Re;
  }
  var ka = Mf();
  function on(X) {
    return X == null ? X === void 0 ? $ : P : tt && tt in Object(X) ? Qc(X) : qc(X);
  }
  function Ra(X) {
    return ai(X) && on(X) == f;
  }
  function Ah(X) {
    if (!pr(X) || On(X))
      return !1;
    var se = Bf(X) ? Tn : q;
    return se.test(Ru(X));
  }
  function Nf(X) {
    return ai(X) && ii(X.length) && !!K[on(X)];
  }
  function Iu(X) {
    if (!pr(X))
      return Oh(X);
    var se = Kc(X), Re = [];
    for (var it in X)
      it == "constructor" && (se || !nn.call(X, it)) || Re.push(it);
    return Re;
  }
  function ri(X, se, Re, it, fn) {
    X !== se && ka(se, function(Dn, wn) {
      if (fn || (fn = new Xi()), pr(Dn))
        kh(X, se, wn, Re, ri, it, fn);
      else {
        var ln = it ? it(ed(X, wn), Dn, wn + "", X, se, fn) : void 0;
        ln === void 0 && (ln = Dn), _f(X, wn, ln);
      }
    }, $f);
  }
  function kh(X, se, Re, it, fn, Dn, wn) {
    var ln = ed(X, Re), Ln = ed(se, Re), Do = wn.get(Ln);
    if (Do) {
      _f(X, Re, Do);
      return;
    }
    var Nr = Dn ? Dn(ln, Ln, Re + "", X, se, wn) : void 0, Pa = Nr === void 0;
    if (Pa) {
      var td = _o(Ln), vo = !td && _n(Ln), Oa = !td && !vo && Ms(Ln);
      Nr = Ln, td || vo || Oa ? _o(ln) ? Nr = ln : kr(ln) ? Nr = kl(ln) : vo ? (Pa = !1, Nr = Ph(Ln, !0)) : Oa ? (Pa = !1, Nr = Jc(Ln, !0)) : Nr = [] : _h(Ln) || Oo(Ln) ? (Nr = ln, Oo(ln) ? Nr = Vf(ln) : (!pr(ln) || Bf(ln)) && (Nr = Lf(Ln))) : Pa = !1;
    }
    Pa && (wn.set(Ln, Nr), fn(Nr, Ln, it, Dn, wn), wn.delete(Ln)), _f(X, Re, Nr);
  }
  function oi(X, se) {
    return Ff($n(X, se, Ls), X + "");
  }
  var Rh = ft ? function(X, se) {
    return ft(X, "toString", {
      configurable: !0,
      enumerable: !1,
      value: Ou(se),
      writable: !0
    });
  } : Ls;
  function Ph(X, se) {
    if (se)
      return X.slice();
    var Re = X.length, it = Xe ? Xe(Re) : new X.constructor(Re);
    return X.copy(it), it;
  }
  function Mg(X) {
    var se = new X.constructor(X.byteLength);
    return new an(se).set(new an(X)), se;
  }
  function Jc(X, se) {
    var Re = se ? Mg(X.buffer) : X.buffer;
    return new X.constructor(Re, X.byteOffset, X.length);
  }
  function kl(X, se) {
    var Re = -1, it = X.length;
    for (se || (se = Array(it)); ++Re < it; )
      se[Re] = X[Re];
    return se;
  }
  function _s(X, se, Re, it) {
    var fn = !Re;
    Re || (Re = {});
    for (var Dn = -1, wn = se.length; ++Dn < wn; ) {
      var ln = se[Dn], Ln = it ? it(Re[ln], X[ln], ln, Re, X) : void 0;
      Ln === void 0 && (Ln = X[ln]), fn ? Df(Re, ln, Ln) : Ng(Re, ln, Ln);
    }
    return Re;
  }
  function Ii(X) {
    return oi(function(se, Re) {
      var it = -1, fn = Re.length, Dn = fn > 1 ? Re[fn - 1] : void 0, wn = fn > 2 ? Re[2] : void 0;
      for (Dn = X.length > 3 && typeof Dn == "function" ? (fn--, Dn) : void 0, wn && Lg(Re[0], Re[1], wn) && (Dn = fn < 3 ? void 0 : Dn, fn = 1), se = Object(se); ++it < fn; ) {
        var ln = Re[it];
        ln && X(se, ln, it, Dn);
      }
      return se;
    });
  }
  function Mf(X) {
    return function(se, Re, it) {
      for (var fn = -1, Dn = Object(se), wn = it(se), ln = wn.length; ln--; ) {
        var Ln = wn[X ? ln : ++fn];
        if (Re(Dn[Ln], Ln, Dn) === !1)
          break;
      }
      return se;
    };
  }
  function Ds(X, se) {
    var Re = X.__data__;
    return ku(se) ? Re[typeof se == "string" ? "string" : "hash"] : Re.map;
  }
  function Au(X, se) {
    var Re = qe(X, se);
    return Ah(Re) ? Re : void 0;
  }
  function Qc(X) {
    var se = nn.call(X, tt), Re = X[tt];
    try {
      X[tt] = void 0;
      var it = !0;
    } catch {
    }
    var fn = mn.call(X);
    return it && (se ? X[tt] = Re : delete X[tt]), fn;
  }
  function Lf(X) {
    return typeof X.constructor == "function" && !Kc(X) ? Ro(_e(X)) : {};
  }
  function Ka(X, se) {
    var Re = typeof X;
    return se = se ?? u, !!se && (Re == "number" || Re != "symbol" && de.test(X)) && X > -1 && X % 1 == 0 && X < se;
  }
  function Lg(X, se, Re) {
    if (!pr(Re))
      return !1;
    var it = typeof se;
    return (it == "number" ? Ns(Re) && Ka(se, Re.length) : it == "string" && se in Re) ? or(Re[se], X) : !1;
  }
  function ku(X) {
    var se = typeof X;
    return se == "string" || se == "number" || se == "symbol" || se == "boolean" ? X !== "__proto__" : X === null;
  }
  function On(X) {
    return !!rn && rn in X;
  }
  function Kc(X) {
    var se = X && X.constructor, Re = typeof se == "function" && se.prototype || Yt;
    return X === Re;
  }
  function Oh(X) {
    var se = [];
    if (X != null)
      for (var Re in Object(X))
        se.push(Re);
    return se;
  }
  function qc(X) {
    return mn.call(X);
  }
  function $n(X, se, Re) {
    return se = kt(se === void 0 ? X.length - 1 : se, 0), function() {
      for (var it = arguments, fn = -1, Dn = kt(it.length - se, 0), wn = Array(Dn); ++fn < Dn; )
        wn[fn] = it[se + fn];
      fn = -1;
      for (var ln = Array(se + 1); ++fn < se; )
        ln[fn] = it[fn];
      return ln[se] = Re(wn), ze(X, this, ln);
    };
  }
  function ed(X, se) {
    if (!(se === "constructor" && typeof X[se] == "function") && se != "__proto__")
      return X[se];
  }
  var Ff = Ut(Rh);
  function Ut(X) {
    var se = 0, Re = 0;
    return function() {
      var it = Mn(), fn = l - (it - Re);
      if (Re = it, fn > 0) {
        if (++se >= a)
          return arguments[0];
      } else
        se = 0;
      return X.apply(void 0, arguments);
    };
  }
  function Ru(X) {
    if (X != null) {
      try {
        return vn.call(X);
      } catch {
      }
      try {
        return X + "";
      } catch {
      }
    }
    return "";
  }
  function or(X, se) {
    return X === se || X !== X && se !== se;
  }
  var Oo = Ra(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Ra : function(X) {
    return ai(X) && nn.call(X, "callee") && !Kt.call(X, "callee");
  }, _o = Array.isArray;
  function Ns(X) {
    return X != null && ii(X.length) && !Bf(X);
  }
  function kr(X) {
    return ai(X) && Ns(X);
  }
  var _n = mt || Fs;
  function Bf(X) {
    if (!pr(X))
      return !1;
    var se = on(X);
    return se == w || se == E || se == v || se == D;
  }
  function ii(X) {
    return typeof X == "number" && X > -1 && X % 1 == 0 && X <= u;
  }
  function pr(X) {
    var se = typeof X;
    return X != null && (se == "object" || se == "function");
  }
  function ai(X) {
    return X != null && typeof X == "object";
  }
  function _h(X) {
    if (!ai(X) || on(X) != _)
      return !1;
    var se = _e(X);
    if (se === null)
      return !0;
    var Re = nn.call(se, "constructor") && se.constructor;
    return typeof Re == "function" && Re instanceof Re && vn.call(Re) == un;
  }
  var Ms = fe ? Ie(fe) : Nf;
  function Vf(X) {
    return _s(X, $f(X));
  }
  function $f(X) {
    return Ns(X) ? Ih(X, !0) : Iu(X);
  }
  var Pu = Ii(function(X, se, Re, it) {
    ri(X, se, Re, it);
  });
  function Ou(X) {
    return function() {
      return X;
    };
  }
  function Ls(X) {
    return X;
  }
  function Fs() {
    return !1;
  }
  e.exports = Pu;
})(Mw, Mw.exports);
var QQ = Mw.exports;
const bs = /* @__PURE__ */ I_(QQ);
var KQ = (e) => /!(important)?$/.test(e), KF = (e) => typeof e == "string" ? e.replace(/!(important)?$/, "").trim() : e, qQ = (e, t) => (n) => {
  const o = String(t), a = KQ(o), l = KF(o), u = e ? `${e}.${l}` : l;
  let f = Ei(n.__cssMap) && u in n.__cssMap ? n.__cssMap[u].varRef : t;
  return f = KF(f), a ? `${f} !important` : f;
};
function M_(e) {
  const { scale: t, transform: n, compose: o } = e;
  return (l, u) => {
    var f;
    const h = qQ(t, l)(u);
    let v = (f = n == null ? void 0 : n(h, u)) != null ? f : h;
    return o && (v = o(v, u)), v;
  };
}
var CC = (...e) => (t) => e.reduce((n, o) => o(n), t);
function ps(e, t) {
  return (n) => {
    const o = { property: n, scale: e };
    return o.transform = M_({
      scale: e,
      transform: t
    }), o;
  };
}
var eK = ({ rtl: e, ltr: t }) => (n) => n.direction === "rtl" ? e : t;
function tK(e) {
  const { property: t, scale: n, transform: o } = e;
  return {
    scale: n,
    property: eK(t),
    transform: n ? M_({
      scale: n,
      compose: o
    }) : o
  };
}
var h4 = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function nK() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...h4
  ].join(" ");
}
function rK() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...h4
  ].join(" ");
}
var oK = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
}, iK = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function aK(e) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": e,
    boxShadow: [
      "var(--chakra-ring-offset-shadow)",
      "var(--chakra-ring-shadow)",
      "var(--chakra-shadow, 0 0 #0000)"
    ].join(", ")
  };
}
var sK = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
}, VP = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
}, lK = new Set(Object.values(VP)), $P = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]), uK = (e) => e.trim();
function cK(e, t) {
  if (e == null || $P.has(e))
    return e;
  if (!(zP(e) || $P.has(e)))
    return `url('${e}')`;
  const a = /(^[a-z-A-Z]+)\((.*)\)/g.exec(e), l = a == null ? void 0 : a[1], u = a == null ? void 0 : a[2];
  if (!l || !u)
    return e;
  const f = l.includes("-gradient") ? l : `${l}-gradient`, [h, ...v] = u.split(",").map(uK).filter(Boolean);
  if ((v == null ? void 0 : v.length) === 0)
    return e;
  const g = h in VP ? VP[h] : h;
  v.unshift(g);
  const b = v.map((S) => {
    if (lK.has(S))
      return S;
    const w = S.indexOf(" "), [E, T] = w !== -1 ? [S.substr(0, w), S.substr(w + 1)] : [S], A = zP(T) ? T : T && T.split(" "), P = `colors.${E}`, _ = P in t.__cssMap ? t.__cssMap[P].varRef : E;
    return A ? [
      _,
      ...Array.isArray(A) ? A : [A]
    ].join(" ") : _;
  });
  return `${f}(${b.join(", ")})`;
}
var zP = (e) => typeof e == "string" && e.includes("(") && e.includes(")"), dK = (e, t) => cK(e, t ?? {});
function fK(e) {
  return /^var\(--.+\)$/.test(e);
}
var pK = (e) => {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}, au = (e) => (t) => `${e}(${t})`, An = {
  filter(e) {
    return e !== "auto" ? e : oK;
  },
  backdropFilter(e) {
    return e !== "auto" ? e : iK;
  },
  ring(e) {
    return aK(An.px(e));
  },
  bgClip(e) {
    return e === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: e };
  },
  transform(e) {
    return e === "auto" ? nK() : e === "auto-gpu" ? rK() : e;
  },
  vh(e) {
    return e === "$100vh" ? "var(--chakra-vh)" : e;
  },
  px(e) {
    if (e == null)
      return e;
    const { unitless: t } = pK(e);
    return t || typeof e == "number" ? `${e}px` : e;
  },
  fraction(e) {
    return typeof e != "number" || e > 1 ? e : `${e * 100}%`;
  },
  float(e, t) {
    const n = { left: "right", right: "left" };
    return t.direction === "rtl" ? n[e] : e;
  },
  degree(e) {
    if (fK(e) || e == null)
      return e;
    const t = typeof e == "string" && !e.endsWith("deg");
    return typeof e == "number" || t ? `${e}deg` : e;
  },
  gradient: dK,
  blur: au("blur"),
  opacity: au("opacity"),
  brightness: au("brightness"),
  contrast: au("contrast"),
  dropShadow: au("drop-shadow"),
  grayscale: au("grayscale"),
  hueRotate: (e) => au("hue-rotate")(An.degree(e)),
  invert: au("invert"),
  saturate: au("saturate"),
  sepia: au("sepia"),
  bgImage(e) {
    return e == null || zP(e) || $P.has(e) ? e : `url(${e})`;
  },
  outline(e) {
    const t = String(e) === "0" || String(e) === "none";
    return e !== null && t ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: e };
  },
  flexDirection(e) {
    var t;
    const { space: n, divide: o } = (t = sK[e]) != null ? t : {}, a = { flexDirection: e };
    return n && (a[n] = 1), o && (a[o] = 1), a;
  }
}, he = {
  borderWidths: ps("borderWidths"),
  borderStyles: ps("borderStyles"),
  colors: ps("colors"),
  borders: ps("borders"),
  gradients: ps("gradients", An.gradient),
  radii: ps("radii", An.px),
  space: ps("space", CC(An.vh, An.px)),
  spaceT: ps("space", CC(An.vh, An.px)),
  degreeT(e) {
    return { property: e, transform: An.degree };
  },
  prop(e, t, n) {
    return {
      property: e,
      scale: t,
      ...t && {
        transform: M_({ scale: t, transform: n })
      }
    };
  },
  propT(e, t) {
    return { property: e, transform: t };
  },
  sizes: ps("sizes", CC(An.vh, An.px)),
  sizesT: ps("sizes", CC(An.vh, An.fraction)),
  shadows: ps("shadows"),
  logical: tK,
  blur: ps("blur", An.blur)
}, nw = {
  background: he.colors("background"),
  backgroundColor: he.colors("backgroundColor"),
  backgroundImage: he.gradients("backgroundImage"),
  backgroundSize: !0,
  backgroundPosition: !0,
  backgroundRepeat: !0,
  backgroundAttachment: !0,
  backgroundClip: { transform: An.bgClip },
  bgSize: he.prop("backgroundSize"),
  bgPosition: he.prop("backgroundPosition"),
  bg: he.colors("background"),
  bgColor: he.colors("backgroundColor"),
  bgPos: he.prop("backgroundPosition"),
  bgRepeat: he.prop("backgroundRepeat"),
  bgAttachment: he.prop("backgroundAttachment"),
  bgGradient: he.gradients("backgroundImage"),
  bgClip: { transform: An.bgClip }
};
Object.assign(nw, {
  bgImage: nw.backgroundImage,
  bgImg: nw.backgroundImage
});
var zn = {
  border: he.borders("border"),
  borderWidth: he.borderWidths("borderWidth"),
  borderStyle: he.borderStyles("borderStyle"),
  borderColor: he.colors("borderColor"),
  borderRadius: he.radii("borderRadius"),
  borderTop: he.borders("borderTop"),
  borderBlockStart: he.borders("borderBlockStart"),
  borderTopLeftRadius: he.radii("borderTopLeftRadius"),
  borderStartStartRadius: he.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: he.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: he.radii("borderTopRightRadius"),
  borderStartEndRadius: he.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: he.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: he.borders("borderRight"),
  borderInlineEnd: he.borders("borderInlineEnd"),
  borderBottom: he.borders("borderBottom"),
  borderBlockEnd: he.borders("borderBlockEnd"),
  borderBottomLeftRadius: he.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: he.radii("borderBottomRightRadius"),
  borderLeft: he.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: he.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: he.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: he.borders(["borderLeft", "borderRight"]),
  borderInline: he.borders("borderInline"),
  borderY: he.borders(["borderTop", "borderBottom"]),
  borderBlock: he.borders("borderBlock"),
  borderTopWidth: he.borderWidths("borderTopWidth"),
  borderBlockStartWidth: he.borderWidths("borderBlockStartWidth"),
  borderTopColor: he.colors("borderTopColor"),
  borderBlockStartColor: he.colors("borderBlockStartColor"),
  borderTopStyle: he.borderStyles("borderTopStyle"),
  borderBlockStartStyle: he.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: he.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: he.borderWidths("borderBlockEndWidth"),
  borderBottomColor: he.colors("borderBottomColor"),
  borderBlockEndColor: he.colors("borderBlockEndColor"),
  borderBottomStyle: he.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: he.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: he.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: he.borderWidths("borderInlineStartWidth"),
  borderLeftColor: he.colors("borderLeftColor"),
  borderInlineStartColor: he.colors("borderInlineStartColor"),
  borderLeftStyle: he.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: he.borderStyles("borderInlineStartStyle"),
  borderRightWidth: he.borderWidths("borderRightWidth"),
  borderInlineEndWidth: he.borderWidths("borderInlineEndWidth"),
  borderRightColor: he.colors("borderRightColor"),
  borderInlineEndColor: he.colors("borderInlineEndColor"),
  borderRightStyle: he.borderStyles("borderRightStyle"),
  borderInlineEndStyle: he.borderStyles("borderInlineEndStyle"),
  borderTopRadius: he.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: he.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: he.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: he.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(zn, {
  rounded: zn.borderRadius,
  roundedTop: zn.borderTopRadius,
  roundedTopLeft: zn.borderTopLeftRadius,
  roundedTopRight: zn.borderTopRightRadius,
  roundedTopStart: zn.borderStartStartRadius,
  roundedTopEnd: zn.borderStartEndRadius,
  roundedBottom: zn.borderBottomRadius,
  roundedBottomLeft: zn.borderBottomLeftRadius,
  roundedBottomRight: zn.borderBottomRightRadius,
  roundedBottomStart: zn.borderEndStartRadius,
  roundedBottomEnd: zn.borderEndEndRadius,
  roundedLeft: zn.borderLeftRadius,
  roundedRight: zn.borderRightRadius,
  roundedStart: zn.borderInlineStartRadius,
  roundedEnd: zn.borderInlineEndRadius,
  borderStart: zn.borderInlineStart,
  borderEnd: zn.borderInlineEnd,
  borderTopStartRadius: zn.borderStartStartRadius,
  borderTopEndRadius: zn.borderStartEndRadius,
  borderBottomStartRadius: zn.borderEndStartRadius,
  borderBottomEndRadius: zn.borderEndEndRadius,
  borderStartRadius: zn.borderInlineStartRadius,
  borderEndRadius: zn.borderInlineEndRadius,
  borderStartWidth: zn.borderInlineStartWidth,
  borderEndWidth: zn.borderInlineEndWidth,
  borderStartColor: zn.borderInlineStartColor,
  borderEndColor: zn.borderInlineEndColor,
  borderStartStyle: zn.borderInlineStartStyle,
  borderEndStyle: zn.borderInlineEndStyle
});
var hK = {
  color: he.colors("color"),
  textColor: he.colors("color"),
  fill: he.colors("fill"),
  stroke: he.colors("stroke")
}, HP = {
  boxShadow: he.shadows("boxShadow"),
  mixBlendMode: !0,
  blendMode: he.prop("mixBlendMode"),
  backgroundBlendMode: !0,
  bgBlendMode: he.prop("backgroundBlendMode"),
  opacity: !0
};
Object.assign(HP, {
  shadow: HP.boxShadow
});
var mK = {
  filter: { transform: An.filter },
  blur: he.blur("--chakra-blur"),
  brightness: he.propT("--chakra-brightness", An.brightness),
  contrast: he.propT("--chakra-contrast", An.contrast),
  hueRotate: he.propT("--chakra-hue-rotate", An.hueRotate),
  invert: he.propT("--chakra-invert", An.invert),
  saturate: he.propT("--chakra-saturate", An.saturate),
  dropShadow: he.propT("--chakra-drop-shadow", An.dropShadow),
  backdropFilter: { transform: An.backdropFilter },
  backdropBlur: he.blur("--chakra-backdrop-blur"),
  backdropBrightness: he.propT(
    "--chakra-backdrop-brightness",
    An.brightness
  ),
  backdropContrast: he.propT("--chakra-backdrop-contrast", An.contrast),
  backdropHueRotate: he.propT(
    "--chakra-backdrop-hue-rotate",
    An.hueRotate
  ),
  backdropInvert: he.propT("--chakra-backdrop-invert", An.invert),
  backdropSaturate: he.propT("--chakra-backdrop-saturate", An.saturate)
}, Lw = {
  alignItems: !0,
  alignContent: !0,
  justifyItems: !0,
  justifyContent: !0,
  flexWrap: !0,
  flexDirection: { transform: An.flexDirection },
  flex: !0,
  flexFlow: !0,
  flexGrow: !0,
  flexShrink: !0,
  flexBasis: he.sizes("flexBasis"),
  justifySelf: !0,
  alignSelf: !0,
  order: !0,
  placeItems: !0,
  placeContent: !0,
  placeSelf: !0,
  gap: he.space("gap"),
  rowGap: he.space("rowGap"),
  columnGap: he.space("columnGap")
};
Object.assign(Lw, {
  flexDir: Lw.flexDirection
});
var m4 = {
  gridGap: he.space("gridGap"),
  gridColumnGap: he.space("gridColumnGap"),
  gridRowGap: he.space("gridRowGap"),
  gridColumn: !0,
  gridRow: !0,
  gridAutoFlow: !0,
  gridAutoColumns: !0,
  gridColumnStart: !0,
  gridColumnEnd: !0,
  gridRowStart: !0,
  gridRowEnd: !0,
  gridAutoRows: !0,
  gridTemplate: !0,
  gridTemplateColumns: !0,
  gridTemplateRows: !0,
  gridTemplateAreas: !0,
  gridArea: !0
}, vK = {
  appearance: !0,
  cursor: !0,
  resize: !0,
  userSelect: !0,
  pointerEvents: !0,
  outline: { transform: An.outline },
  outlineOffset: !0,
  outlineColor: he.colors("outlineColor")
}, ms = {
  width: he.sizesT("width"),
  inlineSize: he.sizesT("inlineSize"),
  height: he.sizes("height"),
  blockSize: he.sizes("blockSize"),
  boxSize: he.sizes(["width", "height"]),
  minWidth: he.sizes("minWidth"),
  minInlineSize: he.sizes("minInlineSize"),
  minHeight: he.sizes("minHeight"),
  minBlockSize: he.sizes("minBlockSize"),
  maxWidth: he.sizes("maxWidth"),
  maxInlineSize: he.sizes("maxInlineSize"),
  maxHeight: he.sizes("maxHeight"),
  maxBlockSize: he.sizes("maxBlockSize"),
  overflow: !0,
  overflowX: !0,
  overflowY: !0,
  overscrollBehavior: !0,
  overscrollBehaviorX: !0,
  overscrollBehaviorY: !0,
  display: !0,
  aspectRatio: !0,
  hideFrom: {
    scale: "breakpoints",
    transform: (e, t) => {
      var n, o, a;
      return { [`@media screen and (min-width: ${(a = (o = (n = t.__breakpoints) == null ? void 0 : n.get(e)) == null ? void 0 : o.minW) != null ? a : e})`]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (e, t) => {
      var n, o, a;
      return { [`@media screen and (max-width: ${(a = (o = (n = t.__breakpoints) == null ? void 0 : n.get(e)) == null ? void 0 : o._minW) != null ? a : e})`]: { display: "none" } };
    }
  },
  verticalAlign: !0,
  boxSizing: !0,
  boxDecorationBreak: !0,
  float: he.propT("float", An.float),
  objectFit: !0,
  objectPosition: !0,
  visibility: !0,
  isolation: !0
};
Object.assign(ms, {
  w: ms.width,
  h: ms.height,
  minW: ms.minWidth,
  maxW: ms.maxWidth,
  minH: ms.minHeight,
  maxH: ms.maxHeight,
  overscroll: ms.overscrollBehavior,
  overscrollX: ms.overscrollBehaviorX,
  overscrollY: ms.overscrollBehaviorY
});
var gK = {
  listStyleType: !0,
  listStylePosition: !0,
  listStylePos: he.prop("listStylePosition"),
  listStyleImage: !0,
  listStyleImg: he.prop("listStyleImage")
};
function yK(e, t, n, o) {
  const a = typeof t == "string" ? t.split(".") : [t];
  for (o = 0; o < a.length && e; o += 1)
    e = e[a[o]];
  return e === void 0 ? n : e;
}
var bK = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (o, a, l, u) => {
    if (typeof o > "u")
      return e(o, a, l);
    t.has(o) || t.set(o, /* @__PURE__ */ new Map());
    const f = t.get(o);
    if (f.has(a))
      return f.get(a);
    const h = e(o, a, l, u);
    return f.set(a, h), h;
  };
}, SK = bK(yK), xK = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
}, CK = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
}, fR = (e, t, n) => {
  const o = {}, a = SK(e, t, {});
  for (const l in a)
    l in n && n[l] != null || (o[l] = a[l]);
  return o;
}, wK = {
  srOnly: {
    transform(e) {
      return e === !0 ? xK : e === "focusable" ? CK : {};
    }
  },
  layerStyle: {
    processResult: !0,
    transform: (e, t, n) => fR(t, `layerStyles.${e}`, n)
  },
  textStyle: {
    processResult: !0,
    transform: (e, t, n) => fR(t, `textStyles.${e}`, n)
  },
  apply: {
    processResult: !0,
    transform: (e, t, n) => fR(t, e, n)
  }
}, y0 = {
  position: !0,
  pos: he.prop("position"),
  zIndex: he.prop("zIndex", "zIndices"),
  inset: he.spaceT("inset"),
  insetX: he.spaceT(["left", "right"]),
  insetInline: he.spaceT("insetInline"),
  insetY: he.spaceT(["top", "bottom"]),
  insetBlock: he.spaceT("insetBlock"),
  top: he.spaceT("top"),
  insetBlockStart: he.spaceT("insetBlockStart"),
  bottom: he.spaceT("bottom"),
  insetBlockEnd: he.spaceT("insetBlockEnd"),
  left: he.spaceT("left"),
  insetInlineStart: he.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: he.spaceT("right"),
  insetInlineEnd: he.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(y0, {
  insetStart: y0.insetInlineStart,
  insetEnd: y0.insetInlineEnd
});
var EK = {
  ring: { transform: An.ring },
  ringColor: he.colors("--chakra-ring-color"),
  ringOffset: he.prop("--chakra-ring-offset-width"),
  ringOffsetColor: he.colors("--chakra-ring-offset-color"),
  ringInset: he.prop("--chakra-ring-inset")
}, Cr = {
  margin: he.spaceT("margin"),
  marginTop: he.spaceT("marginTop"),
  marginBlockStart: he.spaceT("marginBlockStart"),
  marginRight: he.spaceT("marginRight"),
  marginInlineEnd: he.spaceT("marginInlineEnd"),
  marginBottom: he.spaceT("marginBottom"),
  marginBlockEnd: he.spaceT("marginBlockEnd"),
  marginLeft: he.spaceT("marginLeft"),
  marginInlineStart: he.spaceT("marginInlineStart"),
  marginX: he.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: he.spaceT("marginInline"),
  marginY: he.spaceT(["marginTop", "marginBottom"]),
  marginBlock: he.spaceT("marginBlock"),
  padding: he.space("padding"),
  paddingTop: he.space("paddingTop"),
  paddingBlockStart: he.space("paddingBlockStart"),
  paddingRight: he.space("paddingRight"),
  paddingBottom: he.space("paddingBottom"),
  paddingBlockEnd: he.space("paddingBlockEnd"),
  paddingLeft: he.space("paddingLeft"),
  paddingInlineStart: he.space("paddingInlineStart"),
  paddingInlineEnd: he.space("paddingInlineEnd"),
  paddingX: he.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: he.space("paddingInline"),
  paddingY: he.space(["paddingTop", "paddingBottom"]),
  paddingBlock: he.space("paddingBlock")
};
Object.assign(Cr, {
  m: Cr.margin,
  mt: Cr.marginTop,
  mr: Cr.marginRight,
  me: Cr.marginInlineEnd,
  marginEnd: Cr.marginInlineEnd,
  mb: Cr.marginBottom,
  ml: Cr.marginLeft,
  ms: Cr.marginInlineStart,
  marginStart: Cr.marginInlineStart,
  mx: Cr.marginX,
  my: Cr.marginY,
  p: Cr.padding,
  pt: Cr.paddingTop,
  py: Cr.paddingY,
  px: Cr.paddingX,
  pb: Cr.paddingBottom,
  pl: Cr.paddingLeft,
  ps: Cr.paddingInlineStart,
  paddingStart: Cr.paddingInlineStart,
  pr: Cr.paddingRight,
  pe: Cr.paddingInlineEnd,
  paddingEnd: Cr.paddingInlineEnd
});
var TK = {
  textDecorationColor: he.colors("textDecorationColor"),
  textDecoration: !0,
  textDecor: { property: "textDecoration" },
  textDecorationLine: !0,
  textDecorationStyle: !0,
  textDecorationThickness: !0,
  textUnderlineOffset: !0,
  textShadow: he.shadows("textShadow")
}, IK = {
  clipPath: !0,
  transform: he.propT("transform", An.transform),
  transformOrigin: !0,
  translateX: he.spaceT("--chakra-translate-x"),
  translateY: he.spaceT("--chakra-translate-y"),
  skewX: he.degreeT("--chakra-skew-x"),
  skewY: he.degreeT("--chakra-skew-y"),
  scaleX: he.prop("--chakra-scale-x"),
  scaleY: he.prop("--chakra-scale-y"),
  scale: he.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: he.degreeT("--chakra-rotate")
}, AK = {
  transition: !0,
  transitionDelay: !0,
  animation: !0,
  willChange: !0,
  transitionDuration: he.prop("transitionDuration", "transition.duration"),
  transitionProperty: he.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: he.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
}, kK = {
  fontFamily: he.prop("fontFamily", "fonts"),
  fontSize: he.prop("fontSize", "fontSizes", An.px),
  fontWeight: he.prop("fontWeight", "fontWeights"),
  lineHeight: he.prop("lineHeight", "lineHeights"),
  letterSpacing: he.prop("letterSpacing", "letterSpacings"),
  textAlign: !0,
  fontStyle: !0,
  textIndent: !0,
  wordBreak: !0,
  overflowWrap: !0,
  textOverflow: !0,
  textTransform: !0,
  whiteSpace: !0,
  isTruncated: {
    transform(e) {
      if (e === !0)
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
}, RK = {
  scrollBehavior: !0,
  scrollSnapAlign: !0,
  scrollSnapStop: !0,
  scrollSnapType: !0,
  // scroll margin
  scrollMargin: he.spaceT("scrollMargin"),
  scrollMarginTop: he.spaceT("scrollMarginTop"),
  scrollMarginBottom: he.spaceT("scrollMarginBottom"),
  scrollMarginLeft: he.spaceT("scrollMarginLeft"),
  scrollMarginRight: he.spaceT("scrollMarginRight"),
  scrollMarginX: he.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: he.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: he.spaceT("scrollPadding"),
  scrollPaddingTop: he.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: he.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: he.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: he.spaceT("scrollPaddingRight"),
  scrollPaddingX: he.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: he.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function v4(e) {
  return Ei(e) && e.reference ? e.reference : String(e);
}
var HE = (e, ...t) => t.map(v4).join(` ${e} `).replace(/calc/g, ""), qF = (...e) => `calc(${HE("+", ...e)})`, eB = (...e) => `calc(${HE("-", ...e)})`, jP = (...e) => `calc(${HE("*", ...e)})`, tB = (...e) => `calc(${HE("/", ...e)})`, nB = (e) => {
  const t = v4(e);
  return t != null && !Number.isNaN(parseFloat(t)) ? String(t).startsWith("-") ? String(t).slice(1) : `-${t}` : jP(t, -1);
}, Up = Object.assign(
  (e) => ({
    add: (...t) => Up(qF(e, ...t)),
    subtract: (...t) => Up(eB(e, ...t)),
    multiply: (...t) => Up(jP(e, ...t)),
    divide: (...t) => Up(tB(e, ...t)),
    negate: () => Up(nB(e)),
    toString: () => e.toString()
  }),
  {
    add: qF,
    subtract: eB,
    multiply: jP,
    divide: tB,
    negate: nB
  }
);
function PK(e, t = "-") {
  return e.replace(/\s+/g, t);
}
function OK(e) {
  const t = PK(e.toString());
  return DK(_K(t));
}
function _K(e) {
  return e.includes("\\.") ? e : !Number.isInteger(parseFloat(e.toString())) ? e.replace(".", "\\.") : e;
}
function DK(e) {
  return e.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function NK(e, t = "") {
  return [t, e].filter(Boolean).join("-");
}
function MK(e, t) {
  return `var(${e}${t ? `, ${t}` : ""})`;
}
function LK(e, t = "") {
  return OK(`--${NK(e, t)}`);
}
function Pt(e, t, n) {
  const o = LK(e, n);
  return {
    variable: o,
    reference: MK(o, t)
  };
}
function FK(e, t) {
  const n = {};
  for (const o of t) {
    if (Array.isArray(o)) {
      const [a, l] = o;
      n[a] = Pt(`${e}-${a}`, l);
      continue;
    }
    n[o] = Pt(`${e}-${o}`);
  }
  return n;
}
function BK(e) {
  const t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function VK(e) {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}
function GP(e) {
  if (e == null)
    return e;
  const { unitless: t } = VK(e);
  return t || typeof e == "number" ? `${e}px` : e;
}
var g4 = (e, t) => parseInt(e[1], 10) > parseInt(t[1], 10) ? 1 : -1, L_ = (e) => Object.fromEntries(Object.entries(e).sort(g4));
function rB(e) {
  const t = L_(e);
  return Object.assign(Object.values(t), t);
}
function $K(e) {
  const t = Object.keys(L_(e));
  return new Set(t);
}
function oB(e) {
  var t;
  if (!e)
    return e;
  e = (t = GP(e)) != null ? t : e;
  const n = -0.02;
  return typeof e == "number" ? `${e + n}` : e.replace(/(\d+\.?\d*)/u, (o) => `${parseFloat(o) + n}`);
}
function i0(e, t) {
  const n = ["@media screen"];
  return e && n.push("and", `(min-width: ${GP(e)})`), t && n.push("and", `(max-width: ${GP(t)})`), n.join(" ");
}
function zK(e) {
  var t;
  if (!e)
    return null;
  e.base = (t = e.base) != null ? t : "0px";
  const n = rB(e), o = Object.entries(e).sort(g4).map(([u, f], h, v) => {
    var g;
    let [, b] = (g = v[h + 1]) != null ? g : [];
    return b = parseFloat(b) > 0 ? oB(b) : void 0, {
      _minW: oB(f),
      breakpoint: u,
      minW: f,
      maxW: b,
      maxWQuery: i0(null, b),
      minWQuery: i0(f),
      minMaxQuery: i0(f, b)
    };
  }), a = $K(e), l = Array.from(a.values());
  return {
    keys: a,
    normalized: n,
    isResponsive(u) {
      const f = Object.keys(u);
      return f.length > 0 && f.every((h) => a.has(h));
    },
    asObject: L_(e),
    asArray: rB(e),
    details: o,
    get(u) {
      return o.find((f) => f.breakpoint === u);
    },
    media: [
      null,
      ...n.map((u) => i0(u)).slice(1)
    ],
    /**
     * Converts the object responsive syntax to array syntax
     *
     * @example
     * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
     */
    toArrayValue(u) {
      if (!Ei(u))
        throw new Error("toArrayValue: value must be an object");
      const f = l.map((h) => {
        var v;
        return (v = u[h]) != null ? v : null;
      });
      for (; BK(f) === null; )
        f.pop();
      return f;
    },
    /**
     * Converts the array responsive syntax to object syntax
     *
     * @example
     * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
     */
    toObjectValue(u) {
      if (!Array.isArray(u))
        throw new Error("toObjectValue: value must be an array");
      return u.reduce((f, h, v) => {
        const g = l[v];
        return g != null && h != null && (f[g] = h), f;
      }, {});
    }
  };
}
var Ko = {
  hover: (e, t) => `${e}:hover ${t}, ${e}[data-hover] ${t}`,
  focus: (e, t) => `${e}:focus ${t}, ${e}[data-focus] ${t}`,
  focusVisible: (e, t) => `${e}:focus-visible ${t}`,
  focusWithin: (e, t) => `${e}:focus-within ${t}`,
  active: (e, t) => `${e}:active ${t}, ${e}[data-active] ${t}`,
  disabled: (e, t) => `${e}:disabled ${t}, ${e}[data-disabled] ${t}`,
  invalid: (e, t) => `${e}:invalid ${t}, ${e}[data-invalid] ${t}`,
  checked: (e, t) => `${e}:checked ${t}, ${e}[data-checked] ${t}`,
  indeterminate: (e, t) => `${e}:indeterminate ${t}, ${e}[aria-checked=mixed] ${t}, ${e}[data-indeterminate] ${t}`,
  readOnly: (e, t) => `${e}:read-only ${t}, ${e}[readonly] ${t}, ${e}[data-read-only] ${t}`,
  expanded: (e, t) => `${e}:read-only ${t}, ${e}[aria-expanded=true] ${t}, ${e}[data-expanded] ${t}`,
  placeholderShown: (e, t) => `${e}:placeholder-shown ${t}`
}, Jd = (e) => y4((t) => e(t, "&"), "[role=group]", "[data-group]", ".group"), yc = (e) => y4((t) => e(t, "~ &"), "[data-peer]", ".peer"), y4 = (e, ...t) => t.map(e).join(", "), jE = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: Jd(Ko.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: yc(Ko.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: Jd(Ko.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: yc(Ko.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: Jd(Ko.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: yc(Ko.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: Jd(Ko.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: yc(Ko.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: Jd(Ko.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: yc(Ko.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: Jd(Ko.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: yc(Ko.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: Jd(Ko.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: yc(Ko.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: Jd(Ko.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: yc(Ko.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: yc(Ko.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]"
}, b4 = Object.keys(
  jE
);
function iB(e, t) {
  return Pt(String(e).replace(/\./g, "-"), void 0, t);
}
function HK(e, t) {
  let n = {};
  const o = {};
  for (const [a, l] of Object.entries(e)) {
    const { isSemantic: u, value: f } = l, { variable: h, reference: v } = iB(a, t == null ? void 0 : t.cssVarPrefix);
    if (!u) {
      if (a.startsWith("space")) {
        const S = a.split("."), [w, ...E] = S, T = `${w}.-${E.join(".")}`, A = Up.negate(f), P = Up.negate(v);
        o[T] = {
          value: A,
          var: h,
          varRef: P
        };
      }
      n[h] = f, o[a] = {
        value: f,
        var: h,
        varRef: v
      };
      continue;
    }
    const g = (S) => {
      const E = [String(a).split(".")[0], S].join(".");
      if (!e[E])
        return S;
      const { reference: A } = iB(E, t == null ? void 0 : t.cssVarPrefix);
      return A;
    }, b = Ei(f) ? f : { default: f };
    n = bs(
      n,
      Object.entries(b).reduce(
        (S, [w, E]) => {
          var T, A;
          if (!E)
            return S;
          const P = g(`${E}`);
          if (w === "default")
            return S[h] = P, S;
          const _ = (A = (T = jE) == null ? void 0 : T[w]) != null ? A : w;
          return S[_] = { [h]: P }, S;
        },
        {}
      )
    ), o[a] = {
      value: v,
      var: h,
      varRef: v
    };
  }
  return {
    cssVars: n,
    cssMap: o
  };
}
function jK(e, t = []) {
  const n = Object.assign({}, e);
  for (const o of t)
    o in n && delete n[o];
  return n;
}
function GK(e, t) {
  const n = {};
  for (const o of t)
    o in e && (n[o] = e[o]);
  return n;
}
function WK(e) {
  return typeof e == "object" && e != null && !Array.isArray(e);
}
function aB(e, t, n = {}) {
  const { stop: o, getKey: a } = n;
  function l(u, f = []) {
    var h;
    if (WK(u) || Array.isArray(u)) {
      const v = {};
      for (const [g, b] of Object.entries(u)) {
        const S = (h = a == null ? void 0 : a(g)) != null ? h : g, w = [...f, S];
        if (o != null && o(u, w))
          return t(u, f);
        v[S] = l(b, w);
      }
      return v;
    }
    return t(u, f);
  }
  return l(e);
}
var UK = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function XK(e) {
  return GK(e, UK);
}
function ZK(e) {
  return e.semanticTokens;
}
function YK(e) {
  const { __cssMap: t, __cssVars: n, __breakpoints: o, ...a } = e;
  return a;
}
var JK = (e) => b4.includes(e) || e === "default";
function QK({
  tokens: e,
  semanticTokens: t
}) {
  const n = {};
  return aB(e, (o, a) => {
    o != null && (n[a.join(".")] = { isSemantic: !1, value: o });
  }), aB(
    t,
    (o, a) => {
      o != null && (n[a.join(".")] = { isSemantic: !0, value: o });
    },
    {
      stop: (o) => Object.keys(o).every(JK)
    }
  ), n;
}
function KK(e) {
  var t;
  const n = YK(e), o = XK(n), a = ZK(n), l = QK({ tokens: o, semanticTokens: a }), u = (t = n.config) == null ? void 0 : t.cssVarPrefix, {
    /**
     * This is more like a dictionary of tokens users will type `green.500`,
     * and their equivalent css variable.
     */
    cssMap: f,
    /**
     * The extracted css variables will be stored here, and used in
     * the emotion's <Global/> component to attach variables to `:root`
     */
    cssVars: h
  } = HK(l, { cssVarPrefix: u });
  return Object.assign(n, {
    __cssVars: { ...{
      "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-ring-offset-width": "0px",
      "--chakra-ring-offset-color": "#fff",
      "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
      "--chakra-ring-offset-shadow": "0 0 #0000",
      "--chakra-ring-shadow": "0 0 #0000",
      "--chakra-space-x-reverse": "0",
      "--chakra-space-y-reverse": "0"
    }, ...h },
    __cssMap: f,
    __breakpoints: zK(n.breakpoints)
  }), n;
}
var F_ = bs(
  {},
  nw,
  zn,
  hK,
  Lw,
  ms,
  mK,
  EK,
  vK,
  m4,
  wK,
  y0,
  HP,
  Cr,
  RK,
  kK,
  TK,
  IK,
  gK,
  AK
), qK = Object.assign({}, Cr, ms, Lw, m4, y0), S4 = Object.keys(
  qK
), eq = [...Object.keys(F_), ...b4], tq = { ...F_, ...jE }, nq = (e) => e in tq, rq = (e) => (t) => {
  if (!t.__breakpoints)
    return e;
  const { isResponsive: n, toArrayValue: o, media: a } = t.__breakpoints, l = {};
  for (const u in e) {
    let f = Ha(e[u], t);
    if (f == null)
      continue;
    if (f = Ei(f) && n(f) ? o(f) : f, !Array.isArray(f)) {
      l[u] = f;
      continue;
    }
    const h = f.slice(0, a.length).length;
    for (let v = 0; v < h; v += 1) {
      const g = a == null ? void 0 : a[v];
      if (!g) {
        l[u] = f[v];
        continue;
      }
      l[g] = l[g] || {}, f[v] != null && (l[g][u] = f[v]);
    }
  }
  return l;
};
function oq(e) {
  const t = [];
  let n = "", o = !1;
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    l === "(" ? (o = !0, n += l) : l === ")" ? (o = !1, n += l) : l === "," && !o ? (t.push(n), n = "") : n += l;
  }
  return n = n.trim(), n && t.push(n), t;
}
function iq(e) {
  return /^var\(--.+\)$/.test(e);
}
var aq = (e, t) => e.startsWith("--") && typeof t == "string" && !iq(t), sq = (e, t) => {
  var n, o;
  if (t == null)
    return t;
  const a = (h) => {
    var v, g;
    return (g = (v = e.__cssMap) == null ? void 0 : v[h]) == null ? void 0 : g.varRef;
  }, l = (h) => {
    var v;
    return (v = a(h)) != null ? v : h;
  }, [u, f] = oq(t);
  return t = (o = (n = a(u)) != null ? n : l(f)) != null ? o : l(t), t;
};
function lq(e) {
  const { configs: t = {}, pseudos: n = {}, theme: o } = e, a = (l, u = !1) => {
    var f, h, v;
    const g = Ha(l, o), b = rq(g)(o);
    let S = {};
    for (let w in b) {
      const E = b[w];
      let T = Ha(E, o);
      w in n && (w = n[w]), aq(w, T) && (T = sq(o, T));
      let A = t[w];
      if (A === !0 && (A = { property: w }), Ei(T)) {
        S[w] = (f = S[w]) != null ? f : {}, S[w] = bs(
          {},
          S[w],
          a(T, !0)
        );
        continue;
      }
      let P = (v = (h = A == null ? void 0 : A.transform) == null ? void 0 : h.call(A, T, o, g)) != null ? v : T;
      P = A != null && A.processResult ? a(P, !0) : P;
      const _ = Ha(A == null ? void 0 : A.property, o);
      if (!u && (A != null && A.static)) {
        const D = Ha(A.static, o);
        S = bs({}, S, D);
      }
      if (_ && Array.isArray(_)) {
        for (const D of _)
          S[D] = P;
        continue;
      }
      if (_) {
        _ === "&" && Ei(P) ? S = bs({}, S, P) : S[_] = P;
        continue;
      }
      if (Ei(P)) {
        S = bs({}, S, P);
        continue;
      }
      S[w] = P;
    }
    return S;
  };
  return a;
}
var x4 = (e) => (t) => lq({
  theme: t,
  pseudos: jE,
  configs: F_
})(e);
function dn(e) {
  return {
    definePartsStyle(t) {
      return t;
    },
    defineMultiStyleConfig(t) {
      return { parts: e, ...t };
    }
  };
}
function uq(e, t) {
  if (Array.isArray(e))
    return e;
  if (Ei(e))
    return t(e);
  if (e != null)
    return [e];
}
function cq(e, t) {
  for (let n = t + 1; n < e.length; n++)
    if (e[n] != null)
      return n;
  return -1;
}
function dq(e) {
  const t = e.__breakpoints;
  return function(o, a, l, u) {
    var f, h;
    if (!t)
      return;
    const v = {}, g = uq(l, t.toArrayValue);
    if (!g)
      return v;
    const b = g.length, S = b === 1, w = !!o.parts;
    for (let E = 0; E < b; E++) {
      const T = t.details[E], A = t.details[cq(g, E)], P = i0(T.minW, A == null ? void 0 : A._minW), _ = Ha((f = o[a]) == null ? void 0 : f[g[E]], u);
      if (_) {
        if (w) {
          (h = o.parts) == null || h.forEach((D) => {
            bs(v, {
              [D]: S ? _[D] : { [P]: _[D] }
            });
          });
          continue;
        }
        if (!w) {
          S ? bs(v, _) : v[P] = _;
          continue;
        }
        v[P] = _;
      }
    }
    return v;
  };
}
function fq(e) {
  return (t) => {
    var n;
    const { variant: o, size: a, theme: l } = t, u = dq(l);
    return bs(
      {},
      Ha((n = e.baseStyle) != null ? n : {}, t),
      u(e, "sizes", a, t),
      u(e, "variants", o, t)
    );
  };
}
function C4(e, t, n) {
  var o, a, l;
  return (l = (a = (o = e.__cssMap) == null ? void 0 : o[`${t}.${n}`]) == null ? void 0 : a.varRef) != null ? l : n;
}
function Pn(e) {
  return jK(e, ["styleConfig", "size", "variant", "colorScheme"]);
}
var pq = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function hq(e) {
  return Ei(e) ? pq.every(
    (t) => Object.prototype.hasOwnProperty.call(e, t)
  ) : !1;
}
var mq = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
}, vq = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
}, gq = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
}, yq = {
  property: mq,
  easing: vq,
  duration: gq
}, bq = yq, Sq = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
}, xq = Sq, Cq = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
}, wq = Cq, Eq = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
}, Tq = Eq, Iq = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
}, Aq = Iq, kq = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
}, Rq = kq, Pq = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
}, Oq = Pq, _q = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
}, Dq = _q, Nq = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    3: ".75rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
}, w4 = Nq, E4 = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
}, Mq = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
}, Lq = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
}, Fq = {
  ...E4,
  ...Mq,
  container: Lq
}, T4 = Fq, Bq = {
  breakpoints: Tq,
  zIndices: xq,
  radii: Rq,
  blur: Dq,
  colors: Aq,
  ...w4,
  sizes: T4,
  shadows: Oq,
  space: E4,
  borders: wq,
  transition: bq
}, { defineMultiStyleConfig: Vq, definePartsStyle: a0 } = dn([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]), Cc = Pt("stepper-indicator-size"), Rv = Pt("stepper-icon-size"), Pv = Pt("stepper-title-font-size"), s0 = Pt("stepper-description-font-size"), Wb = Pt("stepper-accent-color"), $q = a0(({ colorScheme: e }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [Wb.variable]: `colors.${e}.500`,
    _dark: {
      [Wb.variable]: `colors.${e}.200`
    }
  },
  title: {
    fontSize: Pv.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: s0.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: Pv.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: Rv.reference,
    height: Rv.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: Cc.reference,
    height: Cc.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: Wb.reference
    },
    "&[data-status=complete]": {
      bg: Wb.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: Wb.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${Cc.reference} - 8px)`,
      top: `calc(${Cc.reference} + 4px)`,
      insetStart: `calc(${Cc.reference} / 2 - 1px)`
    }
  }
})), zq = Vq({
  baseStyle: $q,
  sizes: {
    xs: a0({
      stepper: {
        [Cc.variable]: "sizes.4",
        [Rv.variable]: "sizes.3",
        [Pv.variable]: "fontSizes.xs",
        [s0.variable]: "fontSizes.xs"
      }
    }),
    sm: a0({
      stepper: {
        [Cc.variable]: "sizes.6",
        [Rv.variable]: "sizes.4",
        [Pv.variable]: "fontSizes.sm",
        [s0.variable]: "fontSizes.xs"
      }
    }),
    md: a0({
      stepper: {
        [Cc.variable]: "sizes.8",
        [Rv.variable]: "sizes.5",
        [Pv.variable]: "fontSizes.md",
        [s0.variable]: "fontSizes.sm"
      }
    }),
    lg: a0({
      stepper: {
        [Cc.variable]: "sizes.10",
        [Rv.variable]: "sizes.6",
        [Pv.variable]: "fontSizes.lg",
        [s0.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
function Un(e, t = {}) {
  let n = !1;
  function o() {
    if (!n) {
      n = !0;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function a(...g) {
    o();
    for (const b of g)
      t[b] = h(b);
    return Un(e, t);
  }
  function l(...g) {
    for (const b of g)
      b in t || (t[b] = h(b));
    return Un(e, t);
  }
  function u() {
    return Object.fromEntries(
      Object.entries(t).map(([b, S]) => [b, S.selector])
    );
  }
  function f() {
    return Object.fromEntries(
      Object.entries(t).map(([b, S]) => [b, S.className])
    );
  }
  function h(g) {
    const w = `chakra-${(["container", "root"].includes(g ?? "") ? [e] : [e, g]).filter(Boolean).join("__")}`;
    return {
      className: w,
      selector: `.${w}`,
      toString: () => g
    };
  }
  return {
    parts: a,
    toPart: h,
    extend: l,
    selectors: u,
    classnames: f,
    get keys() {
      return Object.keys(t);
    },
    __type: {}
  };
}
var I4 = Un("accordion").parts("root", "container", "button", "panel").extend("icon"), Hq = Un("alert").parts("title", "description", "container").extend("icon", "spinner"), jq = Un("avatar").parts("label", "badge", "container").extend("excessLabel", "group"), Gq = Un("breadcrumb").parts("link", "item", "container").extend("separator");
Un("button").parts();
var A4 = Un("checkbox").parts("control", "icon", "container").extend("label");
Un("progress").parts("track", "filledTrack").extend("label");
var Wq = Un("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"), k4 = Un("editable").parts(
  "preview",
  "input",
  "textarea"
), R4 = Un("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
), P4 = Un("formError").parts("text", "icon"), O4 = Un("input").parts(
  "addon",
  "field",
  "element",
  "group"
), Uq = Un("list").parts("container", "item", "icon"), _4 = Un("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider"), D4 = Un("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"), N4 = Un("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
Un("pininput").parts("field");
var M4 = Un("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton"), L4 = Un("progress").parts(
  "label",
  "filledTrack",
  "track"
), Xq = Un("radio").parts(
  "container",
  "control",
  "label"
), Zq = Un("select").parts("field", "icon"), F4 = Un("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
), Yq = Un("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
), B4 = Un("switch").parts(
  "container",
  "track",
  "thumb",
  "label"
), Jq = Un("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
), V4 = Un("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
), Qq = Un("tag").parts(
  "container",
  "label",
  "closeButton"
), $4 = Un("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
Un("stepper").parts(
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
);
function Yp(e, t, n) {
  return Math.min(Math.max(e, n), t);
}
class Kq extends Error {
  constructor(t) {
    super(`Failed to parse color: "${t}"`);
  }
}
var l0 = Kq;
function B_(e) {
  if (typeof e != "string")
    throw new l0(e);
  if (e.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let t = e.trim();
  t = aee.test(e) ? tee(e) : e;
  const n = nee.exec(t);
  if (n) {
    const u = Array.from(n).slice(1);
    return [...u.slice(0, 3).map((f) => parseInt(H0(f, 2), 16)), parseInt(H0(u[3] || "f", 2), 16) / 255];
  }
  const o = ree.exec(t);
  if (o) {
    const u = Array.from(o).slice(1);
    return [...u.slice(0, 3).map((f) => parseInt(f, 16)), parseInt(u[3] || "ff", 16) / 255];
  }
  const a = oee.exec(t);
  if (a) {
    const u = Array.from(a).slice(1);
    return [...u.slice(0, 3).map((f) => parseInt(f, 10)), parseFloat(u[3] || "1")];
  }
  const l = iee.exec(t);
  if (l) {
    const [u, f, h, v] = Array.from(l).slice(1).map(parseFloat);
    if (Yp(0, 100, f) !== f)
      throw new l0(e);
    if (Yp(0, 100, h) !== h)
      throw new l0(e);
    return [...see(u, f, h), Number.isNaN(v) ? 1 : v];
  }
  throw new l0(e);
}
function qq(e) {
  let t = 5381, n = e.length;
  for (; n; )
    t = t * 33 ^ e.charCodeAt(--n);
  return (t >>> 0) % 2341;
}
const sB = (e) => parseInt(e.replace(/_/g, ""), 36), eee = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((e, t) => {
  const n = sB(t.substring(0, 3)), o = sB(t.substring(3)).toString(16);
  let a = "";
  for (let l = 0; l < 6 - o.length; l++)
    a += "0";
  return e[n] = `${a}${o}`, e;
}, {});
function tee(e) {
  const t = e.toLowerCase().trim(), n = eee[qq(t)];
  if (!n)
    throw new l0(e);
  return `#${n}`;
}
const H0 = (e, t) => Array.from(Array(t)).map(() => e).join(""), nee = new RegExp(`^#${H0("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), ree = new RegExp(`^#${H0("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), oee = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${H0(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), iee = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, aee = /^[a-z]+$/i, lB = (e) => Math.round(e * 255), see = (e, t, n) => {
  let o = n / 100;
  if (t === 0)
    return [o, o, o].map(lB);
  const a = (e % 360 + 360) % 360 / 60, l = (1 - Math.abs(2 * o - 1)) * (t / 100), u = l * (1 - Math.abs(a % 2 - 1));
  let f = 0, h = 0, v = 0;
  a >= 0 && a < 1 ? (f = l, h = u) : a >= 1 && a < 2 ? (f = u, h = l) : a >= 2 && a < 3 ? (h = l, v = u) : a >= 3 && a < 4 ? (h = u, v = l) : a >= 4 && a < 5 ? (f = u, v = l) : a >= 5 && a < 6 && (f = l, v = u);
  const g = o - l / 2, b = f + g, S = h + g, w = v + g;
  return [b, S, w].map(lB);
};
function lee(e, t, n, o) {
  return `rgba(${Yp(0, 255, e).toFixed()}, ${Yp(0, 255, t).toFixed()}, ${Yp(0, 255, n).toFixed()}, ${parseFloat(Yp(0, 1, o).toFixed(3))})`;
}
function uee(e, t) {
  const [n, o, a, l] = B_(e);
  return lee(n, o, a, l - t);
}
function cee(e) {
  const [t, n, o, a] = B_(e);
  let l = (u) => {
    const f = Yp(0, 255, u).toString(16);
    return f.length === 1 ? `0${f}` : f;
  };
  return `#${l(t)}${l(n)}${l(o)}${a < 1 ? l(Math.round(a * 255)) : ""}`;
}
function dee(e, t, n, o, a) {
  for (t = t.split ? t.split(".") : t, o = 0; o < t.length; o++)
    e = e ? e[t[o]] : a;
  return e === a ? n : e;
}
var fee = (e) => Object.keys(e).length === 0, zi = (e, t, n) => {
  const o = dee(e, `colors.${t}`, t);
  try {
    return cee(o), o;
  } catch {
    return n ?? "#000000";
  }
}, pee = (e, t, n) => {
  var o;
  return (o = C4(e, "colors", t)) != null ? o : n;
}, hee = (e) => {
  const [t, n, o] = B_(e);
  return (t * 299 + n * 587 + o * 114) / 1e3;
}, mee = (e) => (t) => {
  const n = zi(t, e);
  return hee(n) < 128 ? "dark" : "light";
}, vee = (e) => (t) => mee(e)(t) === "dark", sg = (e, t) => (n) => {
  const o = zi(n, e);
  return uee(o, 1 - t);
};
function WP(e = "1rem", t = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${t} 25%,
    transparent 25%,
    transparent 50%,
    ${t} 50%,
    ${t} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${e} ${e}`
  };
}
var gee = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function yee(e) {
  const t = gee();
  return !e || fee(e) ? t : e.string && e.colors ? See(e.string, e.colors) : e.string && !e.colors ? bee(e.string) : e.colors && !e.string ? xee(e.colors) : t;
}
function bee(e) {
  let t = 0;
  if (e.length === 0)
    return t.toString();
  for (let o = 0; o < e.length; o += 1)
    t = e.charCodeAt(o) + ((t << 5) - t), t = t & t;
  let n = "#";
  for (let o = 0; o < 3; o += 1) {
    const a = t >> o * 8 & 255;
    n += `00${a.toString(16)}`.substr(-2);
  }
  return n;
}
function See(e, t) {
  let n = 0;
  if (e.length === 0)
    return t[0];
  for (let o = 0; o < e.length; o += 1)
    n = e.charCodeAt(o) + ((n << 5) - n), n = n & n;
  return n = (n % t.length + t.length) % t.length, t[n];
}
function xee(e) {
  return e[Math.floor(Math.random() * e.length)];
}
function Vt(e, t) {
  return (n) => n.colorMode === "dark" ? t : e;
}
function V_(e) {
  const { orientation: t, vertical: n, horizontal: o } = e;
  return t ? t === "vertical" ? n : o : {};
}
function z4(e) {
  return Ei(e) && e.reference ? e.reference : String(e);
}
var GE = (e, ...t) => t.map(z4).join(` ${e} `).replace(/calc/g, ""), uB = (...e) => `calc(${GE("+", ...e)})`, cB = (...e) => `calc(${GE("-", ...e)})`, UP = (...e) => `calc(${GE("*", ...e)})`, dB = (...e) => `calc(${GE("/", ...e)})`, fB = (e) => {
  const t = z4(e);
  return t != null && !Number.isNaN(parseFloat(t)) ? String(t).startsWith("-") ? String(t).slice(1) : `-${t}` : UP(t, -1);
}, wc = Object.assign(
  (e) => ({
    add: (...t) => wc(uB(e, ...t)),
    subtract: (...t) => wc(cB(e, ...t)),
    multiply: (...t) => wc(UP(e, ...t)),
    divide: (...t) => wc(dB(e, ...t)),
    negate: () => wc(fB(e)),
    toString: () => e.toString()
  }),
  {
    add: uB,
    subtract: cB,
    multiply: UP,
    divide: dB,
    negate: fB
  }
);
function Cee(e) {
  return !Number.isInteger(parseFloat(e.toString()));
}
function wee(e, t = "-") {
  return e.replace(/\s+/g, t);
}
function H4(e) {
  const t = wee(e.toString());
  return t.includes("\\.") ? e : Cee(e) ? t.replace(".", "\\.") : e;
}
function Eee(e, t = "") {
  return [t, H4(e)].filter(Boolean).join("-");
}
function Tee(e, t) {
  return `var(${H4(e)}${t ? `, ${t}` : ""})`;
}
function Iee(e, t = "") {
  return `--${Eee(e, t)}`;
}
function Dr(e, t) {
  const n = Iee(e, t == null ? void 0 : t.prefix);
  return {
    variable: n,
    reference: Tee(n, Aee(t == null ? void 0 : t.fallback))
  };
}
function Aee(e) {
  return typeof e == "string" ? e : e == null ? void 0 : e.reference;
}
var { defineMultiStyleConfig: kee, definePartsStyle: rw } = dn(B4.keys), b0 = Dr("switch-track-width"), Kp = Dr("switch-track-height"), pR = Dr("switch-track-diff"), Ree = wc.subtract(b0, Kp), XP = Dr("switch-thumb-x"), Ub = Dr("switch-bg"), Pee = (e) => {
  const { colorScheme: t } = e;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [b0.reference],
    height: [Kp.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [Ub.variable]: "colors.gray.300",
    _dark: {
      [Ub.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [Ub.variable]: `colors.${t}.500`,
      _dark: {
        [Ub.variable]: `colors.${t}.200`
      }
    },
    bg: Ub.reference
  };
}, Oee = {
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [Kp.reference],
  height: [Kp.reference],
  _checked: {
    transform: `translateX(${XP.reference})`
  }
}, _ee = rw((e) => ({
  container: {
    [pR.variable]: Ree,
    [XP.variable]: pR.reference,
    _rtl: {
      [XP.variable]: wc(pR).negate().toString()
    }
  },
  track: Pee(e),
  thumb: Oee
})), Dee = {
  sm: rw({
    container: {
      [b0.variable]: "1.375rem",
      [Kp.variable]: "sizes.3"
    }
  }),
  md: rw({
    container: {
      [b0.variable]: "1.875rem",
      [Kp.variable]: "sizes.4"
    }
  }),
  lg: rw({
    container: {
      [b0.variable]: "2.875rem",
      [Kp.variable]: "sizes.6"
    }
  })
}, Nee = kee({
  baseStyle: _ee,
  sizes: Dee,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: Mee, definePartsStyle: Gv } = dn(Jq.keys), Lee = Gv({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
}), Fw = {
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
}, Fee = Gv((e) => {
  const { colorScheme: t } = e;
  return {
    th: {
      color: Vt("gray.600", "gray.400")(e),
      borderBottom: "1px",
      borderColor: Vt(`${t}.100`, `${t}.700`)(e),
      ...Fw
    },
    td: {
      borderBottom: "1px",
      borderColor: Vt(`${t}.100`, `${t}.700`)(e),
      ...Fw
    },
    caption: {
      color: Vt("gray.600", "gray.100")(e)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), Bee = Gv((e) => {
  const { colorScheme: t } = e;
  return {
    th: {
      color: Vt("gray.600", "gray.400")(e),
      borderBottom: "1px",
      borderColor: Vt(`${t}.100`, `${t}.700`)(e),
      ...Fw
    },
    td: {
      borderBottom: "1px",
      borderColor: Vt(`${t}.100`, `${t}.700`)(e),
      ...Fw
    },
    caption: {
      color: Vt("gray.600", "gray.100")(e)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: Vt(`${t}.100`, `${t}.700`)(e)
          },
          td: {
            background: Vt(`${t}.100`, `${t}.700`)(e)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), Vee = {
  simple: Fee,
  striped: Bee,
  unstyled: {}
}, $ee = {
  sm: Gv({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: Gv({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: Gv({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
}, zee = Mee({
  baseStyle: Lee,
  variants: Vee,
  sizes: $ee,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
}), ma = Pt("tabs-color"), vl = Pt("tabs-bg"), wC = Pt("tabs-border-color"), { defineMultiStyleConfig: Hee, definePartsStyle: hu } = dn(V4.keys), jee = (e) => {
  const { orientation: t } = e;
  return {
    display: t === "vertical" ? "flex" : "block"
  };
}, Gee = (e) => {
  const { isFitted: t } = e;
  return {
    flex: t ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
}, Wee = (e) => {
  const { align: t = "start", orientation: n } = e;
  return {
    justifyContent: {
      end: "flex-end",
      center: "center",
      start: "flex-start"
    }[t],
    flexDirection: n === "vertical" ? "column" : "row"
  };
}, Uee = {
  p: 4
}, Xee = hu((e) => ({
  root: jee(e),
  tab: Gee(e),
  tablist: Wee(e),
  tabpanel: Uee
})), Zee = {
  sm: hu({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: hu({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: hu({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
}, Yee = hu((e) => {
  const { colorScheme: t, orientation: n } = e, o = n === "vertical", a = o ? "borderStart" : "borderBottom", l = o ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [a]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [a]: "2px solid",
      borderColor: "transparent",
      [l]: "-2px",
      _selected: {
        [ma.variable]: `colors.${t}.600`,
        _dark: {
          [ma.variable]: `colors.${t}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [vl.variable]: "colors.gray.200",
        _dark: {
          [vl.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: ma.reference,
      bg: vl.reference
    }
  };
}), Jee = hu((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [wC.variable]: "transparent",
      _selected: {
        [ma.variable]: `colors.${t}.600`,
        [wC.variable]: "colors.white",
        _dark: {
          [ma.variable]: `colors.${t}.300`,
          [wC.variable]: "colors.gray.800"
        },
        borderColor: "inherit",
        borderBottomColor: wC.reference
      },
      color: ma.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), Qee = hu((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [vl.variable]: "colors.gray.50",
      _dark: {
        [vl.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [vl.variable]: "colors.white",
        [ma.variable]: `colors.${t}.600`,
        _dark: {
          [vl.variable]: "colors.gray.800",
          [ma.variable]: `colors.${t}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: ma.reference,
      bg: vl.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), Kee = hu((e) => {
  const { colorScheme: t, theme: n } = e;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: zi(n, `${t}.700`),
        bg: zi(n, `${t}.100`)
      }
    }
  };
}), qee = hu((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [ma.variable]: "colors.gray.600",
      _dark: {
        [ma.variable]: "inherit"
      },
      _selected: {
        [ma.variable]: "colors.white",
        [vl.variable]: `colors.${t}.600`,
        _dark: {
          [ma.variable]: "colors.gray.800",
          [vl.variable]: `colors.${t}.300`
        }
      },
      color: ma.reference,
      bg: vl.reference
    }
  };
}), ete = hu({}), tte = {
  line: Yee,
  enclosed: Jee,
  "enclosed-colored": Qee,
  "soft-rounded": Kee,
  "solid-rounded": qee,
  unstyled: ete
}, nte = Hee({
  baseStyle: Xee,
  sizes: Zee,
  variants: tte,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
}), Kr = FK("badge", ["bg", "color", "shadow"]), rte = {
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: Kr.bg.reference,
  color: Kr.color.reference,
  boxShadow: Kr.shadow.reference
}, ote = (e) => {
  const { colorScheme: t, theme: n } = e, o = sg(`${t}.500`, 0.6)(n);
  return {
    [Kr.bg.variable]: `colors.${t}.500`,
    [Kr.color.variable]: "colors.white",
    _dark: {
      [Kr.bg.variable]: o,
      [Kr.color.variable]: "colors.whiteAlpha.800"
    }
  };
}, ite = (e) => {
  const { colorScheme: t, theme: n } = e, o = sg(`${t}.200`, 0.16)(n);
  return {
    [Kr.bg.variable]: `colors.${t}.100`,
    [Kr.color.variable]: `colors.${t}.800`,
    _dark: {
      [Kr.bg.variable]: o,
      [Kr.color.variable]: `colors.${t}.200`
    }
  };
}, ate = (e) => {
  const { colorScheme: t, theme: n } = e, o = sg(`${t}.200`, 0.8)(n);
  return {
    [Kr.color.variable]: `colors.${t}.500`,
    _dark: {
      [Kr.color.variable]: o
    },
    [Kr.shadow.variable]: `inset 0 0 0px 1px ${Kr.color.reference}`
  };
}, ste = {
  solid: ote,
  subtle: ite,
  outline: ate
}, S0 = {
  baseStyle: rte,
  variants: ste,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
}, { defineMultiStyleConfig: lte, definePartsStyle: qp } = dn(Qq.keys), pB = Pt("tag-bg"), hB = Pt("tag-color"), hR = Pt("tag-shadow"), ow = Pt("tag-min-height"), iw = Pt("tag-min-width"), aw = Pt("tag-font-size"), sw = Pt("tag-padding-inline"), ute = {
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [hB.variable]: Kr.color.reference,
  [pB.variable]: Kr.bg.reference,
  [hR.variable]: Kr.shadow.reference,
  color: hB.reference,
  bg: pB.reference,
  boxShadow: hR.reference,
  borderRadius: "md",
  minH: ow.reference,
  minW: iw.reference,
  fontSize: aw.reference,
  px: sw.reference,
  _focusVisible: {
    [hR.variable]: "shadows.outline"
  }
}, cte = {
  lineHeight: 1.2,
  overflow: "visible"
}, dte = {
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
}, fte = qp({
  container: ute,
  label: cte,
  closeButton: dte
}), pte = {
  sm: qp({
    container: {
      [ow.variable]: "sizes.5",
      [iw.variable]: "sizes.5",
      [aw.variable]: "fontSizes.xs",
      [sw.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: qp({
    container: {
      [ow.variable]: "sizes.6",
      [iw.variable]: "sizes.6",
      [aw.variable]: "fontSizes.sm",
      [sw.variable]: "space.2"
    }
  }),
  lg: qp({
    container: {
      [ow.variable]: "sizes.8",
      [iw.variable]: "sizes.8",
      [aw.variable]: "fontSizes.md",
      [sw.variable]: "space.3"
    }
  })
}, hte = {
  subtle: qp((e) => {
    var t;
    return {
      container: (t = S0.variants) == null ? void 0 : t.subtle(e)
    };
  }),
  solid: qp((e) => {
    var t;
    return {
      container: (t = S0.variants) == null ? void 0 : t.solid(e)
    };
  }),
  outline: qp((e) => {
    var t;
    return {
      container: (t = S0.variants) == null ? void 0 : t.outline(e)
    };
  })
}, mte = lte({
  variants: hte,
  baseStyle: fte,
  sizes: pte,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
}), { definePartsStyle: Ec, defineMultiStyleConfig: vte } = dn(O4.keys), Ov = Pt("input-height"), _v = Pt("input-font-size"), Dv = Pt("input-padding"), Nv = Pt("input-border-radius"), gte = Ec({
  addon: {
    height: Ov.reference,
    fontSize: _v.reference,
    px: Dv.reference,
    borderRadius: Nv.reference
  },
  field: {
    width: "100%",
    height: Ov.reference,
    fontSize: _v.reference,
    px: Dv.reference,
    borderRadius: Nv.reference,
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
}), Qd = {
  lg: {
    [_v.variable]: "fontSizes.lg",
    [Dv.variable]: "space.4",
    [Nv.variable]: "radii.md",
    [Ov.variable]: "sizes.12"
  },
  md: {
    [_v.variable]: "fontSizes.md",
    [Dv.variable]: "space.4",
    [Nv.variable]: "radii.md",
    [Ov.variable]: "sizes.10"
  },
  sm: {
    [_v.variable]: "fontSizes.sm",
    [Dv.variable]: "space.3",
    [Nv.variable]: "radii.sm",
    [Ov.variable]: "sizes.8"
  },
  xs: {
    [_v.variable]: "fontSizes.xs",
    [Dv.variable]: "space.2",
    [Nv.variable]: "radii.sm",
    [Ov.variable]: "sizes.6"
  }
}, yte = {
  lg: Ec({
    field: Qd.lg,
    group: Qd.lg
  }),
  md: Ec({
    field: Qd.md,
    group: Qd.md
  }),
  sm: Ec({
    field: Qd.sm,
    group: Qd.sm
  }),
  xs: Ec({
    field: Qd.xs,
    group: Qd.xs
  })
};
function $_(e) {
  const { focusBorderColor: t, errorBorderColor: n } = e;
  return {
    focusBorderColor: t || Vt("blue.500", "blue.300")(e),
    errorBorderColor: n || Vt("red.500", "red.300")(e)
  };
}
var bte = Ec((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: o } = $_(e);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: Vt("gray.300", "whiteAlpha.400")(e)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: zi(t, o),
        boxShadow: `0 0 0 1px ${zi(t, o)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: zi(t, n),
        boxShadow: `0 0 0 1px ${zi(t, n)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: Vt("inherit", "whiteAlpha.50")(e),
      bg: Vt("gray.100", "whiteAlpha.300")(e)
    }
  };
}), Ste = Ec((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: o } = $_(e);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Vt("gray.100", "whiteAlpha.50")(e),
      _hover: {
        bg: Vt("gray.200", "whiteAlpha.100")(e)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: zi(t, o)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: zi(t, n)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Vt("gray.100", "whiteAlpha.50")(e)
    }
  };
}), xte = Ec((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: o } = $_(e);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: zi(t, o),
        boxShadow: `0px 1px 0px 0px ${zi(t, o)}`
      },
      _focusVisible: {
        borderColor: zi(t, n),
        boxShadow: `0px 1px 0px 0px ${zi(t, n)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
}), Cte = Ec({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
}), wte = {
  outline: bte,
  filled: Ste,
  flushed: xte,
  unstyled: Cte
}, Gn = vte({
  baseStyle: gte,
  sizes: yte,
  variants: wte,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}), mB, Ete = {
  ...(mB = Gn.baseStyle) == null ? void 0 : mB.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
}, vB, gB, Tte = {
  outline: (e) => {
    var t, n;
    return (n = (t = Gn.variants) == null ? void 0 : t.outline(e).field) != null ? n : {};
  },
  flushed: (e) => {
    var t, n;
    return (n = (t = Gn.variants) == null ? void 0 : t.flushed(e).field) != null ? n : {};
  },
  filled: (e) => {
    var t, n;
    return (n = (t = Gn.variants) == null ? void 0 : t.filled(e).field) != null ? n : {};
  },
  unstyled: (gB = (vB = Gn.variants) == null ? void 0 : vB.unstyled.field) != null ? gB : {}
}, yB, bB, SB, xB, CB, wB, EB, TB, Ite = {
  xs: (bB = (yB = Gn.sizes) == null ? void 0 : yB.xs.field) != null ? bB : {},
  sm: (xB = (SB = Gn.sizes) == null ? void 0 : SB.sm.field) != null ? xB : {},
  md: (wB = (CB = Gn.sizes) == null ? void 0 : CB.md.field) != null ? wB : {},
  lg: (TB = (EB = Gn.sizes) == null ? void 0 : EB.lg.field) != null ? TB : {}
}, Ate = {
  baseStyle: Ete,
  sizes: Ite,
  variants: Tte,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}, EC = Dr("tooltip-bg"), mR = Dr("tooltip-fg"), kte = Dr("popper-arrow-bg"), Rte = {
  bg: EC.reference,
  color: mR.reference,
  [EC.variable]: "colors.gray.700",
  [mR.variable]: "colors.whiteAlpha.900",
  _dark: {
    [EC.variable]: "colors.gray.300",
    [mR.variable]: "colors.gray.900"
  },
  [kte.variable]: EC.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
}, Pte = {
  baseStyle: Rte
}, { defineMultiStyleConfig: Ote, definePartsStyle: u0 } = dn(L4.keys), _te = (e) => {
  const { colorScheme: t, theme: n, isIndeterminate: o, hasStripe: a } = e, l = Vt(
    WP(),
    WP("1rem", "rgba(0,0,0,0.1)")
  )(e), u = Vt(`${t}.500`, `${t}.200`)(e), f = `linear-gradient(
    to right,
    transparent 0%,
    ${zi(n, u)} 50%,
    transparent 100%
  )`;
  return {
    ...!o && a && l,
    ...o ? { bgImage: f } : { bgColor: u }
  };
}, Dte = {
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
}, Nte = (e) => ({
  bg: Vt("gray.100", "whiteAlpha.300")(e)
}), Mte = (e) => ({
  transitionProperty: "common",
  transitionDuration: "slow",
  ..._te(e)
}), Lte = u0((e) => ({
  label: Dte,
  filledTrack: Mte(e),
  track: Nte(e)
})), Fte = {
  xs: u0({
    track: { h: "1" }
  }),
  sm: u0({
    track: { h: "2" }
  }),
  md: u0({
    track: { h: "3" }
  }),
  lg: u0({
    track: { h: "4" }
  })
}, Bte = Ote({
  sizes: Fte,
  baseStyle: Lte,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), Vte = (e) => typeof e == "function";
function Hi(e, ...t) {
  return Vte(e) ? e(...t) : e;
}
var { definePartsStyle: lw, defineMultiStyleConfig: $te } = dn(A4.keys), x0 = Pt("checkbox-size"), zte = (e) => {
  const { colorScheme: t } = e;
  return {
    w: x0.reference,
    h: x0.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: Vt(`${t}.500`, `${t}.200`)(e),
      borderColor: Vt(`${t}.500`, `${t}.200`)(e),
      color: Vt("white", "gray.900")(e),
      _hover: {
        bg: Vt(`${t}.600`, `${t}.300`)(e),
        borderColor: Vt(`${t}.600`, `${t}.300`)(e)
      },
      _disabled: {
        borderColor: Vt("gray.200", "transparent")(e),
        bg: Vt("gray.200", "whiteAlpha.300")(e),
        color: Vt("gray.500", "whiteAlpha.500")(e)
      }
    },
    _indeterminate: {
      bg: Vt(`${t}.500`, `${t}.200`)(e),
      borderColor: Vt(`${t}.500`, `${t}.200`)(e),
      color: Vt("white", "gray.900")(e)
    },
    _disabled: {
      bg: Vt("gray.100", "whiteAlpha.100")(e),
      borderColor: Vt("gray.100", "transparent")(e)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: Vt("red.500", "red.300")(e)
    }
  };
}, Hte = {
  _disabled: { cursor: "not-allowed" }
}, jte = {
  userSelect: "none",
  _disabled: { opacity: 0.4 }
}, Gte = {
  transitionProperty: "transform",
  transitionDuration: "normal"
}, Wte = lw((e) => ({
  icon: Gte,
  container: Hte,
  control: Hi(zte, e),
  label: jte
})), Ute = {
  sm: lw({
    control: { [x0.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: lw({
    control: { [x0.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: lw({
    control: { [x0.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
}, Bw = $te({
  baseStyle: Wte,
  sizes: Ute,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: Xte, definePartsStyle: uw } = dn(Xq.keys), Zte = (e) => {
  var t;
  const n = (t = Hi(Bw.baseStyle, e)) == null ? void 0 : t.control;
  return {
    ...n,
    borderRadius: "full",
    _checked: {
      ...n == null ? void 0 : n._checked,
      _before: {
        content: '""',
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
}, Yte = uw((e) => {
  var t, n, o, a;
  return {
    label: (n = (t = Bw).baseStyle) == null ? void 0 : n.call(t, e).label,
    container: (a = (o = Bw).baseStyle) == null ? void 0 : a.call(o, e).container,
    control: Zte(e)
  };
}), Jte = {
  md: uw({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: uw({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: uw({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
}, Qte = Xte({
  baseStyle: Yte,
  sizes: Jte,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: Kte, definePartsStyle: qte } = dn(Zq.keys), TC = Pt("select-bg"), IB, ene = {
  ...(IB = Gn.baseStyle) == null ? void 0 : IB.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: TC.reference,
  [TC.variable]: "colors.white",
  _dark: {
    [TC.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: TC.reference
  }
}, tne = {
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
}, nne = qte({
  field: ene,
  icon: tne
}), IC = {
  paddingInlineEnd: "8"
}, AB, kB, RB, PB, OB, _B, DB, NB, rne = {
  lg: {
    ...(AB = Gn.sizes) == null ? void 0 : AB.lg,
    field: {
      ...(kB = Gn.sizes) == null ? void 0 : kB.lg.field,
      ...IC
    }
  },
  md: {
    ...(RB = Gn.sizes) == null ? void 0 : RB.md,
    field: {
      ...(PB = Gn.sizes) == null ? void 0 : PB.md.field,
      ...IC
    }
  },
  sm: {
    ...(OB = Gn.sizes) == null ? void 0 : OB.sm,
    field: {
      ...(_B = Gn.sizes) == null ? void 0 : _B.sm.field,
      ...IC
    }
  },
  xs: {
    ...(DB = Gn.sizes) == null ? void 0 : DB.xs,
    field: {
      ...(NB = Gn.sizes) == null ? void 0 : NB.xs.field,
      ...IC
    },
    icon: {
      insetEnd: "1"
    }
  }
}, one = Kte({
  baseStyle: nne,
  sizes: rne,
  variants: Gn.variants,
  defaultProps: Gn.defaultProps
}), vR = Pt("skeleton-start-color"), gR = Pt("skeleton-end-color"), ine = {
  [vR.variable]: "colors.gray.100",
  [gR.variable]: "colors.gray.400",
  _dark: {
    [vR.variable]: "colors.gray.800",
    [gR.variable]: "colors.gray.600"
  },
  background: vR.reference,
  borderColor: gR.reference,
  opacity: 0.7,
  borderRadius: "sm"
}, ane = {
  baseStyle: ine
}, yR = Pt("skip-link-bg"), sne = {
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [yR.variable]: "colors.white",
    _dark: {
      [yR.variable]: "colors.gray.700"
    },
    bg: yR.reference
  }
}, lne = {
  baseStyle: sne
}, { defineMultiStyleConfig: une, definePartsStyle: WE } = dn(F4.keys), j0 = Pt("slider-thumb-size"), G0 = Pt("slider-track-size"), af = Pt("slider-bg"), cne = (e) => {
  const { orientation: t } = e;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...V_({
      orientation: t,
      vertical: { h: "100%" },
      horizontal: { w: "100%" }
    })
  };
}, dne = (e) => ({
  ...V_({
    orientation: e.orientation,
    horizontal: { h: G0.reference },
    vertical: { w: G0.reference }
  }),
  overflow: "hidden",
  borderRadius: "sm",
  [af.variable]: "colors.gray.200",
  _dark: {
    [af.variable]: "colors.whiteAlpha.200"
  },
  _disabled: {
    [af.variable]: "colors.gray.300",
    _dark: {
      [af.variable]: "colors.whiteAlpha.300"
    }
  },
  bg: af.reference
}), fne = (e) => {
  const { orientation: t } = e;
  return {
    ...V_({
      orientation: t,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        _active: {
          transform: "translateX(-50%) scale(1.15)"
        }
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        _active: {
          transform: "translateY(-50%) scale(1.15)"
        }
      }
    }),
    w: j0.reference,
    h: j0.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
}, pne = (e) => {
  const { colorScheme: t } = e;
  return {
    width: "inherit",
    height: "inherit",
    [af.variable]: `colors.${t}.500`,
    _dark: {
      [af.variable]: `colors.${t}.200`
    },
    bg: af.reference
  };
}, hne = WE((e) => ({
  container: cne(e),
  track: dne(e),
  thumb: fne(e),
  filledTrack: pne(e)
})), mne = WE({
  container: {
    [j0.variable]: "sizes.4",
    [G0.variable]: "sizes.1"
  }
}), vne = WE({
  container: {
    [j0.variable]: "sizes.3.5",
    [G0.variable]: "sizes.1"
  }
}), gne = WE({
  container: {
    [j0.variable]: "sizes.2.5",
    [G0.variable]: "sizes.0.5"
  }
}), yne = {
  lg: mne,
  md: vne,
  sm: gne
}, bne = une({
  baseStyle: hne,
  sizes: yne,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), Xp = Dr("spinner-size"), Sne = {
  width: [Xp.reference],
  height: [Xp.reference]
}, xne = {
  xs: {
    [Xp.variable]: "sizes.3"
  },
  sm: {
    [Xp.variable]: "sizes.4"
  },
  md: {
    [Xp.variable]: "sizes.6"
  },
  lg: {
    [Xp.variable]: "sizes.8"
  },
  xl: {
    [Xp.variable]: "sizes.12"
  }
}, Cne = {
  baseStyle: Sne,
  sizes: xne,
  defaultProps: {
    size: "md"
  }
}, { defineMultiStyleConfig: wne, definePartsStyle: j4 } = dn(Yq.keys), Ene = {
  fontWeight: "medium"
}, Tne = {
  opacity: 0.8,
  marginBottom: "2"
}, Ine = {
  verticalAlign: "baseline",
  fontWeight: "semibold"
}, Ane = {
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
}, kne = j4({
  container: {},
  label: Ene,
  helpText: Tne,
  number: Ine,
  icon: Ane
}), Rne = {
  md: j4({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
}, Pne = wne({
  baseStyle: kne,
  sizes: Rne,
  defaultProps: {
    size: "md"
  }
}), bR = Pt("kbd-bg"), One = {
  [bR.variable]: "colors.gray.100",
  _dark: {
    [bR.variable]: "colors.whiteAlpha.100"
  },
  bg: bR.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
}, _ne = {
  baseStyle: One
}, Dne = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
}, Nne = {
  baseStyle: Dne
}, { defineMultiStyleConfig: Mne, definePartsStyle: Lne } = dn(Uq.keys), Fne = {
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
}, Bne = Lne({
  icon: Fne
}), Vne = Mne({
  baseStyle: Bne
}), { defineMultiStyleConfig: $ne, definePartsStyle: zne } = dn(_4.keys), su = Pt("menu-bg"), SR = Pt("menu-shadow"), Hne = {
  [su.variable]: "#fff",
  [SR.variable]: "shadows.sm",
  _dark: {
    [su.variable]: "colors.gray.700",
    [SR.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: su.reference,
  boxShadow: SR.reference
}, jne = {
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [su.variable]: "colors.gray.100",
    _dark: {
      [su.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [su.variable]: "colors.gray.200",
    _dark: {
      [su.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [su.variable]: "colors.gray.100",
    _dark: {
      [su.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: su.reference
}, Gne = {
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
}, Wne = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
}, Une = {
  opacity: 0.6
}, Xne = {
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
}, Zne = {
  transitionProperty: "common",
  transitionDuration: "normal"
}, Yne = zne({
  button: Zne,
  list: Hne,
  item: jne,
  groupTitle: Gne,
  icon: Wne,
  command: Une,
  divider: Xne
}), Jne = $ne({
  baseStyle: Yne
}), { defineMultiStyleConfig: Qne, definePartsStyle: ZP } = dn(D4.keys), xR = Pt("modal-bg"), CR = Pt("modal-shadow"), Kne = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, qne = (e) => {
  const { isCentered: t, scrollBehavior: n } = e;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: t ? "center" : "flex-start",
    overflow: n === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
}, ere = (e) => {
  const { isCentered: t, scrollBehavior: n } = e;
  return {
    borderRadius: "md",
    color: "inherit",
    my: t ? "auto" : "16",
    mx: t ? "auto" : void 0,
    zIndex: "modal",
    maxH: n === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [xR.variable]: "colors.white",
    [CR.variable]: "shadows.lg",
    _dark: {
      [xR.variable]: "colors.gray.700",
      [CR.variable]: "shadows.dark-lg"
    },
    bg: xR.reference,
    boxShadow: CR.reference
  };
}, tre = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, nre = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, rre = (e) => {
  const { scrollBehavior: t } = e;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: t === "inside" ? "auto" : void 0
  };
}, ore = {
  px: "6",
  py: "4"
}, ire = ZP((e) => ({
  overlay: Kne,
  dialogContainer: Hi(qne, e),
  dialog: Hi(ere, e),
  header: tre,
  closeButton: nre,
  body: Hi(rre, e),
  footer: ore
}));
function cl(e) {
  return ZP(e === "full" ? {
    dialog: {
      maxW: "100vw",
      minH: "$100vh",
      my: "0",
      borderRadius: "0"
    }
  } : {
    dialog: { maxW: e }
  });
}
var are = {
  xs: cl("xs"),
  sm: cl("sm"),
  md: cl("md"),
  lg: cl("lg"),
  xl: cl("xl"),
  "2xl": cl("2xl"),
  "3xl": cl("3xl"),
  "4xl": cl("4xl"),
  "5xl": cl("5xl"),
  "6xl": cl("6xl"),
  full: cl("full")
}, sre = Qne({
  baseStyle: ire,
  sizes: are,
  defaultProps: { size: "md" }
}), { defineMultiStyleConfig: lre, definePartsStyle: G4 } = dn(N4.keys), z_ = Dr("number-input-stepper-width"), W4 = Dr("number-input-input-padding"), ure = wc(z_).add("0.5rem").toString(), wR = Dr("number-input-bg"), ER = Dr("number-input-color"), TR = Dr("number-input-border-color"), cre = {
  [z_.variable]: "sizes.6",
  [W4.variable]: ure
}, dre = (e) => {
  var t, n;
  return (n = (t = Hi(Gn.baseStyle, e)) == null ? void 0 : t.field) != null ? n : {};
}, fre = {
  width: z_.reference
}, pre = {
  borderStart: "1px solid",
  borderStartColor: TR.reference,
  color: ER.reference,
  bg: wR.reference,
  [ER.variable]: "colors.chakra-body-text",
  [TR.variable]: "colors.chakra-border-color",
  _dark: {
    [ER.variable]: "colors.whiteAlpha.800",
    [TR.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [wR.variable]: "colors.gray.200",
    _dark: {
      [wR.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
}, hre = G4((e) => {
  var t;
  return {
    root: cre,
    field: (t = Hi(dre, e)) != null ? t : {},
    stepperGroup: fre,
    stepper: pre
  };
});
function AC(e) {
  var t, n, o;
  const a = (t = Gn.sizes) == null ? void 0 : t[e], l = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  }, u = (o = (n = a.field) == null ? void 0 : n.fontSize) != null ? o : "md", f = w4.fontSizes[u];
  return G4({
    field: {
      ...a.field,
      paddingInlineEnd: W4.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: wc(f).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: l[e]
      },
      _last: {
        borderBottomEndRadius: l[e],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var mre = {
  xs: AC("xs"),
  sm: AC("sm"),
  md: AC("md"),
  lg: AC("lg")
}, vre = lre({
  baseStyle: hre,
  sizes: mre,
  variants: Gn.variants,
  defaultProps: Gn.defaultProps
}), MB, gre = {
  ...(MB = Gn.baseStyle) == null ? void 0 : MB.field,
  textAlign: "center"
}, yre = {
  lg: {
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  },
  md: {
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  },
  sm: {
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  },
  xs: {
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  }
}, LB, FB, bre = {
  outline: (e) => {
    var t, n, o;
    return (o = (n = Hi((t = Gn.variants) == null ? void 0 : t.outline, e)) == null ? void 0 : n.field) != null ? o : {};
  },
  flushed: (e) => {
    var t, n, o;
    return (o = (n = Hi((t = Gn.variants) == null ? void 0 : t.flushed, e)) == null ? void 0 : n.field) != null ? o : {};
  },
  filled: (e) => {
    var t, n, o;
    return (o = (n = Hi((t = Gn.variants) == null ? void 0 : t.filled, e)) == null ? void 0 : n.field) != null ? o : {};
  },
  unstyled: (FB = (LB = Gn.variants) == null ? void 0 : LB.unstyled.field) != null ? FB : {}
}, Sre = {
  baseStyle: gre,
  sizes: yre,
  variants: bre,
  defaultProps: Gn.defaultProps
}, { defineMultiStyleConfig: xre, definePartsStyle: Cre } = dn(M4.keys), kC = Dr("popper-bg"), wre = Dr("popper-arrow-bg"), BB = Dr("popper-arrow-shadow-color"), Ere = { zIndex: 10 }, Tre = {
  [kC.variable]: "colors.white",
  bg: kC.reference,
  [wre.variable]: kC.reference,
  [BB.variable]: "colors.gray.200",
  _dark: {
    [kC.variable]: "colors.gray.700",
    [BB.variable]: "colors.whiteAlpha.300"
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
}, Ire = {
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
}, Are = {
  px: 3,
  py: 2
}, kre = {
  px: 3,
  py: 2,
  borderTopWidth: "1px"
}, Rre = {
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
}, Pre = Cre({
  popper: Ere,
  content: Tre,
  header: Ire,
  body: Are,
  footer: kre,
  closeButton: Rre
}), Ore = xre({
  baseStyle: Pre
}), { definePartsStyle: YP, defineMultiStyleConfig: _re } = dn(Wq.keys), IR = Pt("drawer-bg"), AR = Pt("drawer-box-shadow");
function yv(e) {
  return YP(e === "full" ? {
    dialog: { maxW: "100vw", h: "100vh" }
  } : {
    dialog: { maxW: e }
  });
}
var Dre = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, Nre = {
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
}, Mre = (e) => {
  const { isFullHeight: t } = e;
  return {
    ...t && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [IR.variable]: "colors.white",
    [AR.variable]: "shadows.lg",
    _dark: {
      [IR.variable]: "colors.gray.700",
      [AR.variable]: "shadows.dark-lg"
    },
    bg: IR.reference,
    boxShadow: AR.reference
  };
}, Lre = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, Fre = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, Bre = {
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
}, Vre = {
  px: "6",
  py: "4"
}, $re = YP((e) => ({
  overlay: Dre,
  dialogContainer: Nre,
  dialog: Hi(Mre, e),
  header: Lre,
  closeButton: Fre,
  body: Bre,
  footer: Vre
})), zre = {
  xs: yv("xs"),
  sm: yv("md"),
  md: yv("lg"),
  lg: yv("2xl"),
  xl: yv("4xl"),
  full: yv("full")
}, Hre = _re({
  baseStyle: $re,
  sizes: zre,
  defaultProps: {
    size: "xs"
  }
}), { definePartsStyle: jre, defineMultiStyleConfig: Gre } = dn(k4.keys), Wre = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
}, Ure = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, Xre = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, Zre = jre({
  preview: Wre,
  input: Ure,
  textarea: Xre
}), Yre = Gre({
  baseStyle: Zre
}), { definePartsStyle: Jre, defineMultiStyleConfig: Qre } = dn(R4.keys), Wv = Pt("form-control-color"), Kre = {
  marginStart: "1",
  [Wv.variable]: "colors.red.500",
  _dark: {
    [Wv.variable]: "colors.red.300"
  },
  color: Wv.reference
}, qre = {
  mt: "2",
  [Wv.variable]: "colors.gray.600",
  _dark: {
    [Wv.variable]: "colors.whiteAlpha.600"
  },
  color: Wv.reference,
  lineHeight: "normal",
  fontSize: "sm"
}, eoe = Jre({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: Kre,
  helperText: qre
}), toe = Qre({
  baseStyle: eoe
}), { definePartsStyle: noe, defineMultiStyleConfig: roe } = dn(P4.keys), Uv = Pt("form-error-color"), ooe = {
  [Uv.variable]: "colors.red.500",
  _dark: {
    [Uv.variable]: "colors.red.300"
  },
  color: Uv.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
}, ioe = {
  marginEnd: "0.5em",
  [Uv.variable]: "colors.red.500",
  _dark: {
    [Uv.variable]: "colors.red.300"
  },
  color: Uv.reference
}, aoe = noe({
  text: ooe,
  icon: ioe
}), soe = roe({
  baseStyle: aoe
}), loe = {
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
}, uoe = {
  baseStyle: loe
}, coe = {
  fontFamily: "heading",
  fontWeight: "bold"
}, doe = {
  "4xl": {
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  },
  "3xl": {
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  },
  "2xl": {
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  },
  xl: {
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  },
  lg: {
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  },
  md: {
    fontSize: "xl",
    lineHeight: 1.2
  },
  sm: {
    fontSize: "md",
    lineHeight: 1.2
  },
  xs: {
    fontSize: "sm",
    lineHeight: 1.2
  }
}, foe = {
  baseStyle: coe,
  sizes: doe,
  defaultProps: {
    size: "xl"
  }
}, { defineMultiStyleConfig: poe, definePartsStyle: hoe } = dn(Gq.keys), kR = Pt("breadcrumb-link-decor"), moe = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: kR.reference,
  [kR.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [kR.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
}, voe = hoe({
  link: moe
}), goe = poe({
  baseStyle: voe
}), yoe = {
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
}, U4 = (e) => {
  const { colorScheme: t, theme: n } = e;
  if (t === "gray")
    return {
      color: Vt("gray.800", "whiteAlpha.900")(e),
      _hover: {
        bg: Vt("gray.100", "whiteAlpha.200")(e)
      },
      _active: { bg: Vt("gray.200", "whiteAlpha.300")(e) }
    };
  const o = sg(`${t}.200`, 0.12)(n), a = sg(`${t}.200`, 0.24)(n);
  return {
    color: Vt(`${t}.600`, `${t}.200`)(e),
    bg: "transparent",
    _hover: {
      bg: Vt(`${t}.50`, o)(e)
    },
    _active: {
      bg: Vt(`${t}.100`, a)(e)
    }
  };
}, boe = (e) => {
  const { colorScheme: t } = e, n = Vt("gray.200", "whiteAlpha.300")(e);
  return {
    border: "1px solid",
    borderColor: t === "gray" ? n : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...Hi(U4, e)
  };
}, Soe = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
}, xoe = (e) => {
  var t;
  const { colorScheme: n } = e;
  if (n === "gray") {
    const h = Vt("gray.100", "whiteAlpha.200")(e);
    return {
      bg: h,
      color: Vt("gray.800", "whiteAlpha.900")(e),
      _hover: {
        bg: Vt("gray.200", "whiteAlpha.300")(e),
        _disabled: {
          bg: h
        }
      },
      _active: { bg: Vt("gray.300", "whiteAlpha.400")(e) }
    };
  }
  const {
    bg: o = `${n}.500`,
    color: a = "white",
    hoverBg: l = `${n}.600`,
    activeBg: u = `${n}.700`
  } = (t = Soe[n]) != null ? t : {}, f = Vt(o, `${n}.200`)(e);
  return {
    bg: f,
    color: Vt(a, "gray.800")(e),
    _hover: {
      bg: Vt(l, `${n}.300`)(e),
      _disabled: {
        bg: f
      }
    },
    _active: { bg: Vt(u, `${n}.400`)(e) }
  };
}, Coe = (e) => {
  const { colorScheme: t } = e;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: Vt(`${t}.500`, `${t}.200`)(e),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: Vt(`${t}.700`, `${t}.500`)(e)
    }
  };
}, woe = {
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
}, Eoe = {
  ghost: U4,
  outline: boe,
  solid: xoe,
  link: Coe,
  unstyled: woe
}, Toe = {
  lg: {
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  },
  md: {
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  },
  sm: {
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  },
  xs: {
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  }
}, Ioe = {
  baseStyle: yoe,
  variants: Eoe,
  sizes: Toe,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
}, { definePartsStyle: eh, defineMultiStyleConfig: Aoe } = dn($4.keys), Vw = Pt("card-bg"), kc = Pt("card-padding"), X4 = Pt("card-shadow"), cw = Pt("card-radius"), Z4 = Pt("card-border-width", "0"), Y4 = Pt("card-border-color"), koe = eh({
  container: {
    [Vw.variable]: "colors.chakra-body-bg",
    backgroundColor: Vw.reference,
    boxShadow: X4.reference,
    borderRadius: cw.reference,
    color: "chakra-body-text",
    borderWidth: Z4.reference,
    borderColor: Y4.reference
  },
  body: {
    padding: kc.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: kc.reference
  },
  footer: {
    padding: kc.reference
  }
}), Roe = {
  sm: eh({
    container: {
      [cw.variable]: "radii.base",
      [kc.variable]: "space.3"
    }
  }),
  md: eh({
    container: {
      [cw.variable]: "radii.md",
      [kc.variable]: "space.5"
    }
  }),
  lg: eh({
    container: {
      [cw.variable]: "radii.xl",
      [kc.variable]: "space.7"
    }
  })
}, Poe = {
  elevated: eh({
    container: {
      [X4.variable]: "shadows.base",
      _dark: {
        [Vw.variable]: "colors.gray.700"
      }
    }
  }),
  outline: eh({
    container: {
      [Z4.variable]: "1px",
      [Y4.variable]: "colors.chakra-border-color"
    }
  }),
  filled: eh({
    container: {
      [Vw.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [kc.variable]: 0
    },
    header: {
      [kc.variable]: 0
    },
    footer: {
      [kc.variable]: 0
    }
  }
}, Ooe = Aoe({
  baseStyle: koe,
  variants: Poe,
  sizes: Roe,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
}), C0 = Dr("close-button-size"), Xb = Dr("close-button-bg"), _oe = {
  w: [C0.reference],
  h: [C0.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [Xb.variable]: "colors.blackAlpha.100",
    _dark: {
      [Xb.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [Xb.variable]: "colors.blackAlpha.200",
    _dark: {
      [Xb.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: Xb.reference
}, Doe = {
  lg: {
    [C0.variable]: "sizes.10",
    fontSize: "md"
  },
  md: {
    [C0.variable]: "sizes.8",
    fontSize: "xs"
  },
  sm: {
    [C0.variable]: "sizes.6",
    fontSize: "2xs"
  }
}, Noe = {
  baseStyle: _oe,
  sizes: Doe,
  defaultProps: {
    size: "md"
  }
}, { variants: Moe, defaultProps: Loe } = S0, Foe = {
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: Kr.bg.reference,
  color: Kr.color.reference,
  boxShadow: Kr.shadow.reference
}, Boe = {
  baseStyle: Foe,
  variants: Moe,
  defaultProps: Loe
}, Voe = {
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
}, $oe = {
  baseStyle: Voe
}, zoe = {
  opacity: 0.6,
  borderColor: "inherit"
}, Hoe = {
  borderStyle: "solid"
}, joe = {
  borderStyle: "dashed"
}, Goe = {
  solid: Hoe,
  dashed: joe
}, Woe = {
  baseStyle: zoe,
  variants: Goe,
  defaultProps: {
    variant: "solid"
  }
}, { definePartsStyle: Uoe, defineMultiStyleConfig: Xoe } = dn(I4.keys), Zoe = {
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
}, Yoe = {
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
}, Joe = {
  pt: "2",
  px: "4",
  pb: "5"
}, Qoe = {
  fontSize: "1.25em"
}, Koe = Uoe({
  container: Zoe,
  button: Yoe,
  panel: Joe,
  icon: Qoe
}), qoe = Xoe({ baseStyle: Koe }), { definePartsStyle: uS, defineMultiStyleConfig: eie } = dn(Hq.keys), Ga = Pt("alert-fg"), Nc = Pt("alert-bg"), tie = uS({
  container: {
    bg: Nc.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: Ga.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: Ga.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function H_(e) {
  const { theme: t, colorScheme: n } = e, o = sg(`${n}.200`, 0.16)(t);
  return {
    light: `colors.${n}.100`,
    dark: o
  };
}
var nie = uS((e) => {
  const { colorScheme: t } = e, n = H_(e);
  return {
    container: {
      [Ga.variable]: `colors.${t}.600`,
      [Nc.variable]: n.light,
      _dark: {
        [Ga.variable]: `colors.${t}.200`,
        [Nc.variable]: n.dark
      }
    }
  };
}), rie = uS((e) => {
  const { colorScheme: t } = e, n = H_(e);
  return {
    container: {
      [Ga.variable]: `colors.${t}.600`,
      [Nc.variable]: n.light,
      _dark: {
        [Ga.variable]: `colors.${t}.200`,
        [Nc.variable]: n.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: Ga.reference
    }
  };
}), oie = uS((e) => {
  const { colorScheme: t } = e, n = H_(e);
  return {
    container: {
      [Ga.variable]: `colors.${t}.600`,
      [Nc.variable]: n.light,
      _dark: {
        [Ga.variable]: `colors.${t}.200`,
        [Nc.variable]: n.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: Ga.reference
    }
  };
}), iie = uS((e) => {
  const { colorScheme: t } = e;
  return {
    container: {
      [Ga.variable]: "colors.white",
      [Nc.variable]: `colors.${t}.600`,
      _dark: {
        [Ga.variable]: "colors.gray.900",
        [Nc.variable]: `colors.${t}.200`
      },
      color: Ga.reference
    }
  };
}), aie = {
  subtle: nie,
  "left-accent": rie,
  "top-accent": oie,
  solid: iie
}, sie = eie({
  baseStyle: tie,
  variants: aie,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
}), { definePartsStyle: J4, defineMultiStyleConfig: lie } = dn(jq.keys), Xv = Pt("avatar-border-color"), w0 = Pt("avatar-bg"), W0 = Pt("avatar-font-size"), lg = Pt("avatar-size"), uie = {
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: Xv.reference,
  [Xv.variable]: "white",
  _dark: {
    [Xv.variable]: "colors.gray.800"
  }
}, cie = {
  bg: w0.reference,
  fontSize: W0.reference,
  width: lg.reference,
  height: lg.reference,
  lineHeight: "1",
  [w0.variable]: "colors.gray.200",
  _dark: {
    [w0.variable]: "colors.whiteAlpha.400"
  }
}, die = (e) => {
  const { name: t, theme: n } = e, o = t ? yee({ string: t }) : "colors.gray.400", a = vee(o)(n);
  let l = "white";
  return a || (l = "gray.800"), {
    bg: w0.reference,
    fontSize: W0.reference,
    color: l,
    borderColor: Xv.reference,
    verticalAlign: "top",
    width: lg.reference,
    height: lg.reference,
    "&:not([data-loaded])": {
      [w0.variable]: o
    },
    [Xv.variable]: "colors.white",
    _dark: {
      [Xv.variable]: "colors.gray.800"
    }
  };
}, fie = {
  fontSize: W0.reference,
  lineHeight: "1"
}, pie = J4((e) => ({
  badge: Hi(uie, e),
  excessLabel: Hi(cie, e),
  container: Hi(die, e),
  label: fie
}));
function Kd(e) {
  const t = e !== "100%" ? T4[e] : void 0;
  return J4({
    container: {
      [lg.variable]: t ?? e,
      [W0.variable]: `calc(${t ?? e} / 2.5)`
    },
    excessLabel: {
      [lg.variable]: t ?? e,
      [W0.variable]: `calc(${t ?? e} / 2.5)`
    }
  });
}
var hie = {
  "2xs": Kd(4),
  xs: Kd(6),
  sm: Kd(8),
  md: Kd(12),
  lg: Kd(16),
  xl: Kd(24),
  "2xl": Kd(32),
  full: Kd("100%")
}, mie = lie({
  baseStyle: pie,
  sizes: hie,
  defaultProps: {
    size: "md"
  }
}), vie = {
  Accordion: qoe,
  Alert: sie,
  Avatar: mie,
  Badge: S0,
  Breadcrumb: goe,
  Button: Ioe,
  Checkbox: Bw,
  CloseButton: Noe,
  Code: Boe,
  Container: $oe,
  Divider: Woe,
  Drawer: Hre,
  Editable: Yre,
  Form: toe,
  FormError: soe,
  FormLabel: uoe,
  Heading: foe,
  Input: Gn,
  Kbd: _ne,
  Link: Nne,
  List: Vne,
  Menu: Jne,
  Modal: sre,
  NumberInput: vre,
  PinInput: Sre,
  Popover: Ore,
  Progress: Bte,
  Radio: Qte,
  Select: one,
  Skeleton: ane,
  SkipLink: lne,
  Slider: bne,
  Spinner: Cne,
  Stat: Pne,
  Switch: Nee,
  Table: zee,
  Tabs: nte,
  Tag: mte,
  Textarea: Ate,
  Tooltip: Pte,
  Card: Ooe,
  Stepper: zq
}, gie = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
}, yie = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
}, bie = "ltr", Sie = {
  useSystemColorMode: !1,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
}, j_ = {
  semanticTokens: gie,
  direction: bie,
  ...Bq,
  components: vie,
  styles: yie,
  config: Sie
};
function c0(e) {
  return typeof e == "function";
}
function xie(...e) {
  return (t) => e.reduce((n, o) => o(n), t);
}
var Cie = (e) => function(...n) {
  let o = [...n], a = n[n.length - 1];
  return hq(a) && // this ensures backward compatibility
  // previously only `extendTheme(override, activeTheme?)` was allowed
  o.length > 1 ? o = o.slice(0, o.length - 1) : a = e, xie(
    ...o.map(
      (l) => (u) => c0(l) ? l(u) : wie(u, l)
    )
  )(a);
}, tDe = Cie(j_);
function wie(...e) {
  return bs({}, ...e, Q4);
}
function Q4(e, t, n, o) {
  if ((c0(e) || c0(t)) && Object.prototype.hasOwnProperty.call(o, n))
    return (...a) => {
      const l = c0(e) ? e(...a) : e, u = c0(t) ? t(...a) : t;
      return bs({}, l, u, Q4);
    };
}
function Eie() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var Tie = /* @__PURE__ */ Eie();
function Iie(e, t) {
  const n = {};
  return Object.keys(e).forEach((o) => {
    t.includes(o) || (n[o] = e[o]);
  }), n;
}
function Aie(e, t, n, o) {
  const a = typeof t == "string" ? t.split(".") : [t];
  for (o = 0; o < a.length && e; o += 1)
    e = e[a[o]];
  return e === void 0 ? n : e;
}
var kie = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (o, a, l, u) => {
    if (typeof o > "u")
      return e(o, a, l);
    t.has(o) || t.set(o, /* @__PURE__ */ new Map());
    const f = t.get(o);
    if (f.has(a))
      return f.get(a);
    const h = e(o, a, l, u);
    return f.set(a, h), h;
  };
}, K4 = kie(Aie);
function q4(e, t) {
  const n = {};
  return Object.keys(e).forEach((o) => {
    const a = e[o];
    t(a, o, e) && (n[o] = a);
  }), n;
}
var e3 = (e) => q4(e, (t) => t != null);
function Rie(e) {
  return typeof e == "function";
}
process.env.NODE_ENV;
process.env.NODE_ENV;
function $w(e, ...t) {
  return Rie(e) ? e(...t) : e;
}
function Pie(...e) {
  return function(n) {
    e.some((o) => (o == null || o(n), n == null ? void 0 : n.defaultPrevented));
  };
}
const t3 = 1 / 60 * 1e3, Oie = typeof performance < "u" ? () => performance.now() : () => Date.now(), n3 = typeof window < "u" ? (e) => window.requestAnimationFrame(e) : (e) => setTimeout(() => e(Oie()), t3);
function _ie(e) {
  let t = [], n = [], o = 0, a = !1, l = !1;
  const u = /* @__PURE__ */ new WeakSet(), f = {
    schedule: (h, v = !1, g = !1) => {
      const b = g && a, S = b ? t : n;
      return v && u.add(h), S.indexOf(h) === -1 && (S.push(h), b && a && (o = t.length)), h;
    },
    cancel: (h) => {
      const v = n.indexOf(h);
      v !== -1 && n.splice(v, 1), u.delete(h);
    },
    process: (h) => {
      if (a) {
        l = !0;
        return;
      }
      if (a = !0, [t, n] = [n, t], n.length = 0, o = t.length, o)
        for (let v = 0; v < o; v++) {
          const g = t[v];
          g(h), u.has(g) && (f.schedule(g), e());
        }
      a = !1, l && (l = !1, f.process(h));
    }
  };
  return f;
}
const Die = 40;
let JP = !0, U0 = !1, QP = !1;
const Zv = {
  delta: 0,
  timestamp: 0
}, cS = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], UE = cS.reduce((e, t) => (e[t] = _ie(() => U0 = !0), e), {}), Nie = cS.reduce((e, t) => {
  const n = UE[t];
  return e[t] = (o, a = !1, l = !1) => (U0 || Fie(), n.schedule(o, a, l)), e;
}, {}), Mie = cS.reduce((e, t) => (e[t] = UE[t].cancel, e), {});
cS.reduce((e, t) => (e[t] = () => UE[t].process(Zv), e), {});
const Lie = (e) => UE[e].process(Zv), r3 = (e) => {
  U0 = !1, Zv.delta = JP ? t3 : Math.max(Math.min(e - Zv.timestamp, Die), 1), Zv.timestamp = e, QP = !0, cS.forEach(Lie), QP = !1, U0 && (JP = !1, n3(r3));
}, Fie = () => {
  U0 = !0, JP = !0, QP || n3(r3);
}, VB = () => Zv;
var Bie = typeof Element < "u", Vie = typeof Map == "function", $ie = typeof Set == "function", zie = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function dw(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, o, a;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (o = n; o-- !== 0; )
        if (!dw(e[o], t[o]))
          return !1;
      return !0;
    }
    var l;
    if (Vie && e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (l = e.entries(); !(o = l.next()).done; )
        if (!t.has(o.value[0]))
          return !1;
      for (l = e.entries(); !(o = l.next()).done; )
        if (!dw(o.value[1], t.get(o.value[0])))
          return !1;
      return !0;
    }
    if ($ie && e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (l = e.entries(); !(o = l.next()).done; )
        if (!t.has(o.value[0]))
          return !1;
      return !0;
    }
    if (zie && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (o = n; o-- !== 0; )
        if (e[o] !== t[o])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf && typeof e.valueOf == "function" && typeof t.valueOf == "function")
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString && typeof e.toString == "function" && typeof t.toString == "function")
      return e.toString() === t.toString();
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, a[o]))
        return !1;
    if (Bie && e instanceof Element)
      return !1;
    for (o = n; o-- !== 0; )
      if (!((a[o] === "_owner" || a[o] === "__v" || a[o] === "__o") && e.$$typeof) && !dw(e[a[o]], t[a[o]]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
var Hie = function(t, n) {
  try {
    return dw(t, n);
  } catch (o) {
    if ((o.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw o;
  }
};
const jie = /* @__PURE__ */ I_(Hie);
function o3(e, t = {}) {
  var n;
  const { styleConfig: o, ...a } = t, { theme: l, colorMode: u } = p4(), f = e ? K4(l, `components.${e}`) : void 0, h = o || f, v = bs(
    { theme: l, colorMode: u },
    (n = h == null ? void 0 : h.defaultProps) != null ? n : {},
    e3(Iie(a, ["children"]))
  ), g = Ue({});
  if (h) {
    const S = fq(h)(v);
    jie(g.current, S) || (g.current = S);
  }
  return g.current;
}
function Gi(e, t = {}) {
  return o3(e, t);
}
function Xn(e, t = {}) {
  return o3(e, t);
}
var Gie = /* @__PURE__ */ new Set([
  ...eq,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]), Wie = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function Uie(e) {
  return Wie.has(e) || !Gie.has(e);
}
function Xie(e, ...t) {
  if (e == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const n = { ...e };
  for (const o of t)
    if (o != null)
      for (const a in o)
        Object.prototype.hasOwnProperty.call(o, a) && (a in n && delete n[a], n[a] = o[a]);
  return n;
}
function G_(e) {
  const t = Object.assign({}, e);
  for (let n in t)
    t[n] === void 0 && delete t[n];
  return t;
}
var Zie = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Yie = /* @__PURE__ */ J5(
  function(e) {
    return Zie.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Jie = Yie, Qie = function(t) {
  return t !== "theme";
}, $B = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? Jie : Qie;
}, zB = function(t, n, o) {
  var a;
  if (n) {
    var l = n.shouldForwardProp;
    a = t.__emotion_forwardProp && l ? function(u) {
      return t.__emotion_forwardProp(u) && l(u);
    } : l;
  }
  return typeof a != "function" && o && (a = t.__emotion_forwardProp), a;
}, HB = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, Kie = function(t) {
  var n = t.cache, o = t.serialized, a = t.isStringTag;
  return LE(n, o, a), P_(function() {
    return FE(n, o, a);
  }), null;
}, qie = function e(t, n) {
  if (process.env.NODE_ENV !== "production" && t === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var o = t.__emotion_real === t, a = o && t.__emotion_base || t, l, u;
  n !== void 0 && (l = n.label, u = n.target);
  var f = zB(t, n, o), h = f || $B(a), v = !h("as");
  return function() {
    var g = arguments, b = o && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (l !== void 0 && b.push("label:" + l + ";"), g[0] == null || g[0].raw === void 0)
      b.push.apply(b, g);
    else {
      process.env.NODE_ENV !== "production" && g[0][0] === void 0 && console.error(HB), b.push(g[0][0]);
      for (var S = g.length, w = 1; w < S; w++)
        process.env.NODE_ENV !== "production" && g[0][w] === void 0 && console.error(HB), b.push(g[w], g[0][w]);
    }
    var E = BE(function(T, A, P) {
      var _ = v && T.as || a, D = "", L = [], F = T;
      if (T.theme == null) {
        F = {};
        for (var V in T)
          F[V] = T[V];
        F.theme = Fe.useContext(df);
      }
      typeof T.className == "string" ? D = k_(A.registered, L, T.className) : T.className != null && (D = T.className + " ");
      var $ = ag(b.concat(L), A.registered, F);
      D += A.key + "-" + $.name, u !== void 0 && (D += " " + u);
      var U = v && f === void 0 ? $B(_) : h, W = {};
      for (var H in T)
        v && H === "as" || // $FlowFixMe
        U(H) && (W[H] = T[H]);
      return W.className = D, W.ref = P, /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, /* @__PURE__ */ Fe.createElement(Kie, {
        cache: A,
        serialized: $,
        isStringTag: typeof _ == "string"
      }), /* @__PURE__ */ Fe.createElement(_, W));
    });
    return E.displayName = l !== void 0 ? l : "Styled(" + (typeof a == "string" ? a : a.displayName || a.name || "Component") + ")", E.defaultProps = t.defaultProps, E.__emotion_real = E, E.__emotion_base = a, E.__emotion_styles = b, E.__emotion_forwardProp = f, Object.defineProperty(E, "toString", {
      value: function() {
        return u === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + u;
      }
    }), E.withComponent = function(T, A) {
      return e(T, Dt({}, n, A, {
        shouldForwardProp: zB(E, A, !0)
      })).apply(void 0, b);
    }, E;
  };
}, eae = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], zw = qie.bind();
eae.forEach(function(e) {
  zw[e] = zw(e);
});
var jB, tae = (jB = zw.default) != null ? jB : zw, nae = ({ baseStyle: e }) => (t) => {
  const { theme: n, css: o, __css: a, sx: l, ...u } = t, f = q4(u, (b, S) => nq(S)), h = $w(e, t), v = Xie(
    {},
    a,
    h,
    e3(f),
    l
  ), g = x4(v)(t.theme);
  return o ? [g, o] : g;
};
function RR(e, t) {
  const { baseStyle: n, ...o } = t ?? {};
  o.shouldForwardProp || (o.shouldForwardProp = Uie);
  const a = nae({ baseStyle: n }), l = tae(
    e,
    o
  )(a);
  return Tt.forwardRef(function(h, v) {
    const { colorMode: g, forced: b } = $E();
    return Tt.createElement(l, {
      ref: v,
      "data-theme": b ? g : void 0,
      ...h
    });
  });
}
function rae() {
  const e = /* @__PURE__ */ new Map();
  return new Proxy(RR, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(t, n, o) {
      return RR(...o);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(t, n) {
      return e.has(n) || e.set(n, RR(n)), e.get(n);
    }
  });
}
var De = rae();
function Le(e) {
  return fr(e);
}
function i3(e = {}) {
  const {
    strict: t = !0,
    errorMessage: n = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name: o
  } = e, a = wa(void 0);
  a.displayName = o;
  function l() {
    var u;
    const f = dr(a);
    if (!f && t) {
      const h = new Error(n);
      throw h.name = "ContextError", (u = Error.captureStackTrace) == null || u.call(Error, h, l), h;
    }
    return f;
  }
  return [
    a.Provider,
    l,
    a
  ];
}
function a3(e) {
  const { cssVarsRoot: t, theme: n, children: o } = e, a = gt(() => KK(n), [n]);
  return /* @__PURE__ */ Nt(fQ, { theme: a, children: [
    /* @__PURE__ */ M(oae, { root: t }),
    o
  ] });
}
function oae({ root: e = ":host, :root" }) {
  const t = [e, "[data-theme]"].join(",");
  return /* @__PURE__ */ M(aS, { styles: (n) => ({ [t]: n.__cssVars }) });
}
i3({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function iae(e) {
  return i3({
    name: `${e}StylesContext`,
    errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${e} />" `
  });
}
function aae() {
  const { colorMode: e } = $E();
  return /* @__PURE__ */ M(
    aS,
    {
      styles: (t) => {
        const n = K4(t, "styles.global"), o = $w(n, { theme: t, colorMode: e });
        return o ? x4(o)(t) : void 0;
      }
    }
  );
}
var W_ = wa({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
W_.displayName = "EnvironmentContext";
function sae({ defer: e } = {}) {
  const [, t] = cJ((n) => n + 1, 0);
  return Ss(() => {
    e && t();
  }, [e]), dr(W_);
}
function s3(e) {
  const { children: t, environment: n, disabled: o } = e, a = Ue(null), l = gt(() => n || {
    getDocument: () => {
      var f, h;
      return (h = (f = a.current) == null ? void 0 : f.ownerDocument) != null ? h : document;
    },
    getWindow: () => {
      var f, h;
      return (h = (f = a.current) == null ? void 0 : f.ownerDocument.defaultView) != null ? h : window;
    }
  }, [n]), u = !o || !n;
  return /* @__PURE__ */ Nt(W_.Provider, { value: l, children: [
    t,
    u && /* @__PURE__ */ M("span", { id: "__chakra_env", hidden: !0, ref: a })
  ] });
}
s3.displayName = "EnvironmentProvider";
var lae = (e) => {
  const {
    children: t,
    colorModeManager: n,
    portalZIndex: o,
    resetScope: a,
    resetCSS: l = !0,
    theme: u = {},
    environment: f,
    cssVarsRoot: h,
    disableEnvironment: v,
    disableGlobalStyle: g
  } = e, b = /* @__PURE__ */ M(
    s3,
    {
      environment: f,
      disabled: v,
      children: t
    }
  );
  return /* @__PURE__ */ M(a3, { theme: u, cssVarsRoot: h, children: /* @__PURE__ */ Nt(
    f4,
    {
      colorModeManager: n,
      options: u.config,
      children: [
        l ? /* @__PURE__ */ M(AQ, { scope: a }) : /* @__PURE__ */ M(IQ, {}),
        !g && /* @__PURE__ */ M(aae, {}),
        o ? /* @__PURE__ */ M(l4, { zIndex: o, children: b }) : b
      ]
    }
  ) });
}, uae = (e, t) => e.find((n) => n.id === t);
function GB(e, t) {
  const n = l3(e, t), o = n ? e[n].findIndex((a) => a.id === t) : -1;
  return {
    position: n,
    index: o
  };
}
function l3(e, t) {
  for (const [n, o] of Object.entries(e))
    if (uae(o, t))
      return n;
}
function cae(e) {
  const t = e.includes("right"), n = e.includes("left");
  let o = "center";
  return t && (o = "flex-end"), n && (o = "flex-start"), {
    display: "flex",
    flexDirection: "column",
    alignItems: o
  };
}
function dae(e) {
  const n = e === "top" || e === "bottom" ? "0 auto" : void 0, o = e.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, a = e.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, l = e.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", u = e.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: n,
    top: o,
    bottom: a,
    right: l,
    left: u
  };
}
function Er(e, t = []) {
  const n = Ue(e);
  return dt(() => {
    n.current = e;
  }), re((...o) => {
    var a;
    return (a = n.current) == null ? void 0 : a.call(n, ...o);
  }, t);
}
function fae(e, t) {
  const n = Er(e);
  dt(() => {
    if (t == null)
      return;
    let o = null;
    return o = window.setTimeout(() => {
      n();
    }, t), () => {
      o && window.clearTimeout(o);
    };
  }, [t, n]);
}
function xl(e, t) {
  const n = Ue(!1), o = Ue(!1);
  dt(() => {
    if (n.current && o.current)
      return e();
    o.current = !0;
  }, t), dt(() => (n.current = !0, () => {
    n.current = !1;
  }), []);
}
const u3 = wa({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), XE = wa({}), dS = wa(null), ZE = typeof document < "u", U_ = ZE ? ph : dt, c3 = wa({ strict: !1 }), X_ = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), pae = "framerAppearId", d3 = "data-" + X_(pae);
function hae(e, t, n, o) {
  const { visualElement: a } = dr(XE), l = dr(c3), u = dr(dS), f = dr(u3).reducedMotion, h = Ue();
  o = o || l.renderer, !h.current && o && (h.current = o(e, {
    visualState: t,
    parent: a,
    props: n,
    presenceContext: u,
    blockInitialAnimation: u ? u.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const v = h.current;
  j5(() => {
    v && v.update(n, u);
  });
  const g = Ue(!!(n[d3] && !window.HandoffComplete));
  return U_(() => {
    v && (v.render(), g.current && v.animationState && v.animationState.animateChanges());
  }), dt(() => {
    v && (v.updateFeatures(), !g.current && v.animationState && v.animationState.animateChanges(), g.current && (g.current = !1, window.HandoffComplete = !0));
  }), v;
}
function Mv(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function mae(e, t, n) {
  return re(
    (o) => {
      o && e.mount && e.mount(o), t && (o ? t.mount(o) : t.unmount()), n && (typeof n == "function" ? n(o) : Mv(n) && (n.current = o));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function X0(e) {
  return typeof e == "string" || Array.isArray(e);
}
function YE(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const Z_ = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Y_ = ["initial", ...Z_];
function JE(e) {
  return YE(e.animate) || Y_.some((t) => X0(e[t]));
}
function f3(e) {
  return !!(JE(e) || e.variants);
}
function vae(e, t) {
  if (JE(e)) {
    const { initial: n, animate: o } = e;
    return {
      initial: n === !1 || X0(n) ? n : void 0,
      animate: X0(o) ? o : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function gae(e) {
  const { initial: t, animate: n } = vae(e, dr(XE));
  return gt(() => ({ initial: t, animate: n }), [WB(t), WB(n)]);
}
function WB(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const UB = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Z0 = {};
for (const e in UB)
  Z0[e] = {
    isEnabled: (t) => UB[e].some((n) => !!t[n])
  };
function yae(e) {
  for (const t in e)
    Z0[t] = {
      ...Z0[t],
      ...e[t]
    };
}
const J_ = wa({}), p3 = wa({}), bae = Symbol.for("motionComponentSymbol");
function Sae({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: o, Component: a }) {
  e && yae(e);
  function l(f, h) {
    let v;
    const g = {
      ...dr(u3),
      ...f,
      layoutId: xae(f)
    }, { isStatic: b } = g, S = gae(f), w = o(f, b);
    if (!b && ZE) {
      S.visualElement = hae(a, w, g, t);
      const E = dr(p3), T = dr(c3).strict;
      S.visualElement && (v = S.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        g,
        T,
        e,
        E
      ));
    }
    return Fe.createElement(
      XE.Provider,
      { value: S },
      v && S.visualElement ? Fe.createElement(v, { visualElement: S.visualElement, ...g }) : null,
      n(a, f, mae(w, S.visualElement, h), w, b, S.visualElement)
    );
  }
  const u = fr(l);
  return u[bae] = a, u;
}
function xae({ layoutId: e }) {
  const t = dr(J_).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function Cae(e) {
  function t(o, a = {}) {
    return Sae(e(o, a));
  }
  if (typeof Proxy > "u")
    return t;
  const n = /* @__PURE__ */ new Map();
  return new Proxy(t, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (o, a) => (n.has(a) || n.set(a, t(a)), n.get(a))
  });
}
const wae = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Q_(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(wae.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(e))
    )
  );
}
const Hw = {};
function Eae(e) {
  Object.assign(Hw, e);
}
const fS = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], mh = new Set(fS);
function h3(e, { layout: t, layoutId: n }) {
  return mh.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Hw[e] || e === "opacity");
}
const Sa = (e) => !!(e && e.getVelocity), Tae = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Iae = fS.length;
function Aae(e, { enableHardwareAcceleration: t = !0, allowTransformNone: n = !0 }, o, a) {
  let l = "";
  for (let u = 0; u < Iae; u++) {
    const f = fS[u];
    if (e[f] !== void 0) {
      const h = Tae[f] || f;
      l += `${h}(${e[f]}) `;
    }
  }
  return t && !e.z && (l += "translateZ(0)"), l = l.trim(), a ? l = a(e, o ? "" : l) : n && o && (l = "none"), l;
}
const m3 = (e) => (t) => typeof t == "string" && t.startsWith(e), v3 = m3("--"), KP = m3("var(--"), kae = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, Rae = (e, t) => t && typeof e == "number" ? t.transform(e) : e, ff = (e, t, n) => Math.min(Math.max(n, e), t), vh = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, E0 = {
  ...vh,
  transform: (e) => ff(0, 1, e)
}, RC = {
  ...vh,
  default: 1
}, T0 = (e) => Math.round(e * 1e5) / 1e5, QE = /(-)?([\d]*\.?[\d])+/g, g3 = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, Pae = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function pS(e) {
  return typeof e == "string";
}
const hS = (e) => ({
  test: (t) => pS(t) && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), qd = hS("deg"), mu = hS("%"), Wt = hS("px"), Oae = hS("vh"), _ae = hS("vw"), XB = {
  ...mu,
  parse: (e) => mu.parse(e) / 100,
  transform: (e) => mu.transform(e * 100)
}, ZB = {
  ...vh,
  transform: Math.round
}, y3 = {
  // Border props
  borderWidth: Wt,
  borderTopWidth: Wt,
  borderRightWidth: Wt,
  borderBottomWidth: Wt,
  borderLeftWidth: Wt,
  borderRadius: Wt,
  radius: Wt,
  borderTopLeftRadius: Wt,
  borderTopRightRadius: Wt,
  borderBottomRightRadius: Wt,
  borderBottomLeftRadius: Wt,
  // Positioning props
  width: Wt,
  maxWidth: Wt,
  height: Wt,
  maxHeight: Wt,
  size: Wt,
  top: Wt,
  right: Wt,
  bottom: Wt,
  left: Wt,
  // Spacing props
  padding: Wt,
  paddingTop: Wt,
  paddingRight: Wt,
  paddingBottom: Wt,
  paddingLeft: Wt,
  margin: Wt,
  marginTop: Wt,
  marginRight: Wt,
  marginBottom: Wt,
  marginLeft: Wt,
  // Transform props
  rotate: qd,
  rotateX: qd,
  rotateY: qd,
  rotateZ: qd,
  scale: RC,
  scaleX: RC,
  scaleY: RC,
  scaleZ: RC,
  skew: qd,
  skewX: qd,
  skewY: qd,
  distance: Wt,
  translateX: Wt,
  translateY: Wt,
  translateZ: Wt,
  x: Wt,
  y: Wt,
  z: Wt,
  perspective: Wt,
  transformPerspective: Wt,
  opacity: E0,
  originX: XB,
  originY: XB,
  originZ: Wt,
  // Misc
  zIndex: ZB,
  // SVG
  fillOpacity: E0,
  strokeOpacity: E0,
  numOctaves: ZB
};
function K_(e, t, n, o) {
  const { style: a, vars: l, transform: u, transformOrigin: f } = e;
  let h = !1, v = !1, g = !0;
  for (const b in t) {
    const S = t[b];
    if (v3(b)) {
      l[b] = S;
      continue;
    }
    const w = y3[b], E = Rae(S, w);
    if (mh.has(b)) {
      if (h = !0, u[b] = E, !g)
        continue;
      S !== (w.default || 0) && (g = !1);
    } else
      b.startsWith("origin") ? (v = !0, f[b] = E) : a[b] = E;
  }
  if (t.transform || (h || o ? a.transform = Aae(e.transform, n, g, o) : a.transform && (a.transform = "none")), v) {
    const { originX: b = "50%", originY: S = "50%", originZ: w = 0 } = f;
    a.transformOrigin = `${b} ${S} ${w}`;
  }
}
const q_ = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function b3(e, t, n) {
  for (const o in t)
    !Sa(t[o]) && !h3(o, n) && (e[o] = t[o]);
}
function Dae({ transformTemplate: e }, t, n) {
  return gt(() => {
    const o = q_();
    return K_(o, t, { enableHardwareAcceleration: !n }, e), Object.assign({}, o.vars, o.style);
  }, [t]);
}
function Nae(e, t, n) {
  const o = e.style || {}, a = {};
  return b3(a, o, e), Object.assign(a, Dae(e, t, n)), e.transformValues ? e.transformValues(a) : a;
}
function Mae(e, t, n) {
  const o = {}, a = Nae(e, t, n);
  return e.drag && e.dragListener !== !1 && (o.draggable = !1, a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none", a.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (o.tabIndex = 0), o.style = a, o;
}
const Lae = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function jw(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Lae.has(e);
}
let S3 = (e) => !jw(e);
function Fae(e) {
  e && (S3 = (t) => t.startsWith("on") ? !jw(t) : e(t));
}
try {
  Fae(require("@emotion/is-prop-valid").default);
} catch {
}
function Bae(e, t, n) {
  const o = {};
  for (const a in e)
    a === "values" && typeof e.values == "object" || (S3(a) || n === !0 && jw(a) || !t && !jw(a) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && a.startsWith("onDrag")) && (o[a] = e[a]);
  return o;
}
function YB(e, t, n) {
  return typeof e == "string" ? e : Wt.transform(t + n * e);
}
function Vae(e, t, n) {
  const o = YB(t, e.x, e.width), a = YB(n, e.y, e.height);
  return `${o} ${a}`;
}
const $ae = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, zae = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Hae(e, t, n = 1, o = 0, a = !0) {
  e.pathLength = 1;
  const l = a ? $ae : zae;
  e[l.offset] = Wt.transform(-o);
  const u = Wt.transform(t), f = Wt.transform(n);
  e[l.array] = `${u} ${f}`;
}
function e2(e, {
  attrX: t,
  attrY: n,
  attrScale: o,
  originX: a,
  originY: l,
  pathLength: u,
  pathSpacing: f = 1,
  pathOffset: h = 0,
  // This is object creation, which we try to avoid per-frame.
  ...v
}, g, b, S) {
  if (K_(e, v, g, S), b) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: w, style: E, dimensions: T } = e;
  w.transform && (T && (E.transform = w.transform), delete w.transform), T && (a !== void 0 || l !== void 0 || E.transform) && (E.transformOrigin = Vae(T, a !== void 0 ? a : 0.5, l !== void 0 ? l : 0.5)), t !== void 0 && (w.x = t), n !== void 0 && (w.y = n), o !== void 0 && (w.scale = o), u !== void 0 && Hae(w, u, f, h, !1);
}
const x3 = () => ({
  ...q_(),
  attrs: {}
}), t2 = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function jae(e, t, n, o) {
  const a = gt(() => {
    const l = x3();
    return e2(l, t, { enableHardwareAcceleration: !1 }, t2(o), e.transformTemplate), {
      ...l.attrs,
      style: { ...l.style }
    };
  }, [t]);
  if (e.style) {
    const l = {};
    b3(l, e.style, e), a.style = { ...l, ...a.style };
  }
  return a;
}
function Gae(e = !1) {
  return (n, o, a, { latestValues: l }, u) => {
    const h = (Q_(n) ? jae : Mae)(o, l, u, n), g = {
      ...Bae(o, typeof n == "string", e),
      ...h,
      ref: a
    }, { children: b } = o, S = gt(() => Sa(b) ? b.get() : b, [b]);
    return S_(n, {
      ...g,
      children: S
    });
  };
}
function C3(e, { style: t, vars: n }, o, a) {
  Object.assign(e.style, t, a && a.getProjectionStyles(o));
  for (const l in n)
    e.style.setProperty(l, n[l]);
}
const w3 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function E3(e, t, n, o) {
  C3(e, t, void 0, o);
  for (const a in t.attrs)
    e.setAttribute(w3.has(a) ? a : X_(a), t.attrs[a]);
}
function n2(e, t) {
  const { style: n } = e, o = {};
  for (const a in n)
    (Sa(n[a]) || t.style && Sa(t.style[a]) || h3(a, e)) && (o[a] = n[a]);
  return o;
}
function T3(e, t) {
  const n = n2(e, t);
  for (const o in e)
    if (Sa(e[o]) || Sa(t[o])) {
      const a = fS.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      n[a] = e[o];
    }
  return n;
}
function r2(e, t, n, o = {}, a = {}) {
  return typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, o, a)), typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, o, a)), t;
}
function I3(e) {
  const t = Ue(null);
  return t.current === null && (t.current = e()), t.current;
}
const Gw = (e) => Array.isArray(e), Wae = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), Uae = (e) => Gw(e) ? e[e.length - 1] || 0 : e;
function fw(e) {
  const t = Sa(e) ? e.get() : e;
  return Wae(t) ? t.toValue() : t;
}
function Xae({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, o, a, l) {
  const u = {
    latestValues: Zae(o, a, l, e),
    renderState: t()
  };
  return n && (u.mount = (f) => n(o, f, u)), u;
}
const A3 = (e) => (t, n) => {
  const o = dr(XE), a = dr(dS), l = () => Xae(e, t, o, a);
  return n ? l() : I3(l);
};
function Zae(e, t, n, o) {
  const a = {}, l = o(e, {});
  for (const S in l)
    a[S] = fw(l[S]);
  let { initial: u, animate: f } = e;
  const h = JE(e), v = f3(e);
  t && v && !h && e.inherit !== !1 && (u === void 0 && (u = t.initial), f === void 0 && (f = t.animate));
  let g = n ? n.initial === !1 : !1;
  g = g || u === !1;
  const b = g ? f : u;
  return b && typeof b != "boolean" && !YE(b) && (Array.isArray(b) ? b : [b]).forEach((w) => {
    const E = r2(e, w);
    if (!E)
      return;
    const { transitionEnd: T, transition: A, ...P } = E;
    for (const _ in P) {
      let D = P[_];
      if (Array.isArray(D)) {
        const L = g ? D.length - 1 : 0;
        D = D[L];
      }
      D !== null && (a[_] = D);
    }
    for (const _ in T)
      a[_] = T[_];
  }), a;
}
const Hr = (e) => e;
class JB {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(t) {
    if (!this.scheduled.has(t))
      return this.scheduled.add(t), this.order.push(t), !0;
  }
  remove(t) {
    const n = this.order.indexOf(t);
    n !== -1 && (this.order.splice(n, 1), this.scheduled.delete(t));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function Yae(e) {
  let t = new JB(), n = new JB(), o = 0, a = !1, l = !1;
  const u = /* @__PURE__ */ new WeakSet(), f = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (h, v = !1, g = !1) => {
      const b = g && a, S = b ? t : n;
      return v && u.add(h), S.add(h) && b && a && (o = t.order.length), h;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (h) => {
      n.remove(h), u.delete(h);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (h) => {
      if (a) {
        l = !0;
        return;
      }
      if (a = !0, [t, n] = [n, t], n.clear(), o = t.order.length, o)
        for (let v = 0; v < o; v++) {
          const g = t.order[v];
          g(h), u.has(g) && (f.schedule(g), e());
        }
      a = !1, l && (l = !1, f.process(h));
    }
  };
  return f;
}
const PC = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], Jae = 40;
function Qae(e, t) {
  let n = !1, o = !0;
  const a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, l = PC.reduce((b, S) => (b[S] = Yae(() => n = !0), b), {}), u = (b) => l[b].process(a), f = () => {
    const b = performance.now();
    n = !1, a.delta = o ? 1e3 / 60 : Math.max(Math.min(b - a.timestamp, Jae), 1), a.timestamp = b, a.isProcessing = !0, PC.forEach(u), a.isProcessing = !1, n && t && (o = !1, e(f));
  }, h = () => {
    n = !0, o = !0, a.isProcessing || e(f);
  };
  return { schedule: PC.reduce((b, S) => {
    const w = l[S];
    return b[S] = (E, T = !1, A = !1) => (n || h(), w.schedule(E, T, A)), b;
  }, {}), cancel: (b) => PC.forEach((S) => l[S].cancel(b)), state: a, steps: l };
}
const { schedule: gr, cancel: Mc, state: wi, steps: PR } = Qae(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Hr, !0), Kae = {
  useVisualState: A3({
    scrapeMotionValuesFromProps: T3,
    createRenderState: x3,
    onMount: (e, t, { renderState: n, latestValues: o }) => {
      gr.read(() => {
        try {
          n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), gr.render(() => {
        e2(n, o, { enableHardwareAcceleration: !1 }, t2(t.tagName), e.transformTemplate), E3(t, n);
      });
    }
  })
}, qae = {
  useVisualState: A3({
    scrapeMotionValuesFromProps: n2,
    createRenderState: q_
  })
};
function ese(e, { forwardMotionProps: t = !1 }, n, o) {
  return {
    ...Q_(e) ? Kae : qae,
    preloadedFeatures: n,
    useRender: Gae(t),
    createVisualElement: o,
    Component: e
  };
}
function Tc(e, t, n, o = { passive: !0 }) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n);
}
const k3 = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function KE(e, t = "page") {
  return {
    point: {
      x: e[t + "X"],
      y: e[t + "Y"]
    }
  };
}
const tse = (e) => (t) => k3(t) && e(t, KE(t));
function Rc(e, t, n, o) {
  return Tc(e, t, tse(n), o);
}
const nse = (e, t) => (n) => t(e(n)), lf = (...e) => e.reduce(nse);
function R3(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const QB = R3("dragHorizontal"), KB = R3("dragVertical");
function P3(e) {
  let t = !1;
  if (e === "y")
    t = KB();
  else if (e === "x")
    t = QB();
  else {
    const n = QB(), o = KB();
    n && o ? t = () => {
      n(), o();
    } : (n && n(), o && o());
  }
  return t;
}
function O3() {
  const e = P3(!0);
  return e ? (e(), !1) : !0;
}
class Ef {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function qB(e, t) {
  const n = "pointer" + (t ? "enter" : "leave"), o = "onHover" + (t ? "Start" : "End"), a = (l, u) => {
    if (l.pointerType === "touch" || O3())
      return;
    const f = e.getProps();
    e.animationState && f.whileHover && e.animationState.setActive("whileHover", t), f[o] && gr.update(() => f[o](l, u));
  };
  return Rc(e.current, n, a, {
    passive: !e.getProps()[o]
  });
}
class rse extends Ef {
  mount() {
    this.unmount = lf(qB(this.node, !0), qB(this.node, !1));
  }
  unmount() {
  }
}
class ose extends Ef {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = lf(Tc(this.node.current, "focus", () => this.onFocus()), Tc(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const _3 = (e, t) => t ? e === t ? !0 : _3(e, t.parentElement) : !1;
function OR(e, t) {
  if (!t)
    return;
  const n = new PointerEvent("pointer" + e);
  t(n, KE(n));
}
class ise extends Ef {
  constructor() {
    super(...arguments), this.removeStartListeners = Hr, this.removeEndListeners = Hr, this.removeAccessibleListeners = Hr, this.startPointerPress = (t, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const o = this.node.getProps(), l = Rc(window, "pointerup", (f, h) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: v, onTapCancel: g, globalTapTarget: b } = this.node.getProps();
        gr.update(() => {
          !b && !_3(this.node.current, f.target) ? g && g(f, h) : v && v(f, h);
        });
      }, { passive: !(o.onTap || o.onPointerUp) }), u = Rc(window, "pointercancel", (f, h) => this.cancelPress(f, h), { passive: !(o.onTapCancel || o.onPointerCancel) });
      this.removeEndListeners = lf(l, u), this.startPress(t, n);
    }, this.startAccessiblePress = () => {
      const t = (l) => {
        if (l.key !== "Enter" || this.isPressing)
          return;
        const u = (f) => {
          f.key !== "Enter" || !this.checkPressEnd() || OR("up", (h, v) => {
            const { onTap: g } = this.node.getProps();
            g && gr.update(() => g(h, v));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Tc(this.node.current, "keyup", u), OR("down", (f, h) => {
          this.startPress(f, h);
        });
      }, n = Tc(this.node.current, "keydown", t), o = () => {
        this.isPressing && OR("cancel", (l, u) => this.cancelPress(l, u));
      }, a = Tc(this.node.current, "blur", o);
      this.removeAccessibleListeners = lf(n, a);
    };
  }
  startPress(t, n) {
    this.isPressing = !0;
    const { onTapStart: o, whileTap: a } = this.node.getProps();
    a && this.node.animationState && this.node.animationState.setActive("whileTap", !0), o && gr.update(() => o(t, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !O3();
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: o } = this.node.getProps();
    o && gr.update(() => o(t, n));
  }
  mount() {
    const t = this.node.getProps(), n = Rc(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(t.onTapStart || t.onPointerStart) }), o = Tc(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = lf(n, o);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const qP = /* @__PURE__ */ new WeakMap(), _R = /* @__PURE__ */ new WeakMap(), ase = (e) => {
  const t = qP.get(e.target);
  t && t(e);
}, sse = (e) => {
  e.forEach(ase);
};
function lse({ root: e, ...t }) {
  const n = e || document;
  _R.has(n) || _R.set(n, {});
  const o = _R.get(n), a = JSON.stringify(t);
  return o[a] || (o[a] = new IntersectionObserver(sse, { root: e, ...t })), o[a];
}
function use(e, t, n) {
  const o = lse(t);
  return qP.set(e, n), o.observe(e), () => {
    qP.delete(e), o.unobserve(e);
  };
}
const cse = {
  some: 0,
  all: 1
};
class dse extends Ef {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: o, amount: a = "some", once: l } = t, u = {
      root: n ? n.current : void 0,
      rootMargin: o,
      threshold: typeof a == "number" ? a : cse[a]
    }, f = (h) => {
      const { isIntersecting: v } = h;
      if (this.isInView === v || (this.isInView = v, l && !v && this.hasEnteredView))
        return;
      v && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", v);
      const { onViewportEnter: g, onViewportLeave: b } = this.node.getProps(), S = v ? g : b;
      S && S(h);
    };
    return use(this.node.current, u, f);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(fse(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function fse({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const pse = {
  inView: {
    Feature: dse
  },
  tap: {
    Feature: ise
  },
  focus: {
    Feature: ose
  },
  hover: {
    Feature: rse
  }
};
function D3(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let o = 0; o < n; o++)
    if (t[o] !== e[o])
      return !1;
  return !0;
}
function hse(e) {
  const t = {};
  return e.values.forEach((n, o) => t[o] = n.get()), t;
}
function mse(e) {
  const t = {};
  return e.values.forEach((n, o) => t[o] = n.getVelocity()), t;
}
function qE(e, t, n) {
  const o = e.getProps();
  return r2(o, t, n !== void 0 ? n : o.custom, hse(e), mse(e));
}
let mS = Hr, Es = Hr;
process.env.NODE_ENV !== "production" && (mS = (e, t) => {
  !e && typeof console < "u" && console.warn(t);
}, Es = (e, t) => {
  if (!e)
    throw new Error(t);
});
const uf = (e) => e * 1e3, Pc = (e) => e / 1e3, vse = {
  current: !1
}, N3 = (e) => Array.isArray(e) && typeof e[0] == "number";
function M3(e) {
  return !!(!e || typeof e == "string" && L3[e] || N3(e) || Array.isArray(e) && e.every(M3));
}
const d0 = ([e, t, n, o]) => `cubic-bezier(${e}, ${t}, ${n}, ${o})`, L3 = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: d0([0, 0.65, 0.55, 1]),
  circOut: d0([0.55, 0, 1, 0.45]),
  backIn: d0([0.31, 0.01, 0.66, -0.59]),
  backOut: d0([0.33, 1.53, 0.69, 0.99])
};
function F3(e) {
  if (e)
    return N3(e) ? d0(e) : Array.isArray(e) ? e.map(F3) : L3[e];
}
function gse(e, t, n, { delay: o = 0, duration: a, repeat: l = 0, repeatType: u = "loop", ease: f, times: h } = {}) {
  const v = { [t]: n };
  h && (v.offset = h);
  const g = F3(f);
  return Array.isArray(g) && (v.easing = g), e.animate(v, {
    delay: o,
    duration: a,
    easing: Array.isArray(g) ? "linear" : g,
    fill: "both",
    iterations: l + 1,
    direction: u === "reverse" ? "alternate" : "normal"
  });
}
function yse(e, { repeat: t, repeatType: n = "loop" }) {
  const o = t && n !== "loop" && t % 2 === 1 ? 0 : e.length - 1;
  return e[o];
}
const B3 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, bse = 1e-7, Sse = 12;
function xse(e, t, n, o, a) {
  let l, u, f = 0;
  do
    u = t + (n - t) / 2, l = B3(u, o, a) - e, l > 0 ? n = u : t = u;
  while (Math.abs(l) > bse && ++f < Sse);
  return u;
}
function vS(e, t, n, o) {
  if (e === t && n === o)
    return Hr;
  const a = (l) => xse(l, 0, 1, e, n);
  return (l) => l === 0 || l === 1 ? l : B3(a(l), t, o);
}
const Cse = vS(0.42, 0, 1, 1), wse = vS(0, 0, 0.58, 1), V3 = vS(0.42, 0, 0.58, 1), Ese = (e) => Array.isArray(e) && typeof e[0] != "number", $3 = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, z3 = (e) => (t) => 1 - e(1 - t), o2 = (e) => 1 - Math.sin(Math.acos(e)), H3 = z3(o2), Tse = $3(o2), j3 = vS(0.33, 1.53, 0.69, 0.99), i2 = z3(j3), Ise = $3(i2), Ase = (e) => (e *= 2) < 1 ? 0.5 * i2(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), eV = {
  linear: Hr,
  easeIn: Cse,
  easeInOut: V3,
  easeOut: wse,
  circIn: o2,
  circInOut: Tse,
  circOut: H3,
  backIn: i2,
  backInOut: Ise,
  backOut: j3,
  anticipate: Ase
}, tV = (e) => {
  if (Array.isArray(e)) {
    Es(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, o, a] = e;
    return vS(t, n, o, a);
  } else if (typeof e == "string")
    return Es(eV[e] !== void 0, `Invalid easing type '${e}'`), eV[e];
  return e;
}, a2 = (e, t) => (n) => !!(pS(n) && Pae.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), G3 = (e, t, n) => (o) => {
  if (!pS(o))
    return o;
  const [a, l, u, f] = o.match(QE);
  return {
    [e]: parseFloat(a),
    [t]: parseFloat(l),
    [n]: parseFloat(u),
    alpha: f !== void 0 ? parseFloat(f) : 1
  };
}, kse = (e) => ff(0, 255, e), DR = {
  ...vh,
  transform: (e) => Math.round(kse(e))
}, Jp = {
  test: a2("rgb", "red"),
  parse: G3("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: o = 1 }) => "rgba(" + DR.transform(e) + ", " + DR.transform(t) + ", " + DR.transform(n) + ", " + T0(E0.transform(o)) + ")"
};
function Rse(e) {
  let t = "", n = "", o = "", a = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), o = e.substring(5, 7), a = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), o = e.substring(3, 4), a = e.substring(4, 5), t += t, n += n, o += o, a += a), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(o, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const eO = {
  test: a2("#"),
  parse: Rse,
  transform: Jp.transform
}, Lv = {
  test: a2("hsl", "hue"),
  parse: G3("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: o = 1 }) => "hsla(" + Math.round(e) + ", " + mu.transform(T0(t)) + ", " + mu.transform(T0(n)) + ", " + T0(E0.transform(o)) + ")"
}, Vi = {
  test: (e) => Jp.test(e) || eO.test(e) || Lv.test(e),
  parse: (e) => Jp.test(e) ? Jp.parse(e) : Lv.test(e) ? Lv.parse(e) : eO.parse(e),
  transform: (e) => pS(e) ? e : e.hasOwnProperty("red") ? Jp.transform(e) : Lv.transform(e)
}, _r = (e, t, n) => -n * e + n * t + e;
function NR(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function Pse({ hue: e, saturation: t, lightness: n, alpha: o }) {
  e /= 360, t /= 100, n /= 100;
  let a = 0, l = 0, u = 0;
  if (!t)
    a = l = u = n;
  else {
    const f = n < 0.5 ? n * (1 + t) : n + t - n * t, h = 2 * n - f;
    a = NR(h, f, e + 1 / 3), l = NR(h, f, e), u = NR(h, f, e - 1 / 3);
  }
  return {
    red: Math.round(a * 255),
    green: Math.round(l * 255),
    blue: Math.round(u * 255),
    alpha: o
  };
}
const MR = (e, t, n) => {
  const o = e * e;
  return Math.sqrt(Math.max(0, n * (t * t - o) + o));
}, Ose = [eO, Jp, Lv], _se = (e) => Ose.find((t) => t.test(e));
function nV(e) {
  const t = _se(e);
  Es(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`);
  let n = t.parse(e);
  return t === Lv && (n = Pse(n)), n;
}
const W3 = (e, t) => {
  const n = nV(e), o = nV(t), a = { ...n };
  return (l) => (a.red = MR(n.red, o.red, l), a.green = MR(n.green, o.green, l), a.blue = MR(n.blue, o.blue, l), a.alpha = _r(n.alpha, o.alpha, l), Jp.transform(a));
};
function Dse(e) {
  var t, n;
  return isNaN(e) && pS(e) && (((t = e.match(QE)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(g3)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const U3 = {
  regex: kae,
  countKey: "Vars",
  token: "${v}",
  parse: Hr
}, X3 = {
  regex: g3,
  countKey: "Colors",
  token: "${c}",
  parse: Vi.parse
}, Z3 = {
  regex: QE,
  countKey: "Numbers",
  token: "${n}",
  parse: vh.parse
};
function LR(e, { regex: t, countKey: n, token: o, parse: a }) {
  const l = e.tokenised.match(t);
  l && (e["num" + n] = l.length, e.tokenised = e.tokenised.replace(t, o), e.values.push(...l.map(a)));
}
function Ww(e) {
  const t = e.toString(), n = {
    value: t,
    tokenised: t,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return n.value.includes("var(--") && LR(n, U3), LR(n, X3), LR(n, Z3), n;
}
function Y3(e) {
  return Ww(e).values;
}
function J3(e) {
  const { values: t, numColors: n, numVars: o, tokenised: a } = Ww(e), l = t.length;
  return (u) => {
    let f = a;
    for (let h = 0; h < l; h++)
      h < o ? f = f.replace(U3.token, u[h]) : h < o + n ? f = f.replace(X3.token, Vi.transform(u[h])) : f = f.replace(Z3.token, T0(u[h]));
    return f;
  };
}
const Nse = (e) => typeof e == "number" ? 0 : e;
function Mse(e) {
  const t = Y3(e);
  return J3(e)(t.map(Nse));
}
const pf = {
  test: Dse,
  parse: Y3,
  createTransformer: J3,
  getAnimatableNone: Mse
}, Q3 = (e, t) => (n) => `${n > 0 ? t : e}`;
function K3(e, t) {
  return typeof e == "number" ? (n) => _r(e, t, n) : Vi.test(e) ? W3(e, t) : e.startsWith("var(") ? Q3(e, t) : e9(e, t);
}
const q3 = (e, t) => {
  const n = [...e], o = n.length, a = e.map((l, u) => K3(l, t[u]));
  return (l) => {
    for (let u = 0; u < o; u++)
      n[u] = a[u](l);
    return n;
  };
}, Lse = (e, t) => {
  const n = { ...e, ...t }, o = {};
  for (const a in n)
    e[a] !== void 0 && t[a] !== void 0 && (o[a] = K3(e[a], t[a]));
  return (a) => {
    for (const l in o)
      n[l] = o[l](a);
    return n;
  };
}, e9 = (e, t) => {
  const n = pf.createTransformer(t), o = Ww(e), a = Ww(t);
  return o.numVars === a.numVars && o.numColors === a.numColors && o.numNumbers >= a.numNumbers ? lf(q3(o.values, a.values), n) : (mS(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Q3(e, t));
}, Y0 = (e, t, n) => {
  const o = t - e;
  return o === 0 ? 1 : (n - e) / o;
}, rV = (e, t) => (n) => _r(e, t, n);
function Fse(e) {
  return typeof e == "number" ? rV : typeof e == "string" ? Vi.test(e) ? W3 : e9 : Array.isArray(e) ? q3 : typeof e == "object" ? Lse : rV;
}
function Bse(e, t, n) {
  const o = [], a = n || Fse(e[0]), l = e.length - 1;
  for (let u = 0; u < l; u++) {
    let f = a(e[u], e[u + 1]);
    if (t) {
      const h = Array.isArray(t) ? t[u] || Hr : t;
      f = lf(h, f);
    }
    o.push(f);
  }
  return o;
}
function t9(e, t, { clamp: n = !0, ease: o, mixer: a } = {}) {
  const l = e.length;
  if (Es(l === t.length, "Both input and output ranges must be the same length"), l === 1)
    return () => t[0];
  e[0] > e[l - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const u = Bse(t, o, a), f = u.length, h = (v) => {
    let g = 0;
    if (f > 1)
      for (; g < e.length - 2 && !(v < e[g + 1]); g++)
        ;
    const b = Y0(e[g], e[g + 1], v);
    return u[g](b);
  };
  return n ? (v) => h(ff(e[0], e[l - 1], v)) : h;
}
function Vse(e, t) {
  const n = e[e.length - 1];
  for (let o = 1; o <= t; o++) {
    const a = Y0(0, t, o);
    e.push(_r(n, 1, a));
  }
}
function $se(e) {
  const t = [0];
  return Vse(t, e.length - 1), t;
}
function zse(e, t) {
  return e.map((n) => n * t);
}
function Hse(e, t) {
  return e.map(() => t || V3).splice(0, e.length - 1);
}
function Uw({ duration: e = 300, keyframes: t, times: n, ease: o = "easeInOut" }) {
  const a = Ese(o) ? o.map(tV) : tV(o), l = {
    done: !1,
    value: t[0]
  }, u = zse(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : $se(t),
    e
  ), f = t9(u, t, {
    ease: Array.isArray(a) ? a : Hse(t, a)
  });
  return {
    calculatedDuration: e,
    next: (h) => (l.value = f(h), l.done = h >= e, l)
  };
}
function n9(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const jse = 5;
function r9(e, t, n) {
  const o = Math.max(t - jse, 0);
  return n9(n - e(o), t - o);
}
const FR = 1e-3, Gse = 0.01, oV = 10, Wse = 0.05, Use = 1;
function Xse({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: o = 1 }) {
  let a, l;
  mS(e <= uf(oV), "Spring duration must be 10 seconds or less");
  let u = 1 - t;
  u = ff(Wse, Use, u), e = ff(Gse, oV, Pc(e)), u < 1 ? (a = (v) => {
    const g = v * u, b = g * e, S = g - n, w = tO(v, u), E = Math.exp(-b);
    return FR - S / w * E;
  }, l = (v) => {
    const b = v * u * e, S = b * n + n, w = Math.pow(u, 2) * Math.pow(v, 2) * e, E = Math.exp(-b), T = tO(Math.pow(v, 2), u);
    return (-a(v) + FR > 0 ? -1 : 1) * ((S - w) * E) / T;
  }) : (a = (v) => {
    const g = Math.exp(-v * e), b = (v - n) * e + 1;
    return -FR + g * b;
  }, l = (v) => {
    const g = Math.exp(-v * e), b = (n - v) * (e * e);
    return g * b;
  });
  const f = 5 / e, h = Yse(a, l, f);
  if (e = uf(e), isNaN(h))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const v = Math.pow(h, 2) * o;
    return {
      stiffness: v,
      damping: u * 2 * Math.sqrt(o * v),
      duration: e
    };
  }
}
const Zse = 12;
function Yse(e, t, n) {
  let o = n;
  for (let a = 1; a < Zse; a++)
    o = o - e(o) / t(o);
  return o;
}
function tO(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const Jse = ["duration", "bounce"], Qse = ["stiffness", "damping", "mass"];
function iV(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function Kse(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!iV(e, Qse) && iV(e, Jse)) {
    const n = Xse(e);
    t = {
      ...t,
      ...n,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
function o9({ keyframes: e, restDelta: t, restSpeed: n, ...o }) {
  const a = e[0], l = e[e.length - 1], u = { done: !1, value: a }, { stiffness: f, damping: h, mass: v, duration: g, velocity: b, isResolvedFromDuration: S } = Kse({
    ...o,
    velocity: -Pc(o.velocity || 0)
  }), w = b || 0, E = h / (2 * Math.sqrt(f * v)), T = l - a, A = Pc(Math.sqrt(f / v)), P = Math.abs(T) < 5;
  n || (n = P ? 0.01 : 2), t || (t = P ? 5e-3 : 0.5);
  let _;
  if (E < 1) {
    const D = tO(A, E);
    _ = (L) => {
      const F = Math.exp(-E * A * L);
      return l - F * ((w + E * A * T) / D * Math.sin(D * L) + T * Math.cos(D * L));
    };
  } else if (E === 1)
    _ = (D) => l - Math.exp(-A * D) * (T + (w + A * T) * D);
  else {
    const D = A * Math.sqrt(E * E - 1);
    _ = (L) => {
      const F = Math.exp(-E * A * L), V = Math.min(D * L, 300);
      return l - F * ((w + E * A * T) * Math.sinh(V) + D * T * Math.cosh(V)) / D;
    };
  }
  return {
    calculatedDuration: S && g || null,
    next: (D) => {
      const L = _(D);
      if (S)
        u.done = D >= g;
      else {
        let F = w;
        D !== 0 && (E < 1 ? F = r9(_, D, L) : F = 0);
        const V = Math.abs(F) <= n, $ = Math.abs(l - L) <= t;
        u.done = V && $;
      }
      return u.value = u.done ? l : L, u;
    }
  };
}
function aV({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: o = 325, bounceDamping: a = 10, bounceStiffness: l = 500, modifyTarget: u, min: f, max: h, restDelta: v = 0.5, restSpeed: g }) {
  const b = e[0], S = {
    done: !1,
    value: b
  }, w = (U) => f !== void 0 && U < f || h !== void 0 && U > h, E = (U) => f === void 0 ? h : h === void 0 || Math.abs(f - U) < Math.abs(h - U) ? f : h;
  let T = n * t;
  const A = b + T, P = u === void 0 ? A : u(A);
  P !== A && (T = P - b);
  const _ = (U) => -T * Math.exp(-U / o), D = (U) => P + _(U), L = (U) => {
    const W = _(U), H = D(U);
    S.done = Math.abs(W) <= v, S.value = S.done ? P : H;
  };
  let F, V;
  const $ = (U) => {
    w(S.value) && (F = U, V = o9({
      keyframes: [S.value, E(S.value)],
      velocity: r9(D, U, S.value),
      damping: a,
      stiffness: l,
      restDelta: v,
      restSpeed: g
    }));
  };
  return $(0), {
    calculatedDuration: null,
    next: (U) => {
      let W = !1;
      return !V && F === void 0 && (W = !0, L(U), $(U)), F !== void 0 && U > F ? V.next(U - F) : (!W && L(U), S);
    }
  };
}
const qse = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: () => gr.update(t, !0),
    stop: () => Mc(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => wi.isProcessing ? wi.timestamp : performance.now()
  };
}, sV = 2e4;
function lV(e) {
  let t = 0;
  const n = 50;
  let o = e.next(t);
  for (; !o.done && t < sV; )
    t += n, o = e.next(t);
  return t >= sV ? 1 / 0 : t;
}
const ele = {
  decay: aV,
  inertia: aV,
  tween: Uw,
  keyframes: Uw,
  spring: o9
};
function Xw({ autoplay: e = !0, delay: t = 0, driver: n = qse, keyframes: o, type: a = "keyframes", repeat: l = 0, repeatDelay: u = 0, repeatType: f = "loop", onPlay: h, onStop: v, onComplete: g, onUpdate: b, ...S }) {
  let w = 1, E = !1, T, A;
  const P = () => {
    A = new Promise((q) => {
      T = q;
    });
  };
  P();
  let _;
  const D = ele[a] || Uw;
  let L;
  D !== Uw && typeof o[0] != "number" && (process.env.NODE_ENV !== "production" && Es(o.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${o}`), L = t9([0, 100], o, {
    clamp: !1
  }), o = [0, 100]);
  const F = D({ ...S, keyframes: o });
  let V;
  f === "mirror" && (V = D({
    ...S,
    keyframes: [...o].reverse(),
    velocity: -(S.velocity || 0)
  }));
  let $ = "idle", U = null, W = null, H = null;
  F.calculatedDuration === null && l && (F.calculatedDuration = lV(F));
  const { calculatedDuration: G } = F;
  let oe = 1 / 0, ce = 1 / 0;
  G !== null && (oe = G + u, ce = oe * (l + 1) - u);
  let te = 0;
  const Ee = (q) => {
    if (W === null)
      return;
    w > 0 && (W = Math.min(W, q)), w < 0 && (W = Math.min(q - ce / w, W)), U !== null ? te = U : te = Math.round(q - W) * w;
    const de = te - t * (w >= 0 ? 1 : -1), K = w >= 0 ? de < 0 : de > ce;
    te = Math.max(de, 0), $ === "finished" && U === null && (te = ce);
    let ne = te, pe = F;
    if (l) {
      const ie = Math.min(te, ce) / oe;
      let ye = Math.floor(ie), we = ie % 1;
      !we && ie >= 1 && (we = 1), we === 1 && ye--, ye = Math.min(ye, l + 1), !!(ye % 2) && (f === "reverse" ? (we = 1 - we, u && (we -= u / oe)) : f === "mirror" && (pe = V)), ne = ff(0, 1, we) * oe;
    }
    const Oe = K ? { done: !1, value: o[0] } : pe.next(ne);
    L && (Oe.value = L(Oe.value));
    let { done: Ce } = Oe;
    !K && G !== null && (Ce = w >= 0 ? te >= ce : te <= 0);
    const xe = U === null && ($ === "finished" || $ === "running" && Ce);
    return b && b(Oe.value), xe && Q(), Oe;
  }, me = () => {
    _ && _.stop(), _ = void 0;
  }, J = () => {
    $ = "idle", me(), T(), P(), W = H = null;
  }, Q = () => {
    $ = "finished", g && g(), me(), T();
  }, ge = () => {
    if (E)
      return;
    _ || (_ = n(Ee));
    const q = _.now();
    h && h(), U !== null ? W = q - U : (!W || $ === "finished") && (W = q), $ === "finished" && P(), H = W, U = null, $ = "running", _.start();
  };
  e && ge();
  const Y = {
    then(q, de) {
      return A.then(q, de);
    },
    get time() {
      return Pc(te);
    },
    set time(q) {
      q = uf(q), te = q, U !== null || !_ || w === 0 ? U = q : W = _.now() - q / w;
    },
    get duration() {
      const q = F.calculatedDuration === null ? lV(F) : F.calculatedDuration;
      return Pc(q);
    },
    get speed() {
      return w;
    },
    set speed(q) {
      q === w || !_ || (w = q, Y.time = Pc(te));
    },
    get state() {
      return $;
    },
    play: ge,
    pause: () => {
      $ = "paused", U = te;
    },
    stop: () => {
      E = !0, $ !== "idle" && ($ = "idle", v && v(), J());
    },
    cancel: () => {
      H !== null && Ee(H), J();
    },
    complete: () => {
      $ = "finished";
    },
    sample: (q) => (W = 0, Ee(q))
  };
  return Y;
}
function tle(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const nle = tle(() => Object.hasOwnProperty.call(Element.prototype, "animate")), rle = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), OC = 10, ole = 2e4, ile = (e, t) => t.type === "spring" || e === "backgroundColor" || !M3(t.ease);
function ale(e, t, { onUpdate: n, onComplete: o, ...a }) {
  if (!(nle() && rle.has(t) && !a.repeatDelay && a.repeatType !== "mirror" && a.damping !== 0 && a.type !== "inertia"))
    return !1;
  let u = !1, f, h, v = !1;
  const g = () => {
    h = new Promise((D) => {
      f = D;
    });
  };
  g();
  let { keyframes: b, duration: S = 300, ease: w, times: E } = a;
  if (ile(t, a)) {
    const D = Xw({
      ...a,
      repeat: 0,
      delay: 0
    });
    let L = { done: !1, value: b[0] };
    const F = [];
    let V = 0;
    for (; !L.done && V < ole; )
      L = D.sample(V), F.push(L.value), V += OC;
    E = void 0, b = F, S = V - OC, w = "linear";
  }
  const T = gse(e.owner.current, t, b, {
    ...a,
    duration: S,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: w,
    times: E
  }), A = () => {
    v = !1, T.cancel();
  }, P = () => {
    v = !0, gr.update(A), f(), g();
  };
  return T.onfinish = () => {
    v || (e.set(yse(b, a)), o && o(), P());
  }, {
    then(D, L) {
      return h.then(D, L);
    },
    attachTimeline(D) {
      return T.timeline = D, T.onfinish = null, Hr;
    },
    get time() {
      return Pc(T.currentTime || 0);
    },
    set time(D) {
      T.currentTime = uf(D);
    },
    get speed() {
      return T.playbackRate;
    },
    set speed(D) {
      T.playbackRate = D;
    },
    get duration() {
      return Pc(S);
    },
    play: () => {
      u || (T.play(), Mc(A));
    },
    pause: () => T.pause(),
    stop: () => {
      if (u = !0, T.playState === "idle")
        return;
      const { currentTime: D } = T;
      if (D) {
        const L = Xw({
          ...a,
          autoplay: !1
        });
        e.setWithVelocity(L.sample(D - OC).value, L.sample(D).value, OC);
      }
      P();
    },
    complete: () => {
      v || T.finish();
    },
    cancel: P
  };
}
function sle({ keyframes: e, delay: t, onUpdate: n, onComplete: o }) {
  const a = () => (n && n(e[e.length - 1]), o && o(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: Hr,
    pause: Hr,
    stop: Hr,
    then: (l) => (l(), Promise.resolve()),
    cancel: Hr,
    complete: Hr
  });
  return t ? Xw({
    keyframes: [0, 1],
    duration: 0,
    delay: t,
    onComplete: a
  }) : a();
}
const lle = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, ule = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), cle = {
  type: "keyframes",
  duration: 0.8
}, dle = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, fle = (e, { keyframes: t }) => t.length > 2 ? cle : mh.has(e) ? e.startsWith("scale") ? ule(t[1]) : lle : dle, nO = (e, t) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(pf.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url(")), ple = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function hle(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [o] = n.match(QE) || [];
  if (!o)
    return e;
  const a = n.replace(o, "");
  let l = ple.has(t) ? 1 : 0;
  return o !== n && (l *= 100), t + "(" + l + a + ")";
}
const mle = /([a-z-]*)\(.*?\)/g, rO = {
  ...pf,
  getAnimatableNone: (e) => {
    const t = e.match(mle);
    return t ? t.map(hle).join(" ") : e;
  }
}, vle = {
  ...y3,
  // Color props
  color: Vi,
  backgroundColor: Vi,
  outlineColor: Vi,
  fill: Vi,
  stroke: Vi,
  // Border props
  borderColor: Vi,
  borderTopColor: Vi,
  borderRightColor: Vi,
  borderBottomColor: Vi,
  borderLeftColor: Vi,
  filter: rO,
  WebkitFilter: rO
}, s2 = (e) => vle[e];
function i9(e, t) {
  let n = s2(e);
  return n !== rO && (n = pf), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const a9 = (e) => /^0[^.\s]+$/.test(e);
function gle(e) {
  if (typeof e == "number")
    return e === 0;
  if (e !== null)
    return e === "none" || e === "0" || a9(e);
}
function yle(e, t, n, o) {
  const a = nO(t, n);
  let l;
  Array.isArray(n) ? l = [...n] : l = [null, n];
  const u = o.from !== void 0 ? o.from : e.get();
  let f;
  const h = [];
  for (let v = 0; v < l.length; v++)
    l[v] === null && (l[v] = v === 0 ? u : l[v - 1]), gle(l[v]) && h.push(v), typeof l[v] == "string" && l[v] !== "none" && l[v] !== "0" && (f = l[v]);
  if (a && h.length && f)
    for (let v = 0; v < h.length; v++) {
      const g = h[v];
      l[g] = i9(t, f);
    }
  return l;
}
function ble({ when: e, delay: t, delayChildren: n, staggerChildren: o, staggerDirection: a, repeat: l, repeatType: u, repeatDelay: f, from: h, elapsed: v, ...g }) {
  return !!Object.keys(g).length;
}
function l2(e, t) {
  return e[t] || e.default || e;
}
const Sle = {
  skipAnimations: !1
}, u2 = (e, t, n, o = {}) => (a) => {
  const l = l2(o, e) || {}, u = l.delay || o.delay || 0;
  let { elapsed: f = 0 } = o;
  f = f - uf(u);
  const h = yle(t, e, n, l), v = h[0], g = h[h.length - 1], b = nO(e, v), S = nO(e, g);
  mS(b === S, `You are trying to animate ${e} from "${v}" to "${g}". ${v} is not an animatable value - to enable this animation set ${v} to a value animatable to ${g} via the \`style\` property.`);
  let w = {
    keyframes: h,
    velocity: t.getVelocity(),
    ease: "easeOut",
    ...l,
    delay: -f,
    onUpdate: (E) => {
      t.set(E), l.onUpdate && l.onUpdate(E);
    },
    onComplete: () => {
      a(), l.onComplete && l.onComplete();
    }
  };
  if (ble(l) || (w = {
    ...w,
    ...fle(e, w)
  }), w.duration && (w.duration = uf(w.duration)), w.repeatDelay && (w.repeatDelay = uf(w.repeatDelay)), !b || !S || vse.current || l.type === !1 || Sle.skipAnimations)
    return sle(w);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !o.isHandoff && t.owner && t.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !t.owner.getProps().onUpdate
  ) {
    const E = ale(t, e, w);
    if (E)
      return E;
  }
  return Xw(w);
};
function Zw(e) {
  return !!(Sa(e) && e.add);
}
const s9 = (e) => /^\-?\d*\.?\d+$/.test(e);
function c2(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function d2(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class f2 {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return c2(this.subscriptions, t), () => d2(this.subscriptions, t);
  }
  notify(t, n, o) {
    const a = this.subscriptions.length;
    if (a)
      if (a === 1)
        this.subscriptions[0](t, n, o);
      else
        for (let l = 0; l < a; l++) {
          const u = this.subscriptions[l];
          u && u(t, n, o);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const uV = /* @__PURE__ */ new Set();
function p2(e, t, n) {
  e || uV.has(t) || (console.warn(t), n && console.warn(n), uV.add(t));
}
const xle = (e) => !isNaN(parseFloat(e));
class Cle {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "10.18.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (o, a = !0) => {
      this.prev = this.current, this.current = o;
      const { delta: l, timestamp: u } = wi;
      this.lastUpdated !== u && (this.timeDelta = l, this.lastUpdated = u, gr.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), a && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => gr.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: o }) => {
      o !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = t, this.canTrackVelocity = xle(this.current), this.owner = n.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return process.env.NODE_ENV !== "production" && p2(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new f2());
    const o = this.events[t].add(n);
    return t === "change" ? () => {
      o(), gr.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : o;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, o) {
    this.set(n), this.prev = t, this.timeDelta = o;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t) {
    this.updateAndNotify(t), this.prev = t, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      n9(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function ug(e, t) {
  return new Cle(e, t);
}
const l9 = (e) => (t) => t.test(e), wle = {
  test: (e) => e === "auto",
  parse: (e) => e
}, u9 = [vh, Wt, mu, qd, _ae, Oae, wle], Zb = (e) => u9.find(l9(e)), Ele = [...u9, Vi, pf], Tle = (e) => Ele.find(l9(e));
function Ile(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, ug(n));
}
function Ale(e, t) {
  const n = qE(e, t);
  let { transitionEnd: o = {}, transition: a = {}, ...l } = n ? e.makeTargetAnimatable(n, !1) : {};
  l = { ...l, ...o };
  for (const u in l) {
    const f = Uae(l[u]);
    Ile(e, u, f);
  }
}
function kle(e, t, n) {
  var o, a;
  const l = Object.keys(t).filter((f) => !e.hasValue(f)), u = l.length;
  if (u)
    for (let f = 0; f < u; f++) {
      const h = l[f], v = t[h];
      let g = null;
      Array.isArray(v) && (g = v[0]), g === null && (g = (a = (o = n[h]) !== null && o !== void 0 ? o : e.readValue(h)) !== null && a !== void 0 ? a : t[h]), g != null && (typeof g == "string" && (s9(g) || a9(g)) ? g = parseFloat(g) : !Tle(g) && pf.test(v) && (g = i9(h, v)), e.addValue(h, ug(g, { owner: e })), n[h] === void 0 && (n[h] = g), g !== null && e.setBaseTarget(h, g));
    }
}
function Rle(e, t) {
  return t ? (t[e] || t.default || t).from : void 0;
}
function Ple(e, t, n) {
  const o = {};
  for (const a in e) {
    const l = Rle(a, t);
    if (l !== void 0)
      o[a] = l;
    else {
      const u = n.getValue(a);
      u && (o[a] = u.get());
    }
  }
  return o;
}
function Ole({ protectedKeys: e, needsAnimating: t }, n) {
  const o = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, o;
}
function _le(e, t) {
  const n = e.get();
  if (Array.isArray(t)) {
    for (let o = 0; o < t.length; o++)
      if (t[o] !== n)
        return !0;
  } else
    return n !== t;
}
function c9(e, t, { delay: n = 0, transitionOverride: o, type: a } = {}) {
  let { transition: l = e.getDefaultTransition(), transitionEnd: u, ...f } = e.makeTargetAnimatable(t);
  const h = e.getValue("willChange");
  o && (l = o);
  const v = [], g = a && e.animationState && e.animationState.getState()[a];
  for (const b in f) {
    const S = e.getValue(b), w = f[b];
    if (!S || w === void 0 || g && Ole(g, b))
      continue;
    const E = {
      delay: n,
      elapsed: 0,
      ...l2(l || {}, b)
    };
    if (window.HandoffAppearAnimations) {
      const P = e.getProps()[d3];
      if (P) {
        const _ = window.HandoffAppearAnimations(P, b, S, gr);
        _ !== null && (E.elapsed = _, E.isHandoff = !0);
      }
    }
    let T = !E.isHandoff && !_le(S, w);
    if (E.type === "spring" && (S.getVelocity() || E.velocity) && (T = !1), S.animation && (T = !1), T)
      continue;
    S.start(u2(b, S, w, e.shouldReduceMotion && mh.has(b) ? { type: !1 } : E));
    const A = S.animation;
    Zw(h) && (h.add(b), A.then(() => h.remove(b))), v.push(A);
  }
  return u && Promise.all(v).then(() => {
    u && Ale(e, u);
  }), v;
}
function oO(e, t, n = {}) {
  const o = qE(e, t, n.custom);
  let { transition: a = e.getDefaultTransition() || {} } = o || {};
  n.transitionOverride && (a = n.transitionOverride);
  const l = o ? () => Promise.all(c9(e, o, n)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => {
    const { delayChildren: v = 0, staggerChildren: g, staggerDirection: b } = a;
    return Dle(e, t, v + h, g, b, n);
  } : () => Promise.resolve(), { when: f } = a;
  if (f) {
    const [h, v] = f === "beforeChildren" ? [l, u] : [u, l];
    return h().then(() => v());
  } else
    return Promise.all([l(), u(n.delay)]);
}
function Dle(e, t, n = 0, o = 0, a = 1, l) {
  const u = [], f = (e.variantChildren.size - 1) * o, h = a === 1 ? (v = 0) => v * o : (v = 0) => f - v * o;
  return Array.from(e.variantChildren).sort(Nle).forEach((v, g) => {
    v.notify("AnimationStart", t), u.push(oO(v, t, {
      ...l,
      delay: n + h(g)
    }).then(() => v.notify("AnimationComplete", t)));
  }), Promise.all(u);
}
function Nle(e, t) {
  return e.sortNodePosition(t);
}
function Mle(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let o;
  if (Array.isArray(t)) {
    const a = t.map((l) => oO(e, l, n));
    o = Promise.all(a);
  } else if (typeof t == "string")
    o = oO(e, t, n);
  else {
    const a = typeof t == "function" ? qE(e, t, n.custom) : t;
    o = Promise.all(c9(e, a, n));
  }
  return o.then(() => e.notify("AnimationComplete", t));
}
const Lle = [...Z_].reverse(), Fle = Z_.length;
function Ble(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: o }) => Mle(e, n, o)));
}
function Vle(e) {
  let t = Ble(e);
  const n = zle();
  let o = !0;
  const a = (h, v) => {
    const g = qE(e, v);
    if (g) {
      const { transition: b, transitionEnd: S, ...w } = g;
      h = { ...h, ...w, ...S };
    }
    return h;
  };
  function l(h) {
    t = h(e);
  }
  function u(h, v) {
    const g = e.getProps(), b = e.getVariantContext(!0) || {}, S = [], w = /* @__PURE__ */ new Set();
    let E = {}, T = 1 / 0;
    for (let P = 0; P < Fle; P++) {
      const _ = Lle[P], D = n[_], L = g[_] !== void 0 ? g[_] : b[_], F = X0(L), V = _ === v ? D.isActive : null;
      V === !1 && (T = P);
      let $ = L === b[_] && L !== g[_] && F;
      if ($ && o && e.manuallyAnimateOnMount && ($ = !1), D.protectedKeys = { ...E }, // If it isn't active and hasn't *just* been set as inactive
      !D.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !L && !D.prevProp || // Or if the prop doesn't define an animation
      YE(L) || typeof L == "boolean")
        continue;
      let W = $le(D.prevProp, L) || // If we're making this variant active, we want to always make it active
      _ === v && D.isActive && !$ && F || // If we removed a higher-priority variant (i is in reverse order)
      P > T && F, H = !1;
      const G = Array.isArray(L) ? L : [L];
      let oe = G.reduce(a, {});
      V === !1 && (oe = {});
      const { prevResolvedValues: ce = {} } = D, te = {
        ...ce,
        ...oe
      }, Ee = (me) => {
        W = !0, w.has(me) && (H = !0, w.delete(me)), D.needsAnimating[me] = !0;
      };
      for (const me in te) {
        const J = oe[me], Q = ce[me];
        if (E.hasOwnProperty(me))
          continue;
        let ge = !1;
        Gw(J) && Gw(Q) ? ge = !D3(J, Q) : ge = J !== Q, ge ? J !== void 0 ? Ee(me) : w.add(me) : J !== void 0 && w.has(me) ? Ee(me) : D.protectedKeys[me] = !0;
      }
      D.prevProp = L, D.prevResolvedValues = oe, D.isActive && (E = { ...E, ...oe }), o && e.blockInitialAnimation && (W = !1), W && (!$ || H) && S.push(...G.map((me) => ({
        animation: me,
        options: { type: _, ...h }
      })));
    }
    if (w.size) {
      const P = {};
      w.forEach((_) => {
        const D = e.getBaseTarget(_);
        D !== void 0 && (P[_] = D);
      }), S.push({ animation: P });
    }
    let A = !!S.length;
    return o && (g.initial === !1 || g.initial === g.animate) && !e.manuallyAnimateOnMount && (A = !1), o = !1, A ? t(S) : Promise.resolve();
  }
  function f(h, v, g) {
    var b;
    if (n[h].isActive === v)
      return Promise.resolve();
    (b = e.variantChildren) === null || b === void 0 || b.forEach((w) => {
      var E;
      return (E = w.animationState) === null || E === void 0 ? void 0 : E.setActive(h, v);
    }), n[h].isActive = v;
    const S = u(g, h);
    for (const w in n)
      n[w].protectedKeys = {};
    return S;
  }
  return {
    animateChanges: u,
    setActive: f,
    setAnimateFunction: l,
    getState: () => n
  };
}
function $le(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !D3(t, e) : !1;
}
function Vp(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function zle() {
  return {
    animate: Vp(!0),
    whileInView: Vp(),
    whileHover: Vp(),
    whileTap: Vp(),
    whileDrag: Vp(),
    whileFocus: Vp(),
    exit: Vp()
  };
}
class Hle extends Ef {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Vle(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    this.unmount(), YE(t) && (this.unmount = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let jle = 0;
class Gle extends Ef {
  constructor() {
    super(...arguments), this.id = jle++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n, custom: o } = this.node.presenceContext, { isPresent: a } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === a)
      return;
    const l = this.node.animationState.setActive("exit", !t, { custom: o ?? this.node.getProps().custom });
    n && !t && l.then(() => n(this.id));
  }
  mount() {
    const { register: t } = this.node.presenceContext || {};
    t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const Wle = {
  animation: {
    Feature: Hle
  },
  exit: {
    Feature: Gle
  }
}, cV = (e, t) => Math.abs(e - t);
function Ule(e, t) {
  const n = cV(e.x, t.x), o = cV(e.y, t.y);
  return Math.sqrt(n ** 2 + o ** 2);
}
class d9 {
  constructor(t, n, { transformPagePoint: o, contextWindow: a, dragSnapToOrigin: l = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const b = VR(this.lastMoveEventInfo, this.history), S = this.startEvent !== null, w = Ule(b.offset, { x: 0, y: 0 }) >= 3;
      if (!S && !w)
        return;
      const { point: E } = b, { timestamp: T } = wi;
      this.history.push({ ...E, timestamp: T });
      const { onStart: A, onMove: P } = this.handlers;
      S || (A && A(this.lastMoveEvent, b), this.startEvent = this.lastMoveEvent), P && P(this.lastMoveEvent, b);
    }, this.handlePointerMove = (b, S) => {
      this.lastMoveEvent = b, this.lastMoveEventInfo = BR(S, this.transformPagePoint), gr.update(this.updatePoint, !0);
    }, this.handlePointerUp = (b, S) => {
      this.end();
      const { onEnd: w, onSessionEnd: E, resumeAnimation: T } = this.handlers;
      if (this.dragSnapToOrigin && T && T(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = VR(b.type === "pointercancel" ? this.lastMoveEventInfo : BR(S, this.transformPagePoint), this.history);
      this.startEvent && w && w(b, A), E && E(b, A);
    }, !k3(t))
      return;
    this.dragSnapToOrigin = l, this.handlers = n, this.transformPagePoint = o, this.contextWindow = a || window;
    const u = KE(t), f = BR(u, this.transformPagePoint), { point: h } = f, { timestamp: v } = wi;
    this.history = [{ ...h, timestamp: v }];
    const { onSessionStart: g } = n;
    g && g(t, VR(f, this.history)), this.removeListeners = lf(Rc(this.contextWindow, "pointermove", this.handlePointerMove), Rc(this.contextWindow, "pointerup", this.handlePointerUp), Rc(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), Mc(this.updatePoint);
  }
}
function BR(e, t) {
  return t ? { point: t(e.point) } : e;
}
function dV(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function VR({ point: e }, t) {
  return {
    point: e,
    delta: dV(e, f9(t)),
    offset: dV(e, Xle(t)),
    velocity: Zle(t, 0.1)
  };
}
function Xle(e) {
  return e[0];
}
function f9(e) {
  return e[e.length - 1];
}
function Zle(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, o = null;
  const a = f9(e);
  for (; n >= 0 && (o = e[n], !(a.timestamp - o.timestamp > uf(t))); )
    n--;
  if (!o)
    return { x: 0, y: 0 };
  const l = Pc(a.timestamp - o.timestamp);
  if (l === 0)
    return { x: 0, y: 0 };
  const u = {
    x: (a.x - o.x) / l,
    y: (a.y - o.y) / l
  };
  return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u;
}
function Ua(e) {
  return e.max - e.min;
}
function iO(e, t = 0, n = 0.01) {
  return Math.abs(e - t) <= n;
}
function fV(e, t, n, o = 0.5) {
  e.origin = o, e.originPoint = _r(t.min, t.max, e.origin), e.scale = Ua(n) / Ua(t), (iO(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = _r(n.min, n.max, e.origin) - e.originPoint, (iO(e.translate) || isNaN(e.translate)) && (e.translate = 0);
}
function I0(e, t, n, o) {
  fV(e.x, t.x, n.x, o ? o.originX : void 0), fV(e.y, t.y, n.y, o ? o.originY : void 0);
}
function pV(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Ua(t);
}
function Yle(e, t, n) {
  pV(e.x, t.x, n.x), pV(e.y, t.y, n.y);
}
function hV(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Ua(t);
}
function A0(e, t, n) {
  hV(e.x, t.x, n.x), hV(e.y, t.y, n.y);
}
function Jle(e, { min: t, max: n }, o) {
  return t !== void 0 && e < t ? e = o ? _r(t, e, o.min) : Math.max(e, t) : n !== void 0 && e > n && (e = o ? _r(n, e, o.max) : Math.min(e, n)), e;
}
function mV(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function Qle(e, { top: t, left: n, bottom: o, right: a }) {
  return {
    x: mV(e.x, n, a),
    y: mV(e.y, t, o)
  };
}
function vV(e, t) {
  let n = t.min - e.min, o = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, o] = [o, n]), { min: n, max: o };
}
function Kle(e, t) {
  return {
    x: vV(e.x, t.x),
    y: vV(e.y, t.y)
  };
}
function qle(e, t) {
  let n = 0.5;
  const o = Ua(e), a = Ua(t);
  return a > o ? n = Y0(t.min, t.max - o, e.min) : o > a && (n = Y0(e.min, e.max - a, t.min)), ff(0, 1, n);
}
function eue(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const aO = 0.35;
function tue(e = aO) {
  return e === !1 ? e = 0 : e === !0 && (e = aO), {
    x: gV(e, "left", "right"),
    y: gV(e, "top", "bottom")
  };
}
function gV(e, t, n) {
  return {
    min: yV(e, t),
    max: yV(e, n)
  };
}
function yV(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const bV = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Fv = () => ({
  x: bV(),
  y: bV()
}), SV = () => ({ min: 0, max: 0 }), co = () => ({
  x: SV(),
  y: SV()
});
function vs(e) {
  return [e("x"), e("y")];
}
function p9({ top: e, left: t, right: n, bottom: o }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: o }
  };
}
function nue({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function rue(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), o = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: o.y,
    right: o.x
  };
}
function $R(e) {
  return e === void 0 || e === 1;
}
function sO({ scale: e, scaleX: t, scaleY: n }) {
  return !$R(e) || !$R(t) || !$R(n);
}
function zp(e) {
  return sO(e) || h9(e) || e.z || e.rotate || e.rotateX || e.rotateY;
}
function h9(e) {
  return xV(e.x) || xV(e.y);
}
function xV(e) {
  return e && e !== "0%";
}
function Yw(e, t, n) {
  const o = e - n, a = t * o;
  return n + a;
}
function CV(e, t, n, o, a) {
  return a !== void 0 && (e = Yw(e, a, o)), Yw(e, n, o) + t;
}
function lO(e, t = 0, n = 1, o, a) {
  e.min = CV(e.min, t, n, o, a), e.max = CV(e.max, t, n, o, a);
}
function m9(e, { x: t, y: n }) {
  lO(e.x, t.translate, t.scale, t.originPoint), lO(e.y, n.translate, n.scale, n.originPoint);
}
function oue(e, t, n, o = !1) {
  const a = n.length;
  if (!a)
    return;
  t.x = t.y = 1;
  let l, u;
  for (let f = 0; f < a; f++) {
    l = n[f], u = l.projectionDelta;
    const h = l.instance;
    h && h.style && h.style.display === "contents" || (o && l.options.layoutScroll && l.scroll && l !== l.root && Bv(e, {
      x: -l.scroll.offset.x,
      y: -l.scroll.offset.y
    }), u && (t.x *= u.x.scale, t.y *= u.y.scale, m9(e, u)), o && zp(l.latestValues) && Bv(e, l.latestValues));
  }
  t.x = wV(t.x), t.y = wV(t.y);
}
function wV(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999 ? e : 1;
}
function nf(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function EV(e, t, [n, o, a]) {
  const l = t[a] !== void 0 ? t[a] : 0.5, u = _r(e.min, e.max, l);
  lO(e, t[n], t[o], u, t.scale);
}
const iue = ["x", "scaleX", "originX"], aue = ["y", "scaleY", "originY"];
function Bv(e, t) {
  EV(e.x, t, iue), EV(e.y, t, aue);
}
function v9(e, t) {
  return p9(rue(e.getBoundingClientRect(), t));
}
function sue(e, t, n) {
  const o = v9(e, n), { scroll: a } = t;
  return a && (nf(o.x, a.offset.x), nf(o.y, a.offset.y)), o;
}
const g9 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, lue = /* @__PURE__ */ new WeakMap();
class uue {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = co(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: o } = this.visualElement;
    if (o && o.isPresent === !1)
      return;
    const a = (g) => {
      const { dragSnapToOrigin: b } = this.getProps();
      b ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(KE(g, "page").point);
    }, l = (g, b) => {
      const { drag: S, dragPropagation: w, onDragStart: E } = this.getProps();
      if (S && !w && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = P3(S), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), vs((A) => {
        let P = this.getAxisMotionValue(A).get() || 0;
        if (mu.test(P)) {
          const { projection: _ } = this.visualElement;
          if (_ && _.layout) {
            const D = _.layout.layoutBox[A];
            D && (P = Ua(D) * (parseFloat(P) / 100));
          }
        }
        this.originPoint[A] = P;
      }), E && gr.update(() => E(g, b), !1, !0);
      const { animationState: T } = this.visualElement;
      T && T.setActive("whileDrag", !0);
    }, u = (g, b) => {
      const { dragPropagation: S, dragDirectionLock: w, onDirectionLock: E, onDrag: T } = this.getProps();
      if (!S && !this.openGlobalLock)
        return;
      const { offset: A } = b;
      if (w && this.currentDirection === null) {
        this.currentDirection = cue(A), this.currentDirection !== null && E && E(this.currentDirection);
        return;
      }
      this.updateAxis("x", b.point, A), this.updateAxis("y", b.point, A), this.visualElement.render(), T && T(g, b);
    }, f = (g, b) => this.stop(g, b), h = () => vs((g) => {
      var b;
      return this.getAnimationState(g) === "paused" && ((b = this.getAxisMotionValue(g).animation) === null || b === void 0 ? void 0 : b.play());
    }), { dragSnapToOrigin: v } = this.getProps();
    this.panSession = new d9(t, {
      onSessionStart: a,
      onStart: l,
      onMove: u,
      onSessionEnd: f,
      resumeAnimation: h
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: v,
      contextWindow: g9(this.visualElement)
    });
  }
  stop(t, n) {
    const o = this.isDragging;
    if (this.cancel(), !o)
      return;
    const { velocity: a } = n;
    this.startAnimation(a);
    const { onDragEnd: l } = this.getProps();
    l && gr.update(() => l(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: o } = this.getProps();
    !o && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, o) {
    const { drag: a } = this.getProps();
    if (!o || !_C(t, a, this.currentDirection))
      return;
    const l = this.getAxisMotionValue(t);
    let u = this.originPoint[t] + o[t];
    this.constraints && this.constraints[t] && (u = Jle(u, this.constraints[t], this.elastic[t])), l.set(u);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: o } = this.getProps(), a = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, l = this.constraints;
    n && Mv(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && a ? this.constraints = Qle(a.layoutBox, n) : this.constraints = !1, this.elastic = tue(o), l !== this.constraints && a && this.constraints && !this.hasMutatedConstraints && vs((u) => {
      this.getAxisMotionValue(u) && (this.constraints[u] = eue(a.layoutBox[u], this.constraints[u]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !Mv(t))
      return !1;
    const o = t.current;
    Es(o !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: a } = this.visualElement;
    if (!a || !a.layout)
      return !1;
    const l = sue(o, a.root, this.visualElement.getTransformPagePoint());
    let u = Kle(a.layout.layoutBox, l);
    if (n) {
      const f = n(nue(u));
      this.hasMutatedConstraints = !!f, f && (u = p9(f));
    }
    return u;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: o, dragElastic: a, dragTransition: l, dragSnapToOrigin: u, onDragTransitionEnd: f } = this.getProps(), h = this.constraints || {}, v = vs((g) => {
      if (!_C(g, n, this.currentDirection))
        return;
      let b = h && h[g] || {};
      u && (b = { min: 0, max: 0 });
      const S = a ? 200 : 1e6, w = a ? 40 : 1e7, E = {
        type: "inertia",
        velocity: o ? t[g] : 0,
        bounceStiffness: S,
        bounceDamping: w,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...l,
        ...b
      };
      return this.startAxisValueAnimation(g, E);
    });
    return Promise.all(v).then(f);
  }
  startAxisValueAnimation(t, n) {
    const o = this.getAxisMotionValue(t);
    return o.start(u2(t, o, 0, n));
  }
  stopAnimation() {
    vs((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    vs((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = "_drag" + t.toUpperCase(), o = this.visualElement.getProps(), a = o[n];
    return a || this.visualElement.getValue(t, (o.initial ? o.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    vs((n) => {
      const { drag: o } = this.getProps();
      if (!_C(n, o, this.currentDirection))
        return;
      const { projection: a } = this.visualElement, l = this.getAxisMotionValue(n);
      if (a && a.layout) {
        const { min: u, max: f } = a.layout.layoutBox[n];
        l.set(t[n] - _r(u, f, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: o } = this.visualElement;
    if (!Mv(n) || !o || !this.constraints)
      return;
    this.stopAnimation();
    const a = { x: 0, y: 0 };
    vs((u) => {
      const f = this.getAxisMotionValue(u);
      if (f) {
        const h = f.get();
        a[u] = qle({ min: h, max: h }, this.constraints[u]);
      }
    });
    const { transformTemplate: l } = this.visualElement.getProps();
    this.visualElement.current.style.transform = l ? l({}, "") : "none", o.root && o.root.updateScroll(), o.updateLayout(), this.resolveConstraints(), vs((u) => {
      if (!_C(u, t, null))
        return;
      const f = this.getAxisMotionValue(u), { min: h, max: v } = this.constraints[u];
      f.set(_r(h, v, a[u]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    lue.set(this.visualElement, this);
    const t = this.visualElement.current, n = Rc(t, "pointerdown", (h) => {
      const { drag: v, dragListener: g = !0 } = this.getProps();
      v && g && this.start(h);
    }), o = () => {
      const { dragConstraints: h } = this.getProps();
      Mv(h) && (this.constraints = this.resolveRefConstraints());
    }, { projection: a } = this.visualElement, l = a.addEventListener("measure", o);
    a && !a.layout && (a.root && a.root.updateScroll(), a.updateLayout()), o();
    const u = Tc(window, "resize", () => this.scalePositionWithinConstraints()), f = a.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: v }) => {
      this.isDragging && v && (vs((g) => {
        const b = this.getAxisMotionValue(g);
        b && (this.originPoint[g] += h[g].translate, b.set(b.get() + h[g].translate));
      }), this.visualElement.render());
    });
    return () => {
      u(), n(), l(), f && f();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: o = !1, dragPropagation: a = !1, dragConstraints: l = !1, dragElastic: u = aO, dragMomentum: f = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: o,
      dragPropagation: a,
      dragConstraints: l,
      dragElastic: u,
      dragMomentum: f
    };
  }
}
function _C(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function cue(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class due extends Ef {
  constructor(t) {
    super(t), this.removeGroupControls = Hr, this.removeListeners = Hr, this.controls = new uue(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Hr;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const TV = (e) => (t, n) => {
  e && gr.update(() => e(t, n));
};
class fue extends Ef {
  constructor() {
    super(...arguments), this.removePointerDownListener = Hr;
  }
  onPointerDown(t) {
    this.session = new d9(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: g9(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: o, onPanEnd: a } = this.node.getProps();
    return {
      onSessionStart: TV(t),
      onStart: TV(n),
      onMove: o,
      onEnd: (l, u) => {
        delete this.session, a && gr.update(() => a(l, u));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Rc(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function y9() {
  const e = dr(dS);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: o } = e, a = ko();
  return dt(() => o(a), []), !t && n ? [!1, () => n && n(a)] : [!0];
}
function pue() {
  return hue(dr(dS));
}
function hue(e) {
  return e === null ? !0 : e.isPresent;
}
const pw = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function IV(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Yb = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (Wt.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = IV(e, t.target.x), o = IV(e, t.target.y);
    return `${n}% ${o}%`;
  }
}, mue = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const o = e, a = pf.parse(e);
    if (a.length > 5)
      return o;
    const l = pf.createTransformer(e), u = typeof a[0] != "number" ? 1 : 0, f = n.x.scale * t.x, h = n.y.scale * t.y;
    a[0 + u] /= f, a[1 + u] /= h;
    const v = _r(f, h, 0.5);
    return typeof a[2 + u] == "number" && (a[2 + u] /= v), typeof a[3 + u] == "number" && (a[3 + u] /= v), l(a);
  }
};
class vue extends Tt.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o, layoutId: a } = this.props, { projection: l } = t;
    Eae(gue), l && (n.group && n.group.add(l), o && o.register && a && o.register(l), l.root.didUpdate(), l.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), l.setOptions({
      ...l.options,
      onExitComplete: () => this.safeToRemove()
    })), pw.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: o, drag: a, isPresent: l } = this.props, u = o.projection;
    return u && (u.isPresent = l, a || t.layoutDependency !== n || n === void 0 ? u.willUpdate() : this.safeToRemove(), t.isPresent !== l && (l ? u.promote() : u.relegate() || gr.postRender(() => {
      const f = u.getStack();
      (!f || !f.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), queueMicrotask(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o } = this.props, { projection: a } = t;
    a && (a.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(a), o && o.deregister && o.deregister(a));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function b9(e) {
  const [t, n] = y9(), o = dr(J_);
  return Tt.createElement(vue, { ...e, layoutGroup: o, switchLayoutGroup: dr(p3), isPresent: t, safeToRemove: n });
}
const gue = {
  borderRadius: {
    ...Yb,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Yb,
  borderTopRightRadius: Yb,
  borderBottomLeftRadius: Yb,
  borderBottomRightRadius: Yb,
  boxShadow: mue
}, S9 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], yue = S9.length, AV = (e) => typeof e == "string" ? parseFloat(e) : e, kV = (e) => typeof e == "number" || Wt.test(e);
function bue(e, t, n, o, a, l) {
  a ? (e.opacity = _r(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    Sue(o)
  ), e.opacityExit = _r(t.opacity !== void 0 ? t.opacity : 1, 0, xue(o))) : l && (e.opacity = _r(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, o));
  for (let u = 0; u < yue; u++) {
    const f = `border${S9[u]}Radius`;
    let h = RV(t, f), v = RV(n, f);
    if (h === void 0 && v === void 0)
      continue;
    h || (h = 0), v || (v = 0), h === 0 || v === 0 || kV(h) === kV(v) ? (e[f] = Math.max(_r(AV(h), AV(v), o), 0), (mu.test(v) || mu.test(h)) && (e[f] += "%")) : e[f] = v;
  }
  (t.rotate || n.rotate) && (e.rotate = _r(t.rotate || 0, n.rotate || 0, o));
}
function RV(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const Sue = x9(0, 0.5, H3), xue = x9(0.5, 0.95, Hr);
function x9(e, t, n) {
  return (o) => o < e ? 0 : o > t ? 1 : n(Y0(e, t, o));
}
function PV(e, t) {
  e.min = t.min, e.max = t.max;
}
function hs(e, t) {
  PV(e.x, t.x), PV(e.y, t.y);
}
function OV(e, t, n, o, a) {
  return e -= t, e = Yw(e, 1 / n, o), a !== void 0 && (e = Yw(e, 1 / a, o)), e;
}
function Cue(e, t = 0, n = 1, o = 0.5, a, l = e, u = e) {
  if (mu.test(t) && (t = parseFloat(t), t = _r(u.min, u.max, t / 100) - u.min), typeof t != "number")
    return;
  let f = _r(l.min, l.max, o);
  e === l && (f -= t), e.min = OV(e.min, t, n, f, a), e.max = OV(e.max, t, n, f, a);
}
function _V(e, t, [n, o, a], l, u) {
  Cue(e, t[n], t[o], t[a], t.scale, l, u);
}
const wue = ["x", "scaleX", "originX"], Eue = ["y", "scaleY", "originY"];
function DV(e, t, n, o) {
  _V(e.x, t, wue, n ? n.x : void 0, o ? o.x : void 0), _V(e.y, t, Eue, n ? n.y : void 0, o ? o.y : void 0);
}
function NV(e) {
  return e.translate === 0 && e.scale === 1;
}
function C9(e) {
  return NV(e.x) && NV(e.y);
}
function Tue(e, t) {
  return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max;
}
function w9(e, t) {
  return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max);
}
function MV(e) {
  return Ua(e.x) / Ua(e.y);
}
class Iue {
  constructor() {
    this.members = [];
  }
  add(t) {
    c2(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (d2(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((a) => t === a);
    if (n === 0)
      return !1;
    let o;
    for (let a = n; a >= 0; a--) {
      const l = this.members[a];
      if (l.isPresent !== !1) {
        o = l;
        break;
      }
    }
    return o ? (this.promote(o), !0) : !1;
  }
  promote(t, n) {
    const o = this.lead;
    if (t !== o && (this.prevLead = o, this.lead = t, t.show(), o)) {
      o.instance && o.scheduleRender(), t.scheduleRender(), t.resumeFrom = o, n && (t.resumeFrom.preserveOpacity = !0), o.snapshot && (t.snapshot = o.snapshot, t.snapshot.latestValues = o.animationValues || o.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: a } = t.options;
      a === !1 && o.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: o } = t;
      n.onExitComplete && n.onExitComplete(), o && o.options.onExitComplete && o.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function LV(e, t, n) {
  let o = "";
  const a = e.x.translate / t.x, l = e.y.translate / t.y;
  if ((a || l) && (o = `translate3d(${a}px, ${l}px, 0) `), (t.x !== 1 || t.y !== 1) && (o += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { rotate: h, rotateX: v, rotateY: g } = n;
    h && (o += `rotate(${h}deg) `), v && (o += `rotateX(${v}deg) `), g && (o += `rotateY(${g}deg) `);
  }
  const u = e.x.scale * t.x, f = e.y.scale * t.y;
  return (u !== 1 || f !== 1) && (o += `scale(${u}, ${f})`), o || "none";
}
const Aue = (e, t) => e.depth - t.depth;
class kue {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    c2(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    d2(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(Aue), this.isDirty = !1, this.children.forEach(t);
  }
}
function Rue(e, t) {
  const n = performance.now(), o = ({ timestamp: a }) => {
    const l = a - n;
    l >= t && (Mc(o), e(l - t));
  };
  return gr.read(o, !0), () => Mc(o);
}
function Pue(e) {
  window.MotionDebug && window.MotionDebug.record(e);
}
function Oue(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function _ue(e, t, n) {
  const o = Sa(e) ? e : ug(e);
  return o.start(u2("", o, t, n)), o.animation;
}
const FV = ["", "X", "Y", "Z"], Due = { visibility: "hidden" }, BV = 1e3;
let Nue = 0;
const Hp = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function E9({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: o, resetTransform: a }) {
  return class {
    constructor(u = {}, f = t == null ? void 0 : t()) {
      this.id = Nue++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Hp.totalNodes = Hp.resolvedTargetDeltas = Hp.recalculatedProjection = 0, this.nodes.forEach(Fue), this.nodes.forEach(Hue), this.nodes.forEach(jue), this.nodes.forEach(Bue), Pue(Hp);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = u, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0;
      for (let h = 0; h < this.path.length; h++)
        this.path[h].shouldResetTransform = !0;
      this.root === this && (this.nodes = new kue());
    }
    addEventListener(u, f) {
      return this.eventHandlers.has(u) || this.eventHandlers.set(u, new f2()), this.eventHandlers.get(u).add(f);
    }
    notifyListeners(u, ...f) {
      const h = this.eventHandlers.get(u);
      h && h.notify(...f);
    }
    hasListeners(u) {
      return this.eventHandlers.has(u);
    }
    /**
     * Lifecycles
     */
    mount(u, f = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = Oue(u), this.instance = u;
      const { layoutId: h, layout: v, visualElement: g } = this.options;
      if (g && !g.current && g.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), f && (v || h) && (this.isLayoutDirty = !0), e) {
        let b;
        const S = () => this.root.updateBlockedByResize = !1;
        e(u, () => {
          this.root.updateBlockedByResize = !0, b && b(), b = Rue(S, 250), pw.hasAnimatedSinceResize && (pw.hasAnimatedSinceResize = !1, this.nodes.forEach($V));
        });
      }
      h && this.root.registerSharedNode(h, this), this.options.animate !== !1 && g && (h || v) && this.addEventListener("didUpdate", ({ delta: b, hasLayoutChanged: S, hasRelativeTargetChanged: w, layout: E }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const T = this.options.transition || g.getDefaultTransition() || Zue, { onLayoutAnimationStart: A, onLayoutAnimationComplete: P } = g.getProps(), _ = !this.targetLayout || !w9(this.targetLayout, E) || w, D = !S && w;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || D || S && (_ || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(b, D);
          const L = {
            ...l2(T, "layout"),
            onPlay: A,
            onComplete: P
          };
          (g.shouldReduceMotion || this.options.layoutRoot) && (L.delay = 0, L.type = !1), this.startAnimation(L);
        } else
          S || $V(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = E;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const u = this.getStack();
      u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Mc(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Gue), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: u } = this.options;
      return u && u.getProps().transformTemplate;
    }
    willUpdate(u = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let g = 0; g < this.path.length; g++) {
        const b = this.path[g];
        b.shouldResetTransform = !0, b.updateScroll("snapshot"), b.options.layoutRoot && b.willUpdate(!1);
      }
      const { layoutId: f, layout: h } = this.options;
      if (f === void 0 && !h)
        return;
      const v = this.getTransformTemplate();
      this.prevTransformTemplateValue = v ? v(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(VV);
        return;
      }
      this.isUpdating || this.nodes.forEach($ue), this.isUpdating = !1, this.nodes.forEach(zue), this.nodes.forEach(Mue), this.nodes.forEach(Lue), this.clearAllSnapshots();
      const f = performance.now();
      wi.delta = ff(0, 1e3 / 60, f - wi.timestamp), wi.timestamp = f, wi.isProcessing = !0, PR.update.process(wi), PR.preRender.process(wi), PR.render.process(wi), wi.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Vue), this.sharedNodes.forEach(Wue);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, gr.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      gr.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++)
          this.path[h].updateScroll();
      const u = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = co(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: f } = this.options;
      f && f.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0);
    }
    updateScroll(u = "measure") {
      let f = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (f = !1), f && (this.scroll = {
        animationId: this.root.animationId,
        phase: u,
        isRoot: o(this.instance),
        offset: n(this.instance)
      });
    }
    resetTransform() {
      if (!a)
        return;
      const u = this.isLayoutDirty || this.shouldResetTransform, f = this.projectionDelta && !C9(this.projectionDelta), h = this.getTransformTemplate(), v = h ? h(this.latestValues, "") : void 0, g = v !== this.prevTransformTemplateValue;
      u && (f || zp(this.latestValues) || g) && (a(this.instance, v), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(u = !0) {
      const f = this.measurePageBox();
      let h = this.removeElementScroll(f);
      return u && (h = this.removeTransform(h)), Yue(h), {
        animationId: this.root.animationId,
        measuredBox: f,
        layoutBox: h,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: u } = this.options;
      if (!u)
        return co();
      const f = u.measureViewportBox(), { scroll: h } = this.root;
      return h && (nf(f.x, h.offset.x), nf(f.y, h.offset.y)), f;
    }
    removeElementScroll(u) {
      const f = co();
      hs(f, u);
      for (let h = 0; h < this.path.length; h++) {
        const v = this.path[h], { scroll: g, options: b } = v;
        if (v !== this.root && g && b.layoutScroll) {
          if (g.isRoot) {
            hs(f, u);
            const { scroll: S } = this.root;
            S && (nf(f.x, -S.offset.x), nf(f.y, -S.offset.y));
          }
          nf(f.x, g.offset.x), nf(f.y, g.offset.y);
        }
      }
      return f;
    }
    applyTransform(u, f = !1) {
      const h = co();
      hs(h, u);
      for (let v = 0; v < this.path.length; v++) {
        const g = this.path[v];
        !f && g.options.layoutScroll && g.scroll && g !== g.root && Bv(h, {
          x: -g.scroll.offset.x,
          y: -g.scroll.offset.y
        }), zp(g.latestValues) && Bv(h, g.latestValues);
      }
      return zp(this.latestValues) && Bv(h, this.latestValues), h;
    }
    removeTransform(u) {
      const f = co();
      hs(f, u);
      for (let h = 0; h < this.path.length; h++) {
        const v = this.path[h];
        if (!v.instance || !zp(v.latestValues))
          continue;
        sO(v.latestValues) && v.updateSnapshot();
        const g = co(), b = v.measurePageBox();
        hs(g, b), DV(f, v.latestValues, v.snapshot ? v.snapshot.layoutBox : void 0, g);
      }
      return zp(this.latestValues) && DV(f, this.latestValues), f;
    }
    setTargetDelta(u) {
      this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(u) {
      this.options = {
        ...this.options,
        ...u,
        crossfade: u.crossfade !== void 0 ? u.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== wi.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(u = !1) {
      var f;
      const h = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty);
      const v = !!this.resumingFrom || this !== h;
      if (!(u || v && this.isSharedProjectionDirty || this.isProjectionDirty || !((f = this.parent) === null || f === void 0) && f.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: b, layoutId: S } = this.options;
      if (!(!this.layout || !(b || S))) {
        if (this.resolvedRelativeTargetAt = wi.timestamp, !this.targetDelta && !this.relativeTarget) {
          const w = this.getClosestProjectingParent();
          w && w.layout && this.animationProgress !== 1 ? (this.relativeParent = w, this.forceRelativeParentToResolveTarget(), this.relativeTarget = co(), this.relativeTargetOrigin = co(), A0(this.relativeTargetOrigin, this.layout.layoutBox, w.layout.layoutBox), hs(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = co(), this.targetWithTransforms = co()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Yle(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : hs(this.target, this.layout.layoutBox), m9(this.target, this.targetDelta)) : hs(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const w = this.getClosestProjectingParent();
            w && !!w.resumingFrom == !!this.resumingFrom && !w.options.layoutScroll && w.target && this.animationProgress !== 1 ? (this.relativeParent = w, this.forceRelativeParentToResolveTarget(), this.relativeTarget = co(), this.relativeTargetOrigin = co(), A0(this.relativeTargetOrigin, this.target, w.target), hs(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Hp.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || sO(this.parent.latestValues) || h9(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var u;
      const f = this.getLead(), h = !!this.resumingFrom || this !== f;
      let v = !0;
      if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (v = !1), h && (this.isSharedProjectionDirty || this.isTransformDirty) && (v = !1), this.resolvedRelativeTargetAt === wi.timestamp && (v = !1), v)
        return;
      const { layout: g, layoutId: b } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(g || b))
        return;
      hs(this.layoutCorrected, this.layout.layoutBox);
      const S = this.treeScale.x, w = this.treeScale.y;
      oue(this.layoutCorrected, this.treeScale, this.path, h), f.layout && !f.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (f.target = f.layout.layoutBox);
      const { target: E } = f;
      if (!E) {
        this.projectionTransform && (this.projectionDelta = Fv(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = Fv(), this.projectionDeltaWithTransform = Fv());
      const T = this.projectionTransform;
      I0(this.projectionDelta, this.layoutCorrected, E, this.latestValues), this.projectionTransform = LV(this.projectionDelta, this.treeScale), (this.projectionTransform !== T || this.treeScale.x !== S || this.treeScale.y !== w) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", E)), Hp.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(u = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), u) {
        const f = this.getStack();
        f && f.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(u, f = !1) {
      const h = this.snapshot, v = h ? h.latestValues : {}, g = { ...this.latestValues }, b = Fv();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f;
      const S = co(), w = h ? h.source : void 0, E = this.layout ? this.layout.source : void 0, T = w !== E, A = this.getStack(), P = !A || A.members.length <= 1, _ = !!(T && !P && this.options.crossfade === !0 && !this.path.some(Xue));
      this.animationProgress = 0;
      let D;
      this.mixTargetDelta = (L) => {
        const F = L / 1e3;
        zV(b.x, u.x, F), zV(b.y, u.y, F), this.setTargetDelta(b), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (A0(S, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Uue(this.relativeTarget, this.relativeTargetOrigin, S, F), D && Tue(this.relativeTarget, D) && (this.isProjectionDirty = !1), D || (D = co()), hs(D, this.relativeTarget)), T && (this.animationValues = g, bue(g, v, this.latestValues, F, _, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = F;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(u) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Mc(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = gr.update(() => {
        pw.hasAnimatedSinceResize = !0, this.currentAnimation = _ue(0, BV, {
          ...u,
          onUpdate: (f) => {
            this.mixTargetDelta(f), u.onUpdate && u.onUpdate(f);
          },
          onComplete: () => {
            u.onComplete && u.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const u = this.getStack();
      u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(BV), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const u = this.getLead();
      let { targetWithTransforms: f, target: h, layout: v, latestValues: g } = u;
      if (!(!f || !h || !v)) {
        if (this !== u && this.layout && v && T9(this.options.animationType, this.layout.layoutBox, v.layoutBox)) {
          h = this.target || co();
          const b = Ua(this.layout.layoutBox.x);
          h.x.min = u.target.x.min, h.x.max = h.x.min + b;
          const S = Ua(this.layout.layoutBox.y);
          h.y.min = u.target.y.min, h.y.max = h.y.min + S;
        }
        hs(f, h), Bv(f, g), I0(this.projectionDeltaWithTransform, this.layoutCorrected, f, g);
      }
    }
    registerSharedNode(u, f) {
      this.sharedNodes.has(u) || this.sharedNodes.set(u, new Iue()), this.sharedNodes.get(u).add(f);
      const v = f.options.initialPromotionConfig;
      f.promote({
        transition: v ? v.transition : void 0,
        preserveFollowOpacity: v && v.shouldPreserveFollowOpacity ? v.shouldPreserveFollowOpacity(f) : void 0
      });
    }
    isLead() {
      const u = this.getStack();
      return u ? u.lead === this : !0;
    }
    getLead() {
      var u;
      const { layoutId: f } = this.options;
      return f ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this;
    }
    getPrevLead() {
      var u;
      const { layoutId: f } = this.options;
      return f ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0;
    }
    getStack() {
      const { layoutId: u } = this.options;
      if (u)
        return this.root.sharedNodes.get(u);
    }
    promote({ needsReset: u, transition: f, preserveFollowOpacity: h } = {}) {
      const v = this.getStack();
      v && v.promote(this, h), u && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f });
    }
    relegate() {
      const u = this.getStack();
      return u ? u.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: u } = this.options;
      if (!u)
        return;
      let f = !1;
      const { latestValues: h } = u;
      if ((h.rotate || h.rotateX || h.rotateY || h.rotateZ) && (f = !0), !f)
        return;
      const v = {};
      for (let g = 0; g < FV.length; g++) {
        const b = "rotate" + FV[g];
        h[b] && (v[b] = h[b], u.setStaticValue(b, 0));
      }
      u.render();
      for (const g in v)
        u.setStaticValue(g, v[g]);
      u.scheduleRender();
    }
    getProjectionStyles(u) {
      var f, h;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return Due;
      const v = {
        visibility: ""
      }, g = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, v.opacity = "", v.pointerEvents = fw(u == null ? void 0 : u.pointerEvents) || "", v.transform = g ? g(this.latestValues, "") : "none", v;
      const b = this.getLead();
      if (!this.projectionDelta || !this.layout || !b.target) {
        const T = {};
        return this.options.layoutId && (T.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, T.pointerEvents = fw(u == null ? void 0 : u.pointerEvents) || ""), this.hasProjected && !zp(this.latestValues) && (T.transform = g ? g({}, "") : "none", this.hasProjected = !1), T;
      }
      const S = b.animationValues || b.latestValues;
      this.applyTransformsToTarget(), v.transform = LV(this.projectionDeltaWithTransform, this.treeScale, S), g && (v.transform = g(S, v.transform));
      const { x: w, y: E } = this.projectionDelta;
      v.transformOrigin = `${w.origin * 100}% ${E.origin * 100}% 0`, b.animationValues ? v.opacity = b === this ? (h = (f = S.opacity) !== null && f !== void 0 ? f : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : S.opacityExit : v.opacity = b === this ? S.opacity !== void 0 ? S.opacity : "" : S.opacityExit !== void 0 ? S.opacityExit : 0;
      for (const T in Hw) {
        if (S[T] === void 0)
          continue;
        const { correct: A, applyTo: P } = Hw[T], _ = v.transform === "none" ? S[T] : A(S[T], b);
        if (P) {
          const D = P.length;
          for (let L = 0; L < D; L++)
            v[P[L]] = _;
        } else
          v[T] = _;
      }
      return this.options.layoutId && (v.pointerEvents = b === this ? fw(u == null ? void 0 : u.pointerEvents) || "" : "none"), v;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((u) => {
        var f;
        return (f = u.currentAnimation) === null || f === void 0 ? void 0 : f.stop();
      }), this.root.nodes.forEach(VV), this.root.sharedNodes.clear();
    }
  };
}
function Mue(e) {
  e.updateLayout();
}
function Lue(e) {
  var t;
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: o, measuredBox: a } = e.layout, { animationType: l } = e.options, u = n.source !== e.layout.source;
    l === "size" ? vs((b) => {
      const S = u ? n.measuredBox[b] : n.layoutBox[b], w = Ua(S);
      S.min = o[b].min, S.max = S.min + w;
    }) : T9(l, n.layoutBox, o) && vs((b) => {
      const S = u ? n.measuredBox[b] : n.layoutBox[b], w = Ua(o[b]);
      S.max = S.min + w, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[b].max = e.relativeTarget[b].min + w);
    });
    const f = Fv();
    I0(f, o, n.layoutBox);
    const h = Fv();
    u ? I0(h, e.applyTransform(a, !0), n.measuredBox) : I0(h, o, n.layoutBox);
    const v = !C9(f);
    let g = !1;
    if (!e.resumeFrom) {
      const b = e.getClosestProjectingParent();
      if (b && !b.resumeFrom) {
        const { snapshot: S, layout: w } = b;
        if (S && w) {
          const E = co();
          A0(E, n.layoutBox, S.layoutBox);
          const T = co();
          A0(T, o, w.layoutBox), w9(E, T) || (g = !0), b.options.layoutRoot && (e.relativeTarget = T, e.relativeTargetOrigin = E, e.relativeParent = b);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: o,
      snapshot: n,
      delta: h,
      layoutDelta: f,
      hasLayoutChanged: v,
      hasRelativeTargetChanged: g
    });
  } else if (e.isLead()) {
    const { onExitComplete: o } = e.options;
    o && o();
  }
  e.options.transition = void 0;
}
function Fue(e) {
  Hp.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Bue(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Vue(e) {
  e.clearSnapshot();
}
function VV(e) {
  e.clearMeasurements();
}
function $ue(e) {
  e.isLayoutDirty = !1;
}
function zue(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function $V(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function Hue(e) {
  e.resolveTargetDelta();
}
function jue(e) {
  e.calcProjection();
}
function Gue(e) {
  e.resetRotation();
}
function Wue(e) {
  e.removeLeadSnapshot();
}
function zV(e, t, n) {
  e.translate = _r(t.translate, 0, n), e.scale = _r(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function HV(e, t, n, o) {
  e.min = _r(t.min, n.min, o), e.max = _r(t.max, n.max, o);
}
function Uue(e, t, n, o) {
  HV(e.x, t.x, n.x, o), HV(e.y, t.y, n.y, o);
}
function Xue(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Zue = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, jV = (e) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(e), GV = jV("applewebkit/") && !jV("chrome/") ? Math.round : Hr;
function WV(e) {
  e.min = GV(e.min), e.max = GV(e.max);
}
function Yue(e) {
  WV(e.x), WV(e.y);
}
function T9(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !iO(MV(t), MV(n), 0.2);
}
const Jue = E9({
  attachResizeListener: (e, t) => Tc(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), zR = {
  current: void 0
}, I9 = E9({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!zR.current) {
      const e = new Jue({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), zR.current = e;
    }
    return zR.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Que = {
  pan: {
    Feature: fue
  },
  drag: {
    Feature: due,
    ProjectionNode: I9,
    MeasureLayout: b9
  }
}, Kue = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function que(e) {
  const t = Kue.exec(e);
  if (!t)
    return [,];
  const [, n, o] = t;
  return [n, o];
}
const ece = 4;
function uO(e, t, n = 1) {
  Es(n <= ece, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [o, a] = que(e);
  if (!o)
    return;
  const l = window.getComputedStyle(t).getPropertyValue(o);
  if (l) {
    const u = l.trim();
    return s9(u) ? parseFloat(u) : u;
  } else
    return KP(a) ? uO(a, t, n + 1) : a;
}
function tce(e, { ...t }, n) {
  const o = e.current;
  if (!(o instanceof Element))
    return { target: t, transitionEnd: n };
  n && (n = { ...n }), e.values.forEach((a) => {
    const l = a.get();
    if (!KP(l))
      return;
    const u = uO(l, o);
    u && a.set(u);
  });
  for (const a in t) {
    const l = t[a];
    if (!KP(l))
      continue;
    const u = uO(l, o);
    u && (t[a] = u, n || (n = {}), n[a] === void 0 && (n[a] = l));
  }
  return { target: t, transitionEnd: n };
}
const nce = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), A9 = (e) => nce.has(e), rce = (e) => Object.keys(e).some(A9), DC = (e) => e === vh || e === Wt, UV = (e, t) => parseFloat(e.split(", ")[t]), XV = (e, t) => (n, { transform: o }) => {
  if (o === "none" || !o)
    return 0;
  const a = o.match(/^matrix3d\((.+)\)$/);
  if (a)
    return UV(a[1], t);
  {
    const l = o.match(/^matrix\((.+)\)$/);
    return l ? UV(l[1], e) : 0;
  }
}, oce = /* @__PURE__ */ new Set(["x", "y", "z"]), ice = fS.filter((e) => !oce.has(e));
function ace(e) {
  const t = [];
  return ice.forEach((n) => {
    const o = e.getValue(n);
    o !== void 0 && (t.push([n, o.get()]), o.set(n.startsWith("scale") ? 1 : 0));
  }), t.length && e.render(), t;
}
const cg = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: XV(4, 13),
  y: XV(5, 14)
};
cg.translateX = cg.x;
cg.translateY = cg.y;
const sce = (e, t, n) => {
  const o = t.measureViewportBox(), a = t.current, l = getComputedStyle(a), { display: u } = l, f = {};
  u === "none" && t.setStaticValue("display", e.display || "block"), n.forEach((v) => {
    f[v] = cg[v](o, l);
  }), t.render();
  const h = t.measureViewportBox();
  return n.forEach((v) => {
    const g = t.getValue(v);
    g && g.jump(f[v]), e[v] = cg[v](h, l);
  }), e;
}, lce = (e, t, n = {}, o = {}) => {
  t = { ...t }, o = { ...o };
  const a = Object.keys(t).filter(A9);
  let l = [], u = !1;
  const f = [];
  if (a.forEach((h) => {
    const v = e.getValue(h);
    if (!e.hasValue(h))
      return;
    let g = n[h], b = Zb(g);
    const S = t[h];
    let w;
    if (Gw(S)) {
      const E = S.length, T = S[0] === null ? 1 : 0;
      g = S[T], b = Zb(g);
      for (let A = T; A < E && S[A] !== null; A++)
        w ? Es(Zb(S[A]) === w, "All keyframes must be of the same type") : (w = Zb(S[A]), Es(w === b || DC(b) && DC(w), "Keyframes must be of the same dimension as the current value"));
    } else
      w = Zb(S);
    if (b !== w)
      if (DC(b) && DC(w)) {
        const E = v.get();
        typeof E == "string" && v.set(parseFloat(E)), typeof S == "string" ? t[h] = parseFloat(S) : Array.isArray(S) && w === Wt && (t[h] = S.map(parseFloat));
      } else
        b != null && b.transform && (w != null && w.transform) && (g === 0 || S === 0) ? g === 0 ? v.set(w.transform(g)) : t[h] = b.transform(S) : (u || (l = ace(e), u = !0), f.push(h), o[h] = o[h] !== void 0 ? o[h] : t[h], v.jump(S));
  }), f.length) {
    const h = f.indexOf("height") >= 0 ? window.pageYOffset : null, v = sce(t, e, f);
    return l.length && l.forEach(([g, b]) => {
      e.getValue(g).set(b);
    }), e.render(), ZE && h !== null && window.scrollTo({ top: h }), { target: v, transitionEnd: o };
  } else
    return { target: t, transitionEnd: o };
};
function uce(e, t, n, o) {
  return rce(t) ? lce(e, t, n, o) : { target: t, transitionEnd: o };
}
const cce = (e, t, n, o) => {
  const a = tce(e, t, o);
  return t = a.target, o = a.transitionEnd, uce(e, t, n, o);
}, cO = { current: null }, k9 = { current: !1 };
function dce() {
  if (k9.current = !0, !!ZE)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => cO.current = e.matches;
      e.addListener(t), t();
    } else
      cO.current = !1;
}
function fce(e, t, n) {
  const { willChange: o } = t;
  for (const a in t) {
    const l = t[a], u = n[a];
    if (Sa(l))
      e.addValue(a, l), Zw(o) && o.add(a), process.env.NODE_ENV === "development" && p2(l.version === "10.18.0", `Attempting to mix Framer Motion versions ${l.version} with 10.18.0 may not work as expected.`);
    else if (Sa(u))
      e.addValue(a, ug(l, { owner: e })), Zw(o) && o.remove(a);
    else if (u !== l)
      if (e.hasValue(a)) {
        const f = e.getValue(a);
        !f.hasAnimated && f.set(l);
      } else {
        const f = e.getStaticValue(a);
        e.addValue(a, ug(f !== void 0 ? f : l, { owner: e }));
      }
  }
  for (const a in n)
    t[a] === void 0 && e.removeValue(a);
  return t;
}
const ZV = /* @__PURE__ */ new WeakMap(), R9 = Object.keys(Z0), pce = R9.length, YV = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], hce = Y_.length;
class mce {
  constructor({ parent: t, props: n, presenceContext: o, reducedMotionConfig: a, visualState: l }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => gr.render(this.render, !1, !0);
    const { latestValues: f, renderState: h } = l;
    this.latestValues = f, this.baseTarget = { ...f }, this.initialValues = n.initial ? { ...f } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = o, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = a, this.options = u, this.isControllingVariants = JE(n), this.isVariantNode = f3(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: v, ...g } = this.scrapeMotionValuesFromProps(n, {});
    for (const b in g) {
      const S = g[b];
      f[b] !== void 0 && Sa(S) && (S.set(f[b], !1), Zw(v) && v.add(b));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n) {
    return {};
  }
  mount(t) {
    this.current = t, ZV.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, o) => this.bindToMotionValue(o, n)), k9.current || dce(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : cO.current, process.env.NODE_ENV !== "production" && p2(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    ZV.delete(this.current), this.projection && this.projection.unmount(), Mc(this.notifyUpdate), Mc(this.render), this.valueSubscriptions.forEach((t) => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features)
      this.features[t].unmount();
    this.current = null;
  }
  bindToMotionValue(t, n) {
    const o = mh.has(t), a = n.on("change", (u) => {
      this.latestValues[t] = u, this.props.onUpdate && gr.update(this.notifyUpdate, !1, !0), o && this.projection && (this.projection.isTransformDirty = !0);
    }), l = n.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(t, () => {
      a(), l();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  loadFeatures({ children: t, ...n }, o, a, l) {
    let u, f;
    if (process.env.NODE_ENV !== "production" && a && o) {
      const h = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      n.ignoreStrict ? mS(!1, h) : Es(!1, h);
    }
    for (let h = 0; h < pce; h++) {
      const v = R9[h], { isEnabled: g, Feature: b, ProjectionNode: S, MeasureLayout: w } = Z0[v];
      S && (u = S), g(n) && (!this.features[v] && b && (this.features[v] = new b(this)), w && (f = w));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && u) {
      this.projection = new u(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: h, layout: v, drag: g, dragConstraints: b, layoutScroll: S, layoutRoot: w } = n;
      this.projection.setOptions({
        layoutId: h,
        layout: v,
        alwaysMeasureLayout: !!g || b && Mv(b),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof v == "string" ? v : "both",
        initialPromotionConfig: l,
        layoutScroll: S,
        layoutRoot: w
      });
    }
    return f;
  }
  updateFeatures() {
    for (const t in this.features) {
      const n = this.features[t];
      n.isMounted ? n.update() : (n.mount(), n.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : co();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(t, n = !0) {
    return this.makeTargetAnimatableFromInstance(t, this.props, n);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let o = 0; o < YV.length; o++) {
      const a = YV[o];
      this.propEventSubscriptions[a] && (this.propEventSubscriptions[a](), delete this.propEventSubscriptions[a]);
      const l = t["on" + a];
      l && (this.propEventSubscriptions[a] = this.on(a, l));
    }
    this.prevMotionValues = fce(this, this.scrapeMotionValuesFromProps(t, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(t = !1) {
    if (t)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const o = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (o.initial = this.props.initial), o;
    }
    const n = {};
    for (let o = 0; o < hce; o++) {
      const a = Y_[o], l = this.props[a];
      (X0(l) || l === !1) && (n[a] = l);
    }
    return n;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    n !== this.values.get(t) && (this.removeValue(t), this.bindToMotionValue(t, n)), this.values.set(t, n), this.latestValues[t] = n.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let o = this.values.get(t);
    return o === void 0 && n !== void 0 && (o = ug(n, { owner: this }), this.addValue(t, o)), o;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t) {
    var n;
    return this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (n = this.getBaseTargetFromProps(this.props, t)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, t, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: o } = this.props, a = typeof o == "string" || typeof o == "object" ? (n = r2(this.props, o)) === null || n === void 0 ? void 0 : n[t] : void 0;
    if (o && a !== void 0)
      return a;
    const l = this.getBaseTargetFromProps(this.props, t);
    return l !== void 0 && !Sa(l) ? l : this.initialValues[t] !== void 0 && a === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new f2()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
class P9 extends mce {
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: o }) {
    delete n[t], delete o[t];
  }
  makeTargetAnimatableFromInstance({ transition: t, transitionEnd: n, ...o }, { transformValues: a }, l) {
    let u = Ple(o, t || {}, this);
    if (a && (n && (n = a(n)), o && (o = a(o)), u && (u = a(u))), l) {
      kle(this, o, u);
      const f = cce(this, o, u, n);
      n = f.transitionEnd, o = f.target;
    }
    return {
      transition: t,
      transitionEnd: n,
      ...o
    };
  }
}
function vce(e) {
  return window.getComputedStyle(e);
}
class gce extends P9 {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(t, n) {
    if (mh.has(n)) {
      const o = s2(n);
      return o && o.default || 0;
    } else {
      const o = vce(t), a = (v3(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof a == "string" ? a.trim() : a;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return v9(t, n);
  }
  build(t, n, o, a) {
    K_(t, n, o, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n) {
    return n2(t, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Sa(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
  renderInstance(t, n, o, a) {
    C3(t, n, o, a);
  }
}
class yce extends P9 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (mh.has(n)) {
      const o = s2(n);
      return o && o.default || 0;
    }
    return n = w3.has(n) ? n : X_(n), t.getAttribute(n);
  }
  measureInstanceViewportBox() {
    return co();
  }
  scrapeMotionValuesFromProps(t, n) {
    return T3(t, n);
  }
  build(t, n, o, a) {
    e2(t, n, o, this.isSVGTag, a.transformTemplate);
  }
  renderInstance(t, n, o, a) {
    E3(t, n, o, a);
  }
  mount(t) {
    this.isSVGTag = t2(t.tagName), super.mount(t);
  }
}
const bce = (e, t) => Q_(e) ? new yce(t, { enableHardwareAcceleration: !1 }) : new gce(t, { enableHardwareAcceleration: !0 }), Sce = {
  layout: {
    ProjectionNode: I9,
    MeasureLayout: b9
  }
}, xce = {
  ...Wle,
  ...pse,
  ...Que,
  ...Sce
}, ti = /* @__PURE__ */ Cae((e, t) => ese(e, t, xce, bce));
function O9() {
  const e = Ue(!1);
  return U_(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function Cce() {
  const e = O9(), [t, n] = ot(0), o = re(() => {
    e.current && n(t + 1);
  }, [t]);
  return [re(() => gr.postRender(o), [o]), t];
}
class wce extends Fe.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const o = this.props.sizeRef.current;
      o.height = n.offsetHeight || 0, o.width = n.offsetWidth || 0, o.top = n.offsetTop, o.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Ece({ children: e, isPresent: t }) {
  const n = ko(), o = Ue(null), a = Ue({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return j5(() => {
    const { width: l, height: u, top: f, left: h } = a.current;
    if (t || !o.current || !l || !u)
      return;
    o.current.dataset.motionPopId = n;
    const v = document.createElement("style");
    return document.head.appendChild(v), v.sheet && v.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${u}px !important;
            top: ${f}px !important;
            left: ${h}px !important;
          }
        `), () => {
      document.head.removeChild(v);
    };
  }, [t]), Fe.createElement(wce, { isPresent: t, childRef: o, sizeRef: a }, Fe.cloneElement(e, { ref: o }));
}
const HR = ({ children: e, initial: t, isPresent: n, onExitComplete: o, custom: a, presenceAffectsLayout: l, mode: u }) => {
  const f = I3(Tce), h = ko(), v = gt(
    () => ({
      id: h,
      initial: t,
      isPresent: n,
      custom: a,
      onExitComplete: (g) => {
        f.set(g, !0);
        for (const b of f.values())
          if (!b)
            return;
        o && o();
      },
      register: (g) => (f.set(g, !1), () => f.delete(g))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    l ? void 0 : [n]
  );
  return gt(() => {
    f.forEach((g, b) => f.set(b, !1));
  }, [n]), Fe.useEffect(() => {
    !n && !f.size && o && o();
  }, [n]), u === "popLayout" && (e = Fe.createElement(Ece, { isPresent: n }, e)), Fe.createElement(dS.Provider, { value: v }, e);
};
function Tce() {
  return /* @__PURE__ */ new Map();
}
function Ice(e) {
  return dt(() => () => e(), []);
}
const jp = (e) => e.key || "";
function Ace(e, t) {
  e.forEach((n) => {
    const o = jp(n);
    t.set(o, n);
  });
}
function kce(e) {
  const t = [];
  return Gc.forEach(e, (n) => {
    hh(n) && t.push(n);
  }), t;
}
const Cu = ({ children: e, custom: t, initial: n = !0, onExitComplete: o, exitBeforeEnter: a, presenceAffectsLayout: l = !0, mode: u = "sync" }) => {
  Es(!a, "Replace exitBeforeEnter with mode='wait'");
  const f = dr(J_).forceRender || Cce()[0], h = O9(), v = kce(e);
  let g = v;
  const b = Ue(/* @__PURE__ */ new Map()).current, S = Ue(g), w = Ue(/* @__PURE__ */ new Map()).current, E = Ue(!0);
  if (U_(() => {
    E.current = !1, Ace(v, w), S.current = g;
  }), Ice(() => {
    E.current = !0, w.clear(), b.clear();
  }), E.current)
    return Fe.createElement(Fe.Fragment, null, g.map((_) => Fe.createElement(HR, { key: jp(_), isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: l, mode: u }, _)));
  g = [...g];
  const T = S.current.map(jp), A = v.map(jp), P = T.length;
  for (let _ = 0; _ < P; _++) {
    const D = T[_];
    A.indexOf(D) === -1 && !b.has(D) && b.set(D, void 0);
  }
  return u === "wait" && b.size && (g = []), b.forEach((_, D) => {
    if (A.indexOf(D) !== -1)
      return;
    const L = w.get(D);
    if (!L)
      return;
    const F = T.indexOf(D);
    let V = _;
    if (!V) {
      const $ = () => {
        b.delete(D);
        const U = Array.from(w.keys()).filter((W) => !A.includes(W));
        if (U.forEach((W) => w.delete(W)), S.current = v.filter((W) => {
          const H = jp(W);
          return (
            // filter out the node exiting
            H === D || // filter out the leftover children
            U.includes(H)
          );
        }), !b.size) {
          if (h.current === !1)
            return;
          f(), o && o();
        }
      };
      V = Fe.createElement(HR, { key: jp(L), isPresent: !1, onExitComplete: $, custom: t, presenceAffectsLayout: l, mode: u }, L), b.set(D, V);
    }
    g.splice(F, 0, V);
  }), g = g.map((_) => {
    const D = _.key;
    return b.has(D) ? _ : Fe.createElement(HR, { key: jp(_), isPresent: !0, presenceAffectsLayout: l, mode: u }, _);
  }), process.env.NODE_ENV !== "production" && u === "wait" && g.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), Fe.createElement(Fe.Fragment, null, b.size ? g : g.map((_) => ya(_)));
};
var Rce = {
  initial: (e) => {
    const { position: t } = e, n = ["top", "bottom"].includes(t) ? "y" : "x";
    let o = ["top-right", "bottom-right"].includes(t) ? 1 : -1;
    return t === "bottom" && (o = 1), {
      opacity: 0,
      [n]: o * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
}, _9 = G5((e) => {
  const {
    id: t,
    message: n,
    onCloseComplete: o,
    onRequestRemove: a,
    requestClose: l = !1,
    position: u = "bottom",
    duration: f = 5e3,
    containerStyle: h,
    motionVariants: v = Rce,
    toastSpacing: g = "0.5rem"
  } = e, [b, S] = ot(f), w = pue();
  xl(() => {
    w || o == null || o();
  }, [w]), xl(() => {
    S(f);
  }, [f]);
  const E = () => S(null), T = () => S(f), A = () => {
    w && a();
  };
  dt(() => {
    w && l && a();
  }, [w, l, a]), fae(A, b);
  const P = gt(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: g,
      ...h
    }),
    [h, g]
  ), _ = gt(() => cae(u), [u]);
  return /* @__PURE__ */ M(
    ti.div,
    {
      layout: !0,
      className: "chakra-toast",
      variants: v,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: E,
      onHoverEnd: T,
      custom: { position: u },
      style: _,
      children: /* @__PURE__ */ M(
        De.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: P,
          children: Ha(n, { id: t, onClose: A })
        }
      )
    }
  );
});
_9.displayName = "ToastComponent";
function Pce(e, t) {
  var n;
  const o = e ?? "bottom", l = {
    "top-start": { ltr: "top-left", rtl: "top-right" },
    "top-end": { ltr: "top-right", rtl: "top-left" },
    "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
    "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
  }[o];
  return (n = l == null ? void 0 : l[t]) != null ? n : o;
}
var JV = {
  path: /* @__PURE__ */ Nt("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ M(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ M(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ M("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
}, ho = Le((e, t) => {
  const {
    as: n,
    viewBox: o,
    color: a = "currentColor",
    focusable: l = !1,
    children: u,
    className: f,
    __css: h,
    ...v
  } = e, g = et("chakra-icon", f), b = Gi("Icon", e), S = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: a,
    ...h,
    ...b
  }, w = {
    ref: t,
    focusable: l,
    className: g,
    __css: S
  }, E = o ?? JV.viewBox;
  if (n && typeof n != "string")
    return /* @__PURE__ */ M(De.svg, { as: n, ...w, ...v });
  const T = u ?? JV.path;
  return /* @__PURE__ */ M(De.svg, { verticalAlign: "middle", viewBox: E, ...w, ...v, children: T });
});
ho.displayName = "Icon";
function D9(e) {
  const {
    viewBox: t = "0 0 24 24",
    d: n,
    displayName: o,
    defaultProps: a = {}
  } = e, l = Gc.toArray(e.path), u = Le((f, h) => /* @__PURE__ */ M(ho, { ref: h, viewBox: t, ...a, ...f, children: l.length ? l : /* @__PURE__ */ M("path", { fill: "currentColor", d: n }) }));
  return u.displayName = o, u;
}
function Oce(e) {
  return /* @__PURE__ */ M(ho, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function _ce(e) {
  return /* @__PURE__ */ M(ho, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function QV(e) {
  return /* @__PURE__ */ M(ho, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
var Dce = Ps({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
}), eT = Le((e, t) => {
  const n = Gi("Spinner", e), {
    label: o = "Loading...",
    thickness: a = "2px",
    speed: l = "0.45s",
    emptyColor: u = "transparent",
    className: f,
    ...h
  } = Pn(e), v = et("chakra-spinner", f), g = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: a,
    borderBottomColor: u,
    borderLeftColor: u,
    animation: `${Dce} ${l} linear infinite`,
    ...n
  };
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: t,
      __css: g,
      className: v,
      ...h,
      children: o && /* @__PURE__ */ M(De.span, { srOnly: !0, children: o })
    }
  );
});
eT.displayName = "Spinner";
var [Nce, h2] = En({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
}), [Mce, m2] = En({
  name: "AlertStylesContext",
  hookName: "useAlertStyles",
  providerName: "<Alert />"
}), N9 = {
  info: { icon: _ce, colorScheme: "blue" },
  warning: { icon: QV, colorScheme: "orange" },
  success: { icon: Oce, colorScheme: "green" },
  error: { icon: QV, colorScheme: "red" },
  loading: { icon: eT, colorScheme: "blue" }
};
function Lce(e) {
  return N9[e].colorScheme;
}
function Fce(e) {
  return N9[e].icon;
}
var M9 = Le(
  function(t, n) {
    const o = m2(), { status: a } = h2(), l = {
      display: "inline",
      ...o.description
    };
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        "data-status": a,
        ...t,
        className: et("chakra-alert__desc", t.className),
        __css: l
      }
    );
  }
);
M9.displayName = "AlertDescription";
function L9(e) {
  const { status: t } = h2(), n = Fce(t), o = m2(), a = t === "loading" ? o.spinner : o.icon;
  return /* @__PURE__ */ M(
    De.span,
    {
      display: "inherit",
      "data-status": t,
      ...e,
      className: et("chakra-alert__icon", e.className),
      __css: a,
      children: e.children || /* @__PURE__ */ M(n, { h: "100%", w: "100%" })
    }
  );
}
L9.displayName = "AlertIcon";
var F9 = Le(
  function(t, n) {
    const o = m2(), { status: a } = h2();
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        "data-status": a,
        ...t,
        className: et("chakra-alert__title", t.className),
        __css: o.title
      }
    );
  }
);
F9.displayName = "AlertTitle";
var B9 = Le(function(t, n) {
  var o;
  const { status: a = "info", addRole: l = !0, ...u } = Pn(t), f = (o = t.colorScheme) != null ? o : Lce(a), h = Xn("Alert", { ...t, colorScheme: f }), v = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...h.container
  };
  return /* @__PURE__ */ M(Nce, { value: { status: a }, children: /* @__PURE__ */ M(Mce, { value: h, children: /* @__PURE__ */ M(
    De.div,
    {
      "data-status": a,
      role: l ? "alert" : void 0,
      ref: n,
      ...u,
      className: et("chakra-alert", t.className),
      __css: v
    }
  ) }) });
});
B9.displayName = "Alert";
function Bce(e) {
  return /* @__PURE__ */ M(ho, { focusable: "false", "aria-hidden": !0, ...e, children: /* @__PURE__ */ M(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
var tT = Le(
  function(t, n) {
    const o = Gi("CloseButton", t), { children: a, isDisabled: l, __css: u, ...f } = Pn(t), h = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ M(
      De.button,
      {
        type: "button",
        "aria-label": "Close",
        ref: n,
        disabled: l,
        __css: {
          ...h,
          ...o,
          ...u
        },
        ...f,
        children: a || /* @__PURE__ */ M(Bce, { width: "1em", height: "1em" })
      }
    );
  }
);
tT.displayName = "CloseButton";
var Vce = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
}, uu = $ce(Vce);
function $ce(e) {
  let t = e;
  const n = /* @__PURE__ */ new Set(), o = (a) => {
    t = a(t), n.forEach((l) => l());
  };
  return {
    getState: () => t,
    subscribe: (a) => (n.add(a), () => {
      o(() => e), n.delete(a);
    }),
    /**
     * Delete a toast record at its position
     */
    removeToast: (a, l) => {
      o((u) => ({
        ...u,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [l]: u[l].filter((f) => f.id != a)
      }));
    },
    notify: (a, l) => {
      const u = zce(a, l), { position: f, id: h } = u;
      return o((v) => {
        var g, b;
        const w = f.includes("top") ? [u, ...(g = v[f]) != null ? g : []] : [...(b = v[f]) != null ? b : [], u];
        return {
          ...v,
          [f]: w
        };
      }), h;
    },
    update: (a, l) => {
      a && o((u) => {
        const f = { ...u }, { position: h, index: v } = GB(f, a);
        return h && v !== -1 && (f[h][v] = {
          ...f[h][v],
          ...l,
          message: V9(l)
        }), f;
      });
    },
    closeAll: ({ positions: a } = {}) => {
      o((l) => (a ?? [
        "bottom",
        "bottom-right",
        "bottom-left",
        "top",
        "top-left",
        "top-right"
      ]).reduce(
        (h, v) => (h[v] = l[v].map((g) => ({
          ...g,
          requestClose: !0
        })), h),
        { ...l }
      ));
    },
    close: (a) => {
      o((l) => {
        const u = l3(l, a);
        return u ? {
          ...l,
          [u]: l[u].map((f) => f.id == a ? {
            ...f,
            requestClose: !0
          } : f)
        } : l;
      });
    },
    isActive: (a) => !!GB(uu.getState(), a).position
  };
}
var KV = 0;
function zce(e, t = {}) {
  var n, o;
  KV += 1;
  const a = (n = t.id) != null ? n : KV, l = (o = t.position) != null ? o : "bottom";
  return {
    id: a,
    message: e,
    position: l,
    duration: t.duration,
    onCloseComplete: t.onCloseComplete,
    onRequestRemove: () => uu.removeToast(String(a), l),
    status: t.status,
    requestClose: !1,
    containerStyle: t.containerStyle
  };
}
var Hce = (e) => {
  const {
    status: t,
    variant: n = "solid",
    id: o,
    title: a,
    isClosable: l,
    onClose: u,
    description: f,
    colorScheme: h,
    icon: v
  } = e, g = o ? {
    root: `toast-${o}`,
    title: `toast-${o}-title`,
    description: `toast-${o}-description`
  } : void 0;
  return /* @__PURE__ */ Nt(
    B9,
    {
      addRole: !1,
      status: t,
      variant: n,
      id: g == null ? void 0 : g.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme: h,
      children: [
        /* @__PURE__ */ M(L9, { children: v }),
        /* @__PURE__ */ Nt(De.div, { flex: "1", maxWidth: "100%", children: [
          a && /* @__PURE__ */ M(F9, { id: g == null ? void 0 : g.title, children: a }),
          f && /* @__PURE__ */ M(M9, { id: g == null ? void 0 : g.description, display: "block", children: f })
        ] }),
        l && /* @__PURE__ */ M(
          tT,
          {
            size: "sm",
            onClick: u,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function V9(e = {}) {
  const { render: t, toastComponent: n = Hce } = e;
  return (a) => typeof t == "function" ? t({ ...a, ...e }) : /* @__PURE__ */ M(n, { ...a, ...e });
}
function $9(e, t) {
  const n = (a) => {
    var l;
    return {
      ...t,
      ...a,
      position: Pce(
        (l = a == null ? void 0 : a.position) != null ? l : t == null ? void 0 : t.position,
        e
      )
    };
  }, o = (a) => {
    const l = n(a), u = V9(l);
    return uu.notify(u, l);
  };
  return o.update = (a, l) => {
    uu.update(a, n(l));
  }, o.promise = (a, l) => {
    const u = o({
      ...l.loading,
      status: "loading",
      duration: null
    });
    a.then(
      (f) => o.update(u, {
        status: "success",
        duration: 5e3,
        ...Ha(l.success, f)
      })
    ).catch(
      (f) => o.update(u, {
        status: "error",
        duration: 5e3,
        ...Ha(l.error, f)
      })
    );
  }, o.closeAll = uu.closeAll, o.close = uu.close, o.isActive = uu.isActive, o;
}
var [jce, Gce] = En({
  name: "ToastOptionsContext",
  strict: !1
}), z9 = (e) => {
  const t = x_(
    uu.subscribe,
    uu.getState,
    uu.getState
  ), {
    motionVariants: n,
    component: o = _9,
    portalProps: a
  } = e, u = Object.keys(t).map((f) => {
    const h = t[f];
    return /* @__PURE__ */ M(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${f}`,
        id: `chakra-toast-manager-${f}`,
        style: dae(f),
        children: /* @__PURE__ */ M(Cu, { initial: !1, children: h.map((v) => /* @__PURE__ */ M(
          o,
          {
            motionVariants: n,
            ...v
          },
          v.id
        )) })
      },
      f
    );
  });
  return /* @__PURE__ */ M(wf, { ...a, children: u });
};
function rDe(e) {
  const { theme: t } = p4(), n = Gce();
  return gt(
    () => $9(t.direction, {
      ...n,
      ...e
    }),
    [e, t.direction, n]
  );
}
var Wce = {
  duration: 5e3,
  variant: "solid"
}, bv = {
  theme: j_,
  colorMode: "light",
  toggleColorMode: () => {
  },
  setColorMode: () => {
  },
  defaultOptions: Wce,
  forced: !1
};
function oDe({
  theme: e = bv.theme,
  colorMode: t = bv.colorMode,
  toggleColorMode: n = bv.toggleColorMode,
  setColorMode: o = bv.setColorMode,
  defaultOptions: a = bv.defaultOptions,
  motionVariants: l,
  toastSpacing: u,
  component: f,
  forced: h
} = bv) {
  const v = {
    colorMode: t,
    setColorMode: o,
    toggleColorMode: n,
    forced: h
  };
  return {
    ToastContainer: () => /* @__PURE__ */ M(a3, { theme: e, children: /* @__PURE__ */ M(sS.Provider, { value: v, children: /* @__PURE__ */ M(
      z9,
      {
        defaultOptions: a,
        motionVariants: l,
        toastSpacing: u,
        component: f
      }
    ) }) }),
    toast: $9(e.direction, a)
  };
}
var Uce = (e) => function({
  children: n,
  theme: o = e,
  toastOptions: a,
  ...l
}) {
  return /* @__PURE__ */ Nt(lae, { theme: o, ...l, children: [
    /* @__PURE__ */ M(jce, { value: a == null ? void 0 : a.defaultOptions, children: n }),
    /* @__PURE__ */ M(z9, { ...a })
  ] });
}, iDe = Uce(j_), Xce = Object.defineProperty, Zce = (e, t, n) => t in e ? Xce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Vr = (e, t, n) => (Zce(e, typeof t != "symbol" ? t + "" : t, n), n);
function qV(e) {
  return e.sort((t, n) => {
    const o = t.compareDocumentPosition(n);
    if (o & Node.DOCUMENT_POSITION_FOLLOWING || o & Node.DOCUMENT_POSITION_CONTAINED_BY)
      return -1;
    if (o & Node.DOCUMENT_POSITION_PRECEDING || o & Node.DOCUMENT_POSITION_CONTAINS)
      return 1;
    if (o & Node.DOCUMENT_POSITION_DISCONNECTED || o & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
      throw Error("Cannot sort the given nodes.");
    return 0;
  });
}
var Yce = (e) => typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
function e$(e, t, n) {
  let o = e + 1;
  return n && o >= t && (o = 0), o;
}
function t$(e, t, n) {
  let o = e - 1;
  return n && o < 0 && (o = t), o;
}
var dO = typeof window < "u" ? ph : dt, Jw = (e) => e, Jce = class {
  constructor() {
    Vr(this, "descendants", /* @__PURE__ */ new Map()), Vr(this, "register", (e) => {
      if (e != null)
        return Yce(e) ? this.registerNode(e) : (t) => {
          this.registerNode(t, e);
        };
    }), Vr(this, "unregister", (e) => {
      this.descendants.delete(e);
      const t = qV(Array.from(this.descendants.keys()));
      this.assignIndex(t);
    }), Vr(this, "destroy", () => {
      this.descendants.clear();
    }), Vr(this, "assignIndex", (e) => {
      this.descendants.forEach((t) => {
        const n = e.indexOf(t.node);
        t.index = n, t.node.dataset.index = t.index.toString();
      });
    }), Vr(this, "count", () => this.descendants.size), Vr(this, "enabledCount", () => this.enabledValues().length), Vr(this, "values", () => Array.from(this.descendants.values()).sort((t, n) => t.index - n.index)), Vr(this, "enabledValues", () => this.values().filter((e) => !e.disabled)), Vr(this, "item", (e) => {
      if (this.count() !== 0)
        return this.values()[e];
    }), Vr(this, "enabledItem", (e) => {
      if (this.enabledCount() !== 0)
        return this.enabledValues()[e];
    }), Vr(this, "first", () => this.item(0)), Vr(this, "firstEnabled", () => this.enabledItem(0)), Vr(this, "last", () => this.item(this.descendants.size - 1)), Vr(this, "lastEnabled", () => {
      const e = this.enabledValues().length - 1;
      return this.enabledItem(e);
    }), Vr(this, "indexOf", (e) => {
      var t, n;
      return e && (n = (t = this.descendants.get(e)) == null ? void 0 : t.index) != null ? n : -1;
    }), Vr(this, "enabledIndexOf", (e) => e == null ? -1 : this.enabledValues().findIndex((t) => t.node.isSameNode(e))), Vr(this, "next", (e, t = !0) => {
      const n = e$(e, this.count(), t);
      return this.item(n);
    }), Vr(this, "nextEnabled", (e, t = !0) => {
      const n = this.item(e);
      if (!n)
        return;
      const o = this.enabledIndexOf(n.node), a = e$(
        o,
        this.enabledCount(),
        t
      );
      return this.enabledItem(a);
    }), Vr(this, "prev", (e, t = !0) => {
      const n = t$(e, this.count() - 1, t);
      return this.item(n);
    }), Vr(this, "prevEnabled", (e, t = !0) => {
      const n = this.item(e);
      if (!n)
        return;
      const o = this.enabledIndexOf(n.node), a = t$(
        o,
        this.enabledCount() - 1,
        t
      );
      return this.enabledItem(a);
    }), Vr(this, "registerNode", (e, t) => {
      if (!e || this.descendants.has(e))
        return;
      const n = Array.from(this.descendants.keys()).concat(e), o = qV(n);
      t != null && t.disabled && (t.disabled = !!t.disabled);
      const a = { node: e, index: -1, ...t };
      this.descendants.set(e, a), this.assignIndex(o);
    });
  }
};
function Qce(e, t) {
  if (e != null) {
    if (typeof e == "function") {
      e(t);
      return;
    }
    try {
      e.current = t;
    } catch {
      throw new Error(`Cannot assign value '${t}' to ref '${e}'`);
    }
  }
}
function Cn(...e) {
  return (t) => {
    e.forEach((n) => {
      Qce(n, t);
    });
  };
}
function Kce(...e) {
  return gt(() => Cn(...e), e);
}
function qce() {
  const e = Ue(new Jce());
  return dO(() => () => e.current.destroy()), e.current;
}
var [ede, H9] = En({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
function tde(e) {
  const t = H9(), [n, o] = ot(-1), a = Ue(null);
  dO(() => () => {
    a.current && t.unregister(a.current);
  }, []), dO(() => {
    if (!a.current)
      return;
    const u = Number(a.current.dataset.index);
    n != u && !Number.isNaN(u) && o(u);
  });
  const l = Jw(e ? t.register(e) : t.register);
  return {
    descendants: t,
    index: n,
    enabledIndex: t.enabledIndexOf(a.current),
    register: Cn(l, a)
  };
}
function v2() {
  return [
    Jw(ede),
    () => Jw(H9()),
    () => qce(),
    (a) => tde(a)
  ];
}
var [nde, nT] = En({
  name: "AccordionStylesContext",
  hookName: "useAccordionStyles",
  providerName: "<Accordion />"
}), [rde, g2] = En({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItem />"
}), [
  ode,
  aDe,
  ide,
  ade
] = v2(), j9 = Le(
  function(t, n) {
    const { getButtonProps: o } = g2(), a = o(t, n), u = {
      display: "flex",
      alignItems: "center",
      width: "100%",
      outline: 0,
      ...nT().button
    };
    return /* @__PURE__ */ M(
      De.button,
      {
        ...a,
        className: et("chakra-accordion__button", t.className),
        __css: u
      }
    );
  }
);
j9.displayName = "AccordionButton";
function Eg(e) {
  const {
    value: t,
    defaultValue: n,
    onChange: o,
    shouldUpdate: a = (S, w) => S !== w
  } = e, l = Er(o), u = Er(a), [f, h] = ot(n), v = t !== void 0, g = v ? t : f, b = Er(
    (S) => {
      const E = typeof S == "function" ? S(g) : S;
      u(g, E) && (v || h(E), l(E));
    },
    [v, l, g, u]
  );
  return [g, b];
}
function sde(e) {
  const {
    onChange: t,
    defaultIndex: n,
    index: o,
    allowMultiple: a,
    allowToggle: l,
    ...u
  } = e;
  cde(e), dde(e);
  const f = ide(), [h, v] = ot(-1);
  dt(() => () => {
    v(-1);
  }, []);
  const [g, b] = Eg({
    value: o,
    defaultValue() {
      return a ? n ?? [] : n ?? -1;
    },
    onChange: t
  });
  return {
    index: g,
    setIndex: b,
    htmlProps: u,
    getAccordionItemProps: (w) => {
      let E = !1;
      return w !== null && (E = Array.isArray(g) ? g.includes(w) : g === w), { isOpen: E, onChange: (A) => {
        if (w !== null)
          if (a && Array.isArray(g)) {
            const P = A ? g.concat(w) : g.filter((_) => _ !== w);
            b(P);
          } else
            A ? b(w) : l && b(-1);
      } };
    },
    focusedIndex: h,
    setFocusedIndex: v,
    descendants: f
  };
}
var [lde, y2] = En({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "Accordion"
});
function ude(e) {
  const { isDisabled: t, isFocusable: n, id: o, ...a } = e, { getAccordionItemProps: l, setFocusedIndex: u } = y2(), f = Ue(null), h = ko(), v = o ?? h, g = `accordion-button-${v}`, b = `accordion-panel-${v}`;
  fde(e);
  const { register: S, index: w, descendants: E } = ade({
    disabled: t && !n
  }), { isOpen: T, onChange: A } = l(
    w === -1 ? null : w
  );
  pde({ isOpen: T, isDisabled: t });
  const P = () => {
    A == null || A(!0);
  }, _ = () => {
    A == null || A(!1);
  }, D = re(() => {
    A == null || A(!T), u(w);
  }, [w, u, T, A]), L = re(
    (U) => {
      const H = {
        ArrowDown: () => {
          const G = E.nextEnabled(w);
          G == null || G.node.focus();
        },
        ArrowUp: () => {
          const G = E.prevEnabled(w);
          G == null || G.node.focus();
        },
        Home: () => {
          const G = E.firstEnabled();
          G == null || G.node.focus();
        },
        End: () => {
          const G = E.lastEnabled();
          G == null || G.node.focus();
        }
      }[U.key];
      H && (U.preventDefault(), H(U));
    },
    [E, w]
  ), F = re(() => {
    u(w);
  }, [u, w]), V = re(
    function(W = {}, H = null) {
      return {
        ...W,
        type: "button",
        ref: Cn(S, f, H),
        id: g,
        disabled: !!t,
        "aria-expanded": !!T,
        "aria-controls": b,
        onClick: st(W.onClick, D),
        onFocus: st(W.onFocus, F),
        onKeyDown: st(W.onKeyDown, L)
      };
    },
    [
      g,
      t,
      T,
      D,
      F,
      L,
      b,
      S
    ]
  ), $ = re(
    function(W = {}, H = null) {
      return {
        ...W,
        ref: H,
        role: "region",
        id: b,
        "aria-labelledby": g,
        hidden: !T
      };
    },
    [g, T, b]
  );
  return {
    isOpen: T,
    isDisabled: t,
    isFocusable: n,
    onOpen: P,
    onClose: _,
    getButtonProps: V,
    getPanelProps: $,
    htmlProps: a
  };
}
function cde(e) {
  const t = e.index || e.defaultIndex, n = t != null && !Array.isArray(t) && e.allowMultiple;
  lS({
    condition: !!n,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof t},`
  });
}
function dde(e) {
  lS({
    condition: !!(e.allowMultiple && e.allowToggle),
    message: "If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not"
  });
}
function fde(e) {
  lS({
    condition: !!(e.isFocusable && !e.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}
function pde(e) {
  lS({
    condition: e.isOpen && !!e.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}
function G9(e) {
  const { isOpen: t, isDisabled: n } = g2(), { reduceMotion: o } = y2(), a = et("chakra-accordion__icon", e.className), l = nT(), u = {
    opacity: n ? 0.4 : 1,
    transform: t ? "rotate(-180deg)" : void 0,
    transition: o ? void 0 : "transform 0.2s",
    transformOrigin: "center",
    ...l.icon
  };
  return /* @__PURE__ */ M(
    ho,
    {
      viewBox: "0 0 24 24",
      "aria-hidden": !0,
      className: a,
      __css: u,
      ...e,
      children: /* @__PURE__ */ M(
        "path",
        {
          fill: "currentColor",
          d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
        }
      )
    }
  );
}
G9.displayName = "AccordionIcon";
var W9 = Le(
  function(t, n) {
    const { children: o, className: a } = t, { htmlProps: l, ...u } = ude(t), h = {
      ...nT().container,
      overflowAnchor: "none"
    }, v = gt(() => u, [u]);
    return /* @__PURE__ */ M(rde, { value: v, children: /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        ...l,
        className: et("chakra-accordion__item", a),
        __css: h,
        children: typeof o == "function" ? o({
          isExpanded: !!u.isOpen,
          isDisabled: !!u.isDisabled
        }) : o
      }
    ) });
  }
);
W9.displayName = "AccordionItem";
var Qp = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
}, Jb = {
  scale: {
    enter: { scale: 1 },
    exit: { scale: 0.95 }
  },
  fade: {
    enter: { opacity: 1 },
    exit: { opacity: 0 }
  },
  pushLeft: {
    enter: { x: "100%" },
    exit: { x: "-30%" }
  },
  pushRight: {
    enter: { x: "-100%" },
    exit: { x: "30%" }
  },
  pushUp: {
    enter: { y: "100%" },
    exit: { y: "-30%" }
  },
  pushDown: {
    enter: { y: "-100%" },
    exit: { y: "30%" }
  },
  slideLeft: {
    position: { left: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "-100%", y: 0 }
  },
  slideRight: {
    position: { right: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "100%", y: 0 }
  },
  slideUp: {
    position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "-100%" }
  },
  slideDown: {
    position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "100%" }
  }
};
function fO(e) {
  var t;
  switch ((t = e == null ? void 0 : e.direction) != null ? t : "right") {
    case "right":
      return Jb.slideRight;
    case "left":
      return Jb.slideLeft;
    case "bottom":
      return Jb.slideDown;
    case "top":
      return Jb.slideUp;
    default:
      return Jb.slideRight;
  }
}
var th = {
  enter: {
    duration: 0.2,
    ease: Qp.easeOut
  },
  exit: {
    duration: 0.1,
    ease: Qp.easeIn
  }
}, Sl = {
  enter: (e, t) => ({
    ...e,
    delay: typeof t == "number" ? t : t == null ? void 0 : t.enter
  }),
  exit: (e, t) => ({
    ...e,
    delay: typeof t == "number" ? t : t == null ? void 0 : t.exit
  })
}, hde = (e) => e != null && parseInt(e.toString(), 10) > 0, n$ = {
  exit: {
    height: { duration: 0.2, ease: Qp.ease },
    opacity: { duration: 0.3, ease: Qp.ease }
  },
  enter: {
    height: { duration: 0.3, ease: Qp.ease },
    opacity: { duration: 0.4, ease: Qp.ease }
  }
}, mde = {
  exit: ({
    animateOpacity: e,
    startingHeight: t,
    transition: n,
    transitionEnd: o,
    delay: a
  }) => {
    var l;
    return {
      ...e && { opacity: hde(t) ? 1 : 0 },
      height: t,
      transitionEnd: o == null ? void 0 : o.exit,
      transition: (l = n == null ? void 0 : n.exit) != null ? l : Sl.exit(n$.exit, a)
    };
  },
  enter: ({
    animateOpacity: e,
    endingHeight: t,
    transition: n,
    transitionEnd: o,
    delay: a
  }) => {
    var l;
    return {
      ...e && { opacity: 1 },
      height: t,
      transitionEnd: o == null ? void 0 : o.enter,
      transition: (l = n == null ? void 0 : n.enter) != null ? l : Sl.enter(n$.enter, a)
    };
  }
}, b2 = fr(
  (e, t) => {
    const {
      in: n,
      unmountOnExit: o,
      animateOpacity: a = !0,
      startingHeight: l = 0,
      endingHeight: u = "auto",
      style: f,
      className: h,
      transition: v,
      transitionEnd: g,
      ...b
    } = e, [S, w] = ot(!1);
    dt(() => {
      const _ = setTimeout(() => {
        w(!0);
      });
      return () => clearTimeout(_);
    }, []), lS({
      condition: Number(l) > 0 && !!o,
      message: "startingHeight and unmountOnExit are mutually exclusive. You can't use them together"
    });
    const E = parseFloat(l.toString()) > 0, T = {
      startingHeight: l,
      endingHeight: u,
      animateOpacity: a,
      transition: S ? v : { enter: { duration: 0 } },
      transitionEnd: {
        enter: g == null ? void 0 : g.enter,
        exit: o ? g == null ? void 0 : g.exit : {
          ...g == null ? void 0 : g.exit,
          display: E ? "block" : "none"
        }
      }
    }, A = o ? n : !0, P = n || o ? "enter" : "exit";
    return /* @__PURE__ */ M(Cu, { initial: !1, custom: T, children: A && /* @__PURE__ */ M(
      ti.div,
      {
        ref: t,
        ...b,
        className: et("chakra-collapse", h),
        style: {
          overflow: "hidden",
          display: "block",
          ...f
        },
        custom: T,
        variants: mde,
        initial: o ? "exit" : !1,
        animate: P,
        exit: "exit"
      }
    ) });
  }
);
b2.displayName = "Collapse";
var vde = {
  enter: ({ transition: e, transitionEnd: t, delay: n } = {}) => {
    var o;
    return {
      opacity: 1,
      transition: (o = e == null ? void 0 : e.enter) != null ? o : Sl.enter(th.enter, n),
      transitionEnd: t == null ? void 0 : t.enter
    };
  },
  exit: ({ transition: e, transitionEnd: t, delay: n } = {}) => {
    var o;
    return {
      opacity: 0,
      transition: (o = e == null ? void 0 : e.exit) != null ? o : Sl.exit(th.exit, n),
      transitionEnd: t == null ? void 0 : t.exit
    };
  }
}, U9 = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: vde
}, gde = fr(function(t, n) {
  const {
    unmountOnExit: o,
    in: a,
    className: l,
    transition: u,
    transitionEnd: f,
    delay: h,
    ...v
  } = t, g = a || o ? "enter" : "exit", b = o ? a && o : !0, S = { transition: u, transitionEnd: f, delay: h };
  return /* @__PURE__ */ M(Cu, { custom: S, children: b && /* @__PURE__ */ M(
    ti.div,
    {
      ref: n,
      className: et("chakra-fade", l),
      custom: S,
      ...U9,
      animate: g,
      ...v
    }
  ) });
});
gde.displayName = "Fade";
var yde = {
  exit: ({ reverse: e, initialScale: t, transition: n, transitionEnd: o, delay: a }) => {
    var l;
    return {
      opacity: 0,
      ...e ? { scale: t, transitionEnd: o == null ? void 0 : o.exit } : { transitionEnd: { scale: t, ...o == null ? void 0 : o.exit } },
      transition: (l = n == null ? void 0 : n.exit) != null ? l : Sl.exit(th.exit, a)
    };
  },
  enter: ({ transitionEnd: e, transition: t, delay: n }) => {
    var o;
    return {
      opacity: 1,
      scale: 1,
      transition: (o = t == null ? void 0 : t.enter) != null ? o : Sl.enter(th.enter, n),
      transitionEnd: e == null ? void 0 : e.enter
    };
  }
}, X9 = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: yde
}, bde = fr(
  function(t, n) {
    const {
      unmountOnExit: o,
      in: a,
      reverse: l = !0,
      initialScale: u = 0.95,
      className: f,
      transition: h,
      transitionEnd: v,
      delay: g,
      ...b
    } = t, S = o ? a && o : !0, w = a || o ? "enter" : "exit", E = { initialScale: u, reverse: l, transition: h, transitionEnd: v, delay: g };
    return /* @__PURE__ */ M(Cu, { custom: E, children: S && /* @__PURE__ */ M(
      ti.div,
      {
        ref: n,
        className: et("chakra-offset-slide", f),
        ...X9,
        animate: w,
        custom: E,
        ...b
      }
    ) });
  }
);
bde.displayName = "ScaleFade";
var Sde = {
  initial: ({ offsetX: e, offsetY: t, transition: n, transitionEnd: o, delay: a }) => {
    var l;
    return {
      opacity: 0,
      x: e,
      y: t,
      transition: (l = n == null ? void 0 : n.exit) != null ? l : Sl.exit(th.exit, a),
      transitionEnd: o == null ? void 0 : o.exit
    };
  },
  enter: ({ transition: e, transitionEnd: t, delay: n }) => {
    var o;
    return {
      opacity: 1,
      x: 0,
      y: 0,
      transition: (o = e == null ? void 0 : e.enter) != null ? o : Sl.enter(th.enter, n),
      transitionEnd: t == null ? void 0 : t.enter
    };
  },
  exit: ({ offsetY: e, offsetX: t, transition: n, transitionEnd: o, reverse: a, delay: l }) => {
    var u;
    const f = { x: t, y: e };
    return {
      opacity: 0,
      transition: (u = n == null ? void 0 : n.exit) != null ? u : Sl.exit(th.exit, l),
      ...a ? { ...f, transitionEnd: o == null ? void 0 : o.exit } : { transitionEnd: { ...f, ...o == null ? void 0 : o.exit } }
    };
  }
}, f0 = {
  initial: "initial",
  animate: "enter",
  exit: "exit",
  variants: Sde
}, xde = fr(
  function(t, n) {
    const {
      unmountOnExit: o,
      in: a,
      reverse: l = !0,
      className: u,
      offsetX: f = 0,
      offsetY: h = 8,
      transition: v,
      transitionEnd: g,
      delay: b,
      ...S
    } = t, w = o ? a && o : !0, E = a || o ? "enter" : "exit", T = {
      offsetX: f,
      offsetY: h,
      reverse: l,
      transition: v,
      transitionEnd: g,
      delay: b
    };
    return /* @__PURE__ */ M(Cu, { custom: T, children: w && /* @__PURE__ */ M(
      ti.div,
      {
        ref: n,
        className: et("chakra-offset-slide", u),
        custom: T,
        ...f0,
        animate: E,
        ...S
      }
    ) });
  }
);
xde.displayName = "SlideFade";
var r$ = {
  exit: {
    duration: 0.15,
    ease: Qp.easeInOut
  },
  enter: {
    type: "spring",
    damping: 25,
    stiffness: 180
  }
}, Cde = {
  exit: ({ direction: e, transition: t, transitionEnd: n, delay: o }) => {
    var a;
    const { exit: l } = fO({ direction: e });
    return {
      ...l,
      transition: (a = t == null ? void 0 : t.exit) != null ? a : Sl.exit(r$.exit, o),
      transitionEnd: n == null ? void 0 : n.exit
    };
  },
  enter: ({ direction: e, transitionEnd: t, transition: n, delay: o }) => {
    var a;
    const { enter: l } = fO({ direction: e });
    return {
      ...l,
      transition: (a = n == null ? void 0 : n.enter) != null ? a : Sl.enter(r$.enter, o),
      transitionEnd: t == null ? void 0 : t.enter
    };
  }
}, wde = fr(function(t, n) {
  const {
    direction: o = "right",
    style: a,
    unmountOnExit: l,
    in: u,
    className: f,
    transition: h,
    transitionEnd: v,
    delay: g,
    motionProps: b,
    ...S
  } = t, w = fO({ direction: o }), E = Object.assign(
    { position: "fixed" },
    w.position,
    a
  ), T = l ? u && l : !0, A = u || l ? "enter" : "exit", P = { transitionEnd: v, transition: h, direction: o, delay: g };
  return /* @__PURE__ */ M(Cu, { custom: P, children: T && /* @__PURE__ */ M(
    ti.div,
    {
      ...S,
      ref: n,
      initial: "exit",
      className: et("chakra-slide", f),
      animate: A,
      exit: "exit",
      custom: P,
      variants: Cde,
      style: E,
      ...b
    }
  ) });
});
wde.displayName = "Slide";
var Z9 = Le(
  function(t, n) {
    const { className: o, motionProps: a, ...l } = t, { reduceMotion: u } = y2(), { getPanelProps: f, isOpen: h } = g2(), v = f(l, n), g = et("chakra-accordion__panel", o), b = nT();
    u || delete v.hidden;
    const S = /* @__PURE__ */ M(De.div, { ...v, __css: b.panel, className: g });
    return u ? S : /* @__PURE__ */ M(b2, { in: h, ...a, children: S });
  }
);
Z9.displayName = "AccordionPanel";
var Y9 = Le(function({ children: t, reduceMotion: n, ...o }, a) {
  const l = Xn("Accordion", o), u = Pn(o), { htmlProps: f, descendants: h, ...v } = sde(u), g = gt(
    () => ({ ...v, reduceMotion: !!n }),
    [v, n]
  );
  return /* @__PURE__ */ M(ode, { value: h, children: /* @__PURE__ */ M(lde, { value: g, children: /* @__PURE__ */ M(nde, { value: l, children: /* @__PURE__ */ M(
    De.div,
    {
      ref: a,
      ...f,
      className: et("chakra-accordion", o.className),
      __css: l.root,
      children: t
    }
  ) }) }) });
});
Y9.displayName = "Accordion";
var pO = Le(function(t, n) {
  const { htmlWidth: o, htmlHeight: a, alt: l, ...u } = t;
  return /* @__PURE__ */ M("img", { width: o, height: a, ref: n, alt: l, ...u });
});
pO.displayName = "NativeImage";
function Ede(e) {
  const {
    loading: t,
    src: n,
    srcSet: o,
    onLoad: a,
    onError: l,
    crossOrigin: u,
    sizes: f,
    ignoreFallback: h
  } = e, [v, g] = ot("pending");
  dt(() => {
    g(n ? "loading" : "pending");
  }, [n]);
  const b = Ue(), S = re(() => {
    if (!n)
      return;
    w();
    const E = new Image();
    E.src = n, u && (E.crossOrigin = u), o && (E.srcset = o), f && (E.sizes = f), t && (E.loading = t), E.onload = (T) => {
      w(), g("loaded"), a == null || a(T);
    }, E.onerror = (T) => {
      w(), g("failed"), l == null || l(T);
    }, b.current = E;
  }, [n, u, o, f, a, l, t]), w = () => {
    b.current && (b.current.onload = null, b.current.onerror = null, b.current = null);
  };
  return Ss(() => {
    if (!h)
      return v === "loading" && S(), () => {
        w();
      };
  }, [v, S, h]), h ? "loaded" : v;
}
var Tde = (e, t) => e !== "loaded" && t === "beforeLoadOrError" || e === "failed" && t === "onError";
function Ide(e, t = []) {
  const n = Object.assign({}, e);
  for (const o of t)
    o in n && delete n[o];
  return n;
}
var Ade = Le(function(t, n) {
  const {
    fallbackSrc: o,
    fallback: a,
    src: l,
    srcSet: u,
    align: f,
    fit: h,
    loading: v,
    ignoreFallback: g,
    crossOrigin: b,
    fallbackStrategy: S = "beforeLoadOrError",
    referrerPolicy: w,
    ...E
  } = t, T = o !== void 0 || a !== void 0, A = v != null || // use can opt out of fallback image
  g || // if the user doesn't provide any kind of fallback we should ignore it
  !T, P = Ede({
    ...t,
    crossOrigin: b,
    ignoreFallback: A
  }), _ = Tde(P, S), D = {
    ref: n,
    objectFit: h,
    objectPosition: f,
    ...A ? E : Ide(E, ["onError", "onLoad"])
  };
  return _ ? a || /* @__PURE__ */ M(
    De.img,
    {
      as: pO,
      className: "chakra-image__placeholder",
      src: o,
      ...D
    }
  ) : /* @__PURE__ */ M(
    De.img,
    {
      as: pO,
      src: l,
      srcSet: u,
      crossOrigin: b,
      loading: v,
      referrerPolicy: w,
      className: "chakra-image",
      ...D
    }
  );
});
Ade.displayName = "Image";
function gS(e) {
  return Gc.toArray(e).filter(
    (t) => hh(t)
  );
}
var [kde, Rde] = En({
  strict: !1,
  name: "ButtonGroupContext"
}), Pde = {
  horizontal: {
    "> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 }
  },
  vertical: {
    "> *:first-of-type:not(:last-of-type)": { borderBottomRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderTopRadius: 0 }
  }
}, Ode = {
  horizontal: (e) => ({
    "& > *:not(style) ~ *:not(style)": { marginStart: e }
  }),
  vertical: (e) => ({
    "& > *:not(style) ~ *:not(style)": { marginTop: e }
  })
}, J9 = Le(
  function(t, n) {
    const {
      size: o,
      colorScheme: a,
      variant: l,
      className: u,
      spacing: f = "0.5rem",
      isAttached: h,
      isDisabled: v,
      orientation: g = "horizontal",
      ...b
    } = t, S = et("chakra-button__group", u), w = gt(
      () => ({ size: o, colorScheme: a, variant: l, isDisabled: v }),
      [o, a, l, v]
    );
    let E = {
      display: "inline-flex",
      ...h ? Pde[g] : Ode[g](f)
    };
    const T = g === "vertical";
    return /* @__PURE__ */ M(kde, { value: w, children: /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        role: "group",
        __css: E,
        className: S,
        "data-attached": h ? "" : void 0,
        "data-orientation": g,
        flexDir: T ? "column" : void 0,
        ...b
      }
    ) });
  }
);
J9.displayName = "ButtonGroup";
function _de(e) {
  const [t, n] = ot(!e);
  return { ref: re((l) => {
    l && n(l.tagName === "BUTTON");
  }, []), type: t ? "button" : void 0 };
}
function hO(e) {
  const { children: t, className: n, ...o } = e, a = hh(t) ? ya(t, {
    "aria-hidden": !0,
    focusable: !1
  }) : t, l = et("chakra-button__icon", n);
  return /* @__PURE__ */ M(
    De.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...o,
      className: l,
      children: a
    }
  );
}
hO.displayName = "ButtonIcon";
function mO(e) {
  const {
    label: t,
    placement: n,
    spacing: o = "0.5rem",
    children: a = /* @__PURE__ */ M(eT, { color: "currentColor", width: "1em", height: "1em" }),
    className: l,
    __css: u,
    ...f
  } = e, h = et("chakra-button__spinner", l), v = n === "start" ? "marginEnd" : "marginStart", g = gt(
    () => ({
      display: "flex",
      alignItems: "center",
      position: t ? "relative" : "absolute",
      [v]: t ? o : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...u
    }),
    [u, t, v, o]
  );
  return /* @__PURE__ */ M(De.div, { className: h, ...f, __css: g, children: a });
}
mO.displayName = "ButtonSpinner";
var Qw = Le((e, t) => {
  const n = Rde(), o = Gi("Button", { ...n, ...e }), {
    isDisabled: a = n == null ? void 0 : n.isDisabled,
    isLoading: l,
    isActive: u,
    children: f,
    leftIcon: h,
    rightIcon: v,
    loadingText: g,
    iconSpacing: b = "0.5rem",
    type: S,
    spinner: w,
    spinnerPlacement: E = "start",
    className: T,
    as: A,
    ...P
  } = Pn(e), _ = gt(() => {
    const V = { ...o == null ? void 0 : o._focus, zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...o,
      ...!!n && { _focus: V }
    };
  }, [o, n]), { ref: D, type: L } = _de(A), F = { rightIcon: v, leftIcon: h, iconSpacing: b, children: f };
  return /* @__PURE__ */ Nt(
    De.button,
    {
      ref: Kce(t, D),
      as: A,
      type: S ?? L,
      "data-active": Ft(u),
      "data-loading": Ft(l),
      __css: _,
      className: et("chakra-button", T),
      ...P,
      disabled: a || l,
      children: [
        l && E === "start" && /* @__PURE__ */ M(
          mO,
          {
            className: "chakra-button__spinner--start",
            label: g,
            placement: "start",
            spacing: b,
            children: w
          }
        ),
        l ? g || /* @__PURE__ */ M(De.span, { opacity: 0, children: /* @__PURE__ */ M(o$, { ...F }) }) : /* @__PURE__ */ M(o$, { ...F }),
        l && E === "end" && /* @__PURE__ */ M(
          mO,
          {
            className: "chakra-button__spinner--end",
            label: g,
            placement: "end",
            spacing: b,
            children: w
          }
        )
      ]
    }
  );
});
Qw.displayName = "Button";
function o$(e) {
  const { leftIcon: t, rightIcon: n, children: o, iconSpacing: a } = e;
  return /* @__PURE__ */ Nt(ah, { children: [
    t && /* @__PURE__ */ M(hO, { marginEnd: a, children: t }),
    o,
    n && /* @__PURE__ */ M(hO, { marginStart: a, children: n })
  ] });
}
var vO = Le(
  (e, t) => {
    const { icon: n, children: o, isRound: a, "aria-label": l, ...u } = e, f = n || o, h = hh(f) ? ya(f, {
      "aria-hidden": !0,
      focusable: !1
    }) : null;
    return /* @__PURE__ */ M(
      Qw,
      {
        padding: "0",
        borderRadius: a ? "full" : void 0,
        ref: t,
        "aria-label": l,
        ...u,
        children: h
      }
    );
  }
);
vO.displayName = "IconButton";
var [Dde, S2] = iae("Card"), sDe = Le(function(t, n) {
  const { className: o, ...a } = t, l = S2();
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: n,
      className: et("chakra-card__body", o),
      __css: l.body,
      ...a
    }
  );
}), lDe = Le(
  function(t, n) {
    const { className: o, justify: a, ...l } = t, u = S2();
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        className: et("chakra-card__footer", o),
        __css: {
          display: "flex",
          justifyContent: a,
          ...u.footer
        },
        ...l
      }
    );
  }
), uDe = Le(
  function(t, n) {
    const { className: o, ...a } = t, l = S2();
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: n,
        className: et("chakra-card__header", o),
        __css: l.header,
        ...a
      }
    );
  }
), cDe = Le(function(t, n) {
  const {
    className: o,
    children: a,
    direction: l = "column",
    justify: u,
    align: f,
    ...h
  } = Pn(t), v = Xn("Card", t);
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: n,
      className: et("chakra-card", o),
      __css: {
        display: "flex",
        flexDirection: l,
        justifyContent: u,
        alignItems: f,
        position: "relative",
        minWidth: 0,
        wordWrap: "break-word",
        ...v.container
      },
      ...h,
      children: /* @__PURE__ */ M(Dde, { value: v, children: a })
    }
  );
}), [dDe, Nde] = En({
  name: "CheckboxGroupContext",
  strict: !1
});
function Mde(e) {
  const [t, n] = ot(e), [o, a] = ot(!1);
  return e !== t && (a(!0), n(e)), o;
}
function Lde(e) {
  return /* @__PURE__ */ M(
    De.svg,
    {
      width: "1.2em",
      viewBox: "0 0 12 10",
      style: {
        fill: "none",
        strokeWidth: 2,
        stroke: "currentColor",
        strokeDasharray: 16
      },
      ...e,
      children: /* @__PURE__ */ M("polyline", { points: "1.5 6 4.5 9 10.5 1" })
    }
  );
}
function Fde(e) {
  return /* @__PURE__ */ M(
    De.svg,
    {
      width: "1.2em",
      viewBox: "0 0 24 24",
      style: { stroke: "currentColor", strokeWidth: 4 },
      ...e,
      children: /* @__PURE__ */ M("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
    }
  );
}
function Bde(e) {
  const { isIndeterminate: t, isChecked: n, ...o } = e, a = t ? Fde : Lde;
  return n || t ? /* @__PURE__ */ M(
    De.div,
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%"
      },
      children: /* @__PURE__ */ M(a, { ...o })
    }
  ) : null;
}
var [Vde, Q9] = En({
  name: "FormControlStylesContext",
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
}), [$de, gh] = En({
  strict: !1,
  name: "FormControlContext"
});
function zde(e) {
  const {
    id: t,
    isRequired: n,
    isInvalid: o,
    isDisabled: a,
    isReadOnly: l,
    ...u
  } = e, f = ko(), h = t || `field-${f}`, v = `${h}-label`, g = `${h}-feedback`, b = `${h}-helptext`, [S, w] = ot(!1), [E, T] = ot(!1), [A, P] = ot(!1), _ = re(
    ($ = {}, U = null) => ({
      id: b,
      ...$,
      /**
       * Notify the field context when the help text is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: Cn(U, (W) => {
        W && T(!0);
      })
    }),
    [b]
  ), D = re(
    ($ = {}, U = null) => ({
      ...$,
      ref: U,
      "data-focus": Ft(A),
      "data-disabled": Ft(a),
      "data-invalid": Ft(o),
      "data-readonly": Ft(l),
      id: $.id !== void 0 ? $.id : v,
      htmlFor: $.htmlFor !== void 0 ? $.htmlFor : h
    }),
    [h, a, A, o, l, v]
  ), L = re(
    ($ = {}, U = null) => ({
      id: g,
      ...$,
      /**
       * Notify the field context when the error message is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: Cn(U, (W) => {
        W && w(!0);
      }),
      "aria-live": "polite"
    }),
    [g]
  ), F = re(
    ($ = {}, U = null) => ({
      ...$,
      ...u,
      ref: U,
      role: "group",
      "data-focus": Ft(A),
      "data-disabled": Ft(a),
      "data-invalid": Ft(o),
      "data-readonly": Ft(l)
    }),
    [u, a, A, o, l]
  ), V = re(
    ($ = {}, U = null) => ({
      ...$,
      ref: U,
      role: "presentation",
      "aria-hidden": !0,
      children: $.children || "*"
    }),
    []
  );
  return {
    isRequired: !!n,
    isInvalid: !!o,
    isReadOnly: !!l,
    isDisabled: !!a,
    isFocused: !!A,
    onFocus: () => P(!0),
    onBlur: () => P(!1),
    hasFeedbackText: S,
    setHasFeedbackText: w,
    hasHelpText: E,
    setHasHelpText: T,
    id: h,
    labelId: v,
    feedbackId: g,
    helpTextId: b,
    htmlProps: u,
    getHelpTextProps: _,
    getErrorMessageProps: L,
    getRootProps: F,
    getLabelProps: D,
    getRequiredIndicatorProps: V
  };
}
var K9 = Le(
  function(t, n) {
    const o = Xn("Form", t), a = Pn(t), {
      getRootProps: l,
      htmlProps: u,
      ...f
    } = zde(a), h = et("chakra-form-control", t.className);
    return /* @__PURE__ */ M($de, { value: f, children: /* @__PURE__ */ M(Vde, { value: o, children: /* @__PURE__ */ M(
      De.div,
      {
        ...l({}, n),
        className: h,
        __css: o.container
      }
    ) }) });
  }
);
K9.displayName = "FormControl";
var Hde = Le(
  function(t, n) {
    const o = gh(), a = Q9(), l = et("chakra-form__helper-text", t.className);
    return /* @__PURE__ */ M(
      De.div,
      {
        ...o == null ? void 0 : o.getHelpTextProps(t, n),
        __css: a.helperText,
        className: l
      }
    );
  }
);
Hde.displayName = "FormHelperText";
var [jde, Gde] = En({
  name: "FormErrorStylesContext",
  errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `
}), Wde = Le(
  (e, t) => {
    const n = Xn("FormError", e), o = Pn(e), a = gh();
    return a != null && a.isInvalid ? /* @__PURE__ */ M(jde, { value: n, children: /* @__PURE__ */ M(
      De.div,
      {
        ...a == null ? void 0 : a.getErrorMessageProps(o, t),
        className: et("chakra-form__error-message", e.className),
        __css: {
          display: "flex",
          alignItems: "center",
          ...n.text
        }
      }
    ) }) : null;
  }
);
Wde.displayName = "FormErrorMessage";
var Ude = Le((e, t) => {
  const n = Gde(), o = gh();
  if (!(o != null && o.isInvalid))
    return null;
  const a = et("chakra-form__error-icon", e.className);
  return /* @__PURE__ */ M(
    ho,
    {
      ref: t,
      "aria-hidden": !0,
      ...e,
      __css: n.icon,
      className: a,
      children: /* @__PURE__ */ M(
        "path",
        {
          fill: "currentColor",
          d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
        }
      )
    }
  );
});
Ude.displayName = "FormErrorIcon";
var q9 = Le(function(t, n) {
  var o;
  const a = Gi("FormLabel", t), l = Pn(t), {
    className: u,
    children: f,
    requiredIndicator: h = /* @__PURE__ */ M(eH, {}),
    optionalIndicator: v = null,
    ...g
  } = l, b = gh(), S = (o = b == null ? void 0 : b.getLabelProps(g, n)) != null ? o : { ref: n, ...g };
  return /* @__PURE__ */ Nt(
    De.label,
    {
      ...S,
      className: et("chakra-form__label", l.className),
      __css: {
        display: "block",
        textAlign: "start",
        ...a
      },
      children: [
        f,
        b != null && b.isRequired ? h : v
      ]
    }
  );
});
q9.displayName = "FormLabel";
var eH = Le(
  function(t, n) {
    const o = gh(), a = Q9();
    if (!(o != null && o.isRequired))
      return null;
    const l = et("chakra-form__required-indicator", t.className);
    return /* @__PURE__ */ M(
      De.span,
      {
        ...o == null ? void 0 : o.getRequiredIndicatorProps(t, n),
        __css: a.requiredIndicator,
        className: l
      }
    );
  }
);
eH.displayName = "RequiredIndicator";
function yh(e) {
  const { isDisabled: t, isInvalid: n, isReadOnly: o, isRequired: a, ...l } = x2(e);
  return {
    ...l,
    disabled: t,
    readOnly: o,
    required: a,
    "aria-invalid": xs(n),
    "aria-required": xs(a),
    "aria-readonly": xs(o)
  };
}
function x2(e) {
  var t, n, o;
  const a = gh(), {
    id: l,
    disabled: u,
    readOnly: f,
    required: h,
    isRequired: v,
    isInvalid: g,
    isReadOnly: b,
    isDisabled: S,
    onFocus: w,
    onBlur: E,
    ...T
  } = e, A = e["aria-describedby"] ? [e["aria-describedby"]] : [];
  return a != null && a.hasFeedbackText && (a != null && a.isInvalid) && A.push(a.feedbackId), a != null && a.hasHelpText && A.push(a.helpTextId), {
    ...T,
    "aria-describedby": A.join(" ") || void 0,
    id: l ?? (a == null ? void 0 : a.id),
    isDisabled: (t = u ?? S) != null ? t : a == null ? void 0 : a.isDisabled,
    isReadOnly: (n = f ?? b) != null ? n : a == null ? void 0 : a.isReadOnly,
    isRequired: (o = h ?? v) != null ? o : a == null ? void 0 : a.isRequired,
    isInvalid: g ?? (a == null ? void 0 : a.isInvalid),
    onFocus: st(a == null ? void 0 : a.onFocus, w),
    onBlur: st(a == null ? void 0 : a.onBlur, E)
  };
}
var Xde = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
}, Zde = () => typeof document < "u", i$ = !1, yS = null, sh = !1, gO = !1, yO = /* @__PURE__ */ new Set();
function C2(e, t) {
  yO.forEach((n) => n(e, t));
}
var Yde = typeof window < "u" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : !1;
function Jde(e) {
  return !(e.metaKey || !Yde && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function a$(e) {
  sh = !0, Jde(e) && (yS = "keyboard", C2("keyboard", e));
}
function Sv(e) {
  if (yS = "pointer", e.type === "mousedown" || e.type === "pointerdown") {
    sh = !0;
    const t = e.composedPath ? e.composedPath()[0] : e.target;
    let n = !1;
    try {
      n = t.matches(":focus-visible");
    } catch {
    }
    if (n)
      return;
    C2("pointer", e);
  }
}
function Qde(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : e.detail === 0 && !e.pointerType;
}
function Kde(e) {
  Qde(e) && (sh = !0, yS = "virtual");
}
function qde(e) {
  e.target === window || e.target === document || (!sh && !gO && (yS = "virtual", C2("virtual", e)), sh = !1, gO = !1);
}
function efe() {
  sh = !1, gO = !0;
}
function s$() {
  return yS !== "pointer";
}
function tfe() {
  if (!Zde() || i$)
    return;
  const { focus: e } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function(...n) {
    sh = !0, e.apply(this, n);
  }, document.addEventListener("keydown", a$, !0), document.addEventListener("keyup", a$, !0), document.addEventListener("click", Kde, !0), window.addEventListener("focus", qde, !0), window.addEventListener("blur", efe, !1), typeof PointerEvent < "u" ? (document.addEventListener("pointerdown", Sv, !0), document.addEventListener("pointermove", Sv, !0), document.addEventListener("pointerup", Sv, !0)) : (document.addEventListener("mousedown", Sv, !0), document.addEventListener("mousemove", Sv, !0), document.addEventListener("mouseup", Sv, !0)), i$ = !0;
}
function tH(e) {
  tfe(), e(s$());
  const t = () => e(s$());
  return yO.add(t), () => {
    yO.delete(t);
  };
}
function nfe(e, t = []) {
  const n = Object.assign({}, e);
  for (const o of t)
    o in n && delete n[o];
  return n;
}
function nH(e = {}) {
  const t = x2(e), {
    isDisabled: n,
    isReadOnly: o,
    isRequired: a,
    isInvalid: l,
    id: u,
    onBlur: f,
    onFocus: h,
    "aria-describedby": v
  } = t, {
    defaultChecked: g,
    isChecked: b,
    isFocusable: S,
    onChange: w,
    isIndeterminate: E,
    name: T,
    value: A,
    tabIndex: P = void 0,
    "aria-label": _,
    "aria-labelledby": D,
    "aria-invalid": L,
    ...F
  } = e, V = nfe(F, [
    "isDisabled",
    "isReadOnly",
    "isRequired",
    "isInvalid",
    "id",
    "onBlur",
    "onFocus",
    "aria-describedby"
  ]), $ = Er(w), U = Er(f), W = Er(h), [H, G] = ot(!1), [oe, ce] = ot(!1), [te, Ee] = ot(!1), [me, J] = ot(!1);
  dt(() => tH(G), []);
  const Q = Ue(null), [ge, Y] = ot(!0), [q, de] = ot(!!g), K = b !== void 0, ne = K ? b : q, pe = re(
    (Ie) => {
      if (o || n) {
        Ie.preventDefault();
        return;
      }
      K || de(ne ? Ie.target.checked : E ? !0 : Ie.target.checked), $ == null || $(Ie);
    },
    [
      o,
      n,
      ne,
      K,
      E,
      $
    ]
  );
  Ss(() => {
    Q.current && (Q.current.indeterminate = !!E);
  }, [E]), xl(() => {
    n && ce(!1);
  }, [n, ce]), Ss(() => {
    const Ie = Q.current;
    if (!(Ie != null && Ie.form))
      return;
    const qe = () => {
      de(!!g);
    };
    return Ie.form.addEventListener("reset", qe), () => {
      var Qe;
      return (Qe = Ie.form) == null ? void 0 : Qe.removeEventListener("reset", qe);
    };
  }, []);
  const Oe = n && !S, Ce = re(
    (Ie) => {
      Ie.key === " " && J(!0);
    },
    [J]
  ), xe = re(
    (Ie) => {
      Ie.key === " " && J(!1);
    },
    [J]
  );
  Ss(() => {
    if (!Q.current)
      return;
    Q.current.checked !== ne && de(Q.current.checked);
  }, [Q.current]);
  const ie = re(
    (Ie = {}, qe = null) => {
      const Qe = (lt) => {
        oe && lt.preventDefault(), J(!0);
      };
      return {
        ...Ie,
        ref: qe,
        "data-active": Ft(me),
        "data-hover": Ft(te),
        "data-checked": Ft(ne),
        "data-focus": Ft(oe),
        "data-focus-visible": Ft(oe && H),
        "data-indeterminate": Ft(E),
        "data-disabled": Ft(n),
        "data-invalid": Ft(l),
        "data-readonly": Ft(o),
        "aria-hidden": !0,
        onMouseDown: st(Ie.onMouseDown, Qe),
        onMouseUp: st(Ie.onMouseUp, () => J(!1)),
        onMouseEnter: st(
          Ie.onMouseEnter,
          () => Ee(!0)
        ),
        onMouseLeave: st(
          Ie.onMouseLeave,
          () => Ee(!1)
        )
      };
    },
    [
      me,
      ne,
      n,
      oe,
      H,
      te,
      E,
      l,
      o
    ]
  ), ye = re(
    (Ie = {}, qe = null) => ({
      ...Ie,
      ref: qe,
      "data-active": Ft(me),
      "data-hover": Ft(te),
      "data-checked": Ft(ne),
      "data-focus": Ft(oe),
      "data-focus-visible": Ft(oe && H),
      "data-indeterminate": Ft(E),
      "data-disabled": Ft(n),
      "data-invalid": Ft(l),
      "data-readonly": Ft(o)
    }),
    [
      me,
      ne,
      n,
      oe,
      H,
      te,
      E,
      l,
      o
    ]
  ), we = re(
    (Ie = {}, qe = null) => ({
      ...V,
      ...Ie,
      ref: Cn(qe, (Qe) => {
        Qe && Y(Qe.tagName === "LABEL");
      }),
      onClick: st(Ie.onClick, () => {
        var Qe;
        ge || ((Qe = Q.current) == null || Qe.click(), requestAnimationFrame(() => {
          var lt;
          (lt = Q.current) == null || lt.focus({ preventScroll: !0 });
        }));
      }),
      "data-disabled": Ft(n),
      "data-checked": Ft(ne),
      "data-invalid": Ft(l)
    }),
    [V, n, ne, l, ge]
  ), fe = re(
    (Ie = {}, qe = null) => ({
      ...Ie,
      ref: Cn(Q, qe),
      type: "checkbox",
      name: T,
      value: A,
      id: u,
      tabIndex: P,
      onChange: st(Ie.onChange, pe),
      onBlur: st(
        Ie.onBlur,
        U,
        () => ce(!1)
      ),
      onFocus: st(
        Ie.onFocus,
        W,
        () => ce(!0)
      ),
      onKeyDown: st(Ie.onKeyDown, Ce),
      onKeyUp: st(Ie.onKeyUp, xe),
      required: a,
      checked: ne,
      disabled: Oe,
      readOnly: o,
      "aria-label": _,
      "aria-labelledby": D,
      "aria-invalid": L ? !!L : l,
      "aria-describedby": v,
      "aria-disabled": n,
      style: Xde
    }),
    [
      T,
      A,
      u,
      pe,
      U,
      W,
      Ce,
      xe,
      a,
      ne,
      Oe,
      o,
      _,
      D,
      L,
      l,
      v,
      n,
      P
    ]
  ), ze = re(
    (Ie = {}, qe = null) => ({
      ...Ie,
      ref: qe,
      onMouseDown: st(Ie.onMouseDown, rfe),
      "data-disabled": Ft(n),
      "data-checked": Ft(ne),
      "data-invalid": Ft(l)
    }),
    [ne, n, l]
  );
  return {
    state: {
      isInvalid: l,
      isFocused: oe,
      isChecked: ne,
      isActive: me,
      isHovered: te,
      isIndeterminate: E,
      isDisabled: n,
      isReadOnly: o,
      isRequired: a
    },
    getRootProps: we,
    getCheckboxProps: ie,
    getIndicatorProps: ye,
    getInputProps: fe,
    getLabelProps: ze,
    htmlProps: V
  };
}
function rfe(e) {
  e.preventDefault(), e.stopPropagation();
}
var ofe = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  verticalAlign: "top",
  userSelect: "none",
  flexShrink: 0
}, ife = {
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "top",
  position: "relative"
}, afe = Ps({
  from: {
    opacity: 0,
    strokeDashoffset: 16,
    transform: "scale(0.95)"
  },
  to: {
    opacity: 1,
    strokeDashoffset: 0,
    transform: "scale(1)"
  }
}), sfe = Ps({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
}), lfe = Ps({
  from: {
    transform: "scaleX(0.65)"
  },
  to: {
    transform: "scaleX(1)"
  }
}), ufe = Le(function(t, n) {
  const o = Nde(), a = { ...o, ...t }, l = Xn("Checkbox", a), u = Pn(t), {
    spacing: f = "0.5rem",
    className: h,
    children: v,
    iconColor: g,
    iconSize: b,
    icon: S = /* @__PURE__ */ M(Bde, {}),
    isChecked: w,
    isDisabled: E = o == null ? void 0 : o.isDisabled,
    onChange: T,
    inputProps: A,
    ...P
  } = u;
  let _ = w;
  o != null && o.value && u.value && (_ = o.value.includes(u.value));
  let D = T;
  o != null && o.onChange && u.value && (D = zE(o.onChange, T));
  const {
    state: L,
    getInputProps: F,
    getCheckboxProps: V,
    getLabelProps: $,
    getRootProps: U
  } = nH({
    ...P,
    isDisabled: E,
    isChecked: _,
    onChange: D
  }), W = Mde(L.isChecked), H = gt(
    () => ({
      animation: W ? L.isIndeterminate ? `${sfe} 20ms linear, ${lfe} 200ms linear` : `${afe} 200ms linear` : void 0,
      fontSize: b,
      color: g,
      ...l.icon
    }),
    [g, b, W, L.isIndeterminate, l.icon]
  ), G = ya(S, {
    __css: H,
    isIndeterminate: L.isIndeterminate,
    isChecked: L.isChecked
  });
  return /* @__PURE__ */ Nt(
    De.label,
    {
      __css: { ...ife, ...l.container },
      className: et("chakra-checkbox", h),
      ...U(),
      children: [
        /* @__PURE__ */ M(
          "input",
          {
            className: "chakra-checkbox__input",
            ...F(A, n)
          }
        ),
        /* @__PURE__ */ M(
          De.span,
          {
            __css: { ...ofe, ...l.control },
            className: "chakra-checkbox__control",
            ...V(),
            children: G
          }
        ),
        v && /* @__PURE__ */ M(
          De.span,
          {
            className: "chakra-checkbox__label",
            ...$(),
            __css: {
              marginStart: f,
              ...l.label
            },
            children: v
          }
        )
      ]
    }
  );
});
ufe.displayName = "Checkbox";
function cfe(e) {
  const t = parseFloat(e);
  return typeof t != "number" || Number.isNaN(t) ? 0 : t;
}
function w2(e, t) {
  let n = cfe(e);
  const o = 10 ** (t ?? 10);
  return n = Math.round(n * o) / o, t ? n.toFixed(t) : n.toString();
}
function bO(e) {
  if (!Number.isFinite(e))
    return 0;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n += 1;
  return n;
}
function Kw(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function rH(e, t, n) {
  return (n - t) * e + t;
}
function SO(e, t, n) {
  const o = Math.round((e - t) / n) * n + t, a = bO(n);
  return w2(o, a);
}
function Yv(e, t, n) {
  return e == null ? e : (n < t && console.warn("clamp: max cannot be less than min"), Math.min(Math.max(e, t), n));
}
function dfe(e = {}) {
  const {
    onChange: t,
    precision: n,
    defaultValue: o,
    value: a,
    step: l = 1,
    min: u = Number.MIN_SAFE_INTEGER,
    max: f = Number.MAX_SAFE_INTEGER,
    keepWithinRange: h = !0
  } = e, v = Er(t), [g, b] = ot(() => {
    var H;
    return o == null ? "" : (H = jR(o, l, n)) != null ? H : "";
  }), S = typeof a < "u", w = S ? a : g, E = oH(ef(w), l), T = n ?? E, A = re(
    (H) => {
      H !== w && (S || b(H.toString()), v == null || v(H.toString(), ef(H)));
    },
    [v, S, w]
  ), P = re(
    (H) => {
      let G = H;
      return h && (G = Yv(G, u, f)), w2(G, T);
    },
    [T, h, f, u]
  ), _ = re(
    (H = l) => {
      let G;
      w === "" ? G = ef(H) : G = ef(w) + H, G = P(G), A(G);
    },
    [P, l, A, w]
  ), D = re(
    (H = l) => {
      let G;
      w === "" ? G = ef(-H) : G = ef(w) - H, G = P(G), A(G);
    },
    [P, l, A, w]
  ), L = re(() => {
    var H;
    let G;
    o == null ? G = "" : G = (H = jR(o, l, n)) != null ? H : u, A(G);
  }, [o, n, l, A, u]), F = re(
    (H) => {
      var G;
      const oe = (G = jR(H, l, T)) != null ? G : u;
      A(oe);
    },
    [T, l, A, u]
  ), V = ef(w);
  return {
    isOutOfRange: V > f || V < u,
    isAtMax: V === f,
    isAtMin: V === u,
    precision: T,
    value: w,
    valueAsNumber: V,
    update: A,
    reset: L,
    increment: _,
    decrement: D,
    clamp: P,
    cast: F,
    setValue: b
  };
}
function ef(e) {
  return parseFloat(e.toString().replace(/[^\w.-]+/g, ""));
}
function oH(e, t) {
  return Math.max(bO(t), bO(e));
}
function jR(e, t, n) {
  const o = ef(e);
  if (Number.isNaN(o))
    return;
  const a = oH(o, t);
  return w2(o, n ?? a);
}
var [ffe, E2] = En({
  name: "EditableStylesContext",
  errorMessage: `useEditableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Editable />" `
}), [pfe, rT] = En({
  name: "EditableContext",
  errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
}), T2 = {
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent"
}, hfe = Le(
  function(t, n) {
    const { getInputProps: o } = rT(), a = E2(), l = o(t, n), u = et("chakra-editable__input", t.className);
    return /* @__PURE__ */ M(
      De.input,
      {
        ...l,
        __css: {
          outline: 0,
          ...T2,
          ...a.input
        },
        className: u
      }
    );
  }
);
hfe.displayName = "EditableInput";
var mfe = Le(
  function(t, n) {
    const { getPreviewProps: o } = rT(), a = E2(), l = o(t, n), u = et("chakra-editable__preview", t.className);
    return /* @__PURE__ */ M(
      De.span,
      {
        ...l,
        __css: {
          cursor: "text",
          display: "inline-block",
          ...T2,
          ...a.preview
        },
        className: u
      }
    );
  }
);
mfe.displayName = "EditablePreview";
var vfe = Le(
  function(t, n) {
    const { getTextareaProps: o } = rT(), a = E2(), l = o(t, n), u = et("chakra-editable__textarea", t.className);
    return /* @__PURE__ */ M(
      De.textarea,
      {
        ...l,
        __css: {
          outline: 0,
          ...T2,
          ...a.textarea
        },
        className: u
      }
    );
  }
);
vfe.displayName = "EditableTextarea";
function nh(e, t, n, o) {
  const a = Er(n);
  return dt(() => {
    const l = typeof e == "function" ? e() : e ?? document;
    if (!(!n || !l))
      return l.addEventListener(t, a, o), () => {
        l.removeEventListener(t, a, o);
      };
  }, [t, e, o, a, n]), () => {
    const l = typeof e == "function" ? e() : e ?? document;
    l == null || l.removeEventListener(t, a, o);
  };
}
function gfe(e) {
  return "current" in e;
}
var iH = () => typeof window < "u";
function yfe() {
  var e;
  const t = navigator.userAgentData;
  return (e = t == null ? void 0 : t.platform) != null ? e : navigator.platform;
}
var bfe = (e) => iH() && e.test(navigator.vendor), Sfe = (e) => iH() && e.test(yfe()), xfe = () => Sfe(/mac|iphone|ipad|ipod/i), Cfe = () => xfe() && bfe(/apple/i);
function aH(e) {
  const { ref: t, elements: n, enabled: o } = e, a = () => {
    var l, u;
    return (u = (l = t.current) == null ? void 0 : l.ownerDocument) != null ? u : document;
  };
  nh(a, "pointerdown", (l) => {
    if (!Cfe() || !o)
      return;
    const u = l.target, h = (n ?? [t]).some((v) => {
      const g = gfe(v) ? v.current : v;
      return (g == null ? void 0 : g.contains(u)) || g === u;
    });
    a().activeElement !== u && h && (l.preventDefault(), u.focus());
  });
}
function l$(e, t) {
  return e ? e === t || e.contains(t) : !1;
}
function wfe(e = {}) {
  const {
    onChange: t,
    onCancel: n,
    onSubmit: o,
    onBlur: a,
    value: l,
    isDisabled: u,
    defaultValue: f,
    startWithEditView: h,
    isPreviewFocusable: v = !0,
    submitOnBlur: g = !0,
    selectAllOnFocus: b = !0,
    placeholder: S,
    onEdit: w,
    finalFocusRef: E,
    ...T
  } = e, A = Er(w), P = !!(h && !u), [_, D] = ot(P), [L, F] = Eg({
    defaultValue: f || "",
    value: l,
    onChange: t
  }), [V, $] = ot(L), U = Ue(null), W = Ue(null), H = Ue(null), G = Ue(null), oe = Ue(null);
  aH({
    ref: U,
    enabled: _,
    elements: [G, oe]
  });
  const ce = !_ && !u;
  Ss(() => {
    var ie, ye;
    _ && ((ie = U.current) == null || ie.focus(), b && ((ye = U.current) == null || ye.select()));
  }, []), xl(() => {
    var ie, ye, we, fe;
    if (!_) {
      E ? (ie = E.current) == null || ie.focus() : (ye = H.current) == null || ye.focus();
      return;
    }
    (we = U.current) == null || we.focus(), b && ((fe = U.current) == null || fe.select()), A == null || A();
  }, [_, A, b]);
  const te = re(() => {
    ce && D(!0);
  }, [ce]), Ee = re(() => {
    $(L);
  }, [L]), me = re(() => {
    D(!1), F(V), n == null || n(V), a == null || a(V);
  }, [n, a, F, V]), J = re(() => {
    D(!1), $(L), o == null || o(L), a == null || a(V);
  }, [L, o, a, V]);
  dt(() => {
    if (_)
      return;
    const ie = U.current;
    (ie == null ? void 0 : ie.ownerDocument.activeElement) === ie && (ie == null || ie.blur());
  }, [_]);
  const Q = re(
    (ie) => {
      F(ie.currentTarget.value);
    },
    [F]
  ), ge = re(
    (ie) => {
      const ye = ie.key, fe = {
        Escape: me,
        Enter: (ze) => {
          !ze.shiftKey && !ze.metaKey && J();
        }
      }[ye];
      fe && (ie.preventDefault(), fe(ie));
    },
    [me, J]
  ), Y = re(
    (ie) => {
      const ye = ie.key, fe = {
        Escape: me
      }[ye];
      fe && (ie.preventDefault(), fe(ie));
    },
    [me]
  ), q = L.length === 0, de = re(
    (ie) => {
      var ye;
      if (!_)
        return;
      const we = ie.currentTarget.ownerDocument, fe = (ye = ie.relatedTarget) != null ? ye : we.activeElement, ze = l$(G.current, fe), Ve = l$(oe.current, fe);
      !ze && !Ve && (g ? J() : me());
    },
    [g, J, me, _]
  ), K = re(
    (ie = {}, ye = null) => {
      const we = ce && v ? 0 : void 0;
      return {
        ...ie,
        ref: Cn(ye, W),
        children: q ? S : L,
        hidden: _,
        "aria-disabled": xs(u),
        tabIndex: we,
        onFocus: st(ie.onFocus, te, Ee)
      };
    },
    [
      u,
      _,
      ce,
      v,
      q,
      te,
      Ee,
      S,
      L
    ]
  ), ne = re(
    (ie = {}, ye = null) => ({
      ...ie,
      hidden: !_,
      placeholder: S,
      ref: Cn(ye, U),
      disabled: u,
      "aria-disabled": xs(u),
      value: L,
      onBlur: st(ie.onBlur, de),
      onChange: st(ie.onChange, Q),
      onKeyDown: st(ie.onKeyDown, ge),
      onFocus: st(ie.onFocus, Ee)
    }),
    [
      u,
      _,
      de,
      Q,
      ge,
      Ee,
      S,
      L
    ]
  ), pe = re(
    (ie = {}, ye = null) => ({
      ...ie,
      hidden: !_,
      placeholder: S,
      ref: Cn(ye, U),
      disabled: u,
      "aria-disabled": xs(u),
      value: L,
      onBlur: st(ie.onBlur, de),
      onChange: st(ie.onChange, Q),
      onKeyDown: st(ie.onKeyDown, Y),
      onFocus: st(ie.onFocus, Ee)
    }),
    [
      u,
      _,
      de,
      Q,
      Y,
      Ee,
      S,
      L
    ]
  ), Oe = re(
    (ie = {}, ye = null) => ({
      "aria-label": "Edit",
      ...ie,
      type: "button",
      onClick: st(ie.onClick, te),
      ref: Cn(ye, H),
      disabled: u
    }),
    [te, u]
  ), Ce = re(
    (ie = {}, ye = null) => ({
      ...ie,
      "aria-label": "Submit",
      ref: Cn(oe, ye),
      type: "button",
      onClick: st(ie.onClick, J),
      disabled: u
    }),
    [J, u]
  ), xe = re(
    (ie = {}, ye = null) => ({
      "aria-label": "Cancel",
      id: "cancel",
      ...ie,
      ref: Cn(G, ye),
      type: "button",
      onClick: st(ie.onClick, me),
      disabled: u
    }),
    [me, u]
  );
  return {
    isEditing: _,
    isDisabled: u,
    isValueEmpty: q,
    value: L,
    onEdit: te,
    onCancel: me,
    onSubmit: J,
    getPreviewProps: K,
    getInputProps: ne,
    getTextareaProps: pe,
    getEditButtonProps: Oe,
    getSubmitButtonProps: Ce,
    getCancelButtonProps: xe,
    htmlProps: T
  };
}
var Efe = Le(function(t, n) {
  const o = Xn("Editable", t), a = Pn(t), { htmlProps: l, ...u } = wfe(a), { isEditing: f, onSubmit: h, onCancel: v, onEdit: g } = u, b = et("chakra-editable", t.className), S = Ha(t.children, {
    isEditing: f,
    onSubmit: h,
    onCancel: v,
    onEdit: g
  });
  return /* @__PURE__ */ M(pfe, { value: u, children: /* @__PURE__ */ M(ffe, { value: o, children: /* @__PURE__ */ M(
    De.div,
    {
      ref: n,
      ...l,
      className: b,
      children: S
    }
  ) }) });
});
Efe.displayName = "Editable";
function fDe() {
  const {
    isEditing: e,
    getEditButtonProps: t,
    getCancelButtonProps: n,
    getSubmitButtonProps: o
  } = rT();
  return {
    isEditing: e,
    getEditButtonProps: t,
    getCancelButtonProps: n,
    getSubmitButtonProps: o
  };
}
function sH(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var xO = { exports: {} }, GR, u$;
function I2() {
  if (u$)
    return GR;
  u$ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return GR = e, GR;
}
var WR, c$;
function Tfe() {
  if (c$)
    return WR;
  c$ = 1;
  var e = I2();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, WR = function() {
    function o(u, f, h, v, g, b) {
      if (b !== e) {
        var S = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw S.name = "Invariant Violation", S;
      }
    }
    o.isRequired = o;
    function a() {
      return o;
    }
    var l = {
      array: o,
      bigint: o,
      bool: o,
      func: o,
      number: o,
      object: o,
      string: o,
      symbol: o,
      any: o,
      arrayOf: a,
      element: o,
      elementType: o,
      instanceOf: a,
      node: o,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return l.PropTypes = l, l;
  }, WR;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var UR, d$;
function Ife() {
  if (d$)
    return UR;
  d$ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function o(l) {
    if (l == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(l);
  }
  function a() {
    try {
      if (!Object.assign)
        return !1;
      var l = new String("abc");
      if (l[5] = "de", Object.getOwnPropertyNames(l)[0] === "5")
        return !1;
      for (var u = {}, f = 0; f < 10; f++)
        u["_" + String.fromCharCode(f)] = f;
      var h = Object.getOwnPropertyNames(u).map(function(g) {
        return u[g];
      });
      if (h.join("") !== "0123456789")
        return !1;
      var v = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(g) {
        v[g] = g;
      }), Object.keys(Object.assign({}, v)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return UR = a() ? Object.assign : function(l, u) {
    for (var f, h = o(l), v, g = 1; g < arguments.length; g++) {
      f = Object(arguments[g]);
      for (var b in f)
        t.call(f, b) && (h[b] = f[b]);
      if (e) {
        v = e(f);
        for (var S = 0; S < v.length; S++)
          n.call(f, v[S]) && (h[v[S]] = f[v[S]]);
      }
    }
    return h;
  }, UR;
}
var XR, f$;
function lH() {
  return f$ || (f$ = 1, XR = Function.call.bind(Object.prototype.hasOwnProperty)), XR;
}
var ZR, p$;
function Afe() {
  if (p$)
    return ZR;
  p$ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = I2(), n = {}, o = lH();
    e = function(l) {
      var u = "Warning: " + l;
      typeof console < "u" && console.error(u);
      try {
        throw new Error(u);
      } catch {
      }
    };
  }
  function a(l, u, f, h, v) {
    if (process.env.NODE_ENV !== "production") {
      for (var g in l)
        if (o(l, g)) {
          var b;
          try {
            if (typeof l[g] != "function") {
              var S = Error(
                (h || "React class") + ": " + f + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw S.name = "Invariant Violation", S;
            }
            b = l[g](u, g, h, f, null, t);
          } catch (E) {
            b = E;
          }
          if (b && !(b instanceof Error) && e(
            (h || "React class") + ": type specification of " + f + " `" + g + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof b + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), b instanceof Error && !(b.message in n)) {
            n[b.message] = !0;
            var w = v ? v() : "";
            e(
              "Failed " + f + " type: " + b.message + (w ?? "")
            );
          }
        }
    }
  }
  return a.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ZR = a, ZR;
}
var YR, h$;
function kfe() {
  if (h$)
    return YR;
  h$ = 1;
  var e = A_, t = Ife(), n = I2(), o = lH(), a = Afe(), l = function() {
  };
  process.env.NODE_ENV !== "production" && (l = function(f) {
    var h = "Warning: " + f;
    typeof console < "u" && console.error(h);
    try {
      throw new Error(h);
    } catch {
    }
  });
  function u() {
    return null;
  }
  return YR = function(f, h) {
    var v = typeof Symbol == "function" && Symbol.iterator, g = "@@iterator";
    function b(Y) {
      var q = Y && (v && Y[v] || Y[g]);
      if (typeof q == "function")
        return q;
    }
    var S = "<<anonymous>>", w = {
      array: P("array"),
      bigint: P("bigint"),
      bool: P("boolean"),
      func: P("function"),
      number: P("number"),
      object: P("object"),
      string: P("string"),
      symbol: P("symbol"),
      any: _(),
      arrayOf: D,
      element: L(),
      elementType: F(),
      instanceOf: V,
      node: H(),
      objectOf: U,
      oneOf: $,
      oneOfType: W,
      shape: oe,
      exact: ce
    };
    function E(Y, q) {
      return Y === q ? Y !== 0 || 1 / Y === 1 / q : Y !== Y && q !== q;
    }
    function T(Y, q) {
      this.message = Y, this.data = q && typeof q == "object" ? q : {}, this.stack = "";
    }
    T.prototype = Error.prototype;
    function A(Y) {
      if (process.env.NODE_ENV !== "production")
        var q = {}, de = 0;
      function K(pe, Oe, Ce, xe, ie, ye, we) {
        if (xe = xe || S, ye = ye || Ce, we !== n) {
          if (h) {
            var fe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw fe.name = "Invariant Violation", fe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ze = xe + ":" + Ce;
            !q[ze] && // Avoid spamming the console because they are often not actionable except for lib authors
            de < 3 && (l(
              "You are manually calling a React.PropTypes validation function for the `" + ye + "` prop on `" + xe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), q[ze] = !0, de++);
          }
        }
        return Oe[Ce] == null ? pe ? Oe[Ce] === null ? new T("The " + ie + " `" + ye + "` is marked as required " + ("in `" + xe + "`, but its value is `null`.")) : new T("The " + ie + " `" + ye + "` is marked as required in " + ("`" + xe + "`, but its value is `undefined`.")) : null : Y(Oe, Ce, xe, ie, ye);
      }
      var ne = K.bind(null, !1);
      return ne.isRequired = K.bind(null, !0), ne;
    }
    function P(Y) {
      function q(de, K, ne, pe, Oe, Ce) {
        var xe = de[K], ie = me(xe);
        if (ie !== Y) {
          var ye = J(xe);
          return new T(
            "Invalid " + pe + " `" + Oe + "` of type " + ("`" + ye + "` supplied to `" + ne + "`, expected ") + ("`" + Y + "`."),
            { expectedType: Y }
          );
        }
        return null;
      }
      return A(q);
    }
    function _() {
      return A(u);
    }
    function D(Y) {
      function q(de, K, ne, pe, Oe) {
        if (typeof Y != "function")
          return new T("Property `" + Oe + "` of component `" + ne + "` has invalid PropType notation inside arrayOf.");
        var Ce = de[K];
        if (!Array.isArray(Ce)) {
          var xe = me(Ce);
          return new T("Invalid " + pe + " `" + Oe + "` of type " + ("`" + xe + "` supplied to `" + ne + "`, expected an array."));
        }
        for (var ie = 0; ie < Ce.length; ie++) {
          var ye = Y(Ce, ie, ne, pe, Oe + "[" + ie + "]", n);
          if (ye instanceof Error)
            return ye;
        }
        return null;
      }
      return A(q);
    }
    function L() {
      function Y(q, de, K, ne, pe) {
        var Oe = q[de];
        if (!f(Oe)) {
          var Ce = me(Oe);
          return new T("Invalid " + ne + " `" + pe + "` of type " + ("`" + Ce + "` supplied to `" + K + "`, expected a single ReactElement."));
        }
        return null;
      }
      return A(Y);
    }
    function F() {
      function Y(q, de, K, ne, pe) {
        var Oe = q[de];
        if (!e.isValidElementType(Oe)) {
          var Ce = me(Oe);
          return new T("Invalid " + ne + " `" + pe + "` of type " + ("`" + Ce + "` supplied to `" + K + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return A(Y);
    }
    function V(Y) {
      function q(de, K, ne, pe, Oe) {
        if (!(de[K] instanceof Y)) {
          var Ce = Y.name || S, xe = ge(de[K]);
          return new T("Invalid " + pe + " `" + Oe + "` of type " + ("`" + xe + "` supplied to `" + ne + "`, expected ") + ("instance of `" + Ce + "`."));
        }
        return null;
      }
      return A(q);
    }
    function $(Y) {
      if (!Array.isArray(Y))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? l(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : l("Invalid argument supplied to oneOf, expected an array.")), u;
      function q(de, K, ne, pe, Oe) {
        for (var Ce = de[K], xe = 0; xe < Y.length; xe++)
          if (E(Ce, Y[xe]))
            return null;
        var ie = JSON.stringify(Y, function(we, fe) {
          var ze = J(fe);
          return ze === "symbol" ? String(fe) : fe;
        });
        return new T("Invalid " + pe + " `" + Oe + "` of value `" + String(Ce) + "` " + ("supplied to `" + ne + "`, expected one of " + ie + "."));
      }
      return A(q);
    }
    function U(Y) {
      function q(de, K, ne, pe, Oe) {
        if (typeof Y != "function")
          return new T("Property `" + Oe + "` of component `" + ne + "` has invalid PropType notation inside objectOf.");
        var Ce = de[K], xe = me(Ce);
        if (xe !== "object")
          return new T("Invalid " + pe + " `" + Oe + "` of type " + ("`" + xe + "` supplied to `" + ne + "`, expected an object."));
        for (var ie in Ce)
          if (o(Ce, ie)) {
            var ye = Y(Ce, ie, ne, pe, Oe + "." + ie, n);
            if (ye instanceof Error)
              return ye;
          }
        return null;
      }
      return A(q);
    }
    function W(Y) {
      if (!Array.isArray(Y))
        return process.env.NODE_ENV !== "production" && l("Invalid argument supplied to oneOfType, expected an instance of array."), u;
      for (var q = 0; q < Y.length; q++) {
        var de = Y[q];
        if (typeof de != "function")
          return l(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(de) + " at index " + q + "."
          ), u;
      }
      function K(ne, pe, Oe, Ce, xe) {
        for (var ie = [], ye = 0; ye < Y.length; ye++) {
          var we = Y[ye], fe = we(ne, pe, Oe, Ce, xe, n);
          if (fe == null)
            return null;
          fe.data && o(fe.data, "expectedType") && ie.push(fe.data.expectedType);
        }
        var ze = ie.length > 0 ? ", expected one of type [" + ie.join(", ") + "]" : "";
        return new T("Invalid " + Ce + " `" + xe + "` supplied to " + ("`" + Oe + "`" + ze + "."));
      }
      return A(K);
    }
    function H() {
      function Y(q, de, K, ne, pe) {
        return te(q[de]) ? null : new T("Invalid " + ne + " `" + pe + "` supplied to " + ("`" + K + "`, expected a ReactNode."));
      }
      return A(Y);
    }
    function G(Y, q, de, K, ne) {
      return new T(
        (Y || "React class") + ": " + q + " type `" + de + "." + K + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ne + "`."
      );
    }
    function oe(Y) {
      function q(de, K, ne, pe, Oe) {
        var Ce = de[K], xe = me(Ce);
        if (xe !== "object")
          return new T("Invalid " + pe + " `" + Oe + "` of type `" + xe + "` " + ("supplied to `" + ne + "`, expected `object`."));
        for (var ie in Y) {
          var ye = Y[ie];
          if (typeof ye != "function")
            return G(ne, pe, Oe, ie, J(ye));
          var we = ye(Ce, ie, ne, pe, Oe + "." + ie, n);
          if (we)
            return we;
        }
        return null;
      }
      return A(q);
    }
    function ce(Y) {
      function q(de, K, ne, pe, Oe) {
        var Ce = de[K], xe = me(Ce);
        if (xe !== "object")
          return new T("Invalid " + pe + " `" + Oe + "` of type `" + xe + "` " + ("supplied to `" + ne + "`, expected `object`."));
        var ie = t({}, de[K], Y);
        for (var ye in ie) {
          var we = Y[ye];
          if (o(Y, ye) && typeof we != "function")
            return G(ne, pe, Oe, ye, J(we));
          if (!we)
            return new T(
              "Invalid " + pe + " `" + Oe + "` key `" + ye + "` supplied to `" + ne + "`.\nBad object: " + JSON.stringify(de[K], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(Y), null, "  ")
            );
          var fe = we(Ce, ye, ne, pe, Oe + "." + ye, n);
          if (fe)
            return fe;
        }
        return null;
      }
      return A(q);
    }
    function te(Y) {
      switch (typeof Y) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !Y;
        case "object":
          if (Array.isArray(Y))
            return Y.every(te);
          if (Y === null || f(Y))
            return !0;
          var q = b(Y);
          if (q) {
            var de = q.call(Y), K;
            if (q !== Y.entries) {
              for (; !(K = de.next()).done; )
                if (!te(K.value))
                  return !1;
            } else
              for (; !(K = de.next()).done; ) {
                var ne = K.value;
                if (ne && !te(ne[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Ee(Y, q) {
      return Y === "symbol" ? !0 : q ? q["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && q instanceof Symbol : !1;
    }
    function me(Y) {
      var q = typeof Y;
      return Array.isArray(Y) ? "array" : Y instanceof RegExp ? "object" : Ee(q, Y) ? "symbol" : q;
    }
    function J(Y) {
      if (typeof Y > "u" || Y === null)
        return "" + Y;
      var q = me(Y);
      if (q === "object") {
        if (Y instanceof Date)
          return "date";
        if (Y instanceof RegExp)
          return "regexp";
      }
      return q;
    }
    function Q(Y) {
      var q = J(Y);
      switch (q) {
        case "array":
        case "object":
          return "an " + q;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + q;
        default:
          return q;
      }
    }
    function ge(Y) {
      return !Y.constructor || !Y.constructor.name ? S : Y.constructor.name;
    }
    return w.checkPropTypes = a, w.resetWarningCache = a.resetWarningCache, w.PropTypes = w, w;
  }, YR;
}
if (process.env.NODE_ENV !== "production") {
  var Rfe = A_, Pfe = !0;
  xO.exports = kfe()(Rfe.isElement, Pfe);
} else
  xO.exports = Tfe()();
var cr = xO.exports;
const uH = /* @__PURE__ */ I_(cr);
var CO = "data-focus-lock", cH = "data-focus-lock-disabled", Ofe = "data-no-focus-lock", _fe = "data-autofocus-inside", Dfe = "data-no-autofocus";
function JR(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Nfe(e, t) {
  var n = ot(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(o) {
          var a = n.value;
          a !== o && (n.value = o, n.callback(o, a));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var m$ = /* @__PURE__ */ new WeakMap();
function dH(e, t) {
  var n = Nfe(t || null, function(o) {
    return e.forEach(function(a) {
      return JR(a, o);
    });
  });
  return Fe.useLayoutEffect(function() {
    var o = m$.get(n);
    if (o) {
      var a = new Set(o), l = new Set(e), u = n.current;
      a.forEach(function(f) {
        l.has(f) || JR(f, null);
      }), l.forEach(function(f) {
        a.has(f) || JR(f, u);
      });
    }
    m$.set(n, e);
  }, [e]), n;
}
var QR = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
process.env.NODE_ENV !== "production" && uH.node;
var cu = function() {
  return cu = Object.assign || function(t) {
    for (var n, o = 1, a = arguments.length; o < a; o++) {
      n = arguments[o];
      for (var l in n)
        Object.prototype.hasOwnProperty.call(n, l) && (t[l] = n[l]);
    }
    return t;
  }, cu.apply(this, arguments);
};
function fH(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, o = Object.getOwnPropertySymbols(e); a < o.length; a++)
      t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[a]) && (n[o[a]] = e[o[a]]);
  return n;
}
function Mfe(e, t, n) {
  if (n || arguments.length === 2)
    for (var o = 0, a = t.length, l; o < a; o++)
      (l || !(o in t)) && (l || (l = Array.prototype.slice.call(t, 0, o)), l[o] = t[o]);
  return e.concat(l || Array.prototype.slice.call(t));
}
function pH(e) {
  return e;
}
function hH(e, t) {
  t === void 0 && (t = pH);
  var n = [], o = !1, a = {
    read: function() {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(l) {
      var u = t(l, o);
      return n.push(u), function() {
        n = n.filter(function(f) {
          return f !== u;
        });
      };
    },
    assignSyncMedium: function(l) {
      for (o = !0; n.length; ) {
        var u = n;
        n = [], u.forEach(l);
      }
      n = {
        push: function(f) {
          return l(f);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(l) {
      o = !0;
      var u = [];
      if (n.length) {
        var f = n;
        n = [], f.forEach(l), u = n;
      }
      var h = function() {
        var g = u;
        u = [], g.forEach(l);
      }, v = function() {
        return Promise.resolve().then(h);
      };
      v(), n = {
        push: function(g) {
          u.push(g), v();
        },
        filter: function(g) {
          return u = u.filter(g), n;
        }
      };
    }
  };
  return a;
}
function A2(e, t) {
  return t === void 0 && (t = pH), hH(e, t);
}
function mH(e) {
  e === void 0 && (e = {});
  var t = hH(null);
  return t.options = cu({ async: !0, ssr: !1 }, e), t;
}
var vH = function(e) {
  var t = e.sideCar, n = fH(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = t.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return Fe.createElement(o, cu({}, n));
};
vH.isSideCarExport = !0;
function Lfe(e, t) {
  return e.useMedium(t), vH;
}
var gH = A2({}, function(e) {
  var t = e.target, n = e.currentTarget;
  return {
    target: t,
    currentTarget: n
  };
}), yH = A2(), Ffe = A2(), Bfe = mH({
  async: !0
  // focus-lock sidecar is not required on the server
  // however, it might be required for JSDOM tests
  // ssr: true,
}), Vfe = [], k2 = /* @__PURE__ */ Fe.forwardRef(function(t, n) {
  var o, a = Fe.useState(), l = a[0], u = a[1], f = Fe.useRef(), h = Fe.useRef(!1), v = Fe.useRef(null), g = t.children, b = t.disabled, S = t.noFocusGuards, w = t.persistentFocus, E = t.crossFrame, T = t.autoFocus, A = t.allowTextSelection, P = t.group, _ = t.className, D = t.whiteList, L = t.hasPositiveIndices, F = t.shards, V = F === void 0 ? Vfe : F, $ = t.as, U = $ === void 0 ? "div" : $, W = t.lockProps, H = W === void 0 ? {} : W, G = t.sideCar, oe = t.returnFocus, ce = t.focusOptions, te = t.onActivation, Ee = t.onDeactivation, me = Fe.useState({}), J = me[0], Q = Fe.useCallback(function() {
    v.current = v.current || document && document.activeElement, f.current && te && te(f.current), h.current = !0;
  }, [te]), ge = Fe.useCallback(function() {
    h.current = !1, Ee && Ee(f.current);
  }, [Ee]);
  dt(function() {
    b || (v.current = null);
  }, []);
  var Y = Fe.useCallback(function(xe) {
    var ie = v.current;
    if (ie && ie.focus) {
      var ye = typeof oe == "function" ? oe(ie) : oe;
      if (ye) {
        var we = typeof ye == "object" ? ye : void 0;
        v.current = null, xe ? Promise.resolve().then(function() {
          return ie.focus(we);
        }) : ie.focus(we);
      }
    }
  }, [oe]), q = Fe.useCallback(function(xe) {
    h.current && gH.useMedium(xe);
  }, []), de = yH.useMedium, K = Fe.useCallback(function(xe) {
    f.current !== xe && (f.current = xe, u(xe));
  }, []);
  process.env.NODE_ENV !== "production" && (typeof A < "u" && console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default"), Fe.useEffect(function() {
    !f.current && typeof U != "string" && console.error("FocusLock: could not obtain ref to internal node");
  }, []));
  var ne = Dt((o = {}, o[cH] = b && "disabled", o[CO] = P, o), H), pe = S !== !0, Oe = pe && S !== "tail", Ce = dH([n, K]);
  return /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, pe && [
    // nearest focus guard
    /* @__PURE__ */ Fe.createElement("div", {
      key: "guard-first",
      "data-focus-guard": !0,
      tabIndex: b ? -1 : 0,
      style: QR
    }),
    // first tabbed element guard
    L ? /* @__PURE__ */ Fe.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": !0,
      tabIndex: b ? -1 : 1,
      style: QR
    }) : null
  ], !b && /* @__PURE__ */ Fe.createElement(G, {
    id: J,
    sideCar: Bfe,
    observed: l,
    disabled: b,
    persistentFocus: w,
    crossFrame: E,
    autoFocus: T,
    whiteList: D,
    shards: V,
    onActivation: Q,
    onDeactivation: ge,
    returnFocus: Y,
    focusOptions: ce
  }), /* @__PURE__ */ Fe.createElement(U, Dt({
    ref: Ce
  }, ne, {
    className: _,
    onBlur: de,
    onFocus: q
  }), g), Oe && /* @__PURE__ */ Fe.createElement("div", {
    "data-focus-guard": !0,
    tabIndex: b ? -1 : 0,
    style: QR
  }));
});
k2.propTypes = process.env.NODE_ENV !== "production" ? {
  children: cr.node,
  disabled: cr.bool,
  returnFocus: cr.oneOfType([cr.bool, cr.object, cr.func]),
  focusOptions: cr.object,
  noFocusGuards: cr.bool,
  hasPositiveIndices: cr.bool,
  allowTextSelection: cr.bool,
  autoFocus: cr.bool,
  persistentFocus: cr.bool,
  crossFrame: cr.bool,
  group: cr.string,
  className: cr.string,
  whiteList: cr.func,
  shards: cr.arrayOf(cr.any),
  as: cr.oneOfType([cr.string, cr.func, cr.object]),
  lockProps: cr.object,
  onActivation: cr.func,
  onDeactivation: cr.func,
  sideCar: cr.any.isRequired
} : {};
k2.defaultProps = {
  children: void 0,
  disabled: !1,
  returnFocus: !1,
  focusOptions: void 0,
  noFocusGuards: !1,
  autoFocus: !0,
  persistentFocus: !1,
  crossFrame: !0,
  hasPositiveIndices: void 0,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
const bH = k2;
function qw(e, t) {
  return qw = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, a) {
    return o.__proto__ = a, o;
  }, qw(e, t);
}
function $fe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, qw(e, t);
}
function lh(e) {
  "@babel/helpers - typeof";
  return lh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lh(e);
}
function zfe(e, t) {
  if (lh(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t || "default");
    if (lh(o) != "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function SH(e) {
  var t = zfe(e, "string");
  return lh(t) == "symbol" ? t : String(t);
}
function Vv(e, t, n) {
  return t = SH(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Hfe(e, t) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof e != "function")
      throw new Error("Expected reducePropsToState to be a function.");
    if (typeof t != "function")
      throw new Error("Expected handleStateChangeOnClient to be a function.");
  }
  function n(o) {
    return o.displayName || o.name || "Component";
  }
  return function(a) {
    if (process.env.NODE_ENV !== "production" && typeof a != "function")
      throw new Error("Expected WrappedComponent to be a React component.");
    var l = [], u;
    function f() {
      u = e(l.map(function(v) {
        return v.props;
      })), t(u);
    }
    var h = /* @__PURE__ */ function(v) {
      $fe(g, v);
      function g() {
        return v.apply(this, arguments) || this;
      }
      g.peek = function() {
        return u;
      };
      var b = g.prototype;
      return b.componentDidMount = function() {
        l.push(this), f();
      }, b.componentDidUpdate = function() {
        f();
      }, b.componentWillUnmount = function() {
        var w = l.indexOf(this);
        l.splice(w, 1), f();
      }, b.render = function() {
        return /* @__PURE__ */ Tt.createElement(a, this.props);
      }, g;
    }(dJ);
    return Vv(h, "displayName", "SideEffect(" + n(a) + ")"), h;
  };
}
var wu = function(e) {
  for (var t = Array(e.length), n = 0; n < e.length; ++n)
    t[n] = e[n];
  return t;
}, eE = function(e) {
  return Array.isArray(e) ? e : [e];
}, xH = function(e) {
  return Array.isArray(e) ? e[0] : e;
}, jfe = function(e) {
  if (e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  var t = window.getComputedStyle(e, null);
  return !t || !t.getPropertyValue ? !1 : t.getPropertyValue("display") === "none" || t.getPropertyValue("visibility") === "hidden";
}, CH = function(e) {
  return e.parentNode && e.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.parentNode.host
  ) : e.parentNode;
}, wH = function(e) {
  return e === document || e && e.nodeType === Node.DOCUMENT_NODE;
}, Gfe = function(e, t) {
  return !e || wH(e) || !jfe(e) && t(CH(e));
}, EH = function(e, t) {
  var n = e.get(t);
  if (n !== void 0)
    return n;
  var o = Gfe(t, EH.bind(void 0, e));
  return e.set(t, o), o;
}, Wfe = function(e, t) {
  return e && !wH(e) ? Zfe(e) ? t(CH(e)) : !1 : !0;
}, TH = function(e, t) {
  var n = e.get(t);
  if (n !== void 0)
    return n;
  var o = Wfe(t, TH.bind(void 0, e));
  return e.set(t, o), o;
}, IH = function(e) {
  return e.dataset;
}, Ufe = function(e) {
  return e.tagName === "BUTTON";
}, AH = function(e) {
  return e.tagName === "INPUT";
}, kH = function(e) {
  return AH(e) && e.type === "radio";
}, Xfe = function(e) {
  return !((AH(e) || Ufe(e)) && (e.type === "hidden" || e.disabled));
}, Zfe = function(e) {
  var t = e.getAttribute(Dfe);
  return ![!0, "true", ""].includes(t);
}, R2 = function(e) {
  var t;
  return !!(e && (!((t = IH(e)) === null || t === void 0) && t.focusGuard));
}, tE = function(e) {
  return !R2(e);
}, Yfe = function(e) {
  return !!e;
}, Jfe = function(e, t) {
  var n = e.tabIndex - t.tabIndex, o = e.index - t.index;
  if (n) {
    if (!e.tabIndex)
      return 1;
    if (!t.tabIndex)
      return -1;
  }
  return n || o;
}, RH = function(e, t, n) {
  return wu(e).map(function(o, a) {
    return {
      node: o,
      index: a,
      tabIndex: n && o.tabIndex === -1 ? (o.dataset || {}).focusGuard ? 0 : -1 : o.tabIndex
    };
  }).filter(function(o) {
    return !t || o.tabIndex >= 0;
  }).sort(Jfe);
}, Qfe = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
], P2 = Qfe.join(","), Kfe = "".concat(P2, ", [data-focus-guard]"), PH = function(e, t) {
  return wu((e.shadowRoot || e).children).reduce(function(n, o) {
    return n.concat(o.matches(t ? Kfe : P2) ? [o] : [], PH(o));
  }, []);
}, qfe = function(e, t) {
  var n;
  return e instanceof HTMLIFrameElement && (!((n = e.contentDocument) === null || n === void 0) && n.body) ? oT([e.contentDocument.body], t) : [e];
}, oT = function(e, t) {
  return e.reduce(function(n, o) {
    var a, l = PH(o, t), u = (a = []).concat.apply(a, l.map(function(f) {
      return qfe(f, t);
    }));
    return n.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      u,
      // add if node is tabbable itself
      o.parentNode ? wu(o.parentNode.querySelectorAll(P2)).filter(function(f) {
        return f === o;
      }) : []
    );
  }, []);
}, epe = function(e) {
  var t = e.querySelectorAll("[".concat(_fe, "]"));
  return wu(t).map(function(n) {
    return oT([n]);
  }).reduce(function(n, o) {
    return n.concat(o);
  }, []);
}, O2 = function(e, t) {
  return wu(e).filter(function(n) {
    return EH(t, n);
  }).filter(function(n) {
    return Xfe(n);
  });
}, v$ = function(e, t) {
  return t === void 0 && (t = /* @__PURE__ */ new Map()), wu(e).filter(function(n) {
    return TH(t, n);
  });
}, wO = function(e, t, n) {
  return RH(O2(oT(e, n), t), !0, n);
}, g$ = function(e, t) {
  return RH(O2(oT(e), t), !1);
}, tpe = function(e, t) {
  return O2(epe(e), t);
}, Jv = function(e, t) {
  return e.shadowRoot ? Jv(e.shadowRoot, t) : Object.getPrototypeOf(e).contains !== void 0 && Object.getPrototypeOf(e).contains.call(e, t) ? !0 : wu(e.children).some(function(n) {
    var o;
    if (n instanceof HTMLIFrameElement) {
      var a = (o = n.contentDocument) === null || o === void 0 ? void 0 : o.body;
      return a ? Jv(a, t) : !1;
    }
    return Jv(n, t);
  });
}, npe = function(e) {
  for (var t = /* @__PURE__ */ new Set(), n = e.length, o = 0; o < n; o += 1)
    for (var a = o + 1; a < n; a += 1) {
      var l = e[o].compareDocumentPosition(e[a]);
      (l & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && t.add(a), (l & Node.DOCUMENT_POSITION_CONTAINS) > 0 && t.add(o);
    }
  return e.filter(function(u, f) {
    return !t.has(f);
  });
}, OH = function(e) {
  return e.parentNode ? OH(e.parentNode) : e;
}, _2 = function(e) {
  var t = eE(e);
  return t.filter(Boolean).reduce(function(n, o) {
    var a = o.getAttribute(CO);
    return n.push.apply(n, a ? npe(wu(OH(o).querySelectorAll("[".concat(CO, '="').concat(a, '"]:not([').concat(cH, '="disabled"])')))) : [o]), n;
  }, []);
}, rpe = function(e) {
  try {
    return e();
  } catch {
    return;
  }
}, J0 = function(e) {
  if (e === void 0 && (e = document), !(!e || !e.activeElement)) {
    var t = e.activeElement;
    return t.shadowRoot ? J0(t.shadowRoot) : t instanceof HTMLIFrameElement && rpe(function() {
      return t.contentWindow.document;
    }) ? J0(t.contentWindow.document) : t;
  }
}, ope = function(e, t) {
  return e === t;
}, ipe = function(e, t) {
  return !!wu(e.querySelectorAll("iframe")).some(function(n) {
    return ope(n, t);
  });
}, _H = function(e, t) {
  return t === void 0 && (t = J0(xH(e).ownerDocument)), !t || t.dataset && t.dataset.focusGuard ? !1 : _2(e).some(function(n) {
    return Jv(n, t) || ipe(n, t);
  });
}, ape = function(e) {
  e === void 0 && (e = document);
  var t = J0(e);
  return t ? wu(e.querySelectorAll("[".concat(Ofe, "]"))).some(function(n) {
    return Jv(n, t);
  }) : !1;
}, spe = function(e, t) {
  return t.filter(kH).filter(function(n) {
    return n.name === e.name;
  }).filter(function(n) {
    return n.checked;
  })[0] || e;
}, D2 = function(e, t) {
  return kH(e) && e.name ? spe(e, t) : e;
}, lpe = function(e) {
  var t = /* @__PURE__ */ new Set();
  return e.forEach(function(n) {
    return t.add(D2(n, e));
  }), e.filter(function(n) {
    return t.has(n);
  });
}, y$ = function(e) {
  return e[0] && e.length > 1 ? D2(e[0], e) : e[0];
}, b$ = function(e, t) {
  return e.length > 1 ? e.indexOf(D2(e[t], e)) : t;
}, DH = "NEW_FOCUS", upe = function(e, t, n, o) {
  var a = e.length, l = e[0], u = e[a - 1], f = R2(n);
  if (!(n && e.indexOf(n) >= 0)) {
    var h = n !== void 0 ? t.indexOf(n) : -1, v = o ? t.indexOf(o) : h, g = o ? e.indexOf(o) : -1, b = h - v, S = t.indexOf(l), w = t.indexOf(u), E = lpe(t), T = n !== void 0 ? E.indexOf(n) : -1, A = T - (o ? E.indexOf(o) : h), P = b$(e, 0), _ = b$(e, a - 1);
    if (h === -1 || g === -1)
      return DH;
    if (!b && g >= 0)
      return g;
    if (h <= S && f && Math.abs(b) > 1)
      return _;
    if (h >= w && f && Math.abs(b) > 1)
      return P;
    if (b && Math.abs(A) > 1)
      return g;
    if (h <= S)
      return _;
    if (h > w)
      return P;
    if (b)
      return Math.abs(b) > 1 ? g : (a + g + b) % a;
  }
}, cpe = function(e) {
  return function(t) {
    var n, o = (n = IH(t)) === null || n === void 0 ? void 0 : n.autofocus;
    return (
      // @ts-expect-error
      t.autofocus || //
      o !== void 0 && o !== "false" || //
      e.indexOf(t) >= 0
    );
  };
}, dpe = function(e, t, n) {
  var o = e.map(function(l) {
    var u = l.node;
    return u;
  }), a = v$(o.filter(cpe(n)));
  return a && a.length ? y$(a) : y$(v$(t));
}, EO = function(e, t) {
  return t === void 0 && (t = []), t.push(e), e.parentNode && EO(e.parentNode.host || e.parentNode, t), t;
}, KR = function(e, t) {
  for (var n = EO(e), o = EO(t), a = 0; a < n.length; a += 1) {
    var l = n[a];
    if (o.indexOf(l) >= 0)
      return l;
  }
  return !1;
}, NH = function(e, t, n) {
  var o = eE(e), a = eE(t), l = o[0], u = !1;
  return a.filter(Boolean).forEach(function(f) {
    u = KR(u || f, f) || u, n.filter(Boolean).forEach(function(h) {
      var v = KR(l, h);
      v && (!u || Jv(v, u) ? u = v : u = KR(v, u));
    });
  }), u;
}, fpe = function(e, t) {
  return e.reduce(function(n, o) {
    return n.concat(tpe(o, t));
  }, []);
}, ppe = function(e, t) {
  var n = /* @__PURE__ */ new Map();
  return t.forEach(function(o) {
    return n.set(o.node, o);
  }), e.map(function(o) {
    return n.get(o);
  }).filter(Yfe);
}, hpe = function(e, t) {
  var n = J0(eE(e).length > 0 ? document : xH(e).ownerDocument), o = _2(e).filter(tE), a = NH(n || e, e, o), l = /* @__PURE__ */ new Map(), u = g$(o, l), f = wO(o, l).filter(function(w) {
    var E = w.node;
    return tE(E);
  });
  if (!(!f[0] && (f = u, !f[0]))) {
    var h = g$([a], l).map(function(w) {
      var E = w.node;
      return E;
    }), v = ppe(h, f), g = v.map(function(w) {
      var E = w.node;
      return E;
    }), b = upe(g, h, n, t);
    if (b === DH) {
      var S = dpe(u, g, fpe(o, l));
      if (S)
        return { node: S };
      console.warn("focus-lock: cannot find any node to move focus into");
      return;
    }
    return b === void 0 ? b : v[b];
  }
}, mpe = function(e) {
  var t = _2(e).filter(tE), n = NH(e, e, t), o = /* @__PURE__ */ new Map(), a = wO([n], o, !0), l = wO(t, o).filter(function(u) {
    var f = u.node;
    return tE(f);
  }).map(function(u) {
    var f = u.node;
    return f;
  });
  return a.map(function(u) {
    var f = u.node, h = u.index;
    return {
      node: f,
      index: h,
      lockItem: l.indexOf(f) >= 0,
      guard: R2(f)
    };
  });
}, vpe = function(e, t) {
  "focus" in e && e.focus(t), "contentWindow" in e && e.contentWindow && e.contentWindow.focus();
}, qR = 0, eP = !1, MH = function(e, t, n) {
  n === void 0 && (n = {});
  var o = hpe(e, t);
  if (!eP && o) {
    if (qR > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), eP = !0, setTimeout(function() {
        eP = !1;
      }, 1);
      return;
    }
    qR++, vpe(o.node, n.focusOptions), qR--;
  }
};
function N2(e) {
  setTimeout(e, 1);
}
var gpe = function() {
  return document && document.activeElement === document.body;
}, ype = function() {
  return gpe() || ape();
}, Qv = null, $v = null, Kv = null, Q0 = !1, bpe = function() {
  return !0;
}, Spe = function(t) {
  return (Qv.whiteList || bpe)(t);
}, xpe = function(t, n) {
  Kv = {
    observerNode: t,
    portaledElement: n
  };
}, Cpe = function(t) {
  return Kv && Kv.portaledElement === t;
};
function S$(e, t, n, o) {
  var a = null, l = e;
  do {
    var u = o[l];
    if (u.guard)
      u.node.dataset.focusAutoGuard && (a = u);
    else if (u.lockItem) {
      if (l !== e)
        return;
      a = null;
    } else
      break;
  } while ((l += n) !== t);
  a && (a.node.tabIndex = 0);
}
var wpe = function(t) {
  return t && "current" in t ? t.current : t;
}, Epe = function(t) {
  return t ? !!Q0 : Q0 === "meanwhile";
}, Tpe = function e(t, n, o) {
  return n && // find host equal to active element and check nested active element
  (n.host === t && (!n.activeElement || o.contains(n.activeElement)) || n.parentNode && e(t, n.parentNode, o));
}, Ipe = function(t, n) {
  return n.some(function(o) {
    return Tpe(t, o, o);
  });
}, nE = function() {
  var t = !1;
  if (Qv) {
    var n = Qv, o = n.observed, a = n.persistentFocus, l = n.autoFocus, u = n.shards, f = n.crossFrame, h = n.focusOptions, v = o || Kv && Kv.portaledElement, g = document && document.activeElement;
    if (v) {
      var b = [v].concat(u.map(wpe).filter(Boolean));
      if ((!g || Spe(g)) && (a || Epe(f) || !ype() || !$v && l) && (v && !// active element is "inside" working area
      (_H(b) || // check for shadow-dom contained elements
      g && Ipe(g, b) || Cpe(g)) && (document && !$v && g && !l ? (g.blur && g.blur(), document.body.focus()) : (t = MH(b, $v, {
        focusOptions: h
      }), Kv = {})), Q0 = !1, $v = document && document.activeElement), document) {
        var S = document && document.activeElement, w = mpe(b), E = w.map(function(T) {
          var A = T.node;
          return A;
        }).indexOf(S);
        E > -1 && (w.filter(function(T) {
          var A = T.guard, P = T.node;
          return A && P.dataset.focusAutoGuard;
        }).forEach(function(T) {
          var A = T.node;
          return A.removeAttribute("tabIndex");
        }), S$(E, w.length, 1, w), S$(E, -1, -1, w));
      }
    }
  }
  return t;
}, LH = function(t) {
  nE() && t && (t.stopPropagation(), t.preventDefault());
}, M2 = function() {
  return N2(nE);
}, Ape = function(t) {
  var n = t.target, o = t.currentTarget;
  o.contains(n) || xpe(o, n);
}, kpe = function() {
  return null;
};
process.env.NODE_ENV !== "production" && uH.node.isRequired;
var FH = function() {
  Q0 = "just", N2(function() {
    Q0 = "meanwhile";
  });
}, Rpe = function() {
  document.addEventListener("focusin", LH), document.addEventListener("focusout", M2), window.addEventListener("blur", FH);
}, Ppe = function() {
  document.removeEventListener("focusin", LH), document.removeEventListener("focusout", M2), window.removeEventListener("blur", FH);
};
function Ope(e) {
  return e.filter(function(t) {
    var n = t.disabled;
    return !n;
  });
}
function _pe(e) {
  var t = e.slice(-1)[0];
  t && !Qv && Rpe();
  var n = Qv, o = n && t && t.id === n.id;
  Qv = t, n && !o && (n.onDeactivation(), e.filter(function(a) {
    var l = a.id;
    return l === n.id;
  }).length || n.returnFocus(!t)), t ? ($v = null, (!o || n.observed !== t.observed) && t.onActivation(), nE(), N2(nE)) : (Ppe(), $v = null);
}
gH.assignSyncMedium(Ape);
yH.assignMedium(M2);
Ffe.assignMedium(function(e) {
  return e({
    moveFocusInside: MH,
    focusInside: _H
  });
});
const Dpe = Hfe(Ope, _pe)(kpe);
var TO = /* @__PURE__ */ Fe.forwardRef(function(t, n) {
  return /* @__PURE__ */ Fe.createElement(bH, Dt({
    sideCar: Dpe,
    ref: n
  }, t));
}), BH = bH.propTypes || {};
BH.sideCar;
var Npe = sH(BH, ["sideCar"]);
TO.propTypes = process.env.NODE_ENV !== "production" ? Npe : {};
function VH(e) {
  return e != null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
function L2(e) {
  var t;
  if (!VH(e))
    return !1;
  const n = (t = e.ownerDocument.defaultView) != null ? t : window;
  return e instanceof n.HTMLElement;
}
function Mpe(e) {
  var t, n;
  return (n = (t = $H(e)) == null ? void 0 : t.defaultView) != null ? n : window;
}
function $H(e) {
  return VH(e) ? e.ownerDocument : document;
}
function Lpe(e) {
  return $H(e).activeElement;
}
function Fpe(e) {
  const t = e.ownerDocument.defaultView || window, { overflow: n, overflowX: o, overflowY: a } = t.getComputedStyle(e);
  return /auto|scroll|overlay|hidden/.test(n + a + o);
}
function Bpe(e) {
  return e.localName === "html" ? e : e.assignedSlot || e.parentElement || e.ownerDocument.documentElement;
}
function zH(e) {
  return ["html", "body", "#document"].includes(e.localName) ? e.ownerDocument.body : L2(e) && Fpe(e) ? e : zH(Bpe(e));
}
var HH = (e) => e.hasAttribute("tabindex"), Vpe = (e) => HH(e) && e.tabIndex === -1;
function $pe(e) {
  return !!e.getAttribute("disabled") || !!e.getAttribute("aria-disabled");
}
function jH(e) {
  return e.parentElement && jH(e.parentElement) ? !0 : e.hidden;
}
function zpe(e) {
  const t = e.getAttribute("contenteditable");
  return t !== "false" && t != null;
}
function GH(e) {
  if (!L2(e) || jH(e) || $pe(e))
    return !1;
  const { localName: t } = e;
  if (["input", "select", "textarea", "button"].indexOf(t) >= 0)
    return !0;
  const o = {
    a: () => e.hasAttribute("href"),
    audio: () => e.hasAttribute("controls"),
    video: () => e.hasAttribute("controls")
  };
  return t in o ? o[t]() : zpe(e) ? !0 : HH(e);
}
function Hpe(e) {
  return e ? L2(e) && GH(e) && !Vpe(e) : !1;
}
var jpe = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
], Gpe = jpe.join(), Wpe = (e) => e.offsetWidth > 0 && e.offsetHeight > 0;
function WH(e) {
  const t = Array.from(
    e.querySelectorAll(Gpe)
  );
  return t.unshift(e), t.filter((n) => GH(n) && Wpe(n));
}
var x$, Upe = (x$ = TO.default) != null ? x$ : TO, UH = (e) => {
  const {
    initialFocusRef: t,
    finalFocusRef: n,
    contentRef: o,
    restoreFocus: a,
    children: l,
    isDisabled: u,
    autoFocus: f,
    persistentFocus: h,
    lockFocusAcrossFrames: v
  } = e, g = re(() => {
    t != null && t.current ? t.current.focus() : o != null && o.current && WH(o.current).length === 0 && requestAnimationFrame(() => {
      var E;
      (E = o.current) == null || E.focus();
    });
  }, [t, o]), b = re(() => {
    var w;
    (w = n == null ? void 0 : n.current) == null || w.focus();
  }, [n]);
  return /* @__PURE__ */ M(
    Upe,
    {
      crossFrame: v,
      persistentFocus: h,
      autoFocus: f,
      disabled: u,
      onActivation: g,
      onDeactivation: b,
      returnFocus: a && !n,
      children: l
    }
  );
};
UH.displayName = "FocusLock";
var Xpe = Tie ? ph : dt;
function IO(e, t = []) {
  const n = Ue(e);
  return Xpe(() => {
    n.current = e;
  }), re((...o) => {
    var a;
    return (a = n.current) == null ? void 0 : a.call(n, ...o);
  }, t);
}
function Zpe(e, t, n, o) {
  const a = IO(t);
  return dt(() => {
    var l;
    const u = (l = $w(n)) != null ? l : document;
    if (t)
      return u.addEventListener(e, a, o), () => {
        u.removeEventListener(e, a, o);
      };
  }, [e, n, o, a, t]), () => {
    var l;
    ((l = $w(n)) != null ? l : document).removeEventListener(e, a, o);
  };
}
function Ype(e, t) {
  const n = ko();
  return gt(
    () => e || [t, n].filter(Boolean).join("-"),
    [e, t, n]
  );
}
function Jpe(e, t) {
  const n = e !== void 0;
  return [n, n && typeof e < "u" ? e : t];
}
function Qpe(e = {}) {
  const {
    onClose: t,
    onOpen: n,
    isOpen: o,
    id: a
  } = e, l = IO(n), u = IO(t), [f, h] = ot(e.defaultIsOpen || !1), [v, g] = Jpe(o, f), b = Ype(a, "disclosure"), S = re(() => {
    v || h(!1), u == null || u();
  }, [v, u]), w = re(() => {
    v || h(!0), l == null || l();
  }, [v, l]), E = re(() => {
    (g ? S : w)();
  }, [g, w, S]);
  return {
    isOpen: !!g,
    onOpen: w,
    onClose: S,
    onToggle: E,
    isControlled: v,
    getButtonProps: (T = {}) => ({
      ...T,
      "aria-expanded": g,
      "aria-controls": b,
      onClick: Pie(T.onClick, E)
    }),
    getDisclosureProps: (T = {}) => ({
      ...T,
      hidden: !g,
      id: b
    })
  };
}
var [Kpe, qpe] = En({
  name: "InputGroupStylesContext",
  errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
}), ehe = Le(
  function(t, n) {
    const o = Xn("Input", t), { children: a, className: l, ...u } = Pn(t), f = et("chakra-input__group", l), h = {}, v = gS(a), g = o.field;
    v.forEach((S) => {
      var w, E;
      o && (g && S.type.id === "InputLeftElement" && (h.paddingStart = (w = g.height) != null ? w : g.h), g && S.type.id === "InputRightElement" && (h.paddingEnd = (E = g.height) != null ? E : g.h), S.type.id === "InputRightAddon" && (h.borderEndRadius = 0), S.type.id === "InputLeftAddon" && (h.borderStartRadius = 0));
    });
    const b = v.map((S) => {
      var w, E;
      const T = G_({
        size: ((w = S.props) == null ? void 0 : w.size) || t.size,
        variant: ((E = S.props) == null ? void 0 : E.variant) || t.variant
      });
      return S.type.id !== "Input" ? ya(S, T) : ya(S, Object.assign(T, h, S.props));
    });
    return /* @__PURE__ */ M(
      De.div,
      {
        className: f,
        ref: n,
        __css: {
          width: "100%",
          display: "flex",
          position: "relative",
          // Parts of inputs override z-index to ensure that they stack correctly on each other
          // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
          isolation: "isolate",
          ...o.group
        },
        "data-group": !0,
        ...u,
        children: /* @__PURE__ */ M(Kpe, { value: o, children: b })
      }
    );
  }
);
ehe.displayName = "InputGroup";
var the = De("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: "0",
    zIndex: 2
  }
}), iT = Le(function(t, n) {
  var o, a;
  const { placement: l = "left", ...u } = t, f = qpe(), h = f.field, g = {
    [l === "left" ? "insetStart" : "insetEnd"]: "0",
    width: (o = h == null ? void 0 : h.height) != null ? o : h == null ? void 0 : h.h,
    height: (a = h == null ? void 0 : h.height) != null ? a : h == null ? void 0 : h.h,
    fontSize: h == null ? void 0 : h.fontSize,
    ...f.element
  };
  return /* @__PURE__ */ M(the, { ref: n, __css: g, ...u });
});
iT.id = "InputElement";
iT.displayName = "InputElement";
var XH = Le(
  function(t, n) {
    const { className: o, ...a } = t, l = et("chakra-input__left-element", o);
    return /* @__PURE__ */ M(
      iT,
      {
        ref: n,
        placement: "left",
        className: l,
        ...a
      }
    );
  }
);
XH.id = "InputLeftElement";
XH.displayName = "InputLeftElement";
var ZH = Le(
  function(t, n) {
    const { className: o, ...a } = t, l = et("chakra-input__right-element", o);
    return /* @__PURE__ */ M(
      iT,
      {
        ref: n,
        placement: "right",
        className: l,
        ...a
      }
    );
  }
);
ZH.id = "InputRightElement";
ZH.displayName = "InputRightElement";
var F2 = Le(function(t, n) {
  const { htmlSize: o, ...a } = t, l = Xn("Input", a), u = Pn(a), f = yh(u), h = et("chakra-input", t.className);
  return /* @__PURE__ */ M(
    De.input,
    {
      size: o,
      ...f,
      __css: l.field,
      ref: n,
      className: h
    }
  );
});
F2.displayName = "Input";
F2.id = "Input";
var YH = Le(function(t, n) {
  const o = Gi("Link", t), { className: a, isExternal: l, ...u } = Pn(t);
  return /* @__PURE__ */ M(
    De.a,
    {
      target: l ? "_blank" : void 0,
      rel: l ? "noopener" : void 0,
      ref: n,
      className: et("chakra-link", a),
      ...u,
      __css: o
    }
  );
});
YH.displayName = "Link";
var [nhe, JH] = En({
  name: "ListStylesContext",
  errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
}), B2 = Le(function(t, n) {
  const o = Xn("List", t), {
    children: a,
    styleType: l = "none",
    stylePosition: u,
    spacing: f,
    ...h
  } = Pn(t), v = gS(a), b = f ? { ["& > *:not(style) ~ *:not(style)"]: { mt: f } } : {};
  return /* @__PURE__ */ M(nhe, { value: o, children: /* @__PURE__ */ M(
    De.ul,
    {
      ref: n,
      listStyleType: l,
      listStylePosition: u,
      role: "list",
      __css: { ...o.container, ...b },
      ...h,
      children: v
    }
  ) });
});
B2.displayName = "List";
var rhe = Le((e, t) => {
  const { as: n, ...o } = e;
  return /* @__PURE__ */ M(B2, { ref: t, as: "ol", styleType: "decimal", marginStart: "1em", ...o });
});
rhe.displayName = "OrderedList";
var ohe = Le(function(t, n) {
  const { as: o, ...a } = t;
  return /* @__PURE__ */ M(B2, { ref: n, as: "ul", styleType: "initial", marginStart: "1em", ...a });
});
ohe.displayName = "UnorderedList";
var ihe = Le(function(t, n) {
  const o = JH();
  return /* @__PURE__ */ M(De.li, { ref: n, ...t, __css: o.item });
});
ihe.displayName = "ListItem";
var ahe = Le(function(t, n) {
  const o = JH();
  return /* @__PURE__ */ M(ho, { ref: n, role: "presentation", ...t, __css: o.icon });
});
ahe.displayName = "ListIcon";
var she = Le(function(t, n) {
  const {
    templateAreas: o,
    gap: a,
    rowGap: l,
    columnGap: u,
    column: f,
    row: h,
    autoFlow: v,
    autoRows: g,
    templateRows: b,
    autoColumns: S,
    templateColumns: w,
    ...E
  } = t, T = {
    display: "grid",
    gridTemplateAreas: o,
    gridGap: a,
    gridRowGap: l,
    gridColumnGap: u,
    gridAutoColumns: S,
    gridColumn: f,
    gridRow: h,
    gridAutoFlow: v,
    gridAutoRows: g,
    gridTemplateRows: b,
    gridTemplateColumns: w
  };
  return /* @__PURE__ */ M(De.div, { ref: n, __css: T, ...E });
});
she.displayName = "Grid";
var QH = Object.freeze([
  "base",
  "sm",
  "md",
  "lg",
  "xl",
  "2xl"
]);
function KH(e, t) {
  return Array.isArray(e) ? e.map((n) => n === null ? null : t(n)) : Ei(e) ? Object.keys(e).reduce((n, o) => (n[o] = t(e[o]), n), {}) : e != null ? t(e) : null;
}
function lhe(e, t = QH) {
  const n = {};
  return e.forEach((o, a) => {
    const l = t[a];
    o != null && (n[l] = o);
  }), n;
}
var V2 = De("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
V2.displayName = "Spacer";
var du = Le(function(t, n) {
  const o = Gi("Text", t), { className: a, align: l, decoration: u, casing: f, ...h } = Pn(t), v = G_({
    textAlign: t.align,
    textDecoration: t.decoration,
    textTransform: t.casing
  });
  return /* @__PURE__ */ M(
    De.p,
    {
      ref: n,
      className: et("chakra-text", t.className),
      ...v,
      ...h,
      __css: o
    }
  );
});
du.displayName = "Text";
var qH = (e) => /* @__PURE__ */ M(
  De.div,
  {
    className: "chakra-stack__item",
    ...e,
    __css: {
      display: "inline-block",
      flex: "0 0 auto",
      minWidth: 0,
      ...e.__css
    }
  }
);
qH.displayName = "StackItem";
function uhe(e) {
  const { spacing: t, direction: n } = e, o = {
    column: {
      my: t,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: t,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: t,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: t,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": KH(
      n,
      (a) => o[a]
    )
  };
}
var $2 = Le((e, t) => {
  const {
    isInline: n,
    direction: o,
    align: a,
    justify: l,
    spacing: u = "0.5rem",
    wrap: f,
    children: h,
    divider: v,
    className: g,
    shouldWrapChildren: b,
    ...S
  } = e, w = n ? "row" : o ?? "column", E = gt(
    () => uhe({ spacing: u, direction: w }),
    [u, w]
  ), T = !!v, A = !b && !T, P = gt(() => {
    const D = gS(h);
    return A ? D : D.map((L, F) => {
      const V = typeof L.key < "u" ? L.key : F, $ = F + 1 === D.length, W = b ? /* @__PURE__ */ M(qH, { children: L }, V) : L;
      if (!T)
        return W;
      const H = ya(
        v,
        {
          __css: E
        }
      );
      return /* @__PURE__ */ Nt(B0, { children: [
        W,
        $ ? null : H
      ] }, V);
    });
  }, [
    v,
    E,
    T,
    A,
    b,
    h
  ]), _ = et("chakra-stack", g);
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: t,
      display: "flex",
      alignItems: a,
      justifyContent: l,
      flexDirection: w,
      flexWrap: f,
      gap: T ? void 0 : u,
      className: _,
      ...S,
      children: P
    }
  );
});
$2.displayName = "Stack";
var che = Le((e, t) => /* @__PURE__ */ M($2, { align: "center", ...e, direction: "column", ref: t }));
che.displayName = "VStack";
var dhe = Le((e, t) => /* @__PURE__ */ M($2, { align: "center", ...e, direction: "row", ref: t }));
dhe.displayName = "HStack";
function C$(e) {
  return KH(
    e,
    (t) => t === "auto" ? "auto" : `span ${t}/span ${t}`
  );
}
var fhe = Le(function(t, n) {
  const {
    area: o,
    colSpan: a,
    colStart: l,
    colEnd: u,
    rowEnd: f,
    rowSpan: h,
    rowStart: v,
    ...g
  } = t, b = G_({
    gridArea: o,
    gridColumn: C$(a),
    gridRow: C$(h),
    gridColumnStart: l,
    gridColumnEnd: u,
    gridRowStart: v,
    gridRowEnd: f
  });
  return /* @__PURE__ */ M(De.div, { ref: n, __css: b, ...g });
});
fhe.displayName = "GridItem";
var phe = Le(function(t, n) {
  const o = Gi("Heading", t), { className: a, ...l } = Pn(t);
  return /* @__PURE__ */ M(
    De.h2,
    {
      ref: n,
      className: et("chakra-heading", t.className),
      ...l,
      __css: o
    }
  );
});
phe.displayName = "Heading";
var qr = De("div");
qr.displayName = "Box";
var ej = Le(function(t, n) {
  const { size: o, centerContent: a = !0, ...l } = t;
  return /* @__PURE__ */ M(
    qr,
    {
      ref: n,
      boxSize: o,
      __css: {
        ...a ? { display: "flex", alignItems: "center", justifyContent: "center" } : {},
        flexShrink: 0,
        flexGrow: 0
      },
      ...l
    }
  );
});
ej.displayName = "Square";
var hhe = Le(function(t, n) {
  const { size: o, ...a } = t;
  return /* @__PURE__ */ M(ej, { size: o, ref: n, borderRadius: "9999px", ...a });
});
hhe.displayName = "Circle";
var mhe = Le(function(t, n) {
  const o = Gi("Kbd", t), { className: a, ...l } = Pn(t);
  return /* @__PURE__ */ M(
    De.kbd,
    {
      ref: n,
      className: et("chakra-kbd", a),
      ...l,
      __css: {
        fontFamily: "mono",
        ...o
      }
    }
  );
});
mhe.displayName = "Kbd";
var z2 = Le(function(t, n) {
  const o = Gi("Badge", t), { className: a, ...l } = Pn(t);
  return /* @__PURE__ */ M(
    De.span,
    {
      ref: n,
      className: et("chakra-badge", t.className),
      ...l,
      __css: {
        display: "inline-block",
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        ...o
      }
    }
  );
});
z2.displayName = "Badge";
var aT = Le(function(t, n) {
  const {
    borderLeftWidth: o,
    borderBottomWidth: a,
    borderTopWidth: l,
    borderRightWidth: u,
    borderWidth: f,
    borderStyle: h,
    borderColor: v,
    ...g
  } = Gi("Divider", t), {
    className: b,
    orientation: S = "horizontal",
    __css: w,
    ...E
  } = Pn(t), T = {
    vertical: {
      borderLeftWidth: o || u || f || "1px",
      height: "100%"
    },
    horizontal: {
      borderBottomWidth: a || l || f || "1px",
      width: "100%"
    }
  };
  return /* @__PURE__ */ M(
    De.hr,
    {
      ref: n,
      "aria-orientation": S,
      ...E,
      __css: {
        ...g,
        border: "0",
        borderColor: v,
        borderStyle: h,
        ...T[S],
        ...w
      },
      className: et("chakra-divider", b)
    }
  );
});
aT.displayName = "Divider";
var zo = Le(function(t, n) {
  const { direction: o, align: a, justify: l, wrap: u, basis: f, grow: h, shrink: v, ...g } = t, b = {
    display: "flex",
    flexDirection: o,
    alignItems: a,
    justifyContent: l,
    flexWrap: u,
    flexBasis: f,
    flexGrow: h,
    flexShrink: v
  };
  return /* @__PURE__ */ M(De.div, { ref: n, __css: b, ...g });
});
zo.displayName = "Flex";
function vhe(e, t = {}) {
  const { ssr: n = !0, fallback: o } = t, { getWindow: a } = sae(), l = Array.isArray(e) ? e : [e];
  let u = Array.isArray(o) ? o : [o];
  u = u.filter((v) => v != null);
  const [f, h] = ot(() => l.map((v, g) => ({
    media: v,
    matches: n ? !!u[g] : a().matchMedia(v).matches
  })));
  return dt(() => {
    const v = a();
    h(
      l.map((S) => ({
        media: S,
        matches: v.matchMedia(S).matches
      }))
    );
    const g = l.map((S) => v.matchMedia(S)), b = (S) => {
      h((w) => w.slice().map((E) => E.media === S.media ? { ...E, matches: S.matches } : E));
    };
    return g.forEach((S) => {
      typeof S.addListener == "function" ? S.addListener(b) : S.addEventListener("change", b);
    }), () => {
      g.forEach((S) => {
        typeof S.removeListener == "function" ? S.removeListener(b) : S.removeEventListener("change", b);
      });
    };
  }, [a]), f.map((v) => v.matches);
}
function ghe(e, t, n = QH) {
  let o = Object.keys(e).indexOf(t);
  if (o !== -1)
    return e[t];
  let a = n.indexOf(t);
  for (; a >= 0; ) {
    const l = n[a];
    if (e.hasOwnProperty(l)) {
      o = a;
      break;
    }
    a -= 1;
  }
  if (o !== -1) {
    const l = n[o];
    return e[l];
  }
}
function yhe(e) {
  var t, n;
  const o = Ei(e) ? e : { fallback: e ?? "base" }, l = wl().__breakpoints.details.map(
    ({ minMaxQuery: v, breakpoint: g }) => ({
      breakpoint: g,
      query: v.replace("@media screen and ", "")
    })
  ), u = l.map((v) => v.breakpoint === o.fallback), h = vhe(
    l.map((v) => v.query),
    { fallback: u, ssr: o.ssr }
  ).findIndex((v) => v == !0);
  return (n = (t = l[h]) == null ? void 0 : t.breakpoint) != null ? n : o.fallback;
}
function bhe(e, t) {
  var n;
  const o = Ei(t) ? t : { fallback: t ?? "base" }, a = yhe(o), l = wl();
  if (!a)
    return;
  const u = Array.from(((n = l.__breakpoints) == null ? void 0 : n.keys) || []), f = Array.isArray(e) ? Object.fromEntries(
    Object.entries(lhe(e, u)).map(
      ([h, v]) => [h, v]
    )
  ) : e;
  return ghe(f, a, u);
}
function She(e) {
  const { key: t } = e;
  return t.length === 1 || t.length > 1 && /[^a-zA-Z0-9]/.test(t);
}
function xhe(e = {}) {
  const { timeout: t = 300, preventDefault: n = () => !0 } = e, [o, a] = ot([]), l = Ue(), u = () => {
    l.current && (clearTimeout(l.current), l.current = null);
  }, f = () => {
    u(), l.current = setTimeout(() => {
      a([]), l.current = null;
    }, t);
  };
  dt(() => u, []);
  function h(v) {
    return (g) => {
      if (g.key === "Backspace") {
        const b = [...o];
        b.pop(), a(b);
        return;
      }
      if (She(g)) {
        const b = o.concat(g.key);
        n(g) && (g.preventDefault(), g.stopPropagation()), a(b), v(b.join("")), f();
      }
    };
  }
  return h;
}
function Che(e, t, n, o) {
  if (t == null)
    return o;
  if (!o)
    return e.find(
      (u) => n(u).toLowerCase().startsWith(t.toLowerCase())
    );
  const a = e.filter(
    (l) => n(l).toLowerCase().startsWith(t.toLowerCase())
  );
  if (a.length > 0) {
    let l;
    return a.includes(o) ? (l = a.indexOf(o) + 1, l === a.length && (l = 0), a[l]) : (l = e.indexOf(a[0]), e[l]);
  }
  return o;
}
function whe() {
  const e = Ue(/* @__PURE__ */ new Map()), t = e.current, n = re((a, l, u, f) => {
    e.current.set(u, { type: l, el: a, options: f }), a.addEventListener(l, u, f);
  }, []), o = re(
    (a, l, u, f) => {
      a.removeEventListener(l, u, f), e.current.delete(u);
    },
    []
  );
  return dt(
    () => () => {
      t.forEach((a, l) => {
        o(a.el, a.type, l, a.options);
      });
    },
    [o, t]
  ), { add: n, remove: o };
}
function tP(e) {
  const t = e.target, { tagName: n, isContentEditable: o } = t;
  return n !== "INPUT" && n !== "TEXTAREA" && o !== !0;
}
function tj(e = {}) {
  const {
    ref: t,
    isDisabled: n,
    isFocusable: o,
    clickOnEnter: a = !0,
    clickOnSpace: l = !0,
    onMouseDown: u,
    onMouseUp: f,
    onClick: h,
    onKeyDown: v,
    onKeyUp: g,
    tabIndex: b,
    onMouseOver: S,
    onMouseLeave: w,
    ...E
  } = e, [T, A] = ot(!0), [P, _] = ot(!1), D = whe(), L = (J) => {
    J && J.tagName !== "BUTTON" && A(!1);
  }, F = T ? b : b || 0, V = n && !o, $ = re(
    (J) => {
      if (n) {
        J.stopPropagation(), J.preventDefault();
        return;
      }
      J.currentTarget.focus(), h == null || h(J);
    },
    [n, h]
  ), U = re(
    (J) => {
      P && tP(J) && (J.preventDefault(), J.stopPropagation(), _(!1), D.remove(document, "keyup", U, !1));
    },
    [P, D]
  ), W = re(
    (J) => {
      if (v == null || v(J), n || J.defaultPrevented || J.metaKey || !tP(J.nativeEvent) || T)
        return;
      const Q = a && J.key === "Enter";
      l && J.key === " " && (J.preventDefault(), _(!0)), Q && (J.preventDefault(), J.currentTarget.click()), D.add(document, "keyup", U, !1);
    },
    [
      n,
      T,
      v,
      a,
      l,
      D,
      U
    ]
  ), H = re(
    (J) => {
      if (g == null || g(J), n || J.defaultPrevented || J.metaKey || !tP(J.nativeEvent) || T)
        return;
      l && J.key === " " && (J.preventDefault(), _(!1), J.currentTarget.click());
    },
    [l, T, n, g]
  ), G = re(
    (J) => {
      J.button === 0 && (_(!1), D.remove(document, "mouseup", G, !1));
    },
    [D]
  ), oe = re(
    (J) => {
      if (J.button !== 0)
        return;
      if (n) {
        J.stopPropagation(), J.preventDefault();
        return;
      }
      T || _(!0), J.currentTarget.focus({ preventScroll: !0 }), D.add(document, "mouseup", G, !1), u == null || u(J);
    },
    [n, T, u, D, G]
  ), ce = re(
    (J) => {
      J.button === 0 && (T || _(!1), f == null || f(J));
    },
    [f, T]
  ), te = re(
    (J) => {
      if (n) {
        J.preventDefault();
        return;
      }
      S == null || S(J);
    },
    [n, S]
  ), Ee = re(
    (J) => {
      P && (J.preventDefault(), _(!1)), w == null || w(J);
    },
    [P, w]
  ), me = Cn(t, L);
  return T ? {
    ...E,
    ref: me,
    type: "button",
    "aria-disabled": V ? void 0 : n,
    disabled: V,
    onClick: $,
    onMouseDown: u,
    onMouseUp: f,
    onKeyUp: g,
    onKeyDown: v,
    onMouseOver: S,
    onMouseLeave: w
  } : {
    ...E,
    ref: me,
    role: "button",
    "data-active": Ft(P),
    "aria-disabled": n ? "true" : void 0,
    tabIndex: V ? void 0 : F,
    onClick: $,
    onMouseDown: oe,
    onMouseUp: ce,
    onKeyUp: H,
    onKeyDown: W,
    onMouseOver: te,
    onMouseLeave: Ee
  };
}
function Ehe(e) {
  const t = e.current;
  if (!t)
    return !1;
  const n = Lpe(t);
  return !n || t.contains(n) ? !1 : !!Hpe(n);
}
function nj(e, t) {
  const { shouldFocus: n, visible: o, focusRef: a } = t, l = n && !o;
  xl(() => {
    if (!l || Ehe(e))
      return;
    const u = (a == null ? void 0 : a.current) || e.current;
    let f;
    if (u)
      return f = requestAnimationFrame(() => {
        u.focus({ preventScroll: !0 });
      }), () => {
        cancelAnimationFrame(f);
      };
  }, [l, e, a]);
}
var The = {
  preventScroll: !0,
  shouldFocus: !1
};
function Ihe(e, t = The) {
  const { focusRef: n, preventScroll: o, shouldFocus: a, visible: l } = t, u = Ahe(e) ? e.current : e, f = a && l, h = Ue(f), v = Ue(l);
  Ss(() => {
    !v.current && l && (h.current = f), v.current = l;
  }, [l, f]);
  const g = re(() => {
    if (!(!l || !u || !h.current) && (h.current = !1, !u.contains(document.activeElement)))
      if (n != null && n.current)
        requestAnimationFrame(() => {
          var b;
          (b = n.current) == null || b.focus({ preventScroll: o });
        });
      else {
        const b = WH(u);
        b.length > 0 && requestAnimationFrame(() => {
          b[0].focus({ preventScroll: o });
        });
      }
  }, [l, o, u, n]);
  xl(() => {
    g();
  }, [g]), nh(u, "transitionend", g);
}
function Ahe(e) {
  return "current" in e;
}
var xv = (e, t) => ({
  var: e,
  varRef: t ? `var(${e}, ${t})` : `var(${e})`
}), po = {
  arrowShadowColor: xv("--popper-arrow-shadow-color"),
  arrowSize: xv("--popper-arrow-size", "8px"),
  arrowSizeHalf: xv("--popper-arrow-size-half"),
  arrowBg: xv("--popper-arrow-bg"),
  transformOrigin: xv("--popper-transform-origin"),
  arrowOffset: xv("--popper-arrow-offset")
};
function khe(e) {
  if (e.includes("top"))
    return "1px 1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("bottom"))
    return "-1px -1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("right"))
    return "-1px 1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("left"))
    return "1px -1px 0px 0 var(--popper-arrow-shadow-color)";
}
var Rhe = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
}, Phe = (e) => Rhe[e], w$ = {
  scroll: !0,
  resize: !0
};
function Ohe(e) {
  let t;
  return typeof e == "object" ? t = {
    enabled: !0,
    options: { ...w$, ...e }
  } : t = {
    enabled: e,
    options: w$
  }, t;
}
var _he = {
  name: "matchWidth",
  enabled: !0,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: e }) => {
    e.styles.popper.width = `${e.rects.reference.width}px`;
  },
  effect: ({ state: e }) => () => {
    const t = e.elements.reference;
    e.elements.popper.style.width = `${t.offsetWidth}px`;
  }
}, Dhe = {
  name: "transformOrigin",
  enabled: !0,
  phase: "write",
  fn: ({ state: e }) => {
    E$(e);
  },
  effect: ({ state: e }) => () => {
    E$(e);
  }
}, E$ = (e) => {
  e.elements.popper.style.setProperty(
    po.transformOrigin.var,
    Phe(e.placement)
  );
}, Nhe = {
  name: "positionArrow",
  enabled: !0,
  phase: "afterWrite",
  fn: ({ state: e }) => {
    Mhe(e);
  }
}, Mhe = (e) => {
  var t;
  if (!e.placement)
    return;
  const n = Lhe(e.placement);
  if ((t = e.elements) != null && t.arrow && n) {
    Object.assign(e.elements.arrow.style, {
      [n.property]: n.value,
      width: po.arrowSize.varRef,
      height: po.arrowSize.varRef,
      zIndex: -1
    });
    const o = {
      [po.arrowSizeHalf.var]: `calc(${po.arrowSize.varRef} / 2 - 1px)`,
      [po.arrowOffset.var]: `calc(${po.arrowSizeHalf.varRef} * -1)`
    };
    for (const a in o)
      e.elements.arrow.style.setProperty(a, o[a]);
  }
}, Lhe = (e) => {
  if (e.startsWith("top"))
    return { property: "bottom", value: po.arrowOffset.varRef };
  if (e.startsWith("bottom"))
    return { property: "top", value: po.arrowOffset.varRef };
  if (e.startsWith("left"))
    return { property: "right", value: po.arrowOffset.varRef };
  if (e.startsWith("right"))
    return { property: "left", value: po.arrowOffset.varRef };
}, Fhe = {
  name: "innerArrow",
  enabled: !0,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: e }) => {
    T$(e);
  },
  effect: ({ state: e }) => () => {
    T$(e);
  }
}, T$ = (e) => {
  if (!e.elements.arrow)
    return;
  const t = e.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!t)
    return;
  const n = khe(e.placement);
  n && t.style.setProperty("--popper-arrow-default-shadow", n), Object.assign(t.style, {
    transform: "rotate(45deg)",
    background: po.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: "var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))"
  });
}, Bhe = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
}, Vhe = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function $he(e, t = "ltr") {
  var n, o;
  const a = ((n = Bhe[e]) == null ? void 0 : n[t]) || e;
  return t === "ltr" ? a : (o = Vhe[e]) != null ? o : a;
}
var va = "top", Ts = "bottom", Is = "right", ga = "left", H2 = "auto", bS = [va, Ts, Is, ga], dg = "start", K0 = "end", zhe = "clippingParents", rj = "viewport", Qb = "popper", Hhe = "reference", I$ = /* @__PURE__ */ bS.reduce(function(e, t) {
  return e.concat([t + "-" + dg, t + "-" + K0]);
}, []), oj = /* @__PURE__ */ [].concat(bS, [H2]).reduce(function(e, t) {
  return e.concat([t, t + "-" + dg, t + "-" + K0]);
}, []), jhe = "beforeRead", Ghe = "read", Whe = "afterRead", Uhe = "beforeMain", Xhe = "main", Zhe = "afterMain", Yhe = "beforeWrite", Jhe = "write", Qhe = "afterWrite", Khe = [jhe, Ghe, Whe, Uhe, Xhe, Zhe, Yhe, Jhe, Qhe];
function yu(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Xa(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function uh(e) {
  var t = Xa(e).Element;
  return e instanceof t || e instanceof Element;
}
function Cs(e) {
  var t = Xa(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function j2(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Xa(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function qhe(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var o = t.styles[n] || {}, a = t.attributes[n] || {}, l = t.elements[n];
    !Cs(l) || !yu(l) || (Object.assign(l.style, o), Object.keys(a).forEach(function(u) {
      var f = a[u];
      f === !1 ? l.removeAttribute(u) : l.setAttribute(u, f === !0 ? "" : f);
    }));
  });
}
function eme(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var a = t.elements[o], l = t.attributes[o] || {}, u = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), f = u.reduce(function(h, v) {
        return h[v] = "", h;
      }, {});
      !Cs(a) || !yu(a) || (Object.assign(a.style, f), Object.keys(l).forEach(function(h) {
        a.removeAttribute(h);
      }));
    });
  };
}
const tme = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: qhe,
  effect: eme,
  requires: ["computeStyles"]
};
function vu(e) {
  return e.split("-")[0];
}
var rh = Math.max, rE = Math.min, fg = Math.round;
function AO() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function ij() {
  return !/^((?!chrome|android).)*safari/i.test(AO());
}
function pg(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var o = e.getBoundingClientRect(), a = 1, l = 1;
  t && Cs(e) && (a = e.offsetWidth > 0 && fg(o.width) / e.offsetWidth || 1, l = e.offsetHeight > 0 && fg(o.height) / e.offsetHeight || 1);
  var u = uh(e) ? Xa(e) : window, f = u.visualViewport, h = !ij() && n, v = (o.left + (h && f ? f.offsetLeft : 0)) / a, g = (o.top + (h && f ? f.offsetTop : 0)) / l, b = o.width / a, S = o.height / l;
  return {
    width: b,
    height: S,
    top: g,
    right: v + b,
    bottom: g + S,
    left: v,
    x: v,
    y: g
  };
}
function G2(e) {
  var t = pg(e), n = e.offsetWidth, o = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: o
  };
}
function aj(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && j2(n)) {
    var o = t;
    do {
      if (o && e.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function Lc(e) {
  return Xa(e).getComputedStyle(e);
}
function nme(e) {
  return ["table", "td", "th"].indexOf(yu(e)) >= 0;
}
function Tf(e) {
  return ((uh(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function sT(e) {
  return yu(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (j2(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Tf(e)
  );
}
function A$(e) {
  return !Cs(e) || // https://github.com/popperjs/popper-core/issues/837
  Lc(e).position === "fixed" ? null : e.offsetParent;
}
function rme(e) {
  var t = /firefox/i.test(AO()), n = /Trident/i.test(AO());
  if (n && Cs(e)) {
    var o = Lc(e);
    if (o.position === "fixed")
      return null;
  }
  var a = sT(e);
  for (j2(a) && (a = a.host); Cs(a) && ["html", "body"].indexOf(yu(a)) < 0; ) {
    var l = Lc(a);
    if (l.transform !== "none" || l.perspective !== "none" || l.contain === "paint" || ["transform", "perspective"].indexOf(l.willChange) !== -1 || t && l.willChange === "filter" || t && l.filter && l.filter !== "none")
      return a;
    a = a.parentNode;
  }
  return null;
}
function SS(e) {
  for (var t = Xa(e), n = A$(e); n && nme(n) && Lc(n).position === "static"; )
    n = A$(n);
  return n && (yu(n) === "html" || yu(n) === "body" && Lc(n).position === "static") ? t : n || rme(e) || t;
}
function W2(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function k0(e, t, n) {
  return rh(e, rE(t, n));
}
function ome(e, t, n) {
  var o = k0(e, t, n);
  return o > n ? n : o;
}
function sj() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function lj(e) {
  return Object.assign({}, sj(), e);
}
function uj(e, t) {
  return t.reduce(function(n, o) {
    return n[o] = e, n;
  }, {});
}
var ime = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, lj(typeof t != "number" ? t : uj(t, bS));
};
function ame(e) {
  var t, n = e.state, o = e.name, a = e.options, l = n.elements.arrow, u = n.modifiersData.popperOffsets, f = vu(n.placement), h = W2(f), v = [ga, Is].indexOf(f) >= 0, g = v ? "height" : "width";
  if (!(!l || !u)) {
    var b = ime(a.padding, n), S = G2(l), w = h === "y" ? va : ga, E = h === "y" ? Ts : Is, T = n.rects.reference[g] + n.rects.reference[h] - u[h] - n.rects.popper[g], A = u[h] - n.rects.reference[h], P = SS(l), _ = P ? h === "y" ? P.clientHeight || 0 : P.clientWidth || 0 : 0, D = T / 2 - A / 2, L = b[w], F = _ - S[g] - b[E], V = _ / 2 - S[g] / 2 + D, $ = k0(L, V, F), U = h;
    n.modifiersData[o] = (t = {}, t[U] = $, t.centerOffset = $ - V, t);
  }
}
function sme(e) {
  var t = e.state, n = e.options, o = n.element, a = o === void 0 ? "[data-popper-arrow]" : o;
  a != null && (typeof a == "string" && (a = t.elements.popper.querySelector(a), !a) || aj(t.elements.popper, a) && (t.elements.arrow = a));
}
const lme = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: ame,
  effect: sme,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function hg(e) {
  return e.split("-")[1];
}
var ume = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function cme(e, t) {
  var n = e.x, o = e.y, a = t.devicePixelRatio || 1;
  return {
    x: fg(n * a) / a || 0,
    y: fg(o * a) / a || 0
  };
}
function k$(e) {
  var t, n = e.popper, o = e.popperRect, a = e.placement, l = e.variation, u = e.offsets, f = e.position, h = e.gpuAcceleration, v = e.adaptive, g = e.roundOffsets, b = e.isFixed, S = u.x, w = S === void 0 ? 0 : S, E = u.y, T = E === void 0 ? 0 : E, A = typeof g == "function" ? g({
    x: w,
    y: T
  }) : {
    x: w,
    y: T
  };
  w = A.x, T = A.y;
  var P = u.hasOwnProperty("x"), _ = u.hasOwnProperty("y"), D = ga, L = va, F = window;
  if (v) {
    var V = SS(n), $ = "clientHeight", U = "clientWidth";
    if (V === Xa(n) && (V = Tf(n), Lc(V).position !== "static" && f === "absolute" && ($ = "scrollHeight", U = "scrollWidth")), V = V, a === va || (a === ga || a === Is) && l === K0) {
      L = Ts;
      var W = b && V === F && F.visualViewport ? F.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        V[$]
      );
      T -= W - o.height, T *= h ? 1 : -1;
    }
    if (a === ga || (a === va || a === Ts) && l === K0) {
      D = Is;
      var H = b && V === F && F.visualViewport ? F.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        V[U]
      );
      w -= H - o.width, w *= h ? 1 : -1;
    }
  }
  var G = Object.assign({
    position: f
  }, v && ume), oe = g === !0 ? cme({
    x: w,
    y: T
  }, Xa(n)) : {
    x: w,
    y: T
  };
  if (w = oe.x, T = oe.y, h) {
    var ce;
    return Object.assign({}, G, (ce = {}, ce[L] = _ ? "0" : "", ce[D] = P ? "0" : "", ce.transform = (F.devicePixelRatio || 1) <= 1 ? "translate(" + w + "px, " + T + "px)" : "translate3d(" + w + "px, " + T + "px, 0)", ce));
  }
  return Object.assign({}, G, (t = {}, t[L] = _ ? T + "px" : "", t[D] = P ? w + "px" : "", t.transform = "", t));
}
function dme(e) {
  var t = e.state, n = e.options, o = n.gpuAcceleration, a = o === void 0 ? !0 : o, l = n.adaptive, u = l === void 0 ? !0 : l, f = n.roundOffsets, h = f === void 0 ? !0 : f, v = {
    placement: vu(t.placement),
    variation: hg(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: a,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, k$(Object.assign({}, v, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: u,
    roundOffsets: h
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, k$(Object.assign({}, v, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: h
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const fme = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: dme,
  data: {}
};
var NC = {
  passive: !0
};
function pme(e) {
  var t = e.state, n = e.instance, o = e.options, a = o.scroll, l = a === void 0 ? !0 : a, u = o.resize, f = u === void 0 ? !0 : u, h = Xa(t.elements.popper), v = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return l && v.forEach(function(g) {
    g.addEventListener("scroll", n.update, NC);
  }), f && h.addEventListener("resize", n.update, NC), function() {
    l && v.forEach(function(g) {
      g.removeEventListener("scroll", n.update, NC);
    }), f && h.removeEventListener("resize", n.update, NC);
  };
}
const hme = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: pme,
  data: {}
};
var mme = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function hw(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return mme[t];
  });
}
var vme = {
  start: "end",
  end: "start"
};
function R$(e) {
  return e.replace(/start|end/g, function(t) {
    return vme[t];
  });
}
function U2(e) {
  var t = Xa(e), n = t.pageXOffset, o = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: o
  };
}
function X2(e) {
  return pg(Tf(e)).left + U2(e).scrollLeft;
}
function gme(e, t) {
  var n = Xa(e), o = Tf(e), a = n.visualViewport, l = o.clientWidth, u = o.clientHeight, f = 0, h = 0;
  if (a) {
    l = a.width, u = a.height;
    var v = ij();
    (v || !v && t === "fixed") && (f = a.offsetLeft, h = a.offsetTop);
  }
  return {
    width: l,
    height: u,
    x: f + X2(e),
    y: h
  };
}
function yme(e) {
  var t, n = Tf(e), o = U2(e), a = (t = e.ownerDocument) == null ? void 0 : t.body, l = rh(n.scrollWidth, n.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), u = rh(n.scrollHeight, n.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), f = -o.scrollLeft + X2(e), h = -o.scrollTop;
  return Lc(a || n).direction === "rtl" && (f += rh(n.clientWidth, a ? a.clientWidth : 0) - l), {
    width: l,
    height: u,
    x: f,
    y: h
  };
}
function Z2(e) {
  var t = Lc(e), n = t.overflow, o = t.overflowX, a = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + a + o);
}
function cj(e) {
  return ["html", "body", "#document"].indexOf(yu(e)) >= 0 ? e.ownerDocument.body : Cs(e) && Z2(e) ? e : cj(sT(e));
}
function R0(e, t) {
  var n;
  t === void 0 && (t = []);
  var o = cj(e), a = o === ((n = e.ownerDocument) == null ? void 0 : n.body), l = Xa(o), u = a ? [l].concat(l.visualViewport || [], Z2(o) ? o : []) : o, f = t.concat(u);
  return a ? f : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    f.concat(R0(sT(u)))
  );
}
function kO(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function bme(e, t) {
  var n = pg(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function P$(e, t, n) {
  return t === rj ? kO(gme(e, n)) : uh(t) ? bme(t, n) : kO(yme(Tf(e)));
}
function Sme(e) {
  var t = R0(sT(e)), n = ["absolute", "fixed"].indexOf(Lc(e).position) >= 0, o = n && Cs(e) ? SS(e) : e;
  return uh(o) ? t.filter(function(a) {
    return uh(a) && aj(a, o) && yu(a) !== "body";
  }) : [];
}
function xme(e, t, n, o) {
  var a = t === "clippingParents" ? Sme(e) : [].concat(t), l = [].concat(a, [n]), u = l[0], f = l.reduce(function(h, v) {
    var g = P$(e, v, o);
    return h.top = rh(g.top, h.top), h.right = rE(g.right, h.right), h.bottom = rE(g.bottom, h.bottom), h.left = rh(g.left, h.left), h;
  }, P$(e, u, o));
  return f.width = f.right - f.left, f.height = f.bottom - f.top, f.x = f.left, f.y = f.top, f;
}
function dj(e) {
  var t = e.reference, n = e.element, o = e.placement, a = o ? vu(o) : null, l = o ? hg(o) : null, u = t.x + t.width / 2 - n.width / 2, f = t.y + t.height / 2 - n.height / 2, h;
  switch (a) {
    case va:
      h = {
        x: u,
        y: t.y - n.height
      };
      break;
    case Ts:
      h = {
        x: u,
        y: t.y + t.height
      };
      break;
    case Is:
      h = {
        x: t.x + t.width,
        y: f
      };
      break;
    case ga:
      h = {
        x: t.x - n.width,
        y: f
      };
      break;
    default:
      h = {
        x: t.x,
        y: t.y
      };
  }
  var v = a ? W2(a) : null;
  if (v != null) {
    var g = v === "y" ? "height" : "width";
    switch (l) {
      case dg:
        h[v] = h[v] - (t[g] / 2 - n[g] / 2);
        break;
      case K0:
        h[v] = h[v] + (t[g] / 2 - n[g] / 2);
        break;
    }
  }
  return h;
}
function q0(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, a = o === void 0 ? e.placement : o, l = n.strategy, u = l === void 0 ? e.strategy : l, f = n.boundary, h = f === void 0 ? zhe : f, v = n.rootBoundary, g = v === void 0 ? rj : v, b = n.elementContext, S = b === void 0 ? Qb : b, w = n.altBoundary, E = w === void 0 ? !1 : w, T = n.padding, A = T === void 0 ? 0 : T, P = lj(typeof A != "number" ? A : uj(A, bS)), _ = S === Qb ? Hhe : Qb, D = e.rects.popper, L = e.elements[E ? _ : S], F = xme(uh(L) ? L : L.contextElement || Tf(e.elements.popper), h, g, u), V = pg(e.elements.reference), $ = dj({
    reference: V,
    element: D,
    strategy: "absolute",
    placement: a
  }), U = kO(Object.assign({}, D, $)), W = S === Qb ? U : V, H = {
    top: F.top - W.top + P.top,
    bottom: W.bottom - F.bottom + P.bottom,
    left: F.left - W.left + P.left,
    right: W.right - F.right + P.right
  }, G = e.modifiersData.offset;
  if (S === Qb && G) {
    var oe = G[a];
    Object.keys(H).forEach(function(ce) {
      var te = [Is, Ts].indexOf(ce) >= 0 ? 1 : -1, Ee = [va, Ts].indexOf(ce) >= 0 ? "y" : "x";
      H[ce] += oe[Ee] * te;
    });
  }
  return H;
}
function Cme(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, a = n.boundary, l = n.rootBoundary, u = n.padding, f = n.flipVariations, h = n.allowedAutoPlacements, v = h === void 0 ? oj : h, g = hg(o), b = g ? f ? I$ : I$.filter(function(E) {
    return hg(E) === g;
  }) : bS, S = b.filter(function(E) {
    return v.indexOf(E) >= 0;
  });
  S.length === 0 && (S = b);
  var w = S.reduce(function(E, T) {
    return E[T] = q0(e, {
      placement: T,
      boundary: a,
      rootBoundary: l,
      padding: u
    })[vu(T)], E;
  }, {});
  return Object.keys(w).sort(function(E, T) {
    return w[E] - w[T];
  });
}
function wme(e) {
  if (vu(e) === H2)
    return [];
  var t = hw(e);
  return [R$(e), t, R$(t)];
}
function Eme(e) {
  var t = e.state, n = e.options, o = e.name;
  if (!t.modifiersData[o]._skip) {
    for (var a = n.mainAxis, l = a === void 0 ? !0 : a, u = n.altAxis, f = u === void 0 ? !0 : u, h = n.fallbackPlacements, v = n.padding, g = n.boundary, b = n.rootBoundary, S = n.altBoundary, w = n.flipVariations, E = w === void 0 ? !0 : w, T = n.allowedAutoPlacements, A = t.options.placement, P = vu(A), _ = P === A, D = h || (_ || !E ? [hw(A)] : wme(A)), L = [A].concat(D).reduce(function(ne, pe) {
      return ne.concat(vu(pe) === H2 ? Cme(t, {
        placement: pe,
        boundary: g,
        rootBoundary: b,
        padding: v,
        flipVariations: E,
        allowedAutoPlacements: T
      }) : pe);
    }, []), F = t.rects.reference, V = t.rects.popper, $ = /* @__PURE__ */ new Map(), U = !0, W = L[0], H = 0; H < L.length; H++) {
      var G = L[H], oe = vu(G), ce = hg(G) === dg, te = [va, Ts].indexOf(oe) >= 0, Ee = te ? "width" : "height", me = q0(t, {
        placement: G,
        boundary: g,
        rootBoundary: b,
        altBoundary: S,
        padding: v
      }), J = te ? ce ? Is : ga : ce ? Ts : va;
      F[Ee] > V[Ee] && (J = hw(J));
      var Q = hw(J), ge = [];
      if (l && ge.push(me[oe] <= 0), f && ge.push(me[J] <= 0, me[Q] <= 0), ge.every(function(ne) {
        return ne;
      })) {
        W = G, U = !1;
        break;
      }
      $.set(G, ge);
    }
    if (U)
      for (var Y = E ? 3 : 1, q = function(pe) {
        var Oe = L.find(function(Ce) {
          var xe = $.get(Ce);
          if (xe)
            return xe.slice(0, pe).every(function(ie) {
              return ie;
            });
        });
        if (Oe)
          return W = Oe, "break";
      }, de = Y; de > 0; de--) {
        var K = q(de);
        if (K === "break")
          break;
      }
    t.placement !== W && (t.modifiersData[o]._skip = !0, t.placement = W, t.reset = !0);
  }
}
const Tme = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Eme,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function O$(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function _$(e) {
  return [va, Is, Ts, ga].some(function(t) {
    return e[t] >= 0;
  });
}
function Ime(e) {
  var t = e.state, n = e.name, o = t.rects.reference, a = t.rects.popper, l = t.modifiersData.preventOverflow, u = q0(t, {
    elementContext: "reference"
  }), f = q0(t, {
    altBoundary: !0
  }), h = O$(u, o), v = O$(f, a, l), g = _$(h), b = _$(v);
  t.modifiersData[n] = {
    referenceClippingOffsets: h,
    popperEscapeOffsets: v,
    isReferenceHidden: g,
    hasPopperEscaped: b
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": g,
    "data-popper-escaped": b
  });
}
const Ame = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Ime
};
function kme(e, t, n) {
  var o = vu(e), a = [ga, va].indexOf(o) >= 0 ? -1 : 1, l = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, u = l[0], f = l[1];
  return u = u || 0, f = (f || 0) * a, [ga, Is].indexOf(o) >= 0 ? {
    x: f,
    y: u
  } : {
    x: u,
    y: f
  };
}
function Rme(e) {
  var t = e.state, n = e.options, o = e.name, a = n.offset, l = a === void 0 ? [0, 0] : a, u = oj.reduce(function(g, b) {
    return g[b] = kme(b, t.rects, l), g;
  }, {}), f = u[t.placement], h = f.x, v = f.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += h, t.modifiersData.popperOffsets.y += v), t.modifiersData[o] = u;
}
const Pme = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Rme
};
function Ome(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = dj({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const _me = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Ome,
  data: {}
};
function Dme(e) {
  return e === "x" ? "y" : "x";
}
function Nme(e) {
  var t = e.state, n = e.options, o = e.name, a = n.mainAxis, l = a === void 0 ? !0 : a, u = n.altAxis, f = u === void 0 ? !1 : u, h = n.boundary, v = n.rootBoundary, g = n.altBoundary, b = n.padding, S = n.tether, w = S === void 0 ? !0 : S, E = n.tetherOffset, T = E === void 0 ? 0 : E, A = q0(t, {
    boundary: h,
    rootBoundary: v,
    padding: b,
    altBoundary: g
  }), P = vu(t.placement), _ = hg(t.placement), D = !_, L = W2(P), F = Dme(L), V = t.modifiersData.popperOffsets, $ = t.rects.reference, U = t.rects.popper, W = typeof T == "function" ? T(Object.assign({}, t.rects, {
    placement: t.placement
  })) : T, H = typeof W == "number" ? {
    mainAxis: W,
    altAxis: W
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, W), G = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, oe = {
    x: 0,
    y: 0
  };
  if (V) {
    if (l) {
      var ce, te = L === "y" ? va : ga, Ee = L === "y" ? Ts : Is, me = L === "y" ? "height" : "width", J = V[L], Q = J + A[te], ge = J - A[Ee], Y = w ? -U[me] / 2 : 0, q = _ === dg ? $[me] : U[me], de = _ === dg ? -U[me] : -$[me], K = t.elements.arrow, ne = w && K ? G2(K) : {
        width: 0,
        height: 0
      }, pe = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : sj(), Oe = pe[te], Ce = pe[Ee], xe = k0(0, $[me], ne[me]), ie = D ? $[me] / 2 - Y - xe - Oe - H.mainAxis : q - xe - Oe - H.mainAxis, ye = D ? -$[me] / 2 + Y + xe + Ce + H.mainAxis : de + xe + Ce + H.mainAxis, we = t.elements.arrow && SS(t.elements.arrow), fe = we ? L === "y" ? we.clientTop || 0 : we.clientLeft || 0 : 0, ze = (ce = G == null ? void 0 : G[L]) != null ? ce : 0, Ve = J + ie - ze - fe, Ie = J + ye - ze, qe = k0(w ? rE(Q, Ve) : Q, J, w ? rh(ge, Ie) : ge);
      V[L] = qe, oe[L] = qe - J;
    }
    if (f) {
      var Qe, lt = L === "x" ? va : ga, tn = L === "x" ? Ts : Is, Yt = V[F], hn = F === "y" ? "height" : "width", vn = Yt + A[lt], nn = Yt - A[tn], rn = [va, ga].indexOf(P) !== -1, mn = (Qe = G == null ? void 0 : G[F]) != null ? Qe : 0, un = rn ? vn : Yt - $[hn] - U[hn] - mn + H.altAxis, Tn = rn ? Yt + $[hn] + U[hn] - mn - H.altAxis : nn, je = w && rn ? ome(un, Yt, Tn) : k0(w ? un : vn, Yt, w ? Tn : nn);
      V[F] = je, oe[F] = je - Yt;
    }
    t.modifiersData[o] = oe;
  }
}
const Mme = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Nme,
  requiresIfExists: ["offset"]
};
function Lme(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Fme(e) {
  return e === Xa(e) || !Cs(e) ? U2(e) : Lme(e);
}
function Bme(e) {
  var t = e.getBoundingClientRect(), n = fg(t.width) / e.offsetWidth || 1, o = fg(t.height) / e.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function Vme(e, t, n) {
  n === void 0 && (n = !1);
  var o = Cs(t), a = Cs(t) && Bme(t), l = Tf(t), u = pg(e, a, n), f = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = {
    x: 0,
    y: 0
  };
  return (o || !o && !n) && ((yu(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Z2(l)) && (f = Fme(t)), Cs(t) ? (h = pg(t, !0), h.x += t.clientLeft, h.y += t.clientTop) : l && (h.x = X2(l))), {
    x: u.left + f.scrollLeft - h.x,
    y: u.top + f.scrollTop - h.y,
    width: u.width,
    height: u.height
  };
}
function $me(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  e.forEach(function(l) {
    t.set(l.name, l);
  });
  function a(l) {
    n.add(l.name);
    var u = [].concat(l.requires || [], l.requiresIfExists || []);
    u.forEach(function(f) {
      if (!n.has(f)) {
        var h = t.get(f);
        h && a(h);
      }
    }), o.push(l);
  }
  return e.forEach(function(l) {
    n.has(l.name) || a(l);
  }), o;
}
function zme(e) {
  var t = $me(e);
  return Khe.reduce(function(n, o) {
    return n.concat(t.filter(function(a) {
      return a.phase === o;
    }));
  }, []);
}
function Hme(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function jme(e) {
  var t = e.reduce(function(n, o) {
    var a = n[o.name];
    return n[o.name] = a ? Object.assign({}, a, o, {
      options: Object.assign({}, a.options, o.options),
      data: Object.assign({}, a.data, o.data)
    }) : o, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var D$ = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function N$() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function Gme(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, a = t.defaultOptions, l = a === void 0 ? D$ : a;
  return function(f, h, v) {
    v === void 0 && (v = l);
    var g = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, D$, l),
      modifiersData: {},
      elements: {
        reference: f,
        popper: h
      },
      attributes: {},
      styles: {}
    }, b = [], S = !1, w = {
      state: g,
      setOptions: function(P) {
        var _ = typeof P == "function" ? P(g.options) : P;
        T(), g.options = Object.assign({}, l, g.options, _), g.scrollParents = {
          reference: uh(f) ? R0(f) : f.contextElement ? R0(f.contextElement) : [],
          popper: R0(h)
        };
        var D = zme(jme([].concat(o, g.options.modifiers)));
        return g.orderedModifiers = D.filter(function(L) {
          return L.enabled;
        }), E(), w.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!S) {
          var P = g.elements, _ = P.reference, D = P.popper;
          if (N$(_, D)) {
            g.rects = {
              reference: Vme(_, SS(D), g.options.strategy === "fixed"),
              popper: G2(D)
            }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function(H) {
              return g.modifiersData[H.name] = Object.assign({}, H.data);
            });
            for (var L = 0; L < g.orderedModifiers.length; L++) {
              if (g.reset === !0) {
                g.reset = !1, L = -1;
                continue;
              }
              var F = g.orderedModifiers[L], V = F.fn, $ = F.options, U = $ === void 0 ? {} : $, W = F.name;
              typeof V == "function" && (g = V({
                state: g,
                options: U,
                name: W,
                instance: w
              }) || g);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Hme(function() {
        return new Promise(function(A) {
          w.forceUpdate(), A(g);
        });
      }),
      destroy: function() {
        T(), S = !0;
      }
    };
    if (!N$(f, h))
      return w;
    w.setOptions(v).then(function(A) {
      !S && v.onFirstUpdate && v.onFirstUpdate(A);
    });
    function E() {
      g.orderedModifiers.forEach(function(A) {
        var P = A.name, _ = A.options, D = _ === void 0 ? {} : _, L = A.effect;
        if (typeof L == "function") {
          var F = L({
            state: g,
            name: P,
            instance: w,
            options: D
          }), V = function() {
          };
          b.push(F || V);
        }
      });
    }
    function T() {
      b.forEach(function(A) {
        return A();
      }), b = [];
    }
    return w;
  };
}
var Wme = [hme, _me, fme, tme, Pme, Tme, Mme, lme, Ame], Ume = /* @__PURE__ */ Gme({
  defaultModifiers: Wme
});
function Y2(e = {}) {
  const {
    enabled: t = !0,
    modifiers: n,
    placement: o = "bottom",
    strategy: a = "absolute",
    arrowPadding: l = 8,
    eventListeners: u = !0,
    offset: f,
    gutter: h = 8,
    flip: v = !0,
    boundary: g = "clippingParents",
    preventOverflow: b = !0,
    matchWidth: S,
    direction: w = "ltr"
  } = e, E = Ue(null), T = Ue(null), A = Ue(null), P = $he(o, w), _ = Ue(() => {
  }), D = re(() => {
    var H;
    !t || !E.current || !T.current || ((H = _.current) == null || H.call(_), A.current = Ume(E.current, T.current, {
      placement: P,
      modifiers: [
        Fhe,
        Nhe,
        Dhe,
        {
          ..._he,
          enabled: !!S
        },
        {
          name: "eventListeners",
          ...Ohe(u)
        },
        {
          name: "arrow",
          options: { padding: l }
        },
        {
          name: "offset",
          options: {
            offset: f ?? [0, h]
          }
        },
        {
          name: "flip",
          enabled: !!v,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!b,
          options: { boundary: g }
        },
        // allow users override internal modifiers
        ...n ?? []
      ],
      strategy: a
    }), A.current.forceUpdate(), _.current = A.current.destroy);
  }, [
    P,
    t,
    n,
    S,
    u,
    l,
    f,
    h,
    v,
    b,
    g,
    a
  ]);
  dt(() => () => {
    var H;
    !E.current && !T.current && ((H = A.current) == null || H.destroy(), A.current = null);
  }, []);
  const L = re(
    (H) => {
      E.current = H, D();
    },
    [D]
  ), F = re(
    (H = {}, G = null) => ({
      ...H,
      ref: Cn(L, G)
    }),
    [L]
  ), V = re(
    (H) => {
      T.current = H, D();
    },
    [D]
  ), $ = re(
    (H = {}, G = null) => ({
      ...H,
      ref: Cn(V, G),
      style: {
        ...H.style,
        position: a,
        minWidth: S ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [a, V, S]
  ), U = re((H = {}, G = null) => {
    const { size: oe, shadowColor: ce, bg: te, style: Ee, ...me } = H;
    return {
      ...me,
      ref: G,
      "data-popper-arrow": "",
      style: Xme(H)
    };
  }, []), W = re(
    (H = {}, G = null) => ({
      ...H,
      ref: G,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      var H;
      (H = A.current) == null || H.update();
    },
    forceUpdate() {
      var H;
      (H = A.current) == null || H.forceUpdate();
    },
    transformOrigin: po.transformOrigin.varRef,
    referenceRef: L,
    popperRef: V,
    getPopperProps: $,
    getArrowProps: U,
    getArrowInnerProps: W,
    getReferenceProps: F
  };
}
function Xme(e) {
  const { size: t, shadowColor: n, bg: o, style: a } = e, l = { ...a, position: "absolute" };
  return t && (l["--popper-arrow-size"] = t), n && (l["--popper-arrow-shadow-color"] = n), o && (l["--popper-arrow-bg"] = o), l;
}
function J2(e = {}) {
  const {
    onClose: t,
    onOpen: n,
    isOpen: o,
    id: a
  } = e, l = Er(n), u = Er(t), [f, h] = ot(e.defaultIsOpen || !1), v = o !== void 0 ? o : f, g = o !== void 0, b = ko(), S = a ?? `disclosure-${b}`, w = re(() => {
    g || h(!1), u == null || u();
  }, [g, u]), E = re(() => {
    g || h(!0), l == null || l();
  }, [g, l]), T = re(() => {
    v ? w() : E();
  }, [v, E, w]);
  function A(_ = {}) {
    return {
      ..._,
      "aria-expanded": v,
      "aria-controls": S,
      onClick(D) {
        var L;
        (L = _.onClick) == null || L.call(_, D), T();
      }
    };
  }
  function P(_ = {}) {
    return {
      ..._,
      hidden: !v,
      id: S
    };
  }
  return {
    isOpen: v,
    onOpen: E,
    onClose: w,
    onToggle: T,
    isControlled: g,
    getButtonProps: A,
    getDisclosureProps: P
  };
}
function Zme(e) {
  const { ref: t, handler: n, enabled: o = !0 } = e, a = Er(n), u = Ue({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }).current;
  dt(() => {
    if (!o)
      return;
    const f = (b) => {
      nP(b, t) && (u.isPointerDown = !0);
    }, h = (b) => {
      if (u.ignoreEmulatedMouseEvents) {
        u.ignoreEmulatedMouseEvents = !1;
        return;
      }
      u.isPointerDown && n && nP(b, t) && (u.isPointerDown = !1, a(b));
    }, v = (b) => {
      u.ignoreEmulatedMouseEvents = !0, n && u.isPointerDown && nP(b, t) && (u.isPointerDown = !1, a(b));
    }, g = fj(t.current);
    return g.addEventListener("mousedown", f, !0), g.addEventListener("mouseup", h, !0), g.addEventListener("touchstart", f, !0), g.addEventListener("touchend", v, !0), () => {
      g.removeEventListener("mousedown", f, !0), g.removeEventListener("mouseup", h, !0), g.removeEventListener("touchstart", f, !0), g.removeEventListener("touchend", v, !0);
    };
  }, [n, t, a, u, o]);
}
function nP(e, t) {
  var n;
  const o = e.target;
  return o && !fj(o).contains(o) ? !1 : !((n = t.current) != null && n.contains(o));
}
function fj(e) {
  var t;
  return (t = e == null ? void 0 : e.ownerDocument) != null ? t : document;
}
function pj(e) {
  const { isOpen: t, ref: n } = e, [o, a] = ot(t), [l, u] = ot(!1);
  return dt(() => {
    l || (a(t), u(!0));
  }, [t, l, o]), nh(
    () => n.current,
    "animationend",
    () => {
      a(t);
    }
  ), {
    present: !(t ? !1 : !o),
    onComplete() {
      var h;
      const v = Mpe(n.current), g = new v.CustomEvent("animationend", { bubbles: !0 });
      (h = n.current) == null || h.dispatchEvent(g);
    }
  };
}
function Q2(e) {
  const { wasSelected: t, enabled: n, isSelected: o, mode: a = "unmount" } = e;
  return !!(!n || o || a === "keepMounted" && t);
}
var [
  Yme,
  Jme,
  Qme,
  Kme
] = v2(), [qme, xS] = En({
  strict: !1,
  name: "MenuContext"
});
function eve(e, ...t) {
  const n = ko(), o = e || n;
  return gt(() => t.map((a) => `${a}-${o}`), [o, t]);
}
function hj(e) {
  var t;
  return (t = e == null ? void 0 : e.ownerDocument) != null ? t : document;
}
function M$(e) {
  return hj(e).activeElement === e;
}
function tve(e = {}) {
  const {
    id: t,
    closeOnSelect: n = !0,
    closeOnBlur: o = !0,
    initialFocusRef: a,
    autoSelect: l = !0,
    isLazy: u,
    isOpen: f,
    defaultIsOpen: h,
    onClose: v,
    onOpen: g,
    placement: b = "bottom-start",
    lazyBehavior: S = "unmount",
    direction: w,
    computePositionOnMount: E = !1,
    ...T
  } = e, A = Ue(null), P = Ue(null), _ = Qme(), D = re(() => {
    requestAnimationFrame(() => {
      var K;
      (K = A.current) == null || K.focus({ preventScroll: !1 });
    });
  }, []), L = re(() => {
    const K = setTimeout(() => {
      var ne;
      if (a)
        (ne = a.current) == null || ne.focus();
      else {
        const pe = _.firstEnabled();
        pe && ce(pe.index);
      }
    });
    Q.current.add(K);
  }, [_, a]), F = re(() => {
    const K = setTimeout(() => {
      const ne = _.lastEnabled();
      ne && ce(ne.index);
    });
    Q.current.add(K);
  }, [_]), V = re(() => {
    g == null || g(), l ? L() : D();
  }, [l, L, D, g]), { isOpen: $, onOpen: U, onClose: W, onToggle: H } = J2({
    isOpen: f,
    defaultIsOpen: h,
    onClose: v,
    onOpen: V
  });
  Zme({
    enabled: $ && o,
    ref: A,
    handler: (K) => {
      var ne;
      (ne = P.current) != null && ne.contains(K.target) || W();
    }
  });
  const G = Y2({
    ...T,
    enabled: $ || E,
    placement: b,
    direction: w
  }), [oe, ce] = ot(-1);
  xl(() => {
    $ || ce(-1);
  }, [$]), nj(A, {
    focusRef: P,
    visible: $,
    shouldFocus: !0
  });
  const te = pj({ isOpen: $, ref: A }), [Ee, me] = eve(t, "menu-button", "menu-list"), J = re(() => {
    U(), D();
  }, [U, D]), Q = Ue(/* @__PURE__ */ new Set([]));
  dt(() => {
    const K = Q.current;
    return () => {
      K.forEach((ne) => clearTimeout(ne)), K.clear();
    };
  }, []);
  const ge = re(() => {
    U(), L();
  }, [L, U]), Y = re(() => {
    U(), F();
  }, [U, F]), q = re(() => {
    var K, ne;
    const pe = hj(A.current), Oe = (K = A.current) == null ? void 0 : K.contains(pe.activeElement);
    if (!($ && !Oe))
      return;
    const xe = (ne = _.item(oe)) == null ? void 0 : ne.node;
    xe == null || xe.focus({ preventScroll: !0 });
  }, [$, oe, _]), de = Ue(null);
  return {
    openAndFocusMenu: J,
    openAndFocusFirstItem: ge,
    openAndFocusLastItem: Y,
    onTransitionEnd: q,
    unstable__animationState: te,
    descendants: _,
    popper: G,
    buttonId: Ee,
    menuId: me,
    forceUpdate: G.forceUpdate,
    orientation: "vertical",
    isOpen: $,
    onToggle: H,
    onOpen: U,
    onClose: W,
    menuRef: A,
    buttonRef: P,
    focusedIndex: oe,
    closeOnSelect: n,
    closeOnBlur: o,
    autoSelect: l,
    setFocusedIndex: ce,
    isLazy: u,
    lazyBehavior: S,
    initialFocusRef: a,
    rafId: de
  };
}
function nve(e = {}, t = null) {
  const n = xS(), { onToggle: o, popper: a, openAndFocusFirstItem: l, openAndFocusLastItem: u } = n, f = re(
    (h) => {
      const v = h.key, b = {
        Enter: l,
        ArrowDown: l,
        ArrowUp: u
      }[v];
      b && (h.preventDefault(), h.stopPropagation(), b(h));
    },
    [l, u]
  );
  return {
    ...e,
    ref: Cn(n.buttonRef, t, a.referenceRef),
    id: n.buttonId,
    "data-active": Ft(n.isOpen),
    "aria-expanded": n.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": n.menuId,
    onClick: st(e.onClick, o),
    onKeyDown: st(e.onKeyDown, f)
  };
}
function RO(e) {
  var t;
  return sve(e) && !!((t = e == null ? void 0 : e.getAttribute("role")) != null && t.startsWith("menuitem"));
}
function rve(e = {}, t = null) {
  const n = xS();
  if (!n)
    throw new Error(
      "useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>"
    );
  const {
    focusedIndex: o,
    setFocusedIndex: a,
    menuRef: l,
    isOpen: u,
    onClose: f,
    menuId: h,
    isLazy: v,
    lazyBehavior: g,
    unstable__animationState: b
  } = n, S = Jme(), w = xhe({
    preventDefault: (P) => P.key !== " " && RO(P.target)
  }), E = re(
    (P) => {
      if (!P.currentTarget.contains(P.target))
        return;
      const _ = P.key, L = {
        Tab: (V) => V.preventDefault(),
        Escape: f,
        ArrowDown: () => {
          const V = S.nextEnabled(o);
          V && a(V.index);
        },
        ArrowUp: () => {
          const V = S.prevEnabled(o);
          V && a(V.index);
        }
      }[_];
      if (L) {
        P.preventDefault(), L(P);
        return;
      }
      const F = w((V) => {
        const $ = Che(
          S.values(),
          V,
          (U) => {
            var W, H;
            return (H = (W = U == null ? void 0 : U.node) == null ? void 0 : W.textContent) != null ? H : "";
          },
          S.item(o)
        );
        if ($) {
          const U = S.indexOf($.node);
          a(U);
        }
      });
      RO(P.target) && F(P);
    },
    [
      S,
      o,
      w,
      f,
      a
    ]
  ), T = Ue(!1);
  u && (T.current = !0);
  const A = Q2({
    wasSelected: T.current,
    enabled: v,
    mode: g,
    isSelected: b.present
  });
  return {
    ...e,
    ref: Cn(l, t),
    children: A ? e.children : null,
    tabIndex: -1,
    role: "menu",
    id: h,
    style: {
      ...e.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: st(e.onKeyDown, E)
  };
}
function ove(e = {}) {
  const { popper: t, isOpen: n } = xS();
  return t.getPopperProps({
    ...e,
    style: {
      visibility: n ? "visible" : "hidden",
      ...e.style
    }
  });
}
function mj(e = {}, t = null) {
  const {
    onMouseEnter: n,
    onMouseMove: o,
    onMouseLeave: a,
    onClick: l,
    onFocus: u,
    isDisabled: f,
    isFocusable: h,
    closeOnSelect: v,
    type: g,
    ...b
  } = e, S = xS(), {
    setFocusedIndex: w,
    focusedIndex: E,
    closeOnSelect: T,
    onClose: A,
    menuRef: P,
    isOpen: _,
    menuId: D,
    rafId: L
  } = S, F = Ue(null), V = `${D}-menuitem-${ko()}`, { index: $, register: U } = Kme({
    disabled: f && !h
  }), W = re(
    (J) => {
      n == null || n(J), !f && w($);
    },
    [w, $, f, n]
  ), H = re(
    (J) => {
      o == null || o(J), F.current && !M$(F.current) && W(J);
    },
    [W, o]
  ), G = re(
    (J) => {
      a == null || a(J), !f && w(-1);
    },
    [w, f, a]
  ), oe = re(
    (J) => {
      l == null || l(J), RO(J.currentTarget) && (v ?? T) && A();
    },
    [A, l, T, v]
  ), ce = re(
    (J) => {
      u == null || u(J), w($);
    },
    [w, u, $]
  ), te = $ === E, Ee = f && !h;
  xl(() => {
    if (_)
      return te && !Ee && F.current ? (L.current && cancelAnimationFrame(L.current), L.current = requestAnimationFrame(() => {
        var J;
        (J = F.current) == null || J.focus({ preventScroll: !0 }), L.current = null;
      })) : P.current && !M$(P.current) && P.current.focus({ preventScroll: !0 }), () => {
        L.current && cancelAnimationFrame(L.current);
      };
  }, [te, Ee, P, _]);
  const me = tj({
    onClick: oe,
    onFocus: ce,
    onMouseEnter: W,
    onMouseMove: H,
    onMouseLeave: G,
    ref: Cn(U, F, t),
    isDisabled: f,
    isFocusable: h
  });
  return {
    ...b,
    ...me,
    type: g ?? me.type,
    id: V,
    role: "menuitem",
    tabIndex: te ? 0 : -1
  };
}
function ive(e = {}, t = null) {
  const { type: n = "radio", isChecked: o, ...a } = e;
  return {
    ...mj(a, t),
    role: `menuitem${n}`,
    "aria-checked": o
  };
}
function ave(e = {}) {
  const {
    children: t,
    type: n = "radio",
    value: o,
    defaultValue: a,
    onChange: l,
    ...u
  } = e, h = n === "radio" ? "" : [], [v, g] = Eg({
    defaultValue: a ?? h,
    value: o,
    onChange: l
  }), b = re(
    (E) => {
      if (n === "radio" && typeof v == "string" && g(E), n === "checkbox" && Array.isArray(v)) {
        const T = v.includes(E) ? v.filter((A) => A !== E) : v.concat(E);
        g(T);
      }
    },
    [v, g, n]
  ), w = gS(t).map((E) => {
    if (E.type.id !== "MenuItemOption")
      return E;
    const T = (P) => {
      var _, D;
      b(E.props.value), (D = (_ = E.props).onClick) == null || D.call(_, P);
    }, A = n === "radio" ? E.props.value === v : v.includes(E.props.value);
    return ya(E, {
      type: n,
      onClick: T,
      isChecked: A
    });
  });
  return {
    ...u,
    children: w
  };
}
function sve(e) {
  var t;
  if (!lve(e))
    return !1;
  const n = (t = e.ownerDocument.defaultView) != null ? t : window;
  return e instanceof n.HTMLElement;
}
function lve(e) {
  return e != null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
var [uve, bh] = En({
  name: "MenuStylesContext",
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
}), K2 = (e) => {
  const { children: t } = e, n = Xn("Menu", e), o = Pn(e), { direction: a } = wl(), { descendants: l, ...u } = tve({ ...o, direction: a }), f = gt(() => u, [u]), { isOpen: h, onClose: v, forceUpdate: g } = f;
  return /* @__PURE__ */ M(Yme, { value: l, children: /* @__PURE__ */ M(qme, { value: f, children: /* @__PURE__ */ M(uve, { value: n, children: Ha(t, { isOpen: h, onClose: v, forceUpdate: g }) }) }) });
};
K2.displayName = "Menu";
var vj = Le(
  (e, t) => {
    const n = bh();
    return /* @__PURE__ */ M(
      De.span,
      {
        ref: t,
        ...e,
        __css: n.command,
        className: "chakra-menu__command"
      }
    );
  }
);
vj.displayName = "MenuCommand";
var gj = Le(
  (e, t) => {
    const { type: n, ...o } = e, a = bh(), l = o.as || n ? n ?? void 0 : "button", u = gt(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...a.item
      }),
      [a.item]
    );
    return /* @__PURE__ */ M(De.button, { ref: t, type: l, ...o, __css: u });
  }
), lT = (e) => {
  const { className: t, children: n, ...o } = e, a = bh(), l = Gc.only(n), u = hh(l) ? ya(l, {
    focusable: "false",
    "aria-hidden": !0,
    className: et("chakra-menu__icon", l.props.className)
  }) : null, f = et("chakra-menu__icon-wrapper", t);
  return /* @__PURE__ */ M(De.span, { className: f, ...o, __css: a.icon, children: u });
};
lT.displayName = "MenuIcon";
var yj = Le((e, t) => {
  const {
    icon: n,
    iconSpacing: o = "0.75rem",
    command: a,
    commandSpacing: l = "0.75rem",
    children: u,
    ...f
  } = e, h = mj(f, t), g = n || a ? /* @__PURE__ */ M("span", { style: { pointerEvents: "none", flex: 1 }, children: u }) : u;
  return /* @__PURE__ */ Nt(
    gj,
    {
      ...h,
      className: et("chakra-menu__menuitem", h.className),
      children: [
        n && /* @__PURE__ */ M(lT, { fontSize: "0.8em", marginEnd: o, children: n }),
        g,
        a && /* @__PURE__ */ M(vj, { marginStart: l, children: a })
      ]
    }
  );
});
yj.displayName = "MenuItem";
var cve = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
}, dve = De(ti.div), bj = Le(function(t, n) {
  var o, a;
  const { rootProps: l, motionProps: u, ...f } = t, {
    isOpen: h,
    onTransitionEnd: v,
    unstable__animationState: g
  } = xS(), b = rve(f, n), S = ove(l), w = bh();
  return /* @__PURE__ */ M(
    De.div,
    {
      ...S,
      __css: { zIndex: (a = t.zIndex) != null ? a : (o = w.list) == null ? void 0 : o.zIndex },
      children: /* @__PURE__ */ M(
        dve,
        {
          variants: cve,
          initial: !1,
          animate: h ? "enter" : "exit",
          __css: { outline: 0, ...w.list },
          ...u,
          className: et("chakra-menu__menu-list", b.className),
          ...b,
          onUpdate: v,
          onAnimationComplete: zE(
            g.onComplete,
            b.onAnimationComplete
          )
        }
      )
    }
  );
});
bj.displayName = "MenuList";
var Sj = Le((e, t) => {
  const { title: n, children: o, className: a, ...l } = e, u = et("chakra-menu__group__title", a), f = bh();
  return /* @__PURE__ */ Nt("div", { ref: t, className: "chakra-menu__group", role: "group", children: [
    n && /* @__PURE__ */ M(De.p, { className: u, ...l, __css: f.groupTitle, children: n }),
    o
  ] });
});
Sj.displayName = "MenuGroup";
var fve = (e) => {
  const { className: t, title: n, ...o } = e, a = ave(o);
  return /* @__PURE__ */ M(
    Sj,
    {
      title: n,
      className: et("chakra-menu__option-group", t),
      ...a
    }
  );
};
fve.displayName = "MenuOptionGroup";
var pve = Le((e, t) => {
  const n = bh();
  return /* @__PURE__ */ M(
    De.button,
    {
      ref: t,
      ...e,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...n.button
      }
    }
  );
}), xj = Le(
  (e, t) => {
    const { children: n, as: o, ...a } = e, l = nve(a, t);
    return /* @__PURE__ */ M(
      o || pve,
      {
        ...l,
        className: et("chakra-menu__menu-button", e.className),
        children: /* @__PURE__ */ M(
          De.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: e.children
          }
        )
      }
    );
  }
);
xj.displayName = "MenuButton";
var hve = (e) => {
  const { className: t, ...n } = e, o = bh();
  return /* @__PURE__ */ M(
    De.hr,
    {
      "aria-orientation": "horizontal",
      className: et("chakra-menu__divider", t),
      ...n,
      __css: o.divider
    }
  );
};
hve.displayName = "MenuDivider";
var mve = (e) => /* @__PURE__ */ M("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", ...e, children: /* @__PURE__ */ M(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) }), Cj = Le(
  (e, t) => {
    const { icon: n, iconSpacing: o = "0.75rem", ...a } = e, l = ive(a, t);
    return /* @__PURE__ */ Nt(
      gj,
      {
        ...l,
        className: et("chakra-menu__menuitem-option", a.className),
        children: [
          n !== null && /* @__PURE__ */ M(
            lT,
            {
              fontSize: "0.8em",
              marginEnd: o,
              opacity: e.isChecked ? 1 : 0,
              children: n || /* @__PURE__ */ M(mve, {})
            }
          ),
          /* @__PURE__ */ M("span", { style: { flex: 1 }, children: l.children })
        ]
      }
    );
  }
);
Cj.id = "MenuItemOption";
Cj.displayName = "MenuItemOption";
var vve = {
  slideInBottom: {
    ...f0,
    custom: { offsetY: 16, reverse: !0 }
  },
  slideInRight: {
    ...f0,
    custom: { offsetX: 16, reverse: !0 }
  },
  slideInTop: {
    ...f0,
    custom: { offsetY: -16, reverse: !0 }
  },
  slideInLeft: {
    ...f0,
    custom: { offsetX: -16, reverse: !0 }
  },
  scale: {
    ...X9,
    custom: { initialScale: 0.95, reverse: !0 }
  },
  none: {}
}, gve = De(ti.section), yve = (e) => vve[e || "none"], wj = fr(
  (e, t) => {
    const { preset: n, motionProps: o = yve(n), ...a } = e;
    return /* @__PURE__ */ M(gve, { ref: t, ...o, ...a });
  }
);
wj.displayName = "ModalTransition";
var bve = Object.defineProperty, Sve = (e, t, n) => t in e ? bve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, xve = (e, t, n) => (Sve(e, typeof t != "symbol" ? t + "" : t, n), n), Cve = class {
  constructor() {
    xve(this, "modals"), this.modals = /* @__PURE__ */ new Map();
  }
  add(e) {
    return this.modals.set(e, this.modals.size + 1), this.modals.size;
  }
  remove(e) {
    this.modals.delete(e);
  }
  isTopModal(e) {
    return e ? this.modals.get(e) === this.modals.size : !1;
  }
}, PO = new Cve();
function Ej(e, t) {
  const [n, o] = ot(0);
  return dt(() => {
    const a = e.current;
    if (a) {
      if (t) {
        const l = PO.add(a);
        o(l);
      }
      return () => {
        PO.remove(a), o(0);
      };
    }
  }, [t, e]), n;
}
var wve = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Cv = /* @__PURE__ */ new WeakMap(), MC = /* @__PURE__ */ new WeakMap(), LC = {}, rP = 0, Tj = function(e) {
  return e && (e.host || Tj(e.parentNode));
}, Eve = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var o = Tj(n);
    return o && e.contains(o) ? o : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, Tve = function(e, t, n, o) {
  var a = Eve(t, Array.isArray(e) ? e : [e]);
  LC[n] || (LC[n] = /* @__PURE__ */ new WeakMap());
  var l = LC[n], u = [], f = /* @__PURE__ */ new Set(), h = new Set(a), v = function(b) {
    !b || f.has(b) || (f.add(b), v(b.parentNode));
  };
  a.forEach(v);
  var g = function(b) {
    !b || h.has(b) || Array.prototype.forEach.call(b.children, function(S) {
      if (f.has(S))
        g(S);
      else {
        var w = S.getAttribute(o), E = w !== null && w !== "false", T = (Cv.get(S) || 0) + 1, A = (l.get(S) || 0) + 1;
        Cv.set(S, T), l.set(S, A), u.push(S), T === 1 && E && MC.set(S, !0), A === 1 && S.setAttribute(n, "true"), E || S.setAttribute(o, "true");
      }
    });
  };
  return g(t), f.clear(), rP++, function() {
    u.forEach(function(b) {
      var S = Cv.get(b) - 1, w = l.get(b) - 1;
      Cv.set(b, S), l.set(b, w), S || (MC.has(b) || b.removeAttribute(o), MC.delete(b)), w || b.removeAttribute(n);
    }), rP--, rP || (Cv = /* @__PURE__ */ new WeakMap(), Cv = /* @__PURE__ */ new WeakMap(), MC = /* @__PURE__ */ new WeakMap(), LC = {});
  };
}, Ive = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var o = Array.from(Array.isArray(e) ? e : [e]), a = t || wve(e);
  return a ? (o.push.apply(o, Array.from(a.querySelectorAll("[aria-live]"))), Tve(o, a, n, "aria-hidden")) : function() {
    return null;
  };
};
function Ave(e) {
  const {
    isOpen: t,
    onClose: n,
    id: o,
    closeOnOverlayClick: a = !0,
    closeOnEsc: l = !0,
    useInert: u = !0,
    onOverlayClick: f,
    onEsc: h
  } = e, v = Ue(null), g = Ue(null), [b, S, w] = Rve(
    o,
    "chakra-modal",
    "chakra-modal--header",
    "chakra-modal--body"
  );
  kve(v, t && u);
  const E = Ej(v, t), T = Ue(null), A = re((W) => {
    T.current = W.target;
  }, []), P = re(
    (W) => {
      W.key === "Escape" && (W.stopPropagation(), l && (n == null || n()), h == null || h());
    },
    [l, n, h]
  ), [_, D] = ot(!1), [L, F] = ot(!1), V = re(
    (W = {}, H = null) => ({
      role: "dialog",
      ...W,
      ref: Cn(H, v),
      id: b,
      tabIndex: -1,
      "aria-modal": !0,
      "aria-labelledby": _ ? S : void 0,
      "aria-describedby": L ? w : void 0,
      onClick: st(
        W.onClick,
        (G) => G.stopPropagation()
      )
    }),
    [w, L, b, S, _]
  ), $ = re(
    (W) => {
      W.stopPropagation(), T.current === W.target && PO.isTopModal(v.current) && (a && (n == null || n()), f == null || f());
    },
    [n, a, f]
  ), U = re(
    (W = {}, H = null) => ({
      ...W,
      ref: Cn(H, g),
      onClick: st(W.onClick, $),
      onKeyDown: st(W.onKeyDown, P),
      onMouseDown: st(W.onMouseDown, A)
    }),
    [P, A, $]
  );
  return {
    isOpen: t,
    onClose: n,
    headerId: S,
    bodyId: w,
    setBodyMounted: F,
    setHeaderMounted: D,
    dialogRef: v,
    overlayRef: g,
    getDialogProps: V,
    getDialogContainerProps: U,
    index: E
  };
}
function kve(e, t) {
  const n = e.current;
  dt(() => {
    if (!(!e.current || !t))
      return Ive(e.current);
  }, [t, e, n]);
}
function Rve(e, ...t) {
  const n = ko(), o = e || n;
  return gt(() => t.map((a) => `${a}-${o}`), [o, t]);
}
var [Pve, Tg] = En({
  name: "ModalStylesContext",
  errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
}), [Ove, ch] = En({
  strict: !0,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
}), Ij = (e) => {
  const t = {
    scrollBehavior: "outside",
    autoFocus: !0,
    trapFocus: !0,
    returnFocusOnClose: !0,
    blockScrollOnMount: !0,
    allowPinchZoom: !1,
    motionPreset: "scale",
    lockFocusAcrossFrames: !0,
    ...e
  }, {
    portalProps: n,
    children: o,
    autoFocus: a,
    trapFocus: l,
    initialFocusRef: u,
    finalFocusRef: f,
    returnFocusOnClose: h,
    blockScrollOnMount: v,
    allowPinchZoom: g,
    preserveScrollBarGap: b,
    motionPreset: S,
    lockFocusAcrossFrames: w,
    onCloseComplete: E
  } = t, T = Xn("Modal", t), P = {
    ...Ave(t),
    autoFocus: a,
    trapFocus: l,
    initialFocusRef: u,
    finalFocusRef: f,
    returnFocusOnClose: h,
    blockScrollOnMount: v,
    allowPinchZoom: g,
    preserveScrollBarGap: b,
    motionPreset: S,
    lockFocusAcrossFrames: w
  };
  return /* @__PURE__ */ M(Ove, { value: P, children: /* @__PURE__ */ M(Pve, { value: T, children: /* @__PURE__ */ M(Cu, { onExitComplete: E, children: P.isOpen && /* @__PURE__ */ M(wf, { ...n, children: o }) }) }) });
};
Ij.displayName = "Modal";
var mw = "right-scroll-bar-position", vw = "width-before-scroll-bar", _ve = "with-scroll-bars-hidden", Dve = "--removed-body-scroll-bar-size", Aj = mH(), oP = function() {
}, uT = Fe.forwardRef(function(e, t) {
  var n = Fe.useRef(null), o = Fe.useState({
    onScrollCapture: oP,
    onWheelCapture: oP,
    onTouchMoveCapture: oP
  }), a = o[0], l = o[1], u = e.forwardProps, f = e.children, h = e.className, v = e.removeScrollBar, g = e.enabled, b = e.shards, S = e.sideCar, w = e.noIsolation, E = e.inert, T = e.allowPinchZoom, A = e.as, P = A === void 0 ? "div" : A, _ = e.gapMode, D = fH(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), L = S, F = dH([n, t]), V = cu(cu({}, D), a);
  return Fe.createElement(
    Fe.Fragment,
    null,
    g && Fe.createElement(L, { sideCar: Aj, removeScrollBar: v, shards: b, noIsolation: w, inert: E, setCallbacks: l, allowPinchZoom: !!T, lockRef: n, gapMode: _ }),
    u ? Fe.cloneElement(Fe.Children.only(f), cu(cu({}, V), { ref: F })) : Fe.createElement(P, cu({}, V, { className: h, ref: F }), f)
  );
});
uT.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
uT.classNames = {
  fullWidth: vw,
  zeroRight: mw
};
var Nve = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Mve() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Nve();
  return t && e.setAttribute("nonce", t), e;
}
function Lve(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Fve(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Bve = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Mve()) && (Lve(t, n), Fve(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Vve = function() {
  var e = Bve();
  return function(t, n) {
    Fe.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, kj = function() {
  var e = Vve(), t = function(n) {
    var o = n.styles, a = n.dynamic;
    return e(o, a), null;
  };
  return t;
}, $ve = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, iP = function(e) {
  return parseInt(e || "", 10) || 0;
}, zve = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], o = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [iP(n), iP(o), iP(a)];
}, Hve = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return $ve;
  var t = zve(e), n = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, o - n + t[2] - t[0])
  };
}, jve = kj(), Gve = function(e, t, n, o) {
  var a = e.left, l = e.top, u = e.right, f = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(_ve, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(f, "px ").concat(o, `;
  }
  body {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(o, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(l, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(o, `;
    `),
    n === "padding" && "padding-right: ".concat(f, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(mw, ` {
    right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(vw, ` {
    margin-right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(mw, " .").concat(mw, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(vw, " .").concat(vw, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body {
    `).concat(Dve, ": ").concat(f, `px;
  }
`);
}, Wve = function(e) {
  var t = e.noRelative, n = e.noImportant, o = e.gapMode, a = o === void 0 ? "margin" : o, l = Fe.useMemo(function() {
    return Hve(a);
  }, [a]);
  return Fe.createElement(jve, { styles: Gve(l, !t, a, n ? "" : "!important") });
}, OO = !1;
if (typeof window < "u")
  try {
    var FC = Object.defineProperty({}, "passive", {
      get: function() {
        return OO = !0, !0;
      }
    });
    window.addEventListener("test", FC, FC), window.removeEventListener("test", FC, FC);
  } catch {
    OO = !1;
  }
var wv = OO ? { passive: !1 } : !1, Uve = function(e) {
  return e.tagName === "TEXTAREA";
}, Rj = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Uve(e) && n[t] === "visible")
  );
}, Xve = function(e) {
  return Rj(e, "overflowY");
}, Zve = function(e) {
  return Rj(e, "overflowX");
}, L$ = function(e, t) {
  var n = t.ownerDocument, o = t;
  do {
    typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host);
    var a = Pj(e, o);
    if (a) {
      var l = Oj(e, o), u = l[1], f = l[2];
      if (u > f)
        return !0;
    }
    o = o.parentNode;
  } while (o && o !== n.body);
  return !1;
}, Yve = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, o = e.clientHeight;
  return [
    t,
    n,
    o
  ];
}, Jve = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, o = e.clientWidth;
  return [
    t,
    n,
    o
  ];
}, Pj = function(e, t) {
  return e === "v" ? Xve(t) : Zve(t);
}, Oj = function(e, t) {
  return e === "v" ? Yve(t) : Jve(t);
}, Qve = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Kve = function(e, t, n, o, a) {
  var l = Qve(e, window.getComputedStyle(t).direction), u = l * o, f = n.target, h = t.contains(f), v = !1, g = u > 0, b = 0, S = 0;
  do {
    var w = Oj(e, f), E = w[0], T = w[1], A = w[2], P = T - A - l * E;
    (E || P) && Pj(e, f) && (b += P, S += E), f instanceof ShadowRoot ? f = f.host : f = f.parentNode;
  } while (
    // portaled content
    !h && f !== document.body || // self content
    h && (t.contains(f) || t === f)
  );
  return (g && (a && Math.abs(b) < 1 || !a && u > b) || !g && (a && Math.abs(S) < 1 || !a && -u > S)) && (v = !0), v;
}, BC = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, F$ = function(e) {
  return [e.deltaX, e.deltaY];
}, B$ = function(e) {
  return e && "current" in e ? e.current : e;
}, qve = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, ege = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, tge = 0, Ev = [];
function nge(e) {
  var t = Fe.useRef([]), n = Fe.useRef([0, 0]), o = Fe.useRef(), a = Fe.useState(tge++)[0], l = Fe.useState(kj)[0], u = Fe.useRef(e);
  Fe.useEffect(function() {
    u.current = e;
  }, [e]), Fe.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var T = Mfe([e.lockRef.current], (e.shards || []).map(B$), !0).filter(Boolean);
      return T.forEach(function(A) {
        return A.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), T.forEach(function(A) {
          return A.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var f = Fe.useCallback(function(T, A) {
    if ("touches" in T && T.touches.length === 2)
      return !u.current.allowPinchZoom;
    var P = BC(T), _ = n.current, D = "deltaX" in T ? T.deltaX : _[0] - P[0], L = "deltaY" in T ? T.deltaY : _[1] - P[1], F, V = T.target, $ = Math.abs(D) > Math.abs(L) ? "h" : "v";
    if ("touches" in T && $ === "h" && V.type === "range")
      return !1;
    var U = L$($, V);
    if (!U)
      return !0;
    if (U ? F = $ : (F = $ === "v" ? "h" : "v", U = L$($, V)), !U)
      return !1;
    if (!o.current && "changedTouches" in T && (D || L) && (o.current = F), !F)
      return !0;
    var W = o.current || F;
    return Kve(W, A, T, W === "h" ? D : L, !0);
  }, []), h = Fe.useCallback(function(T) {
    var A = T;
    if (!(!Ev.length || Ev[Ev.length - 1] !== l)) {
      var P = "deltaY" in A ? F$(A) : BC(A), _ = t.current.filter(function(F) {
        return F.name === A.type && (F.target === A.target || A.target === F.shadowParent) && qve(F.delta, P);
      })[0];
      if (_ && _.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!_) {
        var D = (u.current.shards || []).map(B$).filter(Boolean).filter(function(F) {
          return F.contains(A.target);
        }), L = D.length > 0 ? f(A, D[0]) : !u.current.noIsolation;
        L && A.cancelable && A.preventDefault();
      }
    }
  }, []), v = Fe.useCallback(function(T, A, P, _) {
    var D = { name: T, delta: A, target: P, should: _, shadowParent: rge(P) };
    t.current.push(D), setTimeout(function() {
      t.current = t.current.filter(function(L) {
        return L !== D;
      });
    }, 1);
  }, []), g = Fe.useCallback(function(T) {
    n.current = BC(T), o.current = void 0;
  }, []), b = Fe.useCallback(function(T) {
    v(T.type, F$(T), T.target, f(T, e.lockRef.current));
  }, []), S = Fe.useCallback(function(T) {
    v(T.type, BC(T), T.target, f(T, e.lockRef.current));
  }, []);
  Fe.useEffect(function() {
    return Ev.push(l), e.setCallbacks({
      onScrollCapture: b,
      onWheelCapture: b,
      onTouchMoveCapture: S
    }), document.addEventListener("wheel", h, wv), document.addEventListener("touchmove", h, wv), document.addEventListener("touchstart", g, wv), function() {
      Ev = Ev.filter(function(T) {
        return T !== l;
      }), document.removeEventListener("wheel", h, wv), document.removeEventListener("touchmove", h, wv), document.removeEventListener("touchstart", g, wv);
    };
  }, []);
  var w = e.removeScrollBar, E = e.inert;
  return Fe.createElement(
    Fe.Fragment,
    null,
    E ? Fe.createElement(l, { styles: ege(a) }) : null,
    w ? Fe.createElement(Wve, { gapMode: e.gapMode }) : null
  );
}
function rge(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const oge = Lfe(Aj, nge);
var _j = Fe.forwardRef(function(e, t) {
  return Fe.createElement(uT, cu({}, e, { ref: t, sideCar: oge }));
});
_j.classNames = uT.classNames;
const ige = _j;
function age(e) {
  const {
    autoFocus: t,
    trapFocus: n,
    dialogRef: o,
    initialFocusRef: a,
    blockScrollOnMount: l,
    allowPinchZoom: u,
    finalFocusRef: f,
    returnFocusOnClose: h,
    preserveScrollBarGap: v,
    lockFocusAcrossFrames: g,
    isOpen: b
  } = ch(), [S, w] = y9();
  dt(() => {
    !S && w && setTimeout(w);
  }, [S, w]);
  const E = Ej(o, b);
  return /* @__PURE__ */ M(
    UH,
    {
      autoFocus: t,
      isDisabled: !n,
      initialFocusRef: a,
      finalFocusRef: f,
      restoreFocus: h,
      contentRef: o,
      lockFocusAcrossFrames: g,
      children: /* @__PURE__ */ M(
        ige,
        {
          removeScrollBar: !v,
          allowPinchZoom: u,
          enabled: E === 1 && l,
          forwardProps: !0,
          children: e.children
        }
      )
    }
  );
}
var Dj = Le(
  (e, t) => {
    const {
      className: n,
      children: o,
      containerProps: a,
      motionProps: l,
      ...u
    } = e, { getDialogProps: f, getDialogContainerProps: h } = ch(), v = f(u, t), g = h(a), b = et("chakra-modal__content", n), S = Tg(), w = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...S.dialog
    }, E = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...S.dialogContainer
    }, { motionPreset: T } = ch();
    return /* @__PURE__ */ M(age, { children: /* @__PURE__ */ M(
      De.div,
      {
        ...g,
        className: "chakra-modal__content-container",
        tabIndex: -1,
        __css: E,
        children: /* @__PURE__ */ M(
          wj,
          {
            preset: T,
            motionProps: l,
            className: b,
            ...v,
            __css: w,
            children: o
          }
        )
      }
    ) });
  }
);
Dj.displayName = "ModalContent";
function sge(e) {
  const { leastDestructiveRef: t, ...n } = e;
  return /* @__PURE__ */ M(Ij, { ...n, initialFocusRef: t });
}
var lge = Le(
  (e, t) => /* @__PURE__ */ M(Dj, { ref: t, role: "alertdialog", ...e })
), Nj = Le(
  (e, t) => {
    const { className: n, ...o } = e, a = et("chakra-modal__footer", n), u = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      ...Tg().footer
    };
    return /* @__PURE__ */ M(
      De.footer,
      {
        ref: t,
        ...o,
        __css: u,
        className: a
      }
    );
  }
);
Nj.displayName = "ModalFooter";
var Mj = Le(
  (e, t) => {
    const { className: n, ...o } = e, { headerId: a, setHeaderMounted: l } = ch();
    dt(() => (l(!0), () => l(!1)), [l]);
    const u = et("chakra-modal__header", n), h = {
      flex: 0,
      ...Tg().header
    };
    return /* @__PURE__ */ M(
      De.header,
      {
        ref: t,
        className: u,
        id: a,
        ...o,
        __css: h
      }
    );
  }
);
Mj.displayName = "ModalHeader";
var uge = De(ti.div), Lj = Le(
  (e, t) => {
    const { className: n, transition: o, motionProps: a, ...l } = e, u = et("chakra-modal__overlay", n), h = {
      pos: "fixed",
      left: "0",
      top: "0",
      w: "100vw",
      h: "100vh",
      ...Tg().overlay
    }, { motionPreset: v } = ch();
    return /* @__PURE__ */ M(
      uge,
      {
        ...a || (v === "none" ? {} : U9),
        __css: h,
        ref: t,
        className: u,
        ...l
      }
    );
  }
);
Lj.displayName = "ModalOverlay";
var Fj = Le((e, t) => {
  const { className: n, ...o } = e, { bodyId: a, setBodyMounted: l } = ch();
  dt(() => (l(!0), () => l(!1)), [l]);
  const u = et("chakra-modal__body", n), f = Tg();
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: t,
      className: u,
      id: a,
      ...o,
      __css: f.body
    }
  );
});
Fj.displayName = "ModalBody";
var cge = Le(
  (e, t) => {
    const { onClick: n, className: o, ...a } = e, { onClose: l } = ch(), u = et("chakra-modal__close-btn", o), f = Tg();
    return /* @__PURE__ */ M(
      tT,
      {
        ref: t,
        __css: f.closeButton,
        className: u,
        onClick: st(n, (h) => {
          h.stopPropagation(), l();
        }),
        ...a
      }
    );
  }
);
cge.displayName = "ModalCloseButton";
var dge = (e) => /* @__PURE__ */ M(ho, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
  "path",
  {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  }
) }), fge = (e) => /* @__PURE__ */ M(ho, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
  "path",
  {
    fill: "currentColor",
    d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
  }
) });
function V$(e, t, n, o) {
  dt(() => {
    var a;
    if (!e.current || !o)
      return;
    const l = (a = e.current.ownerDocument.defaultView) != null ? a : window, u = Array.isArray(t) ? t : [t], f = new l.MutationObserver((h) => {
      for (const v of h)
        v.type === "attributes" && v.attributeName && u.includes(v.attributeName) && n(v);
    });
    return f.observe(e.current, { attributes: !0, attributeFilter: u }), () => f.disconnect();
  });
}
function pge(e, t) {
  const n = Er(e);
  dt(() => {
    let o = null;
    const a = () => n();
    return t !== null && (o = window.setInterval(a, t)), () => {
      o && window.clearInterval(o);
    };
  }, [t, n]);
}
var hge = 50, $$ = 300;
function mge(e, t) {
  const [n, o] = ot(!1), [a, l] = ot(null), [u, f] = ot(!0), h = Ue(null), v = () => clearTimeout(h.current);
  pge(
    () => {
      a === "increment" && e(), a === "decrement" && t();
    },
    n ? hge : null
  );
  const g = re(() => {
    u && e(), h.current = setTimeout(() => {
      f(!1), o(!0), l("increment");
    }, $$);
  }, [e, u]), b = re(() => {
    u && t(), h.current = setTimeout(() => {
      f(!1), o(!0), l("decrement");
    }, $$);
  }, [t, u]), S = re(() => {
    f(!0), o(!1), v();
  }, []);
  return dt(() => () => v(), []), { up: g, down: b, stop: S, isSpinning: n };
}
var vge = /^[Ee0-9+\-.]$/;
function gge(e) {
  return vge.test(e);
}
function yge(e, t) {
  if (e.key == null)
    return !0;
  const n = e.ctrlKey || e.altKey || e.metaKey;
  return !(e.key.length === 1) || n ? !0 : t(e.key);
}
function bge(e = {}) {
  const {
    focusInputOnChange: t = !0,
    clampValueOnBlur: n = !0,
    keepWithinRange: o = !0,
    min: a = Number.MIN_SAFE_INTEGER,
    max: l = Number.MAX_SAFE_INTEGER,
    step: u = 1,
    isReadOnly: f,
    isDisabled: h,
    isRequired: v,
    isInvalid: g,
    pattern: b = "[0-9]*(.[0-9]+)?",
    inputMode: S = "decimal",
    allowMouseWheel: w,
    id: E,
    onChange: T,
    precision: A,
    name: P,
    "aria-describedby": _,
    "aria-label": D,
    "aria-labelledby": L,
    onFocus: F,
    onBlur: V,
    onInvalid: $,
    getAriaValueText: U,
    isValidCharacter: W,
    format: H,
    parse: G,
    ...oe
  } = e, ce = Er(F), te = Er(V), Ee = Er($), me = Er(
    W ?? gge
  ), J = Er(U), Q = dfe(e), {
    update: ge,
    increment: Y,
    decrement: q
  } = Q, [de, K] = ot(!1), ne = !(f || h), pe = Ue(null), Oe = Ue(null), Ce = Ue(null), xe = Ue(null), ie = re(
    (je) => je.split("").filter(me).join(""),
    [me]
  ), ye = re(
    (je) => {
      var Ot;
      return (Ot = G == null ? void 0 : G(je)) != null ? Ot : je;
    },
    [G]
  ), we = re(
    (je) => {
      var Ot;
      return ((Ot = H == null ? void 0 : H(je)) != null ? Ot : je).toString();
    },
    [H]
  );
  xl(() => {
    (Q.valueAsNumber > l || Q.valueAsNumber < a) && (Ee == null || Ee("rangeOverflow", we(Q.value), Q.valueAsNumber));
  }, [Q.valueAsNumber, Q.value, we, Ee]), Ss(() => {
    if (!pe.current)
      return;
    if (pe.current.value != Q.value) {
      const Ot = ye(pe.current.value);
      Q.setValue(ie(Ot));
    }
  }, [ye, ie]);
  const fe = re(
    (je = u) => {
      ne && Y(je);
    },
    [Y, ne, u]
  ), ze = re(
    (je = u) => {
      ne && q(je);
    },
    [q, ne, u]
  ), Ve = mge(fe, ze);
  V$(
    Ce,
    "disabled",
    Ve.stop,
    Ve.isSpinning
  ), V$(
    xe,
    "disabled",
    Ve.stop,
    Ve.isSpinning
  );
  const Ie = re(
    (je) => {
      if (je.nativeEvent.isComposing)
        return;
      const an = ye(je.currentTarget.value);
      ge(ie(an)), Oe.current = {
        start: je.currentTarget.selectionStart,
        end: je.currentTarget.selectionEnd
      };
    },
    [ge, ie, ye]
  ), qe = re(
    (je) => {
      var Ot, an, Xe;
      ce == null || ce(je), Oe.current && (je.target.selectionStart = (an = Oe.current.start) != null ? an : (Ot = je.currentTarget.value) == null ? void 0 : Ot.length, je.currentTarget.selectionEnd = (Xe = Oe.current.end) != null ? Xe : je.currentTarget.selectionStart);
    },
    [ce]
  ), Qe = re(
    (je) => {
      if (je.nativeEvent.isComposing)
        return;
      yge(je, me) || je.preventDefault();
      const Ot = lt(je) * u, an = je.key, _e = {
        ArrowUp: () => fe(Ot),
        ArrowDown: () => ze(Ot),
        Home: () => ge(a),
        End: () => ge(l)
      }[an];
      _e && (je.preventDefault(), _e(je));
    },
    [me, u, fe, ze, ge, a, l]
  ), lt = (je) => {
    let Ot = 1;
    return (je.metaKey || je.ctrlKey) && (Ot = 0.1), je.shiftKey && (Ot = 10), Ot;
  }, tn = gt(() => {
    const je = J == null ? void 0 : J(Q.value);
    if (je != null)
      return je;
    const Ot = Q.value.toString();
    return Ot || void 0;
  }, [Q.value, J]), Yt = re(() => {
    let je = Q.value;
    if (Q.value === "")
      return;
    /^[eE]/.test(Q.value.toString()) ? Q.setValue("") : (Q.valueAsNumber < a && (je = a), Q.valueAsNumber > l && (je = l), Q.cast(je));
  }, [Q, l, a]), hn = re(() => {
    K(!1), n && Yt();
  }, [n, K, Yt]), vn = re(() => {
    t && requestAnimationFrame(() => {
      var je;
      (je = pe.current) == null || je.focus();
    });
  }, [t]), nn = re(
    (je) => {
      je.preventDefault(), Ve.up(), vn();
    },
    [vn, Ve]
  ), rn = re(
    (je) => {
      je.preventDefault(), Ve.down(), vn();
    },
    [vn, Ve]
  );
  nh(
    () => pe.current,
    "wheel",
    (je) => {
      var Ot, an;
      const _e = ((an = (Ot = pe.current) == null ? void 0 : Ot.ownerDocument) != null ? an : document).activeElement === pe.current;
      if (!w || !_e)
        return;
      je.preventDefault();
      const Je = lt(je) * u, Kt = Math.sign(je.deltaY);
      Kt === -1 ? fe(Je) : Kt === 1 && ze(Je);
    },
    { passive: !1 }
  );
  const mn = re(
    (je = {}, Ot = null) => {
      const an = h || o && Q.isAtMax;
      return {
        ...je,
        ref: Cn(Ot, Ce),
        role: "button",
        tabIndex: -1,
        onPointerDown: st(je.onPointerDown, (Xe) => {
          Xe.button !== 0 || an || nn(Xe);
        }),
        onPointerLeave: st(je.onPointerLeave, Ve.stop),
        onPointerUp: st(je.onPointerUp, Ve.stop),
        disabled: an,
        "aria-disabled": xs(an)
      };
    },
    [Q.isAtMax, o, nn, Ve.stop, h]
  ), un = re(
    (je = {}, Ot = null) => {
      const an = h || o && Q.isAtMin;
      return {
        ...je,
        ref: Cn(Ot, xe),
        role: "button",
        tabIndex: -1,
        onPointerDown: st(je.onPointerDown, (Xe) => {
          Xe.button !== 0 || an || rn(Xe);
        }),
        onPointerLeave: st(je.onPointerLeave, Ve.stop),
        onPointerUp: st(je.onPointerUp, Ve.stop),
        disabled: an,
        "aria-disabled": xs(an)
      };
    },
    [Q.isAtMin, o, rn, Ve.stop, h]
  ), Tn = re(
    (je = {}, Ot = null) => {
      var an, Xe, _e, Je;
      return {
        name: P,
        inputMode: S,
        type: "text",
        pattern: b,
        "aria-labelledby": L,
        "aria-label": D,
        "aria-describedby": _,
        id: E,
        disabled: h,
        ...je,
        readOnly: (an = je.readOnly) != null ? an : f,
        "aria-readonly": (Xe = je.readOnly) != null ? Xe : f,
        "aria-required": (_e = je.required) != null ? _e : v,
        required: (Je = je.required) != null ? Je : v,
        ref: Cn(pe, Ot),
        value: we(Q.value),
        role: "spinbutton",
        "aria-valuemin": a,
        "aria-valuemax": l,
        "aria-valuenow": Number.isNaN(Q.valueAsNumber) ? void 0 : Q.valueAsNumber,
        "aria-invalid": xs(g ?? Q.isOutOfRange),
        "aria-valuetext": tn,
        autoComplete: "off",
        autoCorrect: "off",
        onChange: st(je.onChange, Ie),
        onKeyDown: st(je.onKeyDown, Qe),
        onFocus: st(
          je.onFocus,
          qe,
          () => K(!0)
        ),
        onBlur: st(je.onBlur, te, hn)
      };
    },
    [
      P,
      S,
      b,
      L,
      D,
      we,
      _,
      E,
      h,
      v,
      f,
      g,
      Q.value,
      Q.valueAsNumber,
      Q.isOutOfRange,
      a,
      l,
      tn,
      Ie,
      Qe,
      qe,
      te,
      hn
    ]
  );
  return {
    value: we(Q.value),
    valueAsNumber: Q.valueAsNumber,
    isFocused: de,
    isDisabled: h,
    isReadOnly: f,
    getIncrementButtonProps: mn,
    getDecrementButtonProps: un,
    getInputProps: Tn,
    htmlProps: oe
  };
}
var [Sge, cT] = En({
  name: "NumberInputStylesContext",
  errorMessage: `useNumberInputStyles returned is 'undefined'. Seems you forgot to wrap the components in "<NumberInput />" `
}), [xge, q2] = En({
  name: "NumberInputContext",
  errorMessage: "useNumberInputContext: `context` is undefined. Seems you forgot to wrap number-input's components within <NumberInput />"
}), Bj = Le(
  function(t, n) {
    const o = Xn("NumberInput", t), a = Pn(t), l = x2(a), { htmlProps: u, ...f } = bge(l), h = gt(() => f, [f]);
    return /* @__PURE__ */ M(xge, { value: h, children: /* @__PURE__ */ M(Sge, { value: o, children: /* @__PURE__ */ M(
      De.div,
      {
        ...u,
        ref: n,
        className: et("chakra-numberinput", t.className),
        __css: {
          position: "relative",
          zIndex: 0,
          ...o.root
        }
      }
    ) }) });
  }
);
Bj.displayName = "NumberInput";
var Vj = Le(
  function(t, n) {
    const o = cT();
    return /* @__PURE__ */ M(
      De.div,
      {
        "aria-hidden": !0,
        ref: n,
        ...t,
        __css: {
          display: "flex",
          flexDirection: "column",
          position: "absolute",
          top: "0",
          insetEnd: "0px",
          margin: "1px",
          height: "calc(100% - 2px)",
          zIndex: 1,
          ...o.stepperGroup
        }
      }
    );
  }
);
Vj.displayName = "NumberInputStepper";
var $j = Le(
  function(t, n) {
    const { getInputProps: o } = q2(), a = o(t, n), l = cT();
    return /* @__PURE__ */ M(
      De.input,
      {
        ...a,
        className: et("chakra-numberinput__field", t.className),
        __css: {
          width: "100%",
          ...l.field
        }
      }
    );
  }
);
$j.displayName = "NumberInputField";
var zj = De("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
}), Hj = Le(function(t, n) {
  var o;
  const a = cT(), { getDecrementButtonProps: l } = q2(), u = l(t, n);
  return /* @__PURE__ */ M(zj, { ...u, __css: a.stepper, children: (o = t.children) != null ? o : /* @__PURE__ */ M(dge, {}) });
});
Hj.displayName = "NumberDecrementStepper";
var jj = Le(function(t, n) {
  var o;
  const { getIncrementButtonProps: a } = q2(), l = a(t, n), u = cT();
  return /* @__PURE__ */ M(zj, { ...l, __css: u.stepper, children: (o = t.children) != null ? o : /* @__PURE__ */ M(fge, {}) });
});
jj.displayName = "NumberIncrementStepper";
var [Cge, If] = En({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
}), [wge, Ig] = En({
  name: "PopoverStylesContext",
  errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `
}), Ege = Le(
  function(t, n) {
    const { getHeaderProps: o } = If(), a = Ig();
    return /* @__PURE__ */ M(
      De.header,
      {
        ...o(t, n),
        className: et("chakra-popover__header", t.className),
        __css: a.header
      }
    );
  }
);
Ege.displayName = "PopoverHeader";
function Tge(e) {
  const t = Gc.only(e.children), { getTriggerProps: n } = If();
  return ya(t, n(t.props, t.ref));
}
Tge.displayName = "PopoverTrigger";
var Tv = {
  click: "click",
  hover: "hover"
};
function Ige(e = {}) {
  const {
    closeOnBlur: t = !0,
    closeOnEsc: n = !0,
    initialFocusRef: o,
    id: a,
    returnFocusOnClose: l = !0,
    autoFocus: u = !0,
    arrowSize: f,
    arrowShadowColor: h,
    trigger: v = Tv.click,
    openDelay: g = 200,
    closeDelay: b = 200,
    isLazy: S,
    lazyBehavior: w = "unmount",
    computePositionOnMount: E,
    ...T
  } = e, { isOpen: A, onClose: P, onOpen: _, onToggle: D } = J2(e), L = Ue(null), F = Ue(null), V = Ue(null), $ = Ue(!1), U = Ue(!1);
  A && (U.current = !0);
  const [W, H] = ot(!1), [G, oe] = ot(!1), ce = ko(), te = a ?? ce, [Ee, me, J, Q] = [
    "popover-trigger",
    "popover-content",
    "popover-header",
    "popover-body"
  ].map((Ie) => `${Ie}-${te}`), {
    referenceRef: ge,
    getArrowProps: Y,
    getPopperProps: q,
    getArrowInnerProps: de,
    forceUpdate: K
  } = Y2({
    ...T,
    enabled: A || !!E
  }), ne = pj({ isOpen: A, ref: V });
  aH({
    enabled: A,
    ref: F
  }), nj(V, {
    focusRef: F,
    visible: A,
    shouldFocus: l && v === Tv.click
  }), Ihe(V, {
    focusRef: o,
    visible: A,
    shouldFocus: u && v === Tv.click
  });
  const pe = Q2({
    wasSelected: U.current,
    enabled: S,
    mode: w,
    isSelected: ne.present
  }), Oe = re(
    (Ie = {}, qe = null) => {
      const Qe = {
        ...Ie,
        style: {
          ...Ie.style,
          transformOrigin: po.transformOrigin.varRef,
          [po.arrowSize.var]: f ? `${f}px` : void 0,
          [po.arrowShadowColor.var]: h
        },
        ref: Cn(V, qe),
        children: pe ? Ie.children : null,
        id: me,
        tabIndex: -1,
        role: "dialog",
        onKeyDown: st(Ie.onKeyDown, (lt) => {
          n && lt.key === "Escape" && P();
        }),
        onBlur: st(Ie.onBlur, (lt) => {
          const tn = z$(lt), Yt = aP(V.current, tn), hn = aP(F.current, tn);
          A && t && (!Yt && !hn) && P();
        }),
        "aria-labelledby": W ? J : void 0,
        "aria-describedby": G ? Q : void 0
      };
      return v === Tv.hover && (Qe.role = "tooltip", Qe.onMouseEnter = st(Ie.onMouseEnter, () => {
        $.current = !0;
      }), Qe.onMouseLeave = st(
        Ie.onMouseLeave,
        (lt) => {
          lt.nativeEvent.relatedTarget !== null && ($.current = !1, setTimeout(() => P(), b));
        }
      )), Qe;
    },
    [
      pe,
      me,
      W,
      J,
      G,
      Q,
      v,
      n,
      P,
      A,
      t,
      b,
      h,
      f
    ]
  ), Ce = re(
    (Ie = {}, qe = null) => q(
      {
        ...Ie,
        style: {
          visibility: A ? "visible" : "hidden",
          ...Ie.style
        }
      },
      qe
    ),
    [A, q]
  ), xe = re(
    (Ie, qe = null) => ({
      ...Ie,
      // If anchor is rendered, it is used as reference.
      ref: Cn(qe, L, ge)
    }),
    [L, ge]
  ), ie = Ue(), ye = Ue(), we = re(
    (Ie) => {
      L.current == null && ge(Ie);
    },
    [ge]
  ), fe = re(
    (Ie = {}, qe = null) => {
      const Qe = {
        ...Ie,
        ref: Cn(F, qe, we),
        id: Ee,
        "aria-haspopup": "dialog",
        "aria-expanded": A,
        "aria-controls": me
      };
      return v === Tv.click && (Qe.onClick = st(Ie.onClick, D)), v === Tv.hover && (Qe.onFocus = st(Ie.onFocus, () => {
        ie.current === void 0 && _();
      }), Qe.onBlur = st(Ie.onBlur, (lt) => {
        const tn = z$(lt), Yt = !aP(V.current, tn);
        A && t && Yt && P();
      }), Qe.onKeyDown = st(Ie.onKeyDown, (lt) => {
        lt.key === "Escape" && P();
      }), Qe.onMouseEnter = st(Ie.onMouseEnter, () => {
        $.current = !0, ie.current = window.setTimeout(() => _(), g);
      }), Qe.onMouseLeave = st(Ie.onMouseLeave, () => {
        $.current = !1, ie.current && (clearTimeout(ie.current), ie.current = void 0), ye.current = window.setTimeout(() => {
          $.current === !1 && P();
        }, b);
      })), Qe;
    },
    [
      Ee,
      A,
      me,
      v,
      we,
      D,
      _,
      t,
      P,
      g,
      b
    ]
  );
  dt(() => () => {
    ie.current && clearTimeout(ie.current), ye.current && clearTimeout(ye.current);
  }, []);
  const ze = re(
    (Ie = {}, qe = null) => ({
      ...Ie,
      id: J,
      ref: Cn(qe, (Qe) => {
        H(!!Qe);
      })
    }),
    [J]
  ), Ve = re(
    (Ie = {}, qe = null) => ({
      ...Ie,
      id: Q,
      ref: Cn(qe, (Qe) => {
        oe(!!Qe);
      })
    }),
    [Q]
  );
  return {
    forceUpdate: K,
    isOpen: A,
    onAnimationComplete: ne.onComplete,
    onClose: P,
    getAnchorProps: xe,
    getArrowProps: Y,
    getArrowInnerProps: de,
    getPopoverPositionerProps: Ce,
    getPopoverProps: Oe,
    getTriggerProps: fe,
    getHeaderProps: ze,
    getBodyProps: Ve
  };
}
function aP(e, t) {
  return e === t || (e == null ? void 0 : e.contains(t));
}
function z$(e) {
  var t;
  const n = e.currentTarget.ownerDocument.activeElement;
  return (t = e.relatedTarget) != null ? t : n;
}
function Age(e) {
  const t = Xn("Popover", e), { children: n, ...o } = Pn(e), a = wl(), l = Ige({ ...o, direction: a.direction });
  return /* @__PURE__ */ M(Cge, { value: l, children: /* @__PURE__ */ M(wge, { value: t, children: Ha(n, {
    isOpen: l.isOpen,
    onClose: l.onClose,
    forceUpdate: l.forceUpdate
  }) }) });
}
Age.displayName = "Popover";
function kge(e) {
  const t = Gc.only(e.children), { getAnchorProps: n } = If();
  return ya(t, n(t.props, t.ref));
}
kge.displayName = "PopoverAnchor";
var sP = (e, t) => t ? `${e}.${t}, ${t}` : void 0;
function Rge(e) {
  var t;
  const { bg: n, bgColor: o, backgroundColor: a, shadow: l, boxShadow: u, shadowColor: f } = e, { getArrowProps: h, getArrowInnerProps: v } = If(), g = Ig(), b = (t = n ?? o) != null ? t : a, S = l ?? u;
  return /* @__PURE__ */ M(
    De.div,
    {
      ...h(),
      className: "chakra-popover__arrow-positioner",
      children: /* @__PURE__ */ M(
        De.div,
        {
          className: et("chakra-popover__arrow", e.className),
          ...v(e),
          __css: {
            "--popper-arrow-shadow-color": sP("colors", f),
            "--popper-arrow-bg": sP("colors", b),
            "--popper-arrow-shadow": sP("shadows", S),
            ...g.arrow
          }
        }
      )
    }
  );
}
Rge.displayName = "PopoverArrow";
var Pge = Le(
  function(t, n) {
    const { getBodyProps: o } = If(), a = Ig();
    return /* @__PURE__ */ M(
      De.div,
      {
        ...o(t, n),
        className: et("chakra-popover__body", t.className),
        __css: a.body
      }
    );
  }
);
Pge.displayName = "PopoverBody";
var Oge = Le(
  function(t, n) {
    const { onClose: o } = If(), a = Ig();
    return /* @__PURE__ */ M(
      tT,
      {
        size: "sm",
        onClick: o,
        className: et("chakra-popover__close-btn", t.className),
        __css: a.closeButton,
        ref: n,
        ...t
      }
    );
  }
);
Oge.displayName = "PopoverCloseButton";
function _ge(e) {
  if (e)
    return {
      enter: {
        ...e.enter,
        visibility: "visible"
      },
      exit: {
        ...e.exit,
        transitionEnd: {
          visibility: "hidden"
        }
      }
    };
}
var Dge = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
}, Nge = De(ti.section), Gj = Le(function(t, n) {
  const { variants: o = Dge, ...a } = t, { isOpen: l } = If();
  return /* @__PURE__ */ M(
    Nge,
    {
      ref: n,
      variants: _ge(o),
      initial: !1,
      animate: l ? "enter" : "exit",
      ...a
    }
  );
});
Gj.displayName = "PopoverTransition";
var Mge = Le(
  function(t, n) {
    const { rootProps: o, motionProps: a, ...l } = t, { getPopoverProps: u, getPopoverPositionerProps: f, onAnimationComplete: h } = If(), v = Ig(), g = {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      ...v.content
    };
    return /* @__PURE__ */ M(
      De.div,
      {
        ...f(o),
        __css: v.popper,
        className: "chakra-popover__popper",
        children: /* @__PURE__ */ M(
          Gj,
          {
            ...a,
            ...u(l, n),
            onAnimationComplete: zE(
              h,
              l.onAnimationComplete
            ),
            className: et("chakra-popover__content", t.className),
            __css: g
          }
        )
      }
    );
  }
);
Mge.displayName = "PopoverContent";
function Lge(e) {
  const t = Ig();
  return /* @__PURE__ */ M(
    De.footer,
    {
      ...e,
      className: et("chakra-popover__footer", e.className),
      __css: t.footer
    }
  );
}
Lge.displayName = "PopoverFooter";
var _O = (e) => /* @__PURE__ */ M(De.circle, { cx: 50, cy: 50, r: 42, fill: "transparent", ...e });
_O.displayName = "Circle";
function Fge(e, t, n) {
  return (e - t) * 100 / (n - t);
}
var Bge = Ps({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
}), Vge = Ps({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
}), $ge = Ps({
  "0%": { left: "-40%" },
  "100%": { left: "100%" }
}), zge = Ps({
  from: { backgroundPosition: "1rem 0" },
  to: { backgroundPosition: "0 0" }
});
function Wj(e) {
  const {
    value: t = 0,
    min: n,
    max: o,
    valueText: a,
    getValueText: l,
    isIndeterminate: u,
    role: f = "progressbar"
  } = e, h = Fge(t, n, o);
  return {
    bind: {
      "data-indeterminate": u ? "" : void 0,
      "aria-valuemax": o,
      "aria-valuemin": n,
      "aria-valuenow": u ? void 0 : t,
      "aria-valuetext": (() => {
        if (t != null)
          return typeof l == "function" ? l(t, h) : a;
      })(),
      role: f
    },
    percent: h,
    value: t
  };
}
var Uj = (e) => {
  const { size: t, isIndeterminate: n, ...o } = e;
  return /* @__PURE__ */ M(
    De.svg,
    {
      viewBox: "0 0 100 100",
      __css: {
        width: t,
        height: t,
        animation: n ? `${Vge} 2s linear infinite` : void 0
      },
      ...o
    }
  );
};
Uj.displayName = "Shape";
var Hge = Le(
  (e, t) => {
    var n;
    const {
      size: o = "48px",
      max: a = 100,
      min: l = 0,
      valueText: u,
      getValueText: f,
      value: h,
      capIsRound: v,
      children: g,
      thickness: b = "10px",
      color: S = "#0078d4",
      trackColor: w = "#edebe9",
      isIndeterminate: E,
      ...T
    } = e, A = Wj({
      min: l,
      max: a,
      value: h,
      valueText: u,
      getValueText: f,
      isIndeterminate: E
    }), P = E ? void 0 : ((n = A.percent) != null ? n : 0) * 2.64, _ = P == null ? void 0 : `${P} ${264 - P}`, D = E ? {
      css: { animation: `${Bge} 1.5s linear infinite` }
    } : {
      strokeDashoffset: 66,
      strokeDasharray: _,
      transitionProperty: "stroke-dasharray, stroke",
      transitionDuration: "0.6s",
      transitionTimingFunction: "ease"
    }, L = {
      display: "inline-block",
      position: "relative",
      verticalAlign: "middle",
      fontSize: o
    };
    return /* @__PURE__ */ Nt(
      De.div,
      {
        ref: t,
        className: "chakra-progress",
        ...A.bind,
        ...T,
        __css: L,
        children: [
          /* @__PURE__ */ Nt(Uj, { size: o, isIndeterminate: E, children: [
            /* @__PURE__ */ M(
              _O,
              {
                stroke: w,
                strokeWidth: b,
                className: "chakra-progress__track"
              }
            ),
            /* @__PURE__ */ M(
              _O,
              {
                stroke: S,
                strokeWidth: b,
                className: "chakra-progress__indicator",
                strokeLinecap: v ? "round" : void 0,
                opacity: A.value === 0 && !E ? 0 : void 0,
                ...D
              }
            )
          ] }),
          g
        ]
      }
    );
  }
);
Hge.displayName = "CircularProgress";
var [jge, Gge] = En({
  name: "ProgressStylesContext",
  errorMessage: `useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
}), Wge = Le(
  (e, t) => {
    const { min: n, max: o, value: a, isIndeterminate: l, role: u, ...f } = e, h = Wj({
      value: a,
      min: n,
      max: o,
      isIndeterminate: l,
      role: u
    }), g = {
      height: "100%",
      ...Gge().filledTrack
    };
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: t,
        style: { width: `${h.percent}%`, ...f.style },
        ...h.bind,
        ...f,
        __css: g
      }
    );
  }
), Uge = Le((e, t) => {
  var n;
  const {
    value: o,
    min: a = 0,
    max: l = 100,
    hasStripe: u,
    isAnimated: f,
    children: h,
    borderRadius: v,
    isIndeterminate: g,
    "aria-label": b,
    "aria-labelledby": S,
    "aria-valuetext": w,
    title: E,
    role: T,
    ...A
  } = Pn(e), P = Xn("Progress", e), _ = v ?? ((n = P.track) == null ? void 0 : n.borderRadius), D = { animation: `${zge} 1s linear infinite` }, V = {
    ...!g && u && f && D,
    ...g && {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: `${$ge} 1s ease infinite normal none running`
    }
  }, $ = {
    overflow: "hidden",
    position: "relative",
    ...P.track
  };
  return /* @__PURE__ */ M(
    De.div,
    {
      ref: t,
      borderRadius: _,
      __css: $,
      ...A,
      children: /* @__PURE__ */ Nt(jge, { value: P, children: [
        /* @__PURE__ */ M(
          Wge,
          {
            "aria-label": b,
            "aria-labelledby": S,
            "aria-valuetext": w,
            min: a,
            max: l,
            value: o,
            isIndeterminate: g,
            css: V,
            borderRadius: _,
            title: E,
            role: T
          }
        ),
        h
      ] })
    }
  );
});
Uge.displayName = "Progress";
function Xge(e) {
  return e && Ei(e) && Ei(e.target);
}
function Zge(e = {}) {
  const {
    onChange: t,
    value: n,
    defaultValue: o,
    name: a,
    isDisabled: l,
    isFocusable: u,
    isNative: f,
    ...h
  } = e, [v, g] = ot(o || ""), b = typeof n < "u", S = b ? n : v, w = Ue(null), E = re(() => {
    const F = w.current;
    if (!F)
      return;
    let V = "input:not(:disabled):checked";
    const $ = F.querySelector(
      V
    );
    if ($) {
      $.focus();
      return;
    }
    V = "input:not(:disabled)";
    const U = F.querySelector(V);
    U == null || U.focus();
  }, []), A = `radio-${ko()}`, P = a || A, _ = re(
    (F) => {
      const V = Xge(F) ? F.target.value : F;
      b || g(V), t == null || t(String(V));
    },
    [t, b]
  ), D = re(
    (F = {}, V = null) => ({
      ...F,
      ref: Cn(V, w),
      role: "radiogroup"
    }),
    []
  ), L = re(
    (F = {}, V = null) => ({
      ...F,
      ref: V,
      name: P,
      [f ? "checked" : "isChecked"]: S != null ? F.value === S : void 0,
      onChange(U) {
        _(U);
      },
      "data-radiogroup": !0
    }),
    [f, P, _, S]
  );
  return {
    getRootProps: D,
    getRadioProps: L,
    name: P,
    ref: w,
    focus: E,
    setValue: g,
    value: S,
    onChange: _,
    isDisabled: l,
    isFocusable: u,
    htmlProps: h
  };
}
var [Yge, Xj] = En({
  name: "RadioGroupContext",
  strict: !1
}), Jge = Le((e, t) => {
  const {
    colorScheme: n,
    size: o,
    variant: a,
    children: l,
    className: u,
    isDisabled: f,
    isFocusable: h,
    ...v
  } = e, { value: g, onChange: b, getRootProps: S, name: w, htmlProps: E } = Zge(v), T = gt(
    () => ({
      name: w,
      size: o,
      onChange: b,
      colorScheme: n,
      value: g,
      variant: a,
      isDisabled: f,
      isFocusable: h
    }),
    [
      w,
      o,
      b,
      n,
      g,
      a,
      f,
      h
    ]
  );
  return /* @__PURE__ */ M(Yge, { value: T, children: /* @__PURE__ */ M(
    De.div,
    {
      ...S(E, t),
      className: et("chakra-radio-group", u),
      children: l
    }
  ) });
});
Jge.displayName = "RadioGroup";
var Qge = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
function Kge(e = {}) {
  const {
    defaultChecked: t,
    isChecked: n,
    isFocusable: o,
    isDisabled: a,
    isReadOnly: l,
    isRequired: u,
    onChange: f,
    isInvalid: h,
    name: v,
    value: g,
    id: b,
    "data-radiogroup": S,
    "aria-describedby": w,
    ...E
  } = e, T = `radio-${ko()}`, A = gh(), _ = !!Xj() || !!S;
  let L = !!A && !_ ? A.id : T;
  L = b ?? L;
  const F = a ?? (A == null ? void 0 : A.isDisabled), V = l ?? (A == null ? void 0 : A.isReadOnly), $ = u ?? (A == null ? void 0 : A.isRequired), U = h ?? (A == null ? void 0 : A.isInvalid), [W, H] = ot(!1), [G, oe] = ot(!1), [ce, te] = ot(!1), [Ee, me] = ot(!1), [J, Q] = ot(!!t), ge = typeof n < "u", Y = ge ? n : J;
  dt(() => tH(H), []);
  const q = re(
    (we) => {
      if (V || F) {
        we.preventDefault();
        return;
      }
      ge || Q(we.target.checked), f == null || f(we);
    },
    [ge, F, V, f]
  ), de = re(
    (we) => {
      we.key === " " && me(!0);
    },
    [me]
  ), K = re(
    (we) => {
      we.key === " " && me(!1);
    },
    [me]
  ), ne = re(
    (we = {}, fe = null) => ({
      ...we,
      ref: fe,
      "data-active": Ft(Ee),
      "data-hover": Ft(ce),
      "data-disabled": Ft(F),
      "data-invalid": Ft(U),
      "data-checked": Ft(Y),
      "data-focus": Ft(G),
      "data-focus-visible": Ft(G && W),
      "data-readonly": Ft(V),
      "aria-hidden": !0,
      onMouseDown: st(we.onMouseDown, () => me(!0)),
      onMouseUp: st(we.onMouseUp, () => me(!1)),
      onMouseEnter: st(
        we.onMouseEnter,
        () => te(!0)
      ),
      onMouseLeave: st(
        we.onMouseLeave,
        () => te(!1)
      )
    }),
    [
      Ee,
      ce,
      F,
      U,
      Y,
      G,
      V,
      W
    ]
  ), { onFocus: pe, onBlur: Oe } = A ?? {}, Ce = re(
    (we = {}, fe = null) => {
      const ze = F && !o;
      return {
        ...we,
        id: L,
        ref: fe,
        type: "radio",
        name: v,
        value: g,
        onChange: st(we.onChange, q),
        onBlur: st(
          Oe,
          we.onBlur,
          () => oe(!1)
        ),
        onFocus: st(
          pe,
          we.onFocus,
          () => oe(!0)
        ),
        onKeyDown: st(we.onKeyDown, de),
        onKeyUp: st(we.onKeyUp, K),
        checked: Y,
        disabled: ze,
        readOnly: V,
        required: $,
        "aria-invalid": xs(U),
        "aria-disabled": xs(ze),
        "aria-required": xs($),
        "data-readonly": Ft(V),
        "aria-describedby": w,
        style: Qge
      };
    },
    [
      F,
      o,
      L,
      v,
      g,
      q,
      Oe,
      pe,
      de,
      K,
      Y,
      V,
      $,
      U,
      w
    ]
  );
  return {
    state: {
      isInvalid: U,
      isFocused: G,
      isChecked: Y,
      isActive: Ee,
      isHovered: ce,
      isDisabled: F,
      isReadOnly: V,
      isRequired: $
    },
    /**
     * @deprecated - use `getRadioProps` instead
     */
    getCheckboxProps: ne,
    getRadioProps: ne,
    getInputProps: Ce,
    getLabelProps: (we = {}, fe = null) => ({
      ...we,
      ref: fe,
      onMouseDown: st(we.onMouseDown, qge),
      "data-disabled": Ft(F),
      "data-checked": Ft(Y),
      "data-invalid": Ft(U)
    }),
    getRootProps: (we, fe = null) => ({
      ...we,
      ref: fe,
      "data-disabled": Ft(F),
      "data-checked": Ft(Y),
      "data-invalid": Ft(U)
    }),
    htmlProps: E
  };
}
function qge(e) {
  e.preventDefault(), e.stopPropagation();
}
function eye(e, t) {
  const n = {}, o = {};
  for (const [a, l] of Object.entries(e))
    t.includes(a) ? n[a] = l : o[a] = l;
  return [n, o];
}
var tye = Le((e, t) => {
  var n;
  const o = Xj(), { onChange: a, value: l } = e, u = Xn("Radio", { ...o, ...e }), f = Pn(e), {
    spacing: h = "0.5rem",
    children: v,
    isDisabled: g = o == null ? void 0 : o.isDisabled,
    isFocusable: b = o == null ? void 0 : o.isFocusable,
    inputProps: S,
    ...w
  } = f;
  let E = e.isChecked;
  (o == null ? void 0 : o.value) != null && l != null && (E = o.value === l);
  let T = a;
  o != null && o.onChange && l != null && (T = zE(o.onChange, a));
  const A = (n = e == null ? void 0 : e.name) != null ? n : o == null ? void 0 : o.name, {
    getInputProps: P,
    getCheckboxProps: _,
    getLabelProps: D,
    getRootProps: L,
    htmlProps: F
  } = Kge({
    ...w,
    isChecked: E,
    isFocusable: b,
    isDisabled: g,
    onChange: T,
    name: A
  }), [V, $] = eye(F, S4), U = _($), W = P(S, t), H = D(), G = Object.assign({}, V, L()), oe = {
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    cursor: "pointer",
    position: "relative",
    ...u.container
  }, ce = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...u.control
  }, te = {
    userSelect: "none",
    marginStart: h,
    ...u.label
  };
  return /* @__PURE__ */ Nt(De.label, { className: "chakra-radio", ...G, __css: oe, children: [
    /* @__PURE__ */ M("input", { className: "chakra-radio__input", ...W }),
    /* @__PURE__ */ M(
      De.span,
      {
        className: "chakra-radio__control",
        ...U,
        __css: ce
      }
    ),
    v && /* @__PURE__ */ M(
      De.span,
      {
        className: "chakra-radio__label",
        ...H,
        __css: te,
        children: v
      }
    )
  ] });
});
tye.displayName = "Radio";
var Zj = Le(
  function(t, n) {
    const { children: o, placeholder: a, className: l, ...u } = t;
    return /* @__PURE__ */ Nt(
      De.select,
      {
        ...u,
        ref: n,
        className: et("chakra-select", l),
        children: [
          a && /* @__PURE__ */ M("option", { value: "", children: a }),
          o
        ]
      }
    );
  }
);
Zj.displayName = "SelectField";
function nye(e, t) {
  const n = {}, o = {};
  for (const [a, l] of Object.entries(e))
    t.includes(a) ? n[a] = l : o[a] = l;
  return [n, o];
}
var rye = Le((e, t) => {
  var n;
  const o = Xn("Select", e), {
    rootProps: a,
    placeholder: l,
    icon: u,
    color: f,
    height: h,
    h: v,
    minH: g,
    minHeight: b,
    iconColor: S,
    iconSize: w,
    ...E
  } = Pn(e), [T, A] = nye(E, S4), P = yh(A), _ = {
    width: "100%",
    height: "fit-content",
    position: "relative",
    color: f
  }, D = {
    paddingEnd: "2rem",
    ...o.field,
    _focus: {
      zIndex: "unset",
      ...(n = o.field) == null ? void 0 : n._focus
    }
  };
  return /* @__PURE__ */ Nt(
    De.div,
    {
      className: "chakra-select__wrapper",
      __css: _,
      ...T,
      ...a,
      children: [
        /* @__PURE__ */ M(
          Zj,
          {
            ref: t,
            height: v ?? h,
            minH: g ?? b,
            placeholder: l,
            ...P,
            __css: D,
            children: e.children
          }
        ),
        /* @__PURE__ */ M(
          Yj,
          {
            "data-disabled": Ft(P.disabled),
            ...(S || f) && { color: S || f },
            __css: o.icon,
            ...w && { fontSize: w },
            children: u
          }
        )
      ]
    }
  );
});
rye.displayName = "Select";
var oye = (e) => /* @__PURE__ */ M("svg", { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ M(
  "path",
  {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }
) }), iye = De("div", {
  baseStyle: {
    position: "absolute",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    pointerEvents: "none",
    top: "50%",
    transform: "translateY(-50%)"
  }
}), Yj = (e) => {
  const { children: t = /* @__PURE__ */ M(oye, {}), ...n } = e, o = ya(t, {
    role: "presentation",
    className: "chakra-select__icon",
    focusable: !1,
    "aria-hidden": !0,
    // force icon to adhere to `IconWrapper` styles
    style: {
      width: "1em",
      height: "1em",
      color: "currentColor"
    }
  });
  return /* @__PURE__ */ M(iye, { ...n, className: "chakra-select__icon-wrapper", children: hh(t) ? o : null });
};
Yj.displayName = "SelectIcon";
function aye() {
  const e = Ue(!0);
  return dt(() => {
    e.current = !1;
  }, []), e.current;
}
function sye(e) {
  const t = Ue();
  return dt(() => {
    t.current = e;
  }, [e]), t.current;
}
var lye = De("div", {
  baseStyle: {
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    }
  }
}), DO = Pt("skeleton-start-color"), NO = Pt("skeleton-end-color"), uye = Ps({
  from: { opacity: 0 },
  to: { opacity: 1 }
}), cye = Ps({
  from: {
    borderColor: DO.reference,
    background: DO.reference
  },
  to: {
    borderColor: NO.reference,
    background: NO.reference
  }
}), dye = Le((e, t) => {
  const n = {
    ...e,
    fadeDuration: typeof e.fadeDuration == "number" ? e.fadeDuration : 0.4,
    speed: typeof e.speed == "number" ? e.speed : 0.8
  }, o = Gi("Skeleton", n), a = aye(), {
    startColor: l = "",
    endColor: u = "",
    isLoaded: f,
    fadeDuration: h,
    speed: v,
    className: g,
    fitContent: b,
    ...S
  } = Pn(n), [w, E] = XQ("colors", [
    l,
    u
  ]), T = sye(f), A = et("chakra-skeleton", g), P = {
    ...w && { [DO.variable]: w },
    ...E && { [NO.variable]: E }
  };
  if (f) {
    const _ = a || T ? "none" : `${uye} ${h}s`;
    return /* @__PURE__ */ M(
      De.div,
      {
        ref: t,
        className: A,
        __css: { animation: _ },
        ...S
      }
    );
  }
  return /* @__PURE__ */ M(
    lye,
    {
      ref: t,
      className: A,
      ...S,
      __css: {
        width: b ? "fit-content" : void 0,
        ...o,
        ...P,
        _dark: { ...o._dark, ...P },
        animation: `${v}s linear infinite alternate ${cye}`
      }
    }
  );
});
dye.displayName = "Skeleton";
var gs = (e) => e ? "" : void 0, qv = (e) => e ? !0 : void 0, Af = (...e) => e.filter(Boolean).join(" ");
function eg(...e) {
  return function(n) {
    e.some((o) => (o == null || o(n), n == null ? void 0 : n.defaultPrevented));
  };
}
function fye(e) {
  return {
    root: `slider-root-${e}`,
    getThumb: (t) => `slider-thumb-${e}-${t}`,
    getInput: (t) => `slider-input-${e}-${t}`,
    track: `slider-track-${e}`,
    innerTrack: `slider-filled-track-${e}`,
    getMarker: (t) => `slider-marker-${e}-${t}`,
    output: `slider-output-${e}`
  };
}
function p0(e) {
  const { orientation: t, vertical: n, horizontal: o } = e;
  return t === "vertical" ? n : o;
}
var gw = { width: 0, height: 0 }, VC = (e) => e || gw;
function Jj(e) {
  const { orientation: t, thumbPercents: n, thumbRects: o, isReversed: a } = e, l = (T) => {
    var A;
    const P = (A = o[T]) != null ? A : gw;
    return {
      position: "absolute",
      userSelect: "none",
      WebkitUserSelect: "none",
      MozUserSelect: "none",
      msUserSelect: "none",
      touchAction: "none",
      ...p0({
        orientation: t,
        vertical: {
          bottom: `calc(${n[T]}% - ${P.height / 2}px)`
        },
        horizontal: {
          left: `calc(${n[T]}% - ${P.width / 2}px)`
        }
      })
    };
  }, u = t === "vertical" ? o.reduce(
    (T, A) => VC(T).height > VC(A).height ? T : A,
    gw
  ) : o.reduce(
    (T, A) => VC(T).width > VC(A).width ? T : A,
    gw
  ), f = {
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0,
    ...p0({
      orientation: t,
      vertical: u ? {
        paddingLeft: u.width / 2,
        paddingRight: u.width / 2
      } : {},
      horizontal: u ? {
        paddingTop: u.height / 2,
        paddingBottom: u.height / 2
      } : {}
    })
  }, h = {
    position: "absolute",
    ...p0({
      orientation: t,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        height: "100%"
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        width: "100%"
      }
    })
  }, v = n.length === 1, g = [0, a ? 100 - n[0] : n[0]], b = v ? g : n;
  let S = b[0];
  !v && a && (S = 100 - S);
  const w = Math.abs(b[b.length - 1] - b[0]), E = {
    ...h,
    ...p0({
      orientation: t,
      vertical: a ? { height: `${w}%`, top: `${S}%` } : { height: `${w}%`, bottom: `${S}%` },
      horizontal: a ? { width: `${w}%`, right: `${S}%` } : { width: `${w}%`, left: `${S}%` }
    })
  };
  return { trackStyle: h, innerTrackStyle: E, rootStyle: f, getThumbStyle: l };
}
function Qj(e) {
  const { isReversed: t, direction: n, orientation: o } = e;
  return n === "ltr" || o === "vertical" ? t : !t;
}
function pye(e, t, n, o) {
  return e.addEventListener(t, n, o), () => {
    e.removeEventListener(t, n, o);
  };
}
function hye(e) {
  const t = vye(e);
  return typeof t.PointerEvent < "u" && e instanceof t.PointerEvent ? e.pointerType === "mouse" : e instanceof t.MouseEvent;
}
function Kj(e) {
  return !!e.touches;
}
function mye(e) {
  return Kj(e) && e.touches.length > 1;
}
function vye(e) {
  var t;
  return (t = e.view) != null ? t : window;
}
function gye(e, t = "page") {
  const n = e.touches[0] || e.changedTouches[0];
  return { x: n[`${t}X`], y: n[`${t}Y`] };
}
function yye(e, t = "page") {
  return {
    x: e[`${t}X`],
    y: e[`${t}Y`]
  };
}
function qj(e, t = "page") {
  return Kj(e) ? gye(e, t) : yye(e, t);
}
function bye(e) {
  return (t) => {
    const n = hye(t);
    (!n || n && t.button === 0) && e(t);
  };
}
function Sye(e, t = !1) {
  function n(a) {
    e(a, { point: qj(a) });
  }
  return t ? bye(n) : n;
}
function yw(e, t, n, o) {
  return pye(e, t, Sye(n, t === "pointerdown"), o);
}
var xye = Object.defineProperty, Cye = (e, t, n) => t in e ? xye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, dl = (e, t, n) => (Cye(e, typeof t != "symbol" ? t + "" : t, n), n), wye = class {
  constructor(e, t, n) {
    dl(this, "history", []), dl(this, "startEvent", null), dl(this, "lastEvent", null), dl(this, "lastEventInfo", null), dl(this, "handlers", {}), dl(this, "removeListeners", () => {
    }), dl(this, "threshold", 3), dl(this, "win"), dl(this, "updatePoint", () => {
      if (!(this.lastEvent && this.lastEventInfo))
        return;
      const f = lP(this.lastEventInfo, this.history), h = this.startEvent !== null, v = Aye(f.offset, { x: 0, y: 0 }) >= this.threshold;
      if (!h && !v)
        return;
      const { timestamp: g } = VB();
      this.history.push({ ...f.point, timestamp: g });
      const { onStart: b, onMove: S } = this.handlers;
      h || (b == null || b(this.lastEvent, f), this.startEvent = this.lastEvent), S == null || S(this.lastEvent, f);
    }), dl(this, "onPointerMove", (f, h) => {
      this.lastEvent = f, this.lastEventInfo = h, Nie.update(this.updatePoint, !0);
    }), dl(this, "onPointerUp", (f, h) => {
      const v = lP(h, this.history), { onEnd: g, onSessionEnd: b } = this.handlers;
      b == null || b(f, v), this.end(), !(!g || !this.startEvent) && (g == null || g(f, v));
    });
    var o;
    if (this.win = (o = e.view) != null ? o : window, mye(e))
      return;
    this.handlers = t, n && (this.threshold = n), e.stopPropagation(), e.preventDefault();
    const a = { point: qj(e) }, { timestamp: l } = VB();
    this.history = [{ ...a.point, timestamp: l }];
    const { onSessionStart: u } = t;
    u == null || u(e, lP(a, this.history)), this.removeListeners = Iye(
      yw(this.win, "pointermove", this.onPointerMove),
      yw(this.win, "pointerup", this.onPointerUp),
      yw(this.win, "pointercancel", this.onPointerUp)
    );
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    var e;
    (e = this.removeListeners) == null || e.call(this), Mie.update(this.updatePoint);
  }
};
function H$(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function lP(e, t) {
  return {
    point: e.point,
    delta: H$(e.point, t[t.length - 1]),
    offset: H$(e.point, t[0]),
    velocity: Tye(t, 0.1)
  };
}
var Eye = (e) => e * 1e3;
function Tye(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, o = null;
  const a = e[e.length - 1];
  for (; n >= 0 && (o = e[n], !(a.timestamp - o.timestamp > Eye(t))); )
    n--;
  if (!o)
    return { x: 0, y: 0 };
  const l = (a.timestamp - o.timestamp) / 1e3;
  if (l === 0)
    return { x: 0, y: 0 };
  const u = {
    x: (a.x - o.x) / l,
    y: (a.y - o.y) / l
  };
  return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u;
}
function Iye(...e) {
  return (t) => e.reduce((n, o) => o(n), t);
}
function uP(e, t) {
  return Math.abs(e - t);
}
function j$(e) {
  return "x" in e && "y" in e;
}
function Aye(e, t) {
  if (typeof e == "number" && typeof t == "number")
    return uP(e, t);
  if (j$(e) && j$(t)) {
    const n = uP(e.x, t.x), o = uP(e.y, t.y);
    return Math.sqrt(n ** 2 + o ** 2);
  }
  return 0;
}
function eG(e) {
  const t = Ue(null);
  return t.current = e, t;
}
function tG(e, t) {
  const {
    onPan: n,
    onPanStart: o,
    onPanEnd: a,
    onPanSessionStart: l,
    onPanSessionEnd: u,
    threshold: f
  } = t, h = !!(n || o || a || l || u), v = Ue(null), g = eG({
    onSessionStart: l,
    onSessionEnd: u,
    onStart: o,
    onMove: n,
    onEnd(b, S) {
      v.current = null, a == null || a(b, S);
    }
  });
  dt(() => {
    var b;
    (b = v.current) == null || b.updateHandlers(g.current);
  }), dt(() => {
    const b = e.current;
    if (!b || !h)
      return;
    function S(w) {
      v.current = new wye(w, g.current, f);
    }
    return yw(b, "pointerdown", S);
  }, [e, h, g, f]), dt(() => () => {
    var b;
    (b = v.current) == null || b.end(), v.current = null;
  }, []);
}
function kye(e, t) {
  if (!e) {
    t(void 0);
    return;
  }
  t({ width: e.offsetWidth, height: e.offsetHeight });
  const n = e.ownerDocument.defaultView ?? window, o = new n.ResizeObserver((a) => {
    if (!Array.isArray(a) || !a.length)
      return;
    const [l] = a;
    let u, f;
    if ("borderBoxSize" in l) {
      const h = l.borderBoxSize, v = Array.isArray(h) ? h[0] : h;
      u = v.inlineSize, f = v.blockSize;
    } else
      u = e.offsetWidth, f = e.offsetHeight;
    t({ width: u, height: f });
  });
  return o.observe(e, { box: "border-box" }), () => o.unobserve(e);
}
var Rye = globalThis != null && globalThis.document ? ph : dt;
function Pye(e, t) {
  var n, o;
  if (!e || !e.parentElement)
    return;
  const a = (o = (n = e.ownerDocument) == null ? void 0 : n.defaultView) != null ? o : window, l = new a.MutationObserver(() => {
    t();
  });
  return l.observe(e.parentElement, { childList: !0 }), () => {
    l.disconnect();
  };
}
function nG({
  getNodes: e,
  observeMutation: t = !0
}) {
  const [n, o] = ot([]), [a, l] = ot(0);
  return Rye(() => {
    const u = e(), f = u.map(
      (h, v) => kye(h, (g) => {
        o((b) => [
          ...b.slice(0, v),
          g,
          ...b.slice(v + 1)
        ]);
      })
    );
    if (t) {
      const h = u[0];
      f.push(
        Pye(h, () => {
          l((v) => v + 1);
        })
      );
    }
    return () => {
      f.forEach((h) => {
        h == null || h();
      });
    };
  }, [a]), n;
}
function Oye(e) {
  return typeof e == "object" && e !== null && "current" in e;
}
function _ye(e) {
  const [t] = nG({
    observeMutation: !1,
    getNodes() {
      return [Oye(e) ? e.current : e];
    }
  });
  return t;
}
function Dye(e) {
  const {
    min: t = 0,
    max: n = 100,
    onChange: o,
    value: a,
    defaultValue: l,
    isReversed: u,
    direction: f = "ltr",
    orientation: h = "horizontal",
    id: v,
    isDisabled: g,
    isReadOnly: b,
    onChangeStart: S,
    onChangeEnd: w,
    step: E = 1,
    getAriaValueText: T,
    "aria-valuetext": A,
    "aria-label": P,
    "aria-labelledby": _,
    name: D,
    focusThumbOnChange: L = !0,
    minStepsBetweenThumbs: F = 0,
    ...V
  } = e, $ = Er(S), U = Er(w), W = Er(T), H = Qj({
    isReversed: u,
    direction: f,
    orientation: h
  }), [G, oe] = Eg({
    value: a,
    defaultValue: l ?? [25, 75],
    onChange: o
  });
  if (!Array.isArray(G))
    throw new TypeError(
      `[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof G}\``
    );
  const [ce, te] = ot(!1), [Ee, me] = ot(!1), [J, Q] = ot(-1), ge = !(g || b), Y = Ue(G), q = G.map((He) => Yv(He, t, n)), de = F * E, K = Nye(q, t, n, de), ne = Ue({
    eventSource: null,
    value: [],
    valueBounds: []
  });
  ne.current.value = q, ne.current.valueBounds = K;
  const pe = q.map((He) => n - He + t), Ce = (H ? pe : q).map((He) => Kw(He, t, n)), xe = h === "vertical", ie = Ue(null), ye = Ue(null), we = nG({
    getNodes() {
      const He = ye.current, tt = He == null ? void 0 : He.querySelectorAll("[role=slider]");
      return tt ? Array.from(tt) : [];
    }
  }), fe = ko(), Ve = fye(v ?? fe), Ie = re(
    (He) => {
      var tt, ft;
      if (!ie.current)
        return;
      ne.current.eventSource = "pointer";
      const mt = ie.current.getBoundingClientRect(), { clientX: kt, clientY: Mn } = (ft = (tt = He.touches) == null ? void 0 : tt[0]) != null ? ft : He, sn = xe ? mt.bottom - Mn : kt - mt.left, Qt = xe ? mt.height : mt.width;
      let Ro = sn / Qt;
      return H && (Ro = 1 - Ro), rH(Ro, t, n);
    },
    [xe, H, n, t]
  ), qe = (n - t) / 10, Qe = E || (n - t) / 100, lt = gt(
    () => ({
      setValueAtIndex(He, tt) {
        if (!ge)
          return;
        const ft = ne.current.valueBounds[He];
        tt = parseFloat(SO(tt, ft.min, Qe)), tt = Yv(tt, ft.min, ft.max);
        const mt = [...ne.current.value];
        mt[He] = tt, oe(mt);
      },
      setActiveIndex: Q,
      stepUp(He, tt = Qe) {
        const ft = ne.current.value[He], mt = H ? ft - tt : ft + tt;
        lt.setValueAtIndex(He, mt);
      },
      stepDown(He, tt = Qe) {
        const ft = ne.current.value[He], mt = H ? ft + tt : ft - tt;
        lt.setValueAtIndex(He, mt);
      },
      reset() {
        oe(Y.current);
      }
    }),
    [Qe, H, oe, ge]
  ), tn = re(
    (He) => {
      const tt = He.key, mt = {
        ArrowRight: () => lt.stepUp(J),
        ArrowUp: () => lt.stepUp(J),
        ArrowLeft: () => lt.stepDown(J),
        ArrowDown: () => lt.stepDown(J),
        PageUp: () => lt.stepUp(J, qe),
        PageDown: () => lt.stepDown(J, qe),
        Home: () => {
          const { min: kt } = K[J];
          lt.setValueAtIndex(J, kt);
        },
        End: () => {
          const { max: kt } = K[J];
          lt.setValueAtIndex(J, kt);
        }
      }[tt];
      mt && (He.preventDefault(), He.stopPropagation(), mt(He), ne.current.eventSource = "keyboard");
    },
    [lt, J, qe, K]
  ), { getThumbStyle: Yt, rootStyle: hn, trackStyle: vn, innerTrackStyle: nn } = gt(
    () => Jj({
      isReversed: H,
      orientation: h,
      thumbRects: we,
      thumbPercents: Ce
    }),
    [H, h, Ce, we]
  ), rn = re(
    (He) => {
      var tt;
      const ft = He ?? J;
      if (ft !== -1 && L) {
        const mt = Ve.getThumb(ft), kt = (tt = ye.current) == null ? void 0 : tt.ownerDocument.getElementById(mt);
        kt && setTimeout(() => kt.focus());
      }
    },
    [L, J, Ve]
  );
  xl(() => {
    ne.current.eventSource === "keyboard" && (U == null || U(ne.current.value));
  }, [q, U]);
  const mn = (He) => {
    const tt = Ie(He) || 0, ft = ne.current.value.map(
      (Qt) => Math.abs(Qt - tt)
    ), mt = Math.min(...ft);
    let kt = ft.indexOf(mt);
    const Mn = ft.filter(
      (Qt) => Qt === mt
    );
    Mn.length > 1 && tt > ne.current.value[kt] && (kt = kt + Mn.length - 1), Q(kt), lt.setValueAtIndex(kt, tt), rn(kt);
  }, un = (He) => {
    if (J == -1)
      return;
    const tt = Ie(He) || 0;
    Q(J), lt.setValueAtIndex(J, tt), rn(J);
  };
  tG(ye, {
    onPanSessionStart(He) {
      ge && (te(!0), mn(He), $ == null || $(ne.current.value));
    },
    onPanSessionEnd() {
      ge && (te(!1), U == null || U(ne.current.value));
    },
    onPan(He) {
      ge && un(He);
    }
  });
  const Tn = re(
    (He = {}, tt = null) => ({
      ...He,
      ...V,
      id: Ve.root,
      ref: Cn(tt, ye),
      tabIndex: -1,
      "aria-disabled": qv(g),
      "data-focused": gs(Ee),
      style: { ...He.style, ...hn }
    }),
    [V, g, Ee, hn, Ve]
  ), je = re(
    (He = {}, tt = null) => ({
      ...He,
      ref: Cn(tt, ie),
      id: Ve.track,
      "data-disabled": gs(g),
      style: { ...He.style, ...vn }
    }),
    [g, vn, Ve]
  ), Ot = re(
    (He = {}, tt = null) => ({
      ...He,
      ref: tt,
      id: Ve.innerTrack,
      style: {
        ...He.style,
        ...nn
      }
    }),
    [nn, Ve]
  ), an = re(
    (He, tt = null) => {
      var ft;
      const { index: mt, ...kt } = He, Mn = q[mt];
      if (Mn == null)
        throw new TypeError(
          `[range-slider > thumb] Cannot find value at index \`${mt}\`. The \`value\` or \`defaultValue\` length is : ${q.length}`
        );
      const sn = K[mt];
      return {
        ...kt,
        ref: tt,
        role: "slider",
        tabIndex: ge ? 0 : void 0,
        id: Ve.getThumb(mt),
        "data-active": gs(ce && J === mt),
        "aria-valuetext": (ft = W == null ? void 0 : W(Mn)) != null ? ft : A == null ? void 0 : A[mt],
        "aria-valuemin": sn.min,
        "aria-valuemax": sn.max,
        "aria-valuenow": Mn,
        "aria-orientation": h,
        "aria-disabled": qv(g),
        "aria-readonly": qv(b),
        "aria-label": P == null ? void 0 : P[mt],
        "aria-labelledby": P != null && P[mt] || _ == null ? void 0 : _[mt],
        style: { ...He.style, ...Yt(mt) },
        onKeyDown: eg(He.onKeyDown, tn),
        onFocus: eg(He.onFocus, () => {
          me(!0), Q(mt);
        }),
        onBlur: eg(He.onBlur, () => {
          me(!1), Q(-1);
        })
      };
    },
    [
      Ve,
      q,
      K,
      ge,
      ce,
      J,
      W,
      A,
      h,
      g,
      b,
      P,
      _,
      Yt,
      tn,
      me
    ]
  ), Xe = re(
    (He = {}, tt = null) => ({
      ...He,
      ref: tt,
      id: Ve.output,
      htmlFor: q.map((ft, mt) => Ve.getThumb(mt)).join(" "),
      "aria-live": "off"
    }),
    [Ve, q]
  ), _e = re(
    (He, tt = null) => {
      const { value: ft, ...mt } = He, kt = !(ft < t || ft > n), Mn = ft >= q[0] && ft <= q[q.length - 1];
      let sn = Kw(ft, t, n);
      sn = H ? 100 - sn : sn;
      const Qt = {
        position: "absolute",
        pointerEvents: "none",
        ...p0({
          orientation: h,
          vertical: { bottom: `${sn}%` },
          horizontal: { left: `${sn}%` }
        })
      };
      return {
        ...mt,
        ref: tt,
        id: Ve.getMarker(He.value),
        role: "presentation",
        "aria-hidden": !0,
        "data-disabled": gs(g),
        "data-invalid": gs(!kt),
        "data-highlighted": gs(Mn),
        style: {
          ...He.style,
          ...Qt
        }
      };
    },
    [g, H, n, t, h, q, Ve]
  ), Je = re(
    (He, tt = null) => {
      const { index: ft, ...mt } = He;
      return {
        ...mt,
        ref: tt,
        id: Ve.getInput(ft),
        type: "hidden",
        value: q[ft],
        name: Array.isArray(D) ? D[ft] : `${D}-${ft}`
      };
    },
    [D, q, Ve]
  );
  return {
    state: {
      value: q,
      isFocused: Ee,
      isDragging: ce,
      getThumbPercent: (He) => Ce[He],
      getThumbMinValue: (He) => K[He].min,
      getThumbMaxValue: (He) => K[He].max
    },
    actions: lt,
    getRootProps: Tn,
    getTrackProps: je,
    getInnerTrackProps: Ot,
    getThumbProps: an,
    getMarkerProps: _e,
    getInputProps: Je,
    getOutputProps: Xe
  };
}
function Nye(e, t, n, o) {
  return e.map((a, l) => {
    const u = l === 0 ? t : e[l - 1] + o, f = l === e.length - 1 ? n : e[l + 1] - o;
    return { min: u, max: f };
  });
}
var [Mye, dT] = En({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
}), [Lye, fT] = En({
  name: "RangeSliderStylesContext",
  errorMessage: `useRangeSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
}), rG = Le(
  function(t, n) {
    const o = {
      orientation: "horizontal",
      ...t
    }, a = Xn("Slider", o), l = Pn(o), { direction: u } = wl();
    l.direction = u;
    const { getRootProps: f, ...h } = Dye(l), v = gt(
      () => ({ ...h, name: o.name }),
      [h, o.name]
    );
    return /* @__PURE__ */ M(Mye, { value: v, children: /* @__PURE__ */ M(Lye, { value: a, children: /* @__PURE__ */ M(
      De.div,
      {
        ...f({}, n),
        className: "chakra-slider",
        __css: a.container,
        children: o.children
      }
    ) }) });
  }
);
rG.displayName = "RangeSlider";
var MO = Le(
  function(t, n) {
    const { getThumbProps: o, getInputProps: a, name: l } = dT(), u = fT(), f = o(t, n);
    return /* @__PURE__ */ Nt(
      De.div,
      {
        ...f,
        className: Af("chakra-slider__thumb", t.className),
        __css: u.thumb,
        children: [
          f.children,
          l && /* @__PURE__ */ M("input", { ...a({ index: t.index }) })
        ]
      }
    );
  }
);
MO.displayName = "RangeSliderThumb";
var oG = Le(
  function(t, n) {
    const { getTrackProps: o } = dT(), a = fT(), l = o(t, n);
    return /* @__PURE__ */ M(
      De.div,
      {
        ...l,
        className: Af("chakra-slider__track", t.className),
        __css: a.track,
        "data-testid": "chakra-range-slider-track"
      }
    );
  }
);
oG.displayName = "RangeSliderTrack";
var iG = Le(function(t, n) {
  const { getInnerTrackProps: o } = dT(), a = fT(), l = o(t, n);
  return /* @__PURE__ */ M(
    De.div,
    {
      ...l,
      className: "chakra-slider__filled-track",
      __css: a.filledTrack
    }
  );
});
iG.displayName = "RangeSliderFilledTrack";
var bw = Le(
  function(t, n) {
    const { getMarkerProps: o } = dT(), a = fT(), l = o(t, n);
    return /* @__PURE__ */ M(
      De.div,
      {
        ...l,
        className: Af("chakra-slider__marker", t.className),
        __css: a.mark
      }
    );
  }
);
bw.displayName = "RangeSliderMark";
function Fye(e) {
  var t;
  const {
    min: n = 0,
    max: o = 100,
    onChange: a,
    value: l,
    defaultValue: u,
    isReversed: f,
    direction: h = "ltr",
    orientation: v = "horizontal",
    id: g,
    isDisabled: b,
    isReadOnly: S,
    onChangeStart: w,
    onChangeEnd: E,
    step: T = 1,
    getAriaValueText: A,
    "aria-valuetext": P,
    "aria-label": _,
    "aria-labelledby": D,
    name: L,
    focusThumbOnChange: F = !0,
    ...V
  } = e, $ = Er(w), U = Er(E), W = Er(A), H = Qj({
    isReversed: f,
    direction: h,
    orientation: v
  }), [G, oe] = Eg({
    value: l,
    defaultValue: u ?? Vye(n, o),
    onChange: a
  }), [ce, te] = ot(!1), [Ee, me] = ot(!1), J = !(b || S), Q = (o - n) / 10, ge = T || (o - n) / 100, Y = Yv(G, n, o), q = o - Y + n, K = Kw(H ? q : Y, n, o), ne = v === "vertical", pe = eG({
    min: n,
    max: o,
    step: T,
    isDisabled: b,
    value: Y,
    isInteractive: J,
    isReversed: H,
    isVertical: ne,
    eventSource: null,
    focusThumbOnChange: F,
    orientation: v
  }), Oe = Ue(null), Ce = Ue(null), xe = Ue(null), ie = ko(), ye = g ?? ie, [we, fe] = [`slider-thumb-${ye}`, `slider-track-${ye}`], ze = re(
    (_e) => {
      var Je, Kt;
      if (!Oe.current)
        return;
      const He = pe.current;
      He.eventSource = "pointer";
      const tt = Oe.current.getBoundingClientRect(), { clientX: ft, clientY: mt } = (Kt = (Je = _e.touches) == null ? void 0 : Je[0]) != null ? Kt : _e, kt = ne ? tt.bottom - mt : ft - tt.left, Mn = ne ? tt.height : tt.width;
      let sn = kt / Mn;
      H && (sn = 1 - sn);
      let Qt = rH(sn, He.min, He.max);
      return He.step && (Qt = parseFloat(
        SO(Qt, He.min, He.step)
      )), Qt = Yv(Qt, He.min, He.max), Qt;
    },
    [ne, H, pe]
  ), Ve = re(
    (_e) => {
      const Je = pe.current;
      Je.isInteractive && (_e = parseFloat(SO(_e, Je.min, ge)), _e = Yv(_e, Je.min, Je.max), oe(_e));
    },
    [ge, oe, pe]
  ), Ie = gt(
    () => ({
      stepUp(_e = ge) {
        const Je = H ? Y - _e : Y + _e;
        Ve(Je);
      },
      stepDown(_e = ge) {
        const Je = H ? Y + _e : Y - _e;
        Ve(Je);
      },
      reset() {
        Ve(u || 0);
      },
      stepTo(_e) {
        Ve(_e);
      }
    }),
    [Ve, H, Y, ge, u]
  ), qe = re(
    (_e) => {
      const Je = pe.current, He = {
        ArrowRight: () => Ie.stepUp(),
        ArrowUp: () => Ie.stepUp(),
        ArrowLeft: () => Ie.stepDown(),
        ArrowDown: () => Ie.stepDown(),
        PageUp: () => Ie.stepUp(Q),
        PageDown: () => Ie.stepDown(Q),
        Home: () => Ve(Je.min),
        End: () => Ve(Je.max)
      }[_e.key];
      He && (_e.preventDefault(), _e.stopPropagation(), He(_e), Je.eventSource = "keyboard");
    },
    [Ie, Ve, Q, pe]
  ), Qe = (t = W == null ? void 0 : W(Y)) != null ? t : P, lt = _ye(Ce), { getThumbStyle: tn, rootStyle: Yt, trackStyle: hn, innerTrackStyle: vn } = gt(() => {
    const _e = pe.current, Je = lt ?? { width: 0, height: 0 };
    return Jj({
      isReversed: H,
      orientation: _e.orientation,
      thumbRects: [Je],
      thumbPercents: [K]
    });
  }, [H, lt, K, pe]), nn = re(() => {
    pe.current.focusThumbOnChange && setTimeout(() => {
      var Je;
      return (Je = Ce.current) == null ? void 0 : Je.focus();
    });
  }, [pe]);
  xl(() => {
    const _e = pe.current;
    nn(), _e.eventSource === "keyboard" && (U == null || U(_e.value));
  }, [Y, U]);
  function rn(_e) {
    const Je = ze(_e);
    Je != null && Je !== pe.current.value && oe(Je);
  }
  tG(xe, {
    onPanSessionStart(_e) {
      const Je = pe.current;
      Je.isInteractive && (te(!0), nn(), rn(_e), $ == null || $(Je.value));
    },
    onPanSessionEnd() {
      const _e = pe.current;
      _e.isInteractive && (te(!1), U == null || U(_e.value));
    },
    onPan(_e) {
      pe.current.isInteractive && rn(_e);
    }
  });
  const mn = re(
    (_e = {}, Je = null) => ({
      ..._e,
      ...V,
      ref: Cn(Je, xe),
      tabIndex: -1,
      "aria-disabled": qv(b),
      "data-focused": gs(Ee),
      style: {
        ..._e.style,
        ...Yt
      }
    }),
    [V, b, Ee, Yt]
  ), un = re(
    (_e = {}, Je = null) => ({
      ..._e,
      ref: Cn(Je, Oe),
      id: fe,
      "data-disabled": gs(b),
      style: {
        ..._e.style,
        ...hn
      }
    }),
    [b, fe, hn]
  ), Tn = re(
    (_e = {}, Je = null) => ({
      ..._e,
      ref: Je,
      style: {
        ..._e.style,
        ...vn
      }
    }),
    [vn]
  ), je = re(
    (_e = {}, Je = null) => ({
      ..._e,
      ref: Cn(Je, Ce),
      role: "slider",
      tabIndex: J ? 0 : void 0,
      id: we,
      "data-active": gs(ce),
      "aria-valuetext": Qe,
      "aria-valuemin": n,
      "aria-valuemax": o,
      "aria-valuenow": Y,
      "aria-orientation": v,
      "aria-disabled": qv(b),
      "aria-readonly": qv(S),
      "aria-label": _,
      "aria-labelledby": _ ? void 0 : D,
      style: {
        ..._e.style,
        ...tn(0)
      },
      onKeyDown: eg(_e.onKeyDown, qe),
      onFocus: eg(_e.onFocus, () => me(!0)),
      onBlur: eg(_e.onBlur, () => me(!1))
    }),
    [
      J,
      we,
      ce,
      Qe,
      n,
      o,
      Y,
      v,
      b,
      S,
      _,
      D,
      tn,
      qe
    ]
  ), Ot = re(
    (_e, Je = null) => {
      const Kt = !(_e.value < n || _e.value > o), He = Y >= _e.value, tt = Kw(_e.value, n, o), ft = {
        position: "absolute",
        pointerEvents: "none",
        ...Bye({
          orientation: v,
          vertical: {
            bottom: H ? `${100 - tt}%` : `${tt}%`
          },
          horizontal: {
            left: H ? `${100 - tt}%` : `${tt}%`
          }
        })
      };
      return {
        ..._e,
        ref: Je,
        role: "presentation",
        "aria-hidden": !0,
        "data-disabled": gs(b),
        "data-invalid": gs(!Kt),
        "data-highlighted": gs(He),
        style: {
          ..._e.style,
          ...ft
        }
      };
    },
    [b, H, o, n, v, Y]
  ), an = re(
    (_e = {}, Je = null) => ({
      ..._e,
      ref: Je,
      type: "hidden",
      value: Y,
      name: L
    }),
    [L, Y]
  );
  return {
    state: { value: Y, isFocused: Ee, isDragging: ce },
    actions: Ie,
    getRootProps: mn,
    getTrackProps: un,
    getInnerTrackProps: Tn,
    getThumbProps: je,
    getMarkerProps: Ot,
    getInputProps: an
  };
}
function Bye(e) {
  const { orientation: t, vertical: n, horizontal: o } = e;
  return t === "vertical" ? n : o;
}
function Vye(e, t) {
  return t < e ? e : e + (t - e) / 2;
}
var [$ye, pT] = En({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<Slider />"
}), [zye, hT] = En({
  name: "SliderStylesContext",
  hookName: "useSliderStyles",
  providerName: "<Slider />"
}), aG = Le((e, t) => {
  var n;
  const o = {
    ...e,
    orientation: (n = e == null ? void 0 : e.orientation) != null ? n : "horizontal"
  }, a = Xn("Slider", o), l = Pn(o), { direction: u } = wl();
  l.direction = u;
  const { getInputProps: f, getRootProps: h, ...v } = Fye(l), g = h(), b = f({}, t);
  return /* @__PURE__ */ M($ye, { value: v, children: /* @__PURE__ */ M(zye, { value: a, children: /* @__PURE__ */ Nt(
    De.div,
    {
      ...g,
      className: Af("chakra-slider", o.className),
      __css: a.container,
      children: [
        o.children,
        /* @__PURE__ */ M("input", { ...b })
      ]
    }
  ) }) });
});
aG.displayName = "Slider";
var sG = Le((e, t) => {
  const { getThumbProps: n } = pT(), o = hT(), a = n(e, t);
  return /* @__PURE__ */ M(
    De.div,
    {
      ...a,
      className: Af("chakra-slider__thumb", e.className),
      __css: o.thumb
    }
  );
});
sG.displayName = "SliderThumb";
var lG = Le((e, t) => {
  const { getTrackProps: n } = pT(), o = hT(), a = n(e, t);
  return /* @__PURE__ */ M(
    De.div,
    {
      ...a,
      className: Af("chakra-slider__track", e.className),
      __css: o.track
    }
  );
});
lG.displayName = "SliderTrack";
var uG = Le(
  (e, t) => {
    const { getInnerTrackProps: n } = pT(), o = hT(), a = n(e, t);
    return /* @__PURE__ */ M(
      De.div,
      {
        ...a,
        className: Af("chakra-slider__filled-track", e.className),
        __css: o.filledTrack
      }
    );
  }
);
uG.displayName = "SliderFilledTrack";
var Sw = Le((e, t) => {
  const { getMarkerProps: n } = pT(), o = hT(), a = n(e, t);
  return /* @__PURE__ */ M(
    De.div,
    {
      ...a,
      className: Af("chakra-slider__marker", e.className),
      __css: o.mark
    }
  );
});
Sw.displayName = "SliderMark";
var [Hye, mT] = En({
  name: "StatStylesContext",
  errorMessage: `useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `
}), jye = Le(function(t, n) {
  const o = Xn("Stat", t), a = {
    position: "relative",
    flex: "1 1 0%",
    ...o.container
  }, { className: l, children: u, ...f } = Pn(t);
  return /* @__PURE__ */ M(Hye, { value: o, children: /* @__PURE__ */ M(
    De.div,
    {
      ref: n,
      ...f,
      className: et("chakra-stat", l),
      __css: a,
      children: /* @__PURE__ */ M("dl", { children: u })
    }
  ) });
});
jye.displayName = "Stat";
var cG = (e) => /* @__PURE__ */ M(ho, { color: "red.400", ...e, children: /* @__PURE__ */ M(
  "path",
  {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  }
) });
cG.displayName = "StatDownArrow";
function dG(e) {
  return /* @__PURE__ */ M(ho, { color: "green.400", ...e, children: /* @__PURE__ */ M(
    "path",
    {
      fill: "currentColor",
      d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
    }
  ) });
}
dG.displayName = "StatUpArrow";
function Gye(e) {
  const { type: t, "aria-label": n, ...o } = e, a = mT(), l = t === "increase" ? dG : cG, f = n || (t === "increase" ? "increased by" : "decreased by");
  return /* @__PURE__ */ Nt(ah, { children: [
    /* @__PURE__ */ M(De.span, { srOnly: !0, children: f }),
    /* @__PURE__ */ M(l, { "aria-hidden": !0, ...o, __css: a.icon })
  ] });
}
Gye.displayName = "StatArrow";
var Wye = Le(function(t, n) {
  return /* @__PURE__ */ M(
    De.div,
    {
      ...t,
      ref: n,
      role: "group",
      className: et("chakra-stat__group", t.className),
      __css: {
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-around",
        alignItems: "flex-start"
      }
    }
  );
});
Wye.displayName = "StatGroup";
var Uye = Le(
  function(t, n) {
    const o = mT();
    return /* @__PURE__ */ M(
      De.dd,
      {
        ref: n,
        ...t,
        className: et("chakra-stat__help-text", t.className),
        __css: o.helpText
      }
    );
  }
);
Uye.displayName = "StatHelpText";
var Xye = Le(function(t, n) {
  const o = mT();
  return /* @__PURE__ */ M(
    De.dt,
    {
      ref: n,
      ...t,
      className: et("chakra-stat__label", t.className),
      __css: o.label
    }
  );
});
Xye.displayName = "StatLabel";
var Zye = Le(function(t, n) {
  const o = mT();
  return /* @__PURE__ */ M(
    De.dd,
    {
      ref: n,
      ...t,
      className: et("chakra-stat__number", t.className),
      __css: {
        ...o.number,
        fontFeatureSettings: "pnum",
        fontVariantNumeric: "proportional-nums"
      }
    }
  );
});
Zye.displayName = "StatNumber";
var Yye = Le(function(t, n) {
  const o = Xn("Switch", t), { spacing: a = "0.5rem", children: l, ...u } = Pn(t), {
    getIndicatorProps: f,
    getInputProps: h,
    getCheckboxProps: v,
    getRootProps: g,
    getLabelProps: b
  } = nH(u), S = gt(
    () => ({
      display: "inline-block",
      position: "relative",
      verticalAlign: "middle",
      lineHeight: 0,
      ...o.container
    }),
    [o.container]
  ), w = gt(
    () => ({
      display: "inline-flex",
      flexShrink: 0,
      justifyContent: "flex-start",
      boxSizing: "content-box",
      cursor: "pointer",
      ...o.track
    }),
    [o.track]
  ), E = gt(
    () => ({
      userSelect: "none",
      marginStart: a,
      ...o.label
    }),
    [a, o.label]
  );
  return /* @__PURE__ */ Nt(
    De.label,
    {
      ...g(),
      className: et("chakra-switch", t.className),
      __css: S,
      children: [
        /* @__PURE__ */ M("input", { className: "chakra-switch__input", ...h({}, n) }),
        /* @__PURE__ */ M(
          De.span,
          {
            ...v(),
            className: "chakra-switch__track",
            __css: w,
            children: /* @__PURE__ */ M(
              De.span,
              {
                __css: o.thumb,
                className: "chakra-switch__thumb",
                ...f()
              }
            )
          }
        ),
        l && /* @__PURE__ */ M(
          De.span,
          {
            className: "chakra-switch__label",
            ...b(),
            __css: E,
            children: l
          }
        )
      ]
    }
  );
});
Yye.displayName = "Switch";
var [
  Jye,
  Qye,
  Kye,
  qye
] = v2();
function ebe(e) {
  var t;
  const {
    defaultIndex: n,
    onChange: o,
    index: a,
    isManual: l,
    isLazy: u,
    lazyBehavior: f = "unmount",
    orientation: h = "horizontal",
    direction: v = "ltr",
    ...g
  } = e, [b, S] = ot(n ?? 0), [w, E] = Eg({
    defaultValue: n ?? 0,
    value: a,
    onChange: o
  });
  dt(() => {
    a != null && S(a);
  }, [a]);
  const T = Kye(), A = ko();
  return {
    id: `tabs-${(t = e.id) != null ? t : A}`,
    selectedIndex: w,
    focusedIndex: b,
    setSelectedIndex: E,
    setFocusedIndex: S,
    isManual: l,
    isLazy: u,
    lazyBehavior: f,
    orientation: h,
    descendants: T,
    direction: v,
    htmlProps: g
  };
}
var [tbe, vT] = En({
  name: "TabsContext",
  errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
});
function nbe(e) {
  const { focusedIndex: t, orientation: n, direction: o } = vT(), a = Qye(), l = re(
    (u) => {
      const f = () => {
        var _;
        const D = a.nextEnabled(t);
        D && ((_ = D.node) == null || _.focus());
      }, h = () => {
        var _;
        const D = a.prevEnabled(t);
        D && ((_ = D.node) == null || _.focus());
      }, v = () => {
        var _;
        const D = a.firstEnabled();
        D && ((_ = D.node) == null || _.focus());
      }, g = () => {
        var _;
        const D = a.lastEnabled();
        D && ((_ = D.node) == null || _.focus());
      }, b = n === "horizontal", S = n === "vertical", w = u.key, E = o === "ltr" ? "ArrowLeft" : "ArrowRight", T = o === "ltr" ? "ArrowRight" : "ArrowLeft", P = {
        [E]: () => b && h(),
        [T]: () => b && f(),
        ArrowDown: () => S && f(),
        ArrowUp: () => S && h(),
        Home: v,
        End: g
      }[w];
      P && (u.preventDefault(), P(u));
    },
    [a, t, n, o]
  );
  return {
    ...e,
    role: "tablist",
    "aria-orientation": n,
    onKeyDown: st(e.onKeyDown, l)
  };
}
function rbe(e) {
  const { isDisabled: t = !1, isFocusable: n = !1, ...o } = e, { setSelectedIndex: a, isManual: l, id: u, setFocusedIndex: f, selectedIndex: h } = vT(), { index: v, register: g } = qye({
    disabled: t && !n
  }), b = v === h, S = () => {
    a(v);
  }, w = () => {
    f(v), !l && !(t && n) && a(v);
  };
  return {
    ...tj({
      ...o,
      ref: Cn(g, e.ref),
      isDisabled: t,
      isFocusable: n,
      onClick: st(e.onClick, S)
    }),
    id: fG(u, v),
    role: "tab",
    tabIndex: b ? 0 : -1,
    type: "button",
    "aria-selected": b,
    "aria-controls": pG(u, v),
    onFocus: t ? void 0 : st(e.onFocus, w)
  };
}
var [obe, ibe] = En({});
function abe(e) {
  const t = vT(), { id: n, selectedIndex: o } = t, l = gS(e.children).map(
    (u, f) => S_(
      obe,
      {
        key: f,
        value: {
          isSelected: f === o,
          id: pG(n, f),
          tabId: fG(n, f),
          selectedIndex: o
        }
      },
      u
    )
  );
  return { ...e, children: l };
}
function sbe(e) {
  const { children: t, ...n } = e, { isLazy: o, lazyBehavior: a } = vT(), { isSelected: l, id: u, tabId: f } = ibe(), h = Ue(!1);
  l && (h.current = !0);
  const v = Q2({
    wasSelected: h.current,
    isSelected: l,
    enabled: o,
    mode: a
  });
  return {
    // Puts the tabpanel in the page `Tab` sequence.
    tabIndex: 0,
    ...n,
    children: v ? t : null,
    role: "tabpanel",
    "aria-labelledby": f,
    hidden: !l,
    id: u
  };
}
function fG(e, t) {
  return `${e}--tab-${t}`;
}
function pG(e, t) {
  return `${e}--tabpanel-${t}`;
}
var [lbe, gT] = En({
  name: "TabsStylesContext",
  errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
}), ube = Le(function(t, n) {
  const o = Xn("Tabs", t), { children: a, className: l, ...u } = Pn(t), { htmlProps: f, descendants: h, ...v } = ebe(u), g = gt(() => v, [v]), { isFitted: b, ...S } = f, w = {
    position: "relative",
    ...o.root
  };
  return /* @__PURE__ */ M(Jye, { value: h, children: /* @__PURE__ */ M(tbe, { value: g, children: /* @__PURE__ */ M(lbe, { value: o, children: /* @__PURE__ */ M(
    De.div,
    {
      className: et("chakra-tabs", l),
      ref: n,
      ...S,
      __css: w,
      children: a
    }
  ) }) }) });
});
ube.displayName = "Tabs";
var cbe = Le(function(t, n) {
  const o = nbe({ ...t, ref: n }), l = {
    display: "flex",
    ...gT().tablist
  };
  return /* @__PURE__ */ M(
    De.div,
    {
      ...o,
      className: et("chakra-tabs__tablist", t.className),
      __css: l
    }
  );
});
cbe.displayName = "TabList";
var dbe = Le(function(t, n) {
  const o = sbe({ ...t, ref: n }), a = gT();
  return /* @__PURE__ */ M(
    De.div,
    {
      outline: "0",
      ...o,
      className: et("chakra-tabs__tab-panel", t.className),
      __css: a.tabpanel
    }
  );
});
dbe.displayName = "TabPanel";
var fbe = Le(function(t, n) {
  const o = abe(t), a = gT();
  return /* @__PURE__ */ M(
    De.div,
    {
      ...o,
      width: "100%",
      ref: n,
      className: et("chakra-tabs__tab-panels", t.className),
      __css: a.tabpanels
    }
  );
});
fbe.displayName = "TabPanels";
var hG = Le(function(t, n) {
  const o = gT(), a = rbe({ ...t, ref: n }), l = {
    outline: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    ...o.tab
  };
  return /* @__PURE__ */ M(
    De.button,
    {
      ...a,
      className: et("chakra-tabs__tab", t.className),
      __css: l
    }
  );
});
hG.displayName = "Tab";
function pbe(e, t = []) {
  const n = Object.assign({}, e);
  for (const o of t)
    o in n && delete n[o];
  return n;
}
var hbe = ["h", "minH", "height", "minHeight"], mG = Le((e, t) => {
  const n = Gi("Textarea", e), { className: o, rows: a, ...l } = Pn(e), u = yh(l), f = a ? pbe(n, hbe) : n;
  return /* @__PURE__ */ M(
    De.textarea,
    {
      ref: t,
      rows: a,
      ...u,
      className: et("chakra-textarea", o),
      __css: f
    }
  );
});
mG.displayName = "Textarea";
var mbe = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: { duration: 0.15, easings: "easeInOut" },
      scale: { duration: 0.2, easings: "easeInOut" }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: { easings: "easeOut", duration: 0.2 },
      scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
    }
  }
}, LO = (e) => {
  var t;
  return ((t = e.current) == null ? void 0 : t.ownerDocument) || document;
}, xw = (e) => {
  var t, n;
  return ((n = (t = e.current) == null ? void 0 : t.ownerDocument) == null ? void 0 : n.defaultView) || window;
};
function vbe(e = {}) {
  const {
    openDelay: t = 0,
    closeDelay: n = 0,
    closeOnClick: o = !0,
    closeOnMouseDown: a,
    closeOnScroll: l,
    closeOnPointerDown: u = a,
    closeOnEsc: f = !0,
    onOpen: h,
    onClose: v,
    placement: g,
    id: b,
    isOpen: S,
    defaultIsOpen: w,
    arrowSize: E = 10,
    arrowShadowColor: T,
    arrowPadding: A,
    modifiers: P,
    isDisabled: _,
    gutter: D,
    offset: L,
    direction: F,
    ...V
  } = e, { isOpen: $, onOpen: U, onClose: W } = J2({
    isOpen: S,
    defaultIsOpen: w,
    onOpen: h,
    onClose: v
  }), { referenceRef: H, getPopperProps: G, getArrowInnerProps: oe, getArrowProps: ce } = Y2({
    enabled: $,
    placement: g,
    arrowPadding: A,
    modifiers: P,
    gutter: D,
    offset: L,
    direction: F
  }), te = ko(), me = `tooltip-${b ?? te}`, J = Ue(null), Q = Ue(), ge = re(() => {
    Q.current && (clearTimeout(Q.current), Q.current = void 0);
  }, []), Y = Ue(), q = re(() => {
    Y.current && (clearTimeout(Y.current), Y.current = void 0);
  }, []), de = re(() => {
    q(), W();
  }, [W, q]), K = gbe(J, de), ne = re(() => {
    if (!_ && !Q.current) {
      $ && K();
      const fe = xw(J);
      Q.current = fe.setTimeout(U, t);
    }
  }, [K, _, $, U, t]), pe = re(() => {
    ge();
    const fe = xw(J);
    Y.current = fe.setTimeout(de, n);
  }, [n, de, ge]), Oe = re(() => {
    $ && o && pe();
  }, [o, pe, $]), Ce = re(() => {
    $ && u && pe();
  }, [u, pe, $]), xe = re(
    (fe) => {
      $ && fe.key === "Escape" && pe();
    },
    [$, pe]
  );
  nh(
    () => LO(J),
    "keydown",
    f ? xe : void 0
  ), nh(
    () => {
      if (!l)
        return null;
      const fe = J.current;
      if (!fe)
        return null;
      const ze = zH(fe);
      return ze.localName === "body" ? xw(J) : ze;
    },
    "scroll",
    () => {
      $ && l && de();
    },
    { passive: !0, capture: !0 }
  ), dt(() => {
    _ && (ge(), $ && W());
  }, [_, $, W, ge]), dt(() => () => {
    ge(), q();
  }, [ge, q]), nh(() => J.current, "pointerleave", pe);
  const ie = re(
    (fe = {}, ze = null) => ({
      ...fe,
      ref: Cn(J, ze, H),
      onPointerEnter: st(fe.onPointerEnter, (Ie) => {
        Ie.pointerType !== "touch" && ne();
      }),
      onClick: st(fe.onClick, Oe),
      onPointerDown: st(fe.onPointerDown, Ce),
      onFocus: st(fe.onFocus, ne),
      onBlur: st(fe.onBlur, pe),
      "aria-describedby": $ ? me : void 0
    }),
    [
      ne,
      pe,
      Ce,
      $,
      me,
      Oe,
      H
    ]
  ), ye = re(
    (fe = {}, ze = null) => G(
      {
        ...fe,
        style: {
          ...fe.style,
          [po.arrowSize.var]: E ? `${E}px` : void 0,
          [po.arrowShadowColor.var]: T
        }
      },
      ze
    ),
    [G, E, T]
  ), we = re(
    (fe = {}, ze = null) => {
      const Ve = {
        ...fe.style,
        position: "relative",
        transformOrigin: po.transformOrigin.varRef
      };
      return {
        ref: ze,
        ...V,
        ...fe,
        id: me,
        role: "tooltip",
        style: Ve
      };
    },
    [V, me]
  );
  return {
    isOpen: $,
    show: ne,
    hide: pe,
    getTriggerProps: ie,
    getTooltipProps: we,
    getTooltipPositionerProps: ye,
    getArrowProps: ce,
    getArrowInnerProps: oe
  };
}
var cP = "chakra-ui:close-tooltip";
function gbe(e, t) {
  return dt(() => {
    const n = LO(e);
    return n.addEventListener(cP, t), () => n.removeEventListener(cP, t);
  }, [t, e]), () => {
    const n = LO(e), o = xw(e);
    n.dispatchEvent(new o.CustomEvent(cP));
  };
}
function ybe(e, t = []) {
  const n = Object.assign({}, e);
  for (const o of t)
    o in n && delete n[o];
  return n;
}
function bbe(e, t) {
  const n = {};
  for (const o of t)
    o in e && (n[o] = e[o]);
  return n;
}
var Sbe = De(ti.div), vG = Le((e, t) => {
  var n, o;
  const a = Gi("Tooltip", e), l = Pn(e), u = wl(), {
    children: f,
    label: h,
    shouldWrapChildren: v,
    "aria-label": g,
    hasArrow: b,
    bg: S,
    portalProps: w,
    background: E,
    backgroundColor: T,
    bgColor: A,
    motionProps: P,
    ..._
  } = l, D = (o = (n = E ?? T) != null ? n : S) != null ? o : A;
  if (D) {
    a.bg = D;
    const G = C4(u, "colors", D);
    a[po.arrowBg.var] = G;
  }
  const L = vbe({ ..._, direction: u.direction }), F = typeof f == "string" || v;
  let V;
  if (F)
    V = /* @__PURE__ */ M(
      De.span,
      {
        display: "inline-block",
        tabIndex: 0,
        ...L.getTriggerProps(),
        children: f
      }
    );
  else {
    const G = Gc.only(f);
    V = ya(
      G,
      L.getTriggerProps(G.props, G.ref)
    );
  }
  const $ = !!g, U = L.getTooltipProps({}, t), W = $ ? ybe(U, ["role", "id"]) : U, H = bbe(U, ["role", "id"]);
  return h ? /* @__PURE__ */ Nt(ah, { children: [
    V,
    /* @__PURE__ */ M(Cu, { children: L.isOpen && /* @__PURE__ */ M(wf, { ...w, children: /* @__PURE__ */ M(
      De.div,
      {
        ...L.getTooltipPositionerProps(),
        __css: {
          zIndex: a.zIndex,
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ Nt(
          Sbe,
          {
            variants: mbe,
            initial: "exit",
            animate: "enter",
            exit: "exit",
            ...P,
            ...W,
            __css: a,
            children: [
              h,
              $ && /* @__PURE__ */ M(De.span, { srOnly: !0, ...H, children: g }),
              b && /* @__PURE__ */ M(
                De.div,
                {
                  "data-popper-arrow": !0,
                  className: "chakra-tooltip__arrow-wrapper",
                  children: /* @__PURE__ */ M(
                    De.div,
                    {
                      "data-popper-arrow-inner": !0,
                      className: "chakra-tooltip__arrow",
                      __css: { bg: a.bg }
                    }
                  )
                }
              )
            ]
          }
        )
      }
    ) }) })
  ] }) : /* @__PURE__ */ M(ah, { children: f });
});
vG.displayName = "Tooltip";
var gG = typeof global == "object" && global && global.Object === Object && global, xbe = typeof self == "object" && self && self.Object === Object && self, Eu = gG || xbe || Function("return this")(), hf = Eu.Symbol, yG = Object.prototype, Cbe = yG.hasOwnProperty, wbe = yG.toString, Kb = hf ? hf.toStringTag : void 0;
function Ebe(e) {
  var t = Cbe.call(e, Kb), n = e[Kb];
  try {
    e[Kb] = void 0;
    var o = !0;
  } catch {
  }
  var a = wbe.call(e);
  return o && (t ? e[Kb] = n : delete e[Kb]), a;
}
var Tbe = Object.prototype, Ibe = Tbe.toString;
function Abe(e) {
  return Ibe.call(e);
}
var kbe = "[object Null]", Rbe = "[object Undefined]", G$ = hf ? hf.toStringTag : void 0;
function kf(e) {
  return e == null ? e === void 0 ? Rbe : kbe : G$ && G$ in Object(e) ? Ebe(e) : Abe(e);
}
function Wc(e) {
  return e != null && typeof e == "object";
}
var Pbe = "[object Symbol]";
function bG(e) {
  return typeof e == "symbol" || Wc(e) && kf(e) == Pbe;
}
function Obe(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, a = Array(o); ++n < o; )
    a[n] = t(e[n], n, e);
  return a;
}
var mg = Array.isArray, _be = 1 / 0, W$ = hf ? hf.prototype : void 0, U$ = W$ ? W$.toString : void 0;
function oE(e) {
  if (typeof e == "string")
    return e;
  if (mg(e))
    return Obe(e, oE) + "";
  if (bG(e))
    return U$ ? U$.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -_be ? "-0" : t;
}
var Dbe = /\s/;
function Nbe(e) {
  for (var t = e.length; t-- && Dbe.test(e.charAt(t)); )
    ;
  return t;
}
var Mbe = /^\s+/;
function Lbe(e) {
  return e && e.slice(0, Nbe(e) + 1).replace(Mbe, "");
}
function Cl(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var X$ = NaN, Fbe = /^[-+]0x[0-9a-f]+$/i, Bbe = /^0b[01]+$/i, Vbe = /^0o[0-7]+$/i, $be = parseInt;
function Cw(e) {
  if (typeof e == "number")
    return e;
  if (bG(e))
    return X$;
  if (Cl(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Cl(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Lbe(e);
  var n = Bbe.test(e);
  return n || Vbe.test(e) ? $be(e.slice(2), n ? 2 : 8) : Fbe.test(e) ? X$ : +e;
}
var Z$ = 1 / 0, zbe = 17976931348623157e292;
function Hbe(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Cw(e), e === Z$ || e === -Z$) {
    var t = e < 0 ? -1 : 1;
    return t * zbe;
  }
  return e === e ? e : 0;
}
function jbe(e) {
  var t = Hbe(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function SG(e) {
  return e;
}
var Gbe = "[object AsyncFunction]", Wbe = "[object Function]", Ube = "[object GeneratorFunction]", Xbe = "[object Proxy]";
function eD(e) {
  if (!Cl(e))
    return !1;
  var t = kf(e);
  return t == Wbe || t == Ube || t == Gbe || t == Xbe;
}
var dP = Eu["__core-js_shared__"], Y$ = function() {
  var e = /[^.]+$/.exec(dP && dP.keys && dP.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Zbe(e) {
  return !!Y$ && Y$ in e;
}
var Ybe = Function.prototype, Jbe = Ybe.toString;
function Sh(e) {
  if (e != null) {
    try {
      return Jbe.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Qbe = /[\\^$.*+?()[\]{}|]/g, Kbe = /^\[object .+?Constructor\]$/, qbe = Function.prototype, e0e = Object.prototype, t0e = qbe.toString, n0e = e0e.hasOwnProperty, r0e = RegExp(
  "^" + t0e.call(n0e).replace(Qbe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function o0e(e) {
  if (!Cl(e) || Zbe(e))
    return !1;
  var t = eD(e) ? r0e : Kbe;
  return t.test(Sh(e));
}
function i0e(e, t) {
  return e == null ? void 0 : e[t];
}
function xh(e, t) {
  var n = i0e(e, t);
  return o0e(n) ? n : void 0;
}
var FO = xh(Eu, "WeakMap"), J$ = Object.create, a0e = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Cl(t))
      return {};
    if (J$)
      return J$(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function s0e(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function xG(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var l0e = 800, u0e = 16, c0e = Date.now;
function d0e(e) {
  var t = 0, n = 0;
  return function() {
    var o = c0e(), a = u0e - (o - n);
    if (n = o, a > 0) {
      if (++t >= l0e)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function f0e(e) {
  return function() {
    return e;
  };
}
var iE = function() {
  try {
    var e = xh(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), p0e = iE ? function(e, t) {
  return iE(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: f0e(t),
    writable: !0
  });
} : SG;
const h0e = p0e;
var m0e = d0e(h0e);
function v0e(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var g0e = 9007199254740991, y0e = /^(?:0|[1-9]\d*)$/;
function CG(e, t) {
  var n = typeof e;
  return t = t ?? g0e, !!t && (n == "number" || n != "symbol" && y0e.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function tD(e, t, n) {
  t == "__proto__" && iE ? iE(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function yT(e, t) {
  return e === t || e !== e && t !== t;
}
var b0e = Object.prototype, S0e = b0e.hasOwnProperty;
function wG(e, t, n) {
  var o = e[t];
  (!(S0e.call(e, t) && yT(o, n)) || n === void 0 && !(t in e)) && tD(e, t, n);
}
function CS(e, t, n, o) {
  var a = !n;
  n || (n = {});
  for (var l = -1, u = t.length; ++l < u; ) {
    var f = t[l], h = o ? o(n[f], e[f], f, n, e) : void 0;
    h === void 0 && (h = e[f]), a ? tD(n, f, h) : wG(n, f, h);
  }
  return n;
}
var Q$ = Math.max;
function x0e(e, t, n) {
  return t = Q$(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, a = -1, l = Q$(o.length - t, 0), u = Array(l); ++a < l; )
      u[a] = o[t + a];
    a = -1;
    for (var f = Array(t + 1); ++a < t; )
      f[a] = o[a];
    return f[t] = n(u), s0e(e, this, f);
  };
}
function C0e(e, t) {
  return m0e(x0e(e, t, SG), e + "");
}
var w0e = 9007199254740991;
function EG(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= w0e;
}
function bT(e) {
  return e != null && EG(e.length) && !eD(e);
}
function E0e(e, t, n) {
  if (!Cl(n))
    return !1;
  var o = typeof t;
  return (o == "number" ? bT(n) && CG(t, n.length) : o == "string" && t in n) ? yT(n[t], e) : !1;
}
function T0e(e) {
  return C0e(function(t, n) {
    var o = -1, a = n.length, l = a > 1 ? n[a - 1] : void 0, u = a > 2 ? n[2] : void 0;
    for (l = e.length > 3 && typeof l == "function" ? (a--, l) : void 0, u && E0e(n[0], n[1], u) && (l = a < 3 ? void 0 : l, a = 1), t = Object(t); ++o < a; ) {
      var f = n[o];
      f && e(t, f, o, l);
    }
    return t;
  });
}
var I0e = Object.prototype;
function nD(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || I0e;
  return e === n;
}
function A0e(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
var k0e = "[object Arguments]";
function K$(e) {
  return Wc(e) && kf(e) == k0e;
}
var TG = Object.prototype, R0e = TG.hasOwnProperty, P0e = TG.propertyIsEnumerable, BO = K$(/* @__PURE__ */ function() {
  return arguments;
}()) ? K$ : function(e) {
  return Wc(e) && R0e.call(e, "callee") && !P0e.call(e, "callee");
};
function O0e() {
  return !1;
}
var IG = typeof exports == "object" && exports && !exports.nodeType && exports, q$ = IG && typeof module == "object" && module && !module.nodeType && module, _0e = q$ && q$.exports === IG, ez = _0e ? Eu.Buffer : void 0, D0e = ez ? ez.isBuffer : void 0, rD = D0e || O0e, N0e = "[object Arguments]", M0e = "[object Array]", L0e = "[object Boolean]", F0e = "[object Date]", B0e = "[object Error]", V0e = "[object Function]", $0e = "[object Map]", z0e = "[object Number]", H0e = "[object Object]", j0e = "[object RegExp]", G0e = "[object Set]", W0e = "[object String]", U0e = "[object WeakMap]", X0e = "[object ArrayBuffer]", Z0e = "[object DataView]", Y0e = "[object Float32Array]", J0e = "[object Float64Array]", Q0e = "[object Int8Array]", K0e = "[object Int16Array]", q0e = "[object Int32Array]", eSe = "[object Uint8Array]", tSe = "[object Uint8ClampedArray]", nSe = "[object Uint16Array]", rSe = "[object Uint32Array]", wr = {};
wr[Y0e] = wr[J0e] = wr[Q0e] = wr[K0e] = wr[q0e] = wr[eSe] = wr[tSe] = wr[nSe] = wr[rSe] = !0;
wr[N0e] = wr[M0e] = wr[X0e] = wr[L0e] = wr[Z0e] = wr[F0e] = wr[B0e] = wr[V0e] = wr[$0e] = wr[z0e] = wr[H0e] = wr[j0e] = wr[G0e] = wr[W0e] = wr[U0e] = !1;
function oSe(e) {
  return Wc(e) && EG(e.length) && !!wr[kf(e)];
}
function ST(e) {
  return function(t) {
    return e(t);
  };
}
var AG = typeof exports == "object" && exports && !exports.nodeType && exports, P0 = AG && typeof module == "object" && module && !module.nodeType && module, iSe = P0 && P0.exports === AG, fP = iSe && gG.process, mf = function() {
  try {
    var e = P0 && P0.require && P0.require("util").types;
    return e || fP && fP.binding && fP.binding("util");
  } catch {
  }
}(), tz = mf && mf.isTypedArray, kG = tz ? ST(tz) : oSe, aSe = Object.prototype, sSe = aSe.hasOwnProperty;
function RG(e, t) {
  var n = mg(e), o = !n && BO(e), a = !n && !o && rD(e), l = !n && !o && !a && kG(e), u = n || o || a || l, f = u ? A0e(e.length, String) : [], h = f.length;
  for (var v in e)
    (t || sSe.call(e, v)) && !(u && // Safari 9 has enumerable `arguments.length` in strict mode.
    (v == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    a && (v == "offset" || v == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    l && (v == "buffer" || v == "byteLength" || v == "byteOffset") || // Skip index properties.
    CG(v, h))) && f.push(v);
  return f;
}
function PG(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var lSe = PG(Object.keys, Object), uSe = Object.prototype, cSe = uSe.hasOwnProperty;
function dSe(e) {
  if (!nD(e))
    return lSe(e);
  var t = [];
  for (var n in Object(e))
    cSe.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function oD(e) {
  return bT(e) ? RG(e) : dSe(e);
}
function fSe(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var pSe = Object.prototype, hSe = pSe.hasOwnProperty;
function mSe(e) {
  if (!Cl(e))
    return fSe(e);
  var t = nD(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !hSe.call(e, o)) || n.push(o);
  return n;
}
function wS(e) {
  return bT(e) ? RG(e, !0) : mSe(e);
}
var eS = xh(Object, "create");
function vSe() {
  this.__data__ = eS ? eS(null) : {}, this.size = 0;
}
function gSe(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var ySe = "__lodash_hash_undefined__", bSe = Object.prototype, SSe = bSe.hasOwnProperty;
function xSe(e) {
  var t = this.__data__;
  if (eS) {
    var n = t[e];
    return n === ySe ? void 0 : n;
  }
  return SSe.call(t, e) ? t[e] : void 0;
}
var CSe = Object.prototype, wSe = CSe.hasOwnProperty;
function ESe(e) {
  var t = this.__data__;
  return eS ? t[e] !== void 0 : wSe.call(t, e);
}
var TSe = "__lodash_hash_undefined__";
function ISe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = eS && t === void 0 ? TSe : t, this;
}
function dh(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
dh.prototype.clear = vSe;
dh.prototype.delete = gSe;
dh.prototype.get = xSe;
dh.prototype.has = ESe;
dh.prototype.set = ISe;
function ASe() {
  this.__data__ = [], this.size = 0;
}
function xT(e, t) {
  for (var n = e.length; n--; )
    if (yT(e[n][0], t))
      return n;
  return -1;
}
var kSe = Array.prototype, RSe = kSe.splice;
function PSe(e) {
  var t = this.__data__, n = xT(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : RSe.call(t, n, 1), --this.size, !0;
}
function OSe(e) {
  var t = this.__data__, n = xT(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function _Se(e) {
  return xT(this.__data__, e) > -1;
}
function DSe(e, t) {
  var n = this.__data__, o = xT(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function Uc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Uc.prototype.clear = ASe;
Uc.prototype.delete = PSe;
Uc.prototype.get = OSe;
Uc.prototype.has = _Se;
Uc.prototype.set = DSe;
var tS = xh(Eu, "Map");
function NSe() {
  this.size = 0, this.__data__ = {
    hash: new dh(),
    map: new (tS || Uc)(),
    string: new dh()
  };
}
function MSe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function CT(e, t) {
  var n = e.__data__;
  return MSe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function LSe(e) {
  var t = CT(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function FSe(e) {
  return CT(this, e).get(e);
}
function BSe(e) {
  return CT(this, e).has(e);
}
function VSe(e, t) {
  var n = CT(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Ag(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Ag.prototype.clear = NSe;
Ag.prototype.delete = LSe;
Ag.prototype.get = FSe;
Ag.prototype.has = BSe;
Ag.prototype.set = VSe;
function nz(e) {
  return e == null ? "" : oE(e);
}
function OG(e, t) {
  for (var n = -1, o = t.length, a = e.length; ++n < o; )
    e[a + n] = t[n];
  return e;
}
var $Se = PG(Object.getPrototypeOf, Object);
const iD = $Se;
var zSe = "[object Object]", HSe = Function.prototype, jSe = Object.prototype, _G = HSe.toString, GSe = jSe.hasOwnProperty, WSe = _G.call(Object);
function USe(e) {
  if (!Wc(e) || kf(e) != zSe)
    return !1;
  var t = iD(e);
  if (t === null)
    return !0;
  var n = GSe.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && _G.call(n) == WSe;
}
function XSe(e, t, n) {
  var o = -1, a = e.length;
  t < 0 && (t = -t > a ? 0 : a + t), n = n > a ? a : n, n < 0 && (n += a), a = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var l = Array(a); ++o < a; )
    l[o] = e[o + t];
  return l;
}
function ZSe(e, t, n) {
  var o = e.length;
  return n = n === void 0 ? o : n, !t && n >= o ? e : XSe(e, t, n);
}
var YSe = "\\ud800-\\udfff", JSe = "\\u0300-\\u036f", QSe = "\\ufe20-\\ufe2f", KSe = "\\u20d0-\\u20ff", qSe = JSe + QSe + KSe, e1e = "\\ufe0e\\ufe0f", t1e = "\\u200d", n1e = RegExp("[" + t1e + YSe + qSe + e1e + "]");
function aD(e) {
  return n1e.test(e);
}
function r1e(e) {
  return e.split("");
}
var DG = "\\ud800-\\udfff", o1e = "\\u0300-\\u036f", i1e = "\\ufe20-\\ufe2f", a1e = "\\u20d0-\\u20ff", s1e = o1e + i1e + a1e, l1e = "\\ufe0e\\ufe0f", u1e = "[" + DG + "]", VO = "[" + s1e + "]", $O = "\\ud83c[\\udffb-\\udfff]", c1e = "(?:" + VO + "|" + $O + ")", NG = "[^" + DG + "]", MG = "(?:\\ud83c[\\udde6-\\uddff]){2}", LG = "[\\ud800-\\udbff][\\udc00-\\udfff]", d1e = "\\u200d", FG = c1e + "?", BG = "[" + l1e + "]?", f1e = "(?:" + d1e + "(?:" + [NG, MG, LG].join("|") + ")" + BG + FG + ")*", p1e = BG + FG + f1e, h1e = "(?:" + [NG + VO + "?", VO, MG, LG, u1e].join("|") + ")", m1e = RegExp($O + "(?=" + $O + ")|" + h1e + p1e, "g");
function v1e(e) {
  return e.match(m1e) || [];
}
function g1e(e) {
  return aD(e) ? v1e(e) : r1e(e);
}
function y1e(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
function b1e(e, t, n) {
  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = Cw(n), n = n === n ? n : 0), t !== void 0 && (t = Cw(t), t = t === t ? t : 0), y1e(Cw(e), t, n);
}
function S1e() {
  this.__data__ = new Uc(), this.size = 0;
}
function x1e(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function C1e(e) {
  return this.__data__.get(e);
}
function w1e(e) {
  return this.__data__.has(e);
}
var E1e = 200;
function T1e(e, t) {
  var n = this.__data__;
  if (n instanceof Uc) {
    var o = n.__data__;
    if (!tS || o.length < E1e - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Ag(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Ch(e) {
  var t = this.__data__ = new Uc(e);
  this.size = t.size;
}
Ch.prototype.clear = S1e;
Ch.prototype.delete = x1e;
Ch.prototype.get = C1e;
Ch.prototype.has = w1e;
Ch.prototype.set = T1e;
function I1e(e, t) {
  return e && CS(t, oD(t), e);
}
function A1e(e, t) {
  return e && CS(t, wS(t), e);
}
var VG = typeof exports == "object" && exports && !exports.nodeType && exports, rz = VG && typeof module == "object" && module && !module.nodeType && module, k1e = rz && rz.exports === VG, oz = k1e ? Eu.Buffer : void 0, iz = oz ? oz.allocUnsafe : void 0;
function $G(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = iz ? iz(n) : new e.constructor(n);
  return e.copy(o), o;
}
function R1e(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, a = 0, l = []; ++n < o; ) {
    var u = e[n];
    t(u, n, e) && (l[a++] = u);
  }
  return l;
}
function zG() {
  return [];
}
var P1e = Object.prototype, O1e = P1e.propertyIsEnumerable, az = Object.getOwnPropertySymbols, sD = az ? function(e) {
  return e == null ? [] : (e = Object(e), R1e(az(e), function(t) {
    return O1e.call(e, t);
  }));
} : zG;
function _1e(e, t) {
  return CS(e, sD(e), t);
}
var D1e = Object.getOwnPropertySymbols, HG = D1e ? function(e) {
  for (var t = []; e; )
    OG(t, sD(e)), e = iD(e);
  return t;
} : zG;
function N1e(e, t) {
  return CS(e, HG(e), t);
}
function jG(e, t, n) {
  var o = t(e);
  return mg(e) ? o : OG(o, n(e));
}
function M1e(e) {
  return jG(e, oD, sD);
}
function L1e(e) {
  return jG(e, wS, HG);
}
var zO = xh(Eu, "DataView"), HO = xh(Eu, "Promise"), jO = xh(Eu, "Set"), sz = "[object Map]", F1e = "[object Object]", lz = "[object Promise]", uz = "[object Set]", cz = "[object WeakMap]", dz = "[object DataView]", B1e = Sh(zO), V1e = Sh(tS), $1e = Sh(HO), z1e = Sh(jO), H1e = Sh(FO), Gp = kf;
(zO && Gp(new zO(new ArrayBuffer(1))) != dz || tS && Gp(new tS()) != sz || HO && Gp(HO.resolve()) != lz || jO && Gp(new jO()) != uz || FO && Gp(new FO()) != cz) && (Gp = function(e) {
  var t = kf(e), n = t == F1e ? e.constructor : void 0, o = n ? Sh(n) : "";
  if (o)
    switch (o) {
      case B1e:
        return dz;
      case V1e:
        return sz;
      case $1e:
        return lz;
      case z1e:
        return uz;
      case H1e:
        return cz;
    }
  return t;
});
const lD = Gp;
var j1e = Object.prototype, G1e = j1e.hasOwnProperty;
function W1e(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && G1e.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var fz = Eu.Uint8Array;
function uD(e) {
  var t = new e.constructor(e.byteLength);
  return new fz(t).set(new fz(e)), t;
}
function U1e(e, t) {
  var n = t ? uD(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var X1e = /\w*$/;
function Z1e(e) {
  var t = new e.constructor(e.source, X1e.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var pz = hf ? hf.prototype : void 0, hz = pz ? pz.valueOf : void 0;
function Y1e(e) {
  return hz ? Object(hz.call(e)) : {};
}
function GG(e, t) {
  var n = t ? uD(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var J1e = "[object Boolean]", Q1e = "[object Date]", K1e = "[object Map]", q1e = "[object Number]", exe = "[object RegExp]", txe = "[object Set]", nxe = "[object String]", rxe = "[object Symbol]", oxe = "[object ArrayBuffer]", ixe = "[object DataView]", axe = "[object Float32Array]", sxe = "[object Float64Array]", lxe = "[object Int8Array]", uxe = "[object Int16Array]", cxe = "[object Int32Array]", dxe = "[object Uint8Array]", fxe = "[object Uint8ClampedArray]", pxe = "[object Uint16Array]", hxe = "[object Uint32Array]";
function mxe(e, t, n) {
  var o = e.constructor;
  switch (t) {
    case oxe:
      return uD(e);
    case J1e:
    case Q1e:
      return new o(+e);
    case ixe:
      return U1e(e, n);
    case axe:
    case sxe:
    case lxe:
    case uxe:
    case cxe:
    case dxe:
    case fxe:
    case pxe:
    case hxe:
      return GG(e, n);
    case K1e:
      return new o();
    case q1e:
    case nxe:
      return new o(e);
    case exe:
      return Z1e(e);
    case txe:
      return new o();
    case rxe:
      return Y1e(e);
  }
}
function WG(e) {
  return typeof e.constructor == "function" && !nD(e) ? a0e(iD(e)) : {};
}
var vxe = "[object Map]";
function gxe(e) {
  return Wc(e) && lD(e) == vxe;
}
var mz = mf && mf.isMap, yxe = mz ? ST(mz) : gxe, bxe = "[object Set]";
function Sxe(e) {
  return Wc(e) && lD(e) == bxe;
}
var vz = mf && mf.isSet, xxe = vz ? ST(vz) : Sxe, Cxe = 1, wxe = 2, Exe = 4, UG = "[object Arguments]", Txe = "[object Array]", Ixe = "[object Boolean]", Axe = "[object Date]", kxe = "[object Error]", XG = "[object Function]", Rxe = "[object GeneratorFunction]", Pxe = "[object Map]", Oxe = "[object Number]", ZG = "[object Object]", _xe = "[object RegExp]", Dxe = "[object Set]", Nxe = "[object String]", Mxe = "[object Symbol]", Lxe = "[object WeakMap]", Fxe = "[object ArrayBuffer]", Bxe = "[object DataView]", Vxe = "[object Float32Array]", $xe = "[object Float64Array]", zxe = "[object Int8Array]", Hxe = "[object Int16Array]", jxe = "[object Int32Array]", Gxe = "[object Uint8Array]", Wxe = "[object Uint8ClampedArray]", Uxe = "[object Uint16Array]", Xxe = "[object Uint32Array]", vr = {};
vr[UG] = vr[Txe] = vr[Fxe] = vr[Bxe] = vr[Ixe] = vr[Axe] = vr[Vxe] = vr[$xe] = vr[zxe] = vr[Hxe] = vr[jxe] = vr[Pxe] = vr[Oxe] = vr[ZG] = vr[_xe] = vr[Dxe] = vr[Nxe] = vr[Mxe] = vr[Gxe] = vr[Wxe] = vr[Uxe] = vr[Xxe] = !0;
vr[kxe] = vr[XG] = vr[Lxe] = !1;
function ww(e, t, n, o, a, l) {
  var u, f = t & Cxe, h = t & wxe, v = t & Exe;
  if (n && (u = a ? n(e, o, a, l) : n(e)), u !== void 0)
    return u;
  if (!Cl(e))
    return e;
  var g = mg(e);
  if (g) {
    if (u = W1e(e), !f)
      return xG(e, u);
  } else {
    var b = lD(e), S = b == XG || b == Rxe;
    if (rD(e))
      return $G(e, f);
    if (b == ZG || b == UG || S && !a) {
      if (u = h || S ? {} : WG(e), !f)
        return h ? N1e(e, A1e(u, e)) : _1e(e, I1e(u, e));
    } else {
      if (!vr[b])
        return a ? e : {};
      u = mxe(e, b, f);
    }
  }
  l || (l = new Ch());
  var w = l.get(e);
  if (w)
    return w;
  l.set(e, u), xxe(e) ? e.forEach(function(A) {
    u.add(ww(A, t, n, A, e, l));
  }) : yxe(e) && e.forEach(function(A, P) {
    u.set(P, ww(A, t, n, P, e, l));
  });
  var E = v ? h ? L1e : M1e : h ? wS : oD, T = g ? void 0 : E(e);
  return v0e(T || e, function(A, P) {
    T && (P = A, A = e[P]), wG(u, P, ww(A, t, n, P, e, l));
  }), u;
}
var Zxe = 1, Yxe = 4;
function Jxe(e) {
  return ww(e, Zxe | Yxe);
}
function Qxe(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function Kxe(e) {
  return function(t, n, o) {
    for (var a = -1, l = Object(t), u = o(t), f = u.length; f--; ) {
      var h = u[e ? f : ++a];
      if (n(l[h], h, l) === !1)
        break;
    }
    return t;
  };
}
var qxe = Kxe();
function GO(e, t, n) {
  (n !== void 0 && !yT(e[t], n) || n === void 0 && !(t in e)) && tD(e, t, n);
}
function eCe(e) {
  return Wc(e) && bT(e);
}
function WO(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function tCe(e) {
  return CS(e, wS(e));
}
function nCe(e, t, n, o, a, l, u) {
  var f = WO(e, n), h = WO(t, n), v = u.get(h);
  if (v) {
    GO(e, n, v);
    return;
  }
  var g = l ? l(f, h, n + "", e, t, u) : void 0, b = g === void 0;
  if (b) {
    var S = mg(h), w = !S && rD(h), E = !S && !w && kG(h);
    g = h, S || w || E ? mg(f) ? g = f : eCe(f) ? g = xG(f) : w ? (b = !1, g = $G(h, !0)) : E ? (b = !1, g = GG(h, !0)) : g = [] : USe(h) || BO(h) ? (g = f, BO(f) ? g = tCe(f) : (!Cl(f) || eD(f)) && (g = WG(h))) : b = !1;
  }
  b && (u.set(h, g), a(g, h, o, l, u), u.delete(h)), GO(e, n, g);
}
function YG(e, t, n, o, a) {
  e !== t && qxe(t, function(l, u) {
    if (a || (a = new Ch()), Cl(l))
      nCe(e, t, u, n, YG, o, a);
    else {
      var f = o ? o(WO(e, u), l, u + "", e, t, a) : void 0;
      f === void 0 && (f = l), GO(e, u, f);
    }
  }, wS);
}
function rCe(e) {
  return e == null;
}
var oCe = "[object RegExp]";
function iCe(e) {
  return Wc(e) && kf(e) == oCe;
}
var gz = mf && mf.isRegExp, aCe = gz ? ST(gz) : iCe, sCe = T0e(function(e, t, n) {
  YG(e, t, n);
});
const lCe = sCe;
var uCe = Qxe("length"), JG = "\\ud800-\\udfff", cCe = "\\u0300-\\u036f", dCe = "\\ufe20-\\ufe2f", fCe = "\\u20d0-\\u20ff", pCe = cCe + dCe + fCe, hCe = "\\ufe0e\\ufe0f", mCe = "[" + JG + "]", UO = "[" + pCe + "]", XO = "\\ud83c[\\udffb-\\udfff]", vCe = "(?:" + UO + "|" + XO + ")", QG = "[^" + JG + "]", KG = "(?:\\ud83c[\\udde6-\\uddff]){2}", qG = "[\\ud800-\\udbff][\\udc00-\\udfff]", gCe = "\\u200d", eW = vCe + "?", tW = "[" + hCe + "]?", yCe = "(?:" + gCe + "(?:" + [QG, KG, qG].join("|") + ")" + tW + eW + ")*", bCe = tW + eW + yCe, SCe = "(?:" + [QG + UO + "?", UO, KG, qG, mCe].join("|") + ")", yz = RegExp(XO + "(?=" + XO + ")|" + SCe + bCe, "g");
function xCe(e) {
  for (var t = yz.lastIndex = 0; yz.test(e); )
    ++t;
  return t;
}
function CCe(e) {
  return aD(e) ? xCe(e) : uCe(e);
}
var wCe = 30, ECe = "...", TCe = /\w*$/;
function ICe(e, t) {
  var n = wCe, o = ECe;
  if (Cl(t)) {
    var a = "separator" in t ? t.separator : a;
    n = "length" in t ? jbe(t.length) : n, o = "omission" in t ? oE(t.omission) : o;
  }
  e = nz(e);
  var l = e.length;
  if (aD(e)) {
    var u = g1e(e);
    l = u.length;
  }
  if (n >= l)
    return e;
  var f = n - CCe(o);
  if (f < 1)
    return o;
  var h = u ? ZSe(u, 0, f).join("") : e.slice(0, f);
  if (a === void 0)
    return h + o;
  if (u && (f += h.length - f), aCe(a)) {
    if (e.slice(f).search(a)) {
      var v, g = h;
      for (a.global || (a = RegExp(a.source, nz(TCe.exec(a)) + "g")), a.lastIndex = 0; v = a.exec(g); )
        var b = v.index;
      h = h.slice(0, b === void 0 ? f : b);
    }
  } else if (e.indexOf(oE(a), f) != f) {
    var S = h.lastIndexOf(a);
    S > -1 && (h = h.slice(0, S));
  }
  return h + o;
}
const ACe = (e) => {
  e.preventDefault();
}, cD = (e) => {
  e.stopPropagation();
}, rr = G5, nW = rr(
  Le((e, t) => {
    const { children: n, badges: o, ...a } = e, l = gt(
      () => o == null ? void 0 : o.map((u) => ICe(String(u), { length: 24, omission: "..." })),
      [o]
    );
    return /* @__PURE__ */ Nt(j9, { ref: t, ...a, children: [
      n,
      /* @__PURE__ */ M(V2, {}),
      l == null ? void 0 : l.map((u, f) => /* @__PURE__ */ M(z2, { colorScheme: "appBlue", children: u }, `${u}.${f}`)),
      /* @__PURE__ */ M(G9, {})
    ] });
  })
);
nW.displayName = "AccordionButton";
const kCe = rr((e) => {
  const t = re(
    (n) => {
      n.preventDefault(), e.onToggle();
    },
    [e]
  );
  return /* @__PURE__ */ M(Y9, { index: e.isOpen ? 0 : void 0, allowToggle: !0, children: /* @__PURE__ */ Nt(W9, { children: [
    /* @__PURE__ */ M(nW, { badges: e.badges, onClick: t, children: e.label }),
    /* @__PURE__ */ M(Z9, { children: e.children })
  ] }) });
});
kCe.displayName = "StandaloneAccordion";
function RCe() {
  if (console && console.warn) {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    typeof t[0] == "string" && (t[0] = `react-i18next:: ${t[0]}`), console.warn(...t);
  }
}
const bz = {};
function ZO() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  typeof t[0] == "string" && bz[t[0]] || (typeof t[0] == "string" && (bz[t[0]] = /* @__PURE__ */ new Date()), RCe(...t));
}
const rW = (e, t) => () => {
  if (e.isInitialized)
    t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), t();
    };
    e.on("initialized", n);
  }
};
function Sz(e, t, n) {
  e.loadNamespaces(t, rW(e, n));
}
function xz(e, t, n, o) {
  typeof n == "string" && (n = [n]), n.forEach((a) => {
    e.options.ns.indexOf(a) < 0 && e.options.ns.push(a);
  }), e.loadLanguages(t, rW(e, o));
}
function PCe(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const o = t.languages[0], a = t.options ? t.options.fallbackLng : !1, l = t.languages[t.languages.length - 1];
  if (o.toLowerCase() === "cimode")
    return !0;
  const u = (f, h) => {
    const v = t.services.backendConnector.state[`${f}|${h}`];
    return v === -1 || v === 2;
  };
  return n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !u(t.isLanguageChangingTo, e) ? !1 : !!(t.hasResourceBundle(o, e) || !t.services.backendConnector.backend || t.options.resources && !t.options.partialBundledLanguages || u(o, e) && (!a || u(l, e)));
}
function OCe(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !t.languages || !t.languages.length ? (ZO("i18n.languages were undefined or empty", t.languages), !0) : t.options.ignoreJSONStructure !== void 0 ? t.hasLoadedNamespace(e, {
    lng: n.lng,
    precheck: (a, l) => {
      if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && a.services.backendConnector.backend && a.isLanguageChangingTo && !l(a.isLanguageChangingTo, e))
        return !1;
    }
  }) : PCe(e, t, n);
}
const _Ce = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, DCe = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}, NCe = (e) => DCe[e], MCe = (e) => e.replace(_Ce, NCe);
let LCe = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: MCe
};
function FCe() {
  return LCe;
}
let BCe;
function VCe() {
  return BCe;
}
const $Ce = wa();
class zCe {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const HCe = (e, t) => {
  const n = Ue();
  return dt(() => {
    n.current = t ? n.current : e;
  }, [e, t]), n.current;
};
function dD(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: n
  } = t, {
    i18n: o,
    defaultNS: a
  } = dr($Ce) || {}, l = n || o || VCe();
  if (l && !l.reportNamespaces && (l.reportNamespaces = new zCe()), !l) {
    ZO("You will need to pass in an i18next instance by using initReactI18next");
    const D = (F, V) => typeof V == "string" ? V : V && typeof V == "object" && typeof V.defaultValue == "string" ? V.defaultValue : Array.isArray(F) ? F[F.length - 1] : F, L = [D, {}, !1];
    return L.t = D, L.i18n = {}, L.ready = !1, L;
  }
  l.options.react && l.options.react.wait !== void 0 && ZO("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const u = {
    ...FCe(),
    ...l.options.react,
    ...t
  }, {
    useSuspense: f,
    keyPrefix: h
  } = u;
  let v = e || a || l.options && l.options.defaultNS;
  v = typeof v == "string" ? [v] : v || ["translation"], l.reportNamespaces.addUsedNamespaces && l.reportNamespaces.addUsedNamespaces(v);
  const g = (l.isInitialized || l.initializedStoreOnce) && v.every((D) => OCe(D, l, u));
  function b() {
    return l.getFixedT(t.lng || null, u.nsMode === "fallback" ? v : v[0], h);
  }
  const [S, w] = ot(b);
  let E = v.join();
  t.lng && (E = `${t.lng}${E}`);
  const T = HCe(E), A = Ue(!0);
  dt(() => {
    const {
      bindI18n: D,
      bindI18nStore: L
    } = u;
    A.current = !0, !g && !f && (t.lng ? xz(l, t.lng, v, () => {
      A.current && w(b);
    }) : Sz(l, v, () => {
      A.current && w(b);
    })), g && T && T !== E && A.current && w(b);
    function F() {
      A.current && w(b);
    }
    return D && l && l.on(D, F), L && l && l.store.on(L, F), () => {
      A.current = !1, D && l && D.split(" ").forEach((V) => l.off(V, F)), L && l && L.split(" ").forEach((V) => l.store.off(V, F));
    };
  }, [l, E]);
  const P = Ue(!0);
  dt(() => {
    A.current && !P.current && w(b), P.current = !1;
  }, [l, h]);
  const _ = [S, l, g];
  if (_.t = S, _.i18n = l, _.ready = g, g || !g && !f)
    return _;
  throw new Promise((D) => {
    t.lng ? xz(l, t.lng, v, () => D()) : Sz(l, v, () => D());
  });
}
const jCe = [
  {
    name: "preventOverflow",
    options: {
      padding: 12
    }
  }
], Fc = rr(
  Le((e, t) => {
    const { children: n, hasArrow: o = !0, placement: a = "top", ...l } = e;
    return /* @__PURE__ */ M(vG, { ref: t, hasArrow: o, placement: a, arrowSize: 8, modifiers: jCe, ...l, children: n });
  })
);
Fc.displayName = "Tooltip";
const YO = rr(
  Le(({ isChecked: e, tooltip: t, children: n, ...o }, a) => t ? /* @__PURE__ */ M(Fc, { label: t, children: /* @__PURE__ */ M(Qw, { ref: a, colorScheme: e ? "appBlue" : "base", ...o, children: n }) }) : /* @__PURE__ */ M(Qw, { ref: a, colorScheme: e ? "appBlue" : "base", ...o, children: n }))
);
YO.displayName = "Button";
const GCe = rr(
  Le(({ isAttached: e = !0, ...t }, n) => /* @__PURE__ */ M(J9, { ref: n, isAttached: e, ...t }))
);
GCe.displayName = "ButtonGroup";
const oW = rr(
  Le(({ isChecked: e, tooltip: t, ...n }, o) => t ? /* @__PURE__ */ M(Fc, { label: t, children: /* @__PURE__ */ M(vO, { ref: o, colorScheme: e ? "appBlue" : "base", ...n }) }) : /* @__PURE__ */ M(vO, { ref: o, colorScheme: e ? "appBlue" : "base", ...n }))
);
oW.displayName = "IconButton";
const pDe = rr((e) => {
  const { t } = dD(), {
    acceptCallback: n,
    cancelCallback: o,
    acceptButtonText: a = t("common.accept", "Accept"),
    cancelButtonText: l = t("common.cancel", "Cancel"),
    children: u,
    title: f,
    isOpen: h,
    onClose: v
  } = e, g = Ue(null), b = re(() => {
    n(), v();
  }, [n, v]), S = re(() => {
    o && o(), v();
  }, [o, v]);
  return /* @__PURE__ */ M(sge, { isOpen: h, leastDestructiveRef: g, onClose: v, isCentered: !0, children: /* @__PURE__ */ M(Lj, { children: /* @__PURE__ */ Nt(lge, { children: [
    /* @__PURE__ */ M(Mj, { fontSize: "lg", fontWeight: "bold", children: f }),
    /* @__PURE__ */ M(Fj, { children: u }),
    /* @__PURE__ */ Nt(Nj, { children: [
      /* @__PURE__ */ M(YO, { ref: g, onClick: S, children: l }),
      /* @__PURE__ */ M(YO, { colorScheme: "error", onClick: b, ml: 3, children: a })
    ] })
  ] }) }) });
});
function Cz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function $t(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cz(Object(n), !0).forEach(function(o) {
      Vv(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cz(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function WCe(e) {
  if (Array.isArray(e))
    return e;
}
function UCe(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o, a, l, u, f = [], h = !0, v = !1;
    try {
      if (l = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n)
          return;
        h = !1;
      } else
        for (; !(h = (o = l.call(n)).done) && (f.push(o.value), f.length !== t); h = !0)
          ;
    } catch (g) {
      v = !0, a = g;
    } finally {
      try {
        if (!h && n.return != null && (u = n.return(), Object(u) !== u))
          return;
      } finally {
        if (v)
          throw a;
      }
    }
    return f;
  }
}
function JO(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function iW(e, t) {
  if (e) {
    if (typeof e == "string")
      return JO(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return JO(e, t);
  }
}
function XCe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Oc(e, t) {
  return WCe(e) || UCe(e, t) || iW(e, t) || XCe();
}
function Xc(e, t) {
  if (e == null)
    return {};
  var n = sH(e, t), o, a;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (a = 0; a < l.length; a++)
      o = l[a], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
var ZCe = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function YCe(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, o = e.defaultMenuIsOpen, a = o === void 0 ? !1 : o, l = e.defaultValue, u = l === void 0 ? null : l, f = e.inputValue, h = e.menuIsOpen, v = e.onChange, g = e.onInputChange, b = e.onMenuClose, S = e.onMenuOpen, w = e.value, E = Xc(e, ZCe), T = ot(f !== void 0 ? f : n), A = Oc(T, 2), P = A[0], _ = A[1], D = ot(h !== void 0 ? h : a), L = Oc(D, 2), F = L[0], V = L[1], $ = ot(w !== void 0 ? w : u), U = Oc($, 2), W = U[0], H = U[1], G = re(function(Q, ge) {
    typeof v == "function" && v(Q, ge), H(Q);
  }, [v]), oe = re(function(Q, ge) {
    var Y;
    typeof g == "function" && (Y = g(Q, ge)), _(Y !== void 0 ? Y : Q);
  }, [g]), ce = re(function() {
    typeof S == "function" && S(), V(!0);
  }, [S]), te = re(function() {
    typeof b == "function" && b(), V(!1);
  }, [b]), Ee = f !== void 0 ? f : P, me = h !== void 0 ? h : F, J = w !== void 0 ? w : W;
  return $t($t({}, E), {}, {
    inputValue: Ee,
    menuIsOpen: me,
    onChange: G,
    onInputChange: oe,
    onMenuClose: te,
    onMenuOpen: ce,
    value: J
  });
}
function JCe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wz(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, SH(o.key), o);
  }
}
function QCe(e, t, n) {
  return t && wz(e.prototype, t), n && wz(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function KCe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && qw(e, t);
}
function aE(e) {
  return aE = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, aE(e);
}
function aW() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (aW = function() {
    return !!e;
  })();
}
function qCe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ewe(e, t) {
  if (t && (lh(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return qCe(e);
}
function twe(e) {
  var t = aW();
  return function() {
    var o = aE(e), a;
    if (t) {
      var l = aE(this).constructor;
      a = Reflect.construct(o, arguments, l);
    } else
      a = o.apply(this, arguments);
    return ewe(this, a);
  };
}
function nwe(e) {
  if (Array.isArray(e))
    return JO(e);
}
function rwe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function owe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sW(e) {
  return nwe(e) || rwe(e) || iW(e) || owe();
}
function iwe(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
const vf = Math.min, za = Math.max, sE = Math.round, $C = Math.floor, gf = (e) => ({
  x: e,
  y: e
}), awe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, swe = {
  start: "end",
  end: "start"
};
function QO(e, t, n) {
  return za(e, vf(t, n));
}
function kg(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function yf(e) {
  return e.split("-")[0];
}
function Rg(e) {
  return e.split("-")[1];
}
function lW(e) {
  return e === "x" ? "y" : "x";
}
function fD(e) {
  return e === "y" ? "height" : "width";
}
function ES(e) {
  return ["top", "bottom"].includes(yf(e)) ? "y" : "x";
}
function pD(e) {
  return lW(ES(e));
}
function lwe(e, t, n) {
  n === void 0 && (n = !1);
  const o = Rg(e), a = pD(e), l = fD(a);
  let u = a === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[l] > t.floating[l] && (u = lE(u)), [u, lE(u)];
}
function uwe(e) {
  const t = lE(e);
  return [KO(e), t, KO(t)];
}
function KO(e) {
  return e.replace(/start|end/g, (t) => swe[t]);
}
function cwe(e, t, n) {
  const o = ["left", "right"], a = ["right", "left"], l = ["top", "bottom"], u = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? a : o : t ? o : a;
    case "left":
    case "right":
      return t ? l : u;
    default:
      return [];
  }
}
function dwe(e, t, n, o) {
  const a = Rg(e);
  let l = cwe(yf(e), n === "start", o);
  return a && (l = l.map((u) => u + "-" + a), t && (l = l.concat(l.map(KO)))), l;
}
function lE(e) {
  return e.replace(/left|right|bottom|top/g, (t) => awe[t]);
}
function fwe(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function uW(e) {
  return typeof e != "number" ? fwe(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function uE(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function Ez(e, t, n) {
  let {
    reference: o,
    floating: a
  } = e;
  const l = ES(t), u = pD(t), f = fD(u), h = yf(t), v = l === "y", g = o.x + o.width / 2 - a.width / 2, b = o.y + o.height / 2 - a.height / 2, S = o[f] / 2 - a[f] / 2;
  let w;
  switch (h) {
    case "top":
      w = {
        x: g,
        y: o.y - a.height
      };
      break;
    case "bottom":
      w = {
        x: g,
        y: o.y + o.height
      };
      break;
    case "right":
      w = {
        x: o.x + o.width,
        y: b
      };
      break;
    case "left":
      w = {
        x: o.x - a.width,
        y: b
      };
      break;
    default:
      w = {
        x: o.x,
        y: o.y
      };
  }
  switch (Rg(t)) {
    case "start":
      w[u] -= S * (n && v ? -1 : 1);
      break;
    case "end":
      w[u] += S * (n && v ? -1 : 1);
      break;
  }
  return w;
}
const pwe = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: a = "absolute",
    middleware: l = [],
    platform: u
  } = n, f = l.filter(Boolean), h = await (u.isRTL == null ? void 0 : u.isRTL(t));
  let v = await u.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: g,
    y: b
  } = Ez(v, o, h), S = o, w = {}, E = 0;
  for (let T = 0; T < f.length; T++) {
    const {
      name: A,
      fn: P
    } = f[T], {
      x: _,
      y: D,
      data: L,
      reset: F
    } = await P({
      x: g,
      y: b,
      initialPlacement: o,
      placement: S,
      strategy: a,
      middlewareData: w,
      rects: v,
      platform: u,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (g = _ ?? g, b = D ?? b, w = {
      ...w,
      [A]: {
        ...w[A],
        ...L
      }
    }, F && E <= 50) {
      E++, typeof F == "object" && (F.placement && (S = F.placement), F.rects && (v = F.rects === !0 ? await u.getElementRects({
        reference: e,
        floating: t,
        strategy: a
      }) : F.rects), {
        x: g,
        y: b
      } = Ez(v, S, h)), T = -1;
      continue;
    }
  }
  return {
    x: g,
    y: b,
    placement: S,
    strategy: a,
    middlewareData: w
  };
};
async function hD(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: a,
    platform: l,
    rects: u,
    elements: f,
    strategy: h
  } = e, {
    boundary: v = "clippingAncestors",
    rootBoundary: g = "viewport",
    elementContext: b = "floating",
    altBoundary: S = !1,
    padding: w = 0
  } = kg(t, e), E = uW(w), A = f[S ? b === "floating" ? "reference" : "floating" : b], P = uE(await l.getClippingRect({
    element: (n = await (l.isElement == null ? void 0 : l.isElement(A))) == null || n ? A : A.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)),
    boundary: v,
    rootBoundary: g,
    strategy: h
  })), _ = b === "floating" ? {
    ...u.floating,
    x: o,
    y: a
  } : u.reference, D = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), L = await (l.isElement == null ? void 0 : l.isElement(D)) ? await (l.getScale == null ? void 0 : l.getScale(D)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, F = uE(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: _,
    offsetParent: D,
    strategy: h
  }) : _);
  return {
    top: (P.top - F.top + E.top) / L.y,
    bottom: (F.bottom - P.bottom + E.bottom) / L.y,
    left: (P.left - F.left + E.left) / L.x,
    right: (F.right - P.right + E.right) / L.x
  };
}
const hwe = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: a,
      rects: l,
      platform: u,
      elements: f,
      middlewareData: h
    } = t, {
      element: v,
      padding: g = 0
    } = kg(e, t) || {};
    if (v == null)
      return {};
    const b = uW(g), S = {
      x: n,
      y: o
    }, w = pD(a), E = fD(w), T = await u.getDimensions(v), A = w === "y", P = A ? "top" : "left", _ = A ? "bottom" : "right", D = A ? "clientHeight" : "clientWidth", L = l.reference[E] + l.reference[w] - S[w] - l.floating[E], F = S[w] - l.reference[w], V = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(v));
    let $ = V ? V[D] : 0;
    (!$ || !await (u.isElement == null ? void 0 : u.isElement(V))) && ($ = f.floating[D] || l.floating[E]);
    const U = L / 2 - F / 2, W = $ / 2 - T[E] / 2 - 1, H = vf(b[P], W), G = vf(b[_], W), oe = H, ce = $ - T[E] - G, te = $ / 2 - T[E] / 2 + U, Ee = QO(oe, te, ce), me = !h.arrow && Rg(a) != null && te != Ee && l.reference[E] / 2 - (te < oe ? H : G) - T[E] / 2 < 0, J = me ? te < oe ? te - oe : te - ce : 0;
    return {
      [w]: S[w] + J,
      data: {
        [w]: Ee,
        centerOffset: te - Ee - J,
        ...me && {
          alignmentOffset: J
        }
      },
      reset: me
    };
  }
}), mwe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: a,
        middlewareData: l,
        rects: u,
        initialPlacement: f,
        platform: h,
        elements: v
      } = t, {
        mainAxis: g = !0,
        crossAxis: b = !0,
        fallbackPlacements: S,
        fallbackStrategy: w = "bestFit",
        fallbackAxisSideDirection: E = "none",
        flipAlignment: T = !0,
        ...A
      } = kg(e, t);
      if ((n = l.arrow) != null && n.alignmentOffset)
        return {};
      const P = yf(a), _ = yf(f) === f, D = await (h.isRTL == null ? void 0 : h.isRTL(v.floating)), L = S || (_ || !T ? [lE(f)] : uwe(f));
      !S && E !== "none" && L.push(...dwe(f, T, E, D));
      const F = [f, ...L], V = await hD(t, A), $ = [];
      let U = ((o = l.flip) == null ? void 0 : o.overflows) || [];
      if (g && $.push(V[P]), b) {
        const oe = lwe(a, u, D);
        $.push(V[oe[0]], V[oe[1]]);
      }
      if (U = [...U, {
        placement: a,
        overflows: $
      }], !$.every((oe) => oe <= 0)) {
        var W, H;
        const oe = (((W = l.flip) == null ? void 0 : W.index) || 0) + 1, ce = F[oe];
        if (ce)
          return {
            data: {
              index: oe,
              overflows: U
            },
            reset: {
              placement: ce
            }
          };
        let te = (H = U.filter((Ee) => Ee.overflows[0] <= 0).sort((Ee, me) => Ee.overflows[1] - me.overflows[1])[0]) == null ? void 0 : H.placement;
        if (!te)
          switch (w) {
            case "bestFit": {
              var G;
              const Ee = (G = U.map((me) => [me.placement, me.overflows.filter((J) => J > 0).reduce((J, Q) => J + Q, 0)]).sort((me, J) => me[1] - J[1])[0]) == null ? void 0 : G[0];
              Ee && (te = Ee);
              break;
            }
            case "initialPlacement":
              te = f;
              break;
          }
        if (a !== te)
          return {
            reset: {
              placement: te
            }
          };
      }
      return {};
    }
  };
};
async function vwe(e, t) {
  const {
    placement: n,
    platform: o,
    elements: a
  } = e, l = await (o.isRTL == null ? void 0 : o.isRTL(a.floating)), u = yf(n), f = Rg(n), h = ES(n) === "y", v = ["left", "top"].includes(u) ? -1 : 1, g = l && h ? -1 : 1, b = kg(t, e);
  let {
    mainAxis: S,
    crossAxis: w,
    alignmentAxis: E
  } = typeof b == "number" ? {
    mainAxis: b,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...b
  };
  return f && typeof E == "number" && (w = f === "end" ? E * -1 : E), h ? {
    x: w * g,
    y: S * v
  } : {
    x: S * v,
    y: w * g
  };
}
const gwe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: a,
        y: l,
        placement: u,
        middlewareData: f
      } = t, h = await vwe(t, e);
      return u === ((n = f.offset) == null ? void 0 : n.placement) && (o = f.arrow) != null && o.alignmentOffset ? {} : {
        x: a + h.x,
        y: l + h.y,
        data: {
          ...h,
          placement: u
        }
      };
    }
  };
}, ywe = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: a
      } = t, {
        mainAxis: l = !0,
        crossAxis: u = !1,
        limiter: f = {
          fn: (A) => {
            let {
              x: P,
              y: _
            } = A;
            return {
              x: P,
              y: _
            };
          }
        },
        ...h
      } = kg(e, t), v = {
        x: n,
        y: o
      }, g = await hD(t, h), b = ES(yf(a)), S = lW(b);
      let w = v[S], E = v[b];
      if (l) {
        const A = S === "y" ? "top" : "left", P = S === "y" ? "bottom" : "right", _ = w + g[A], D = w - g[P];
        w = QO(_, w, D);
      }
      if (u) {
        const A = b === "y" ? "top" : "left", P = b === "y" ? "bottom" : "right", _ = E + g[A], D = E - g[P];
        E = QO(_, E, D);
      }
      const T = f.fn({
        ...t,
        [S]: w,
        [b]: E
      });
      return {
        ...T,
        data: {
          x: T.x - n,
          y: T.y - o
        }
      };
    }
  };
}, bwe = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: o,
        platform: a,
        elements: l
      } = t, {
        apply: u = () => {
        },
        ...f
      } = kg(e, t), h = await hD(t, f), v = yf(n), g = Rg(n), b = ES(n) === "y", {
        width: S,
        height: w
      } = o.floating;
      let E, T;
      v === "top" || v === "bottom" ? (E = v, T = g === (await (a.isRTL == null ? void 0 : a.isRTL(l.floating)) ? "start" : "end") ? "left" : "right") : (T = v, E = g === "end" ? "top" : "bottom");
      const A = w - h[E], P = S - h[T], _ = !t.middlewareData.shift;
      let D = A, L = P;
      if (b) {
        const V = S - h.left - h.right;
        L = g || _ ? vf(P, V) : V;
      } else {
        const V = w - h.top - h.bottom;
        D = g || _ ? vf(A, V) : V;
      }
      if (_ && !g) {
        const V = za(h.left, 0), $ = za(h.right, 0), U = za(h.top, 0), W = za(h.bottom, 0);
        b ? L = S - 2 * (V !== 0 || $ !== 0 ? V + $ : za(h.left, h.right)) : D = w - 2 * (U !== 0 || W !== 0 ? U + W : za(h.top, h.bottom));
      }
      await u({
        ...t,
        availableWidth: L,
        availableHeight: D
      });
      const F = await a.getDimensions(l.floating);
      return S !== F.width || w !== F.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function bf(e) {
  return cW(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Wa(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Zc(e) {
  var t;
  return (t = (cW(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function cW(e) {
  return e instanceof Node || e instanceof Wa(e).Node;
}
function Bc(e) {
  return e instanceof Element || e instanceof Wa(e).Element;
}
function bu(e) {
  return e instanceof HTMLElement || e instanceof Wa(e).HTMLElement;
}
function Tz(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Wa(e).ShadowRoot;
}
function TS(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: a
  } = As(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(a);
}
function Swe(e) {
  return ["table", "td", "th"].includes(bf(e));
}
function mD(e) {
  const t = vD(), n = As(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function xwe(e) {
  let t = vg(e);
  for (; bu(t) && !wT(t); ) {
    if (mD(t))
      return t;
    t = vg(t);
  }
  return null;
}
function vD() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function wT(e) {
  return ["html", "body", "#document"].includes(bf(e));
}
function As(e) {
  return Wa(e).getComputedStyle(e);
}
function ET(e) {
  return Bc(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function vg(e) {
  if (bf(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Tz(e) && e.host || // Fallback.
    Zc(e)
  );
  return Tz(t) ? t.host : t;
}
function dW(e) {
  const t = vg(e);
  return wT(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : bu(t) && TS(t) ? t : dW(t);
}
function gg(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const a = dW(e), l = a === ((o = e.ownerDocument) == null ? void 0 : o.body), u = Wa(a);
  return l ? t.concat(u, u.visualViewport || [], TS(a) ? a : [], u.frameElement && n ? gg(u.frameElement) : []) : t.concat(a, gg(a, [], n));
}
function fW(e) {
  const t = As(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const a = bu(e), l = a ? e.offsetWidth : n, u = a ? e.offsetHeight : o, f = sE(n) !== l || sE(o) !== u;
  return f && (n = l, o = u), {
    width: n,
    height: o,
    $: f
  };
}
function gD(e) {
  return Bc(e) ? e : e.contextElement;
}
function tg(e) {
  const t = gD(e);
  if (!bu(t))
    return gf(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: a,
    $: l
  } = fW(t);
  let u = (l ? sE(n.width) : n.width) / o, f = (l ? sE(n.height) : n.height) / a;
  return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), {
    x: u,
    y: f
  };
}
const Cwe = /* @__PURE__ */ gf(0);
function pW(e) {
  const t = Wa(e);
  return !vD() || !t.visualViewport ? Cwe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function wwe(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Wa(e) ? !1 : t;
}
function fh(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), l = gD(e);
  let u = gf(1);
  t && (o ? Bc(o) && (u = tg(o)) : u = tg(e));
  const f = wwe(l, n, o) ? pW(l) : gf(0);
  let h = (a.left + f.x) / u.x, v = (a.top + f.y) / u.y, g = a.width / u.x, b = a.height / u.y;
  if (l) {
    const S = Wa(l), w = o && Bc(o) ? Wa(o) : o;
    let E = S.frameElement;
    for (; E && o && w !== S; ) {
      const T = tg(E), A = E.getBoundingClientRect(), P = As(E), _ = A.left + (E.clientLeft + parseFloat(P.paddingLeft)) * T.x, D = A.top + (E.clientTop + parseFloat(P.paddingTop)) * T.y;
      h *= T.x, v *= T.y, g *= T.x, b *= T.y, h += _, v += D, E = Wa(E).frameElement;
    }
  }
  return uE({
    width: g,
    height: b,
    x: h,
    y: v
  });
}
function Ewe(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: o
  } = e;
  const a = bu(n), l = Zc(n);
  if (n === l)
    return t;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = gf(1);
  const h = gf(0);
  if ((a || !a && o !== "fixed") && ((bf(n) !== "body" || TS(l)) && (u = ET(n)), bu(n))) {
    const v = fh(n);
    f = tg(n), h.x = v.x + n.clientLeft, h.y = v.y + n.clientTop;
  }
  return {
    width: t.width * f.x,
    height: t.height * f.y,
    x: t.x * f.x - u.scrollLeft * f.x + h.x,
    y: t.y * f.y - u.scrollTop * f.y + h.y
  };
}
function Twe(e) {
  return Array.from(e.getClientRects());
}
function hW(e) {
  return fh(Zc(e)).left + ET(e).scrollLeft;
}
function Iwe(e) {
  const t = Zc(e), n = ET(e), o = e.ownerDocument.body, a = za(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), l = za(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let u = -n.scrollLeft + hW(e);
  const f = -n.scrollTop;
  return As(o).direction === "rtl" && (u += za(t.clientWidth, o.clientWidth) - a), {
    width: a,
    height: l,
    x: u,
    y: f
  };
}
function Awe(e, t) {
  const n = Wa(e), o = Zc(e), a = n.visualViewport;
  let l = o.clientWidth, u = o.clientHeight, f = 0, h = 0;
  if (a) {
    l = a.width, u = a.height;
    const v = vD();
    (!v || v && t === "fixed") && (f = a.offsetLeft, h = a.offsetTop);
  }
  return {
    width: l,
    height: u,
    x: f,
    y: h
  };
}
function kwe(e, t) {
  const n = fh(e, !0, t === "fixed"), o = n.top + e.clientTop, a = n.left + e.clientLeft, l = bu(e) ? tg(e) : gf(1), u = e.clientWidth * l.x, f = e.clientHeight * l.y, h = a * l.x, v = o * l.y;
  return {
    width: u,
    height: f,
    x: h,
    y: v
  };
}
function Iz(e, t, n) {
  let o;
  if (t === "viewport")
    o = Awe(e, n);
  else if (t === "document")
    o = Iwe(Zc(e));
  else if (Bc(t))
    o = kwe(t, n);
  else {
    const a = pW(e);
    o = {
      ...t,
      x: t.x - a.x,
      y: t.y - a.y
    };
  }
  return uE(o);
}
function mW(e, t) {
  const n = vg(e);
  return n === t || !Bc(n) || wT(n) ? !1 : As(n).position === "fixed" || mW(n, t);
}
function Rwe(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = gg(e, [], !1).filter((f) => Bc(f) && bf(f) !== "body"), a = null;
  const l = As(e).position === "fixed";
  let u = l ? vg(e) : e;
  for (; Bc(u) && !wT(u); ) {
    const f = As(u), h = mD(u);
    !h && f.position === "fixed" && (a = null), (l ? !h && !a : !h && f.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || TS(u) && !h && mW(e, u)) ? o = o.filter((g) => g !== u) : a = f, u = vg(u);
  }
  return t.set(e, o), o;
}
function Pwe(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: a
  } = e;
  const u = [...n === "clippingAncestors" ? Rwe(t, this._c) : [].concat(n), o], f = u[0], h = u.reduce((v, g) => {
    const b = Iz(t, g, a);
    return v.top = za(b.top, v.top), v.right = vf(b.right, v.right), v.bottom = vf(b.bottom, v.bottom), v.left = za(b.left, v.left), v;
  }, Iz(t, f, a));
  return {
    width: h.right - h.left,
    height: h.bottom - h.top,
    x: h.left,
    y: h.top
  };
}
function Owe(e) {
  const {
    width: t,
    height: n
  } = fW(e);
  return {
    width: t,
    height: n
  };
}
function _we(e, t, n) {
  const o = bu(t), a = Zc(t), l = n === "fixed", u = fh(e, !0, l, t);
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const h = gf(0);
  if (o || !o && !l)
    if ((bf(t) !== "body" || TS(a)) && (f = ET(t)), o) {
      const v = fh(t, !0, l, t);
      h.x = v.x + t.clientLeft, h.y = v.y + t.clientTop;
    } else
      a && (h.x = hW(a));
  return {
    x: u.left + f.scrollLeft - h.x,
    y: u.top + f.scrollTop - h.y,
    width: u.width,
    height: u.height
  };
}
function Az(e, t) {
  return !bu(e) || As(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function vW(e, t) {
  const n = Wa(e);
  if (!bu(e))
    return n;
  let o = Az(e, t);
  for (; o && Swe(o) && As(o).position === "static"; )
    o = Az(o, t);
  return o && (bf(o) === "html" || bf(o) === "body" && As(o).position === "static" && !mD(o)) ? n : o || xwe(e) || n;
}
const Dwe = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: o
  } = e;
  const a = this.getOffsetParent || vW, l = this.getDimensions;
  return {
    reference: _we(t, await a(n), o),
    floating: {
      x: 0,
      y: 0,
      ...await l(n)
    }
  };
};
function Nwe(e) {
  return As(e).direction === "rtl";
}
const Mwe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ewe,
  getDocumentElement: Zc,
  getClippingRect: Pwe,
  getOffsetParent: vW,
  getElementRects: Dwe,
  getClientRects: Twe,
  getDimensions: Owe,
  getScale: tg,
  isElement: Bc,
  isRTL: Nwe
};
function Lwe(e, t) {
  let n = null, o;
  const a = Zc(e);
  function l() {
    clearTimeout(o), n && n.disconnect(), n = null;
  }
  function u(f, h) {
    f === void 0 && (f = !1), h === void 0 && (h = 1), l();
    const {
      left: v,
      top: g,
      width: b,
      height: S
    } = e.getBoundingClientRect();
    if (f || t(), !b || !S)
      return;
    const w = $C(g), E = $C(a.clientWidth - (v + b)), T = $C(a.clientHeight - (g + S)), A = $C(v), _ = {
      rootMargin: -w + "px " + -E + "px " + -T + "px " + -A + "px",
      threshold: za(0, vf(1, h)) || 1
    };
    let D = !0;
    function L(F) {
      const V = F[0].intersectionRatio;
      if (V !== h) {
        if (!D)
          return u();
        V ? u(!1, V) : o = setTimeout(() => {
          u(!1, 1e-7);
        }, 100);
      }
      D = !1;
    }
    try {
      n = new IntersectionObserver(L, {
        ..._,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(L, _);
    }
    n.observe(e);
  }
  return u(!0), l;
}
function Fwe(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: l = !0,
    elementResize: u = typeof ResizeObserver == "function",
    layoutShift: f = typeof IntersectionObserver == "function",
    animationFrame: h = !1
  } = o, v = gD(e), g = a || l ? [...v ? gg(v) : [], ...gg(t)] : [];
  g.forEach((P) => {
    a && P.addEventListener("scroll", n, {
      passive: !0
    }), l && P.addEventListener("resize", n);
  });
  const b = v && f ? Lwe(v, n) : null;
  let S = -1, w = null;
  u && (w = new ResizeObserver((P) => {
    let [_] = P;
    _ && _.target === v && w && (w.unobserve(t), cancelAnimationFrame(S), S = requestAnimationFrame(() => {
      w && w.observe(t);
    })), n();
  }), v && !h && w.observe(v), w.observe(t));
  let E, T = h ? fh(e) : null;
  h && A();
  function A() {
    const P = fh(e);
    T && (P.x !== T.x || P.y !== T.y || P.width !== T.width || P.height !== T.height) && n(), T = P, E = requestAnimationFrame(A);
  }
  return n(), () => {
    g.forEach((P) => {
      a && P.removeEventListener("scroll", n), l && P.removeEventListener("resize", n);
    }), b && b(), w && w.disconnect(), w = null, h && cancelAnimationFrame(E);
  };
}
const Bwe = ywe, Vwe = mwe, $we = bwe, zwe = hwe, Hwe = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), a = {
    platform: Mwe,
    ...n
  }, l = {
    ...a.platform,
    _c: o
  };
  return pwe(e, t, {
    ...a,
    platform: l
  });
};
var qO = ph, jwe = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], cE = function() {
};
function Gwe(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Wwe(e, t) {
  for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    o[a - 2] = arguments[a];
  var l = [].concat(o);
  if (t && e)
    for (var u in t)
      t.hasOwnProperty(u) && t[u] && l.push("".concat(Gwe(e, u)));
  return l.filter(function(f) {
    return f;
  }).map(function(f) {
    return String(f).trim();
  }).join(" ");
}
var kz = function(t) {
  return eEe(t) ? t.filter(Boolean) : lh(t) === "object" && t !== null ? [t] : [];
}, gW = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = Xc(t, jwe);
  return $t({}, n);
}, jr = function(t, n, o) {
  var a = t.cx, l = t.getStyles, u = t.getClassNames, f = t.className;
  return {
    css: l(n, t),
    className: a(o ?? {}, u(n, t), f)
  };
};
function TT(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function Uwe(e) {
  return TT(e) ? window.innerHeight : e.clientHeight;
}
function yW(e) {
  return TT(e) ? window.pageYOffset : e.scrollTop;
}
function dE(e, t) {
  if (TT(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Xwe(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", o = /(auto|scroll)/;
  if (t.position === "fixed")
    return document.documentElement;
  for (var a = e; a = a.parentElement; )
    if (t = getComputedStyle(a), !(n && t.position === "static") && o.test(t.overflow + t.overflowY + t.overflowX))
      return a;
  return document.documentElement;
}
function Zwe(e, t, n, o) {
  return n * ((e = e / o - 1) * e * e + 1) + t;
}
function zC(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : cE, a = yW(e), l = t - a, u = 10, f = 0;
  function h() {
    f += u;
    var v = Zwe(f, a, l, n);
    dE(e, v), f < n ? window.requestAnimationFrame(h) : o(e);
  }
  h();
}
function Rz(e, t) {
  var n = e.getBoundingClientRect(), o = t.getBoundingClientRect(), a = t.offsetHeight / 3;
  o.bottom + a > n.bottom ? dE(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + a, e.scrollHeight)) : o.top - a < n.top && dE(e, Math.max(t.offsetTop - a, 0));
}
function Ywe(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function Pz() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Jwe() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var bW = !1, Qwe = {
  get passive() {
    return bW = !0;
  }
}, HC = typeof window < "u" ? window : {};
HC.addEventListener && HC.removeEventListener && (HC.addEventListener("p", cE, Qwe), HC.removeEventListener("p", cE, !1));
var Kwe = bW;
function qwe(e) {
  return e != null;
}
function eEe(e) {
  return Array.isArray(e);
}
function jC(e, t, n) {
  return e ? t : n;
}
var tEe = function(t) {
  for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
    o[a - 1] = arguments[a];
  var l = Object.entries(t).filter(function(u) {
    var f = Oc(u, 1), h = f[0];
    return !o.includes(h);
  });
  return l.reduce(function(u, f) {
    var h = Oc(f, 2), v = h[0], g = h[1];
    return u[v] = g, u;
  }, {});
}, nEe = ["children", "innerProps"], rEe = ["children", "innerProps"];
function oEe(e) {
  var t = e.maxHeight, n = e.menuEl, o = e.minHeight, a = e.placement, l = e.shouldScroll, u = e.isFixedPosition, f = e.controlHeight, h = Xwe(n), v = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent)
    return v;
  var g = h.getBoundingClientRect(), b = g.height, S = n.getBoundingClientRect(), w = S.bottom, E = S.height, T = S.top, A = n.offsetParent.getBoundingClientRect(), P = A.top, _ = u ? window.innerHeight : Uwe(h), D = yW(h), L = parseInt(getComputedStyle(n).marginBottom, 10), F = parseInt(getComputedStyle(n).marginTop, 10), V = P - F, $ = _ - T, U = V + D, W = b - D - T, H = w - _ + D + L, G = D + T - F, oe = 160;
  switch (a) {
    case "auto":
    case "bottom":
      if ($ >= E)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (W >= E && !u)
        return l && zC(h, H, oe), {
          placement: "bottom",
          maxHeight: t
        };
      if (!u && W >= o || u && $ >= o) {
        l && zC(h, H, oe);
        var ce = u ? $ - L : W - L;
        return {
          placement: "bottom",
          maxHeight: ce
        };
      }
      if (a === "auto" || u) {
        var te = t, Ee = u ? V : U;
        return Ee >= o && (te = Math.min(Ee - L - f, t)), {
          placement: "top",
          maxHeight: te
        };
      }
      if (a === "bottom")
        return l && dE(h, H), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (V >= E)
        return {
          placement: "top",
          maxHeight: t
        };
      if (U >= E && !u)
        return l && zC(h, G, oe), {
          placement: "top",
          maxHeight: t
        };
      if (!u && U >= o || u && V >= o) {
        var me = t;
        return (!u && U >= o || u && V >= o) && (me = u ? V - F : U - F), l && zC(h, G, oe), {
          placement: "top",
          maxHeight: me
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(a, '".'));
  }
  return v;
}
function iEe(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var SW = function(t) {
  return t === "auto" ? "bottom" : t;
}, aEe = function(t, n) {
  var o, a = t.placement, l = t.theme, u = l.borderRadius, f = l.spacing, h = l.colors;
  return $t((o = {
    label: "menu"
  }, Vv(o, iEe(a), "100%"), Vv(o, "position", "absolute"), Vv(o, "width", "100%"), Vv(o, "zIndex", 1), o), n ? {} : {
    backgroundColor: h.neutral0,
    borderRadius: u,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: f.menuGutter,
    marginTop: f.menuGutter
  });
}, xW = /* @__PURE__ */ wa(null), sEe = function(t) {
  var n = t.children, o = t.minMenuHeight, a = t.maxMenuHeight, l = t.menuPlacement, u = t.menuPosition, f = t.menuShouldScrollIntoView, h = t.theme, v = dr(xW) || {}, g = v.setPortalPlacement, b = Ue(null), S = ot(a), w = Oc(S, 2), E = w[0], T = w[1], A = ot(null), P = Oc(A, 2), _ = P[0], D = P[1], L = h.spacing.controlHeight;
  return qO(function() {
    var F = b.current;
    if (F) {
      var V = u === "fixed", $ = f && !V, U = oEe({
        maxHeight: a,
        menuEl: F,
        minHeight: o,
        placement: l,
        shouldScroll: $,
        isFixedPosition: V,
        controlHeight: L
      });
      T(U.maxHeight), D(U.placement), g == null || g(U.placement);
    }
  }, [a, l, u, f, o, g, L]), n({
    ref: b,
    placerProps: $t($t({}, t), {}, {
      placement: _ || SW(l),
      maxHeight: E
    })
  });
}, lEe = function(t) {
  var n = t.children, o = t.innerRef, a = t.innerProps;
  return Ht("div", Dt({}, jr(t, "menu", {
    menu: !0
  }), {
    ref: o
  }, a), n);
}, uEe = lEe, cEe = function(t, n) {
  var o = t.maxHeight, a = t.theme.spacing.baseUnit;
  return $t({
    maxHeight: o,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: a,
    paddingTop: a
  });
}, dEe = function(t) {
  var n = t.children, o = t.innerProps, a = t.innerRef, l = t.isMulti;
  return Ht("div", Dt({}, jr(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": l
  }), {
    ref: a
  }, o), n);
}, CW = function(t, n) {
  var o = t.theme, a = o.spacing.baseUnit, l = o.colors;
  return $t({
    textAlign: "center"
  }, n ? {} : {
    color: l.neutral40,
    padding: "".concat(a * 2, "px ").concat(a * 3, "px")
  });
}, fEe = CW, pEe = CW, hEe = function(t) {
  var n = t.children, o = n === void 0 ? "No options" : n, a = t.innerProps, l = Xc(t, nEe);
  return Ht("div", Dt({}, jr($t($t({}, l), {}, {
    children: o,
    innerProps: a
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), a), o);
}, mEe = function(t) {
  var n = t.children, o = n === void 0 ? "Loading..." : n, a = t.innerProps, l = Xc(t, rEe);
  return Ht("div", Dt({}, jr($t($t({}, l), {}, {
    children: o,
    innerProps: a
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), a), o);
}, vEe = function(t) {
  var n = t.rect, o = t.offset, a = t.position;
  return {
    left: n.left,
    position: a,
    top: o,
    width: n.width,
    zIndex: 1
  };
}, gEe = function(t) {
  var n = t.appendTo, o = t.children, a = t.controlElement, l = t.innerProps, u = t.menuPlacement, f = t.menuPosition, h = Ue(null), v = Ue(null), g = ot(SW(u)), b = Oc(g, 2), S = b[0], w = b[1], E = gt(function() {
    return {
      setPortalPlacement: w
    };
  }, []), T = ot(null), A = Oc(T, 2), P = A[0], _ = A[1], D = re(function() {
    if (a) {
      var $ = Ywe(a), U = f === "fixed" ? 0 : window.pageYOffset, W = $[S] + U;
      (W !== (P == null ? void 0 : P.offset) || $.left !== (P == null ? void 0 : P.rect.left) || $.width !== (P == null ? void 0 : P.rect.width)) && _({
        offset: W,
        rect: $
      });
    }
  }, [a, f, S, P == null ? void 0 : P.offset, P == null ? void 0 : P.rect.left, P == null ? void 0 : P.rect.width]);
  qO(function() {
    D();
  }, [D]);
  var L = re(function() {
    typeof v.current == "function" && (v.current(), v.current = null), a && h.current && (v.current = Fwe(a, h.current, D, {
      elementResize: "ResizeObserver" in window
    }));
  }, [a, D]);
  qO(function() {
    L();
  }, [L]);
  var F = re(function($) {
    h.current = $, L();
  }, [L]);
  if (!n && f !== "fixed" || !P)
    return null;
  var V = Ht("div", Dt({
    ref: F
  }, jr($t($t({}, t), {}, {
    offset: P.offset,
    position: f,
    rect: P.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), l), o);
  return Ht(xW.Provider, {
    value: E
  }, n ? /* @__PURE__ */ VE.createPortal(V, n) : V);
}, yEe = function(t) {
  var n = t.isDisabled, o = t.isRtl;
  return {
    label: "container",
    direction: o ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, bEe = function(t) {
  var n = t.children, o = t.innerProps, a = t.isDisabled, l = t.isRtl;
  return Ht("div", Dt({}, jr(t, "container", {
    "--is-disabled": a,
    "--is-rtl": l
  }), o), n);
}, SEe = function(t, n) {
  var o = t.theme.spacing, a = t.isMulti, l = t.hasValue, u = t.selectProps.controlShouldRenderValue;
  return $t({
    alignItems: "center",
    display: a && l && u ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(o.baseUnit / 2, "px ").concat(o.baseUnit * 2, "px")
  });
}, xEe = function(t) {
  var n = t.children, o = t.innerProps, a = t.isMulti, l = t.hasValue;
  return Ht("div", Dt({}, jr(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": a,
    "value-container--has-value": l
  }), o), n);
}, CEe = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, wEe = function(t) {
  var n = t.children, o = t.innerProps;
  return Ht("div", Dt({}, jr(t, "indicatorsContainer", {
    indicators: !0
  }), o), n);
}, Oz, EEe = ["size"], TEe = ["innerProps", "isRtl", "size"];
function IEe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var AEe = process.env.NODE_ENV === "production" ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */",
  toString: IEe
}, wW = function(t) {
  var n = t.size, o = Xc(t, EEe);
  return Ht("svg", Dt({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: AEe
  }, o));
}, yD = function(t) {
  return Ht(wW, Dt({
    size: 20
  }, t), Ht("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, EW = function(t) {
  return Ht(wW, Dt({
    size: 20
  }, t), Ht("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, TW = function(t, n) {
  var o = t.isFocused, a = t.theme, l = a.spacing.baseUnit, u = a.colors;
  return $t({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: o ? u.neutral60 : u.neutral20,
    padding: l * 2,
    ":hover": {
      color: o ? u.neutral80 : u.neutral40
    }
  });
}, kEe = TW, REe = function(t) {
  var n = t.children, o = t.innerProps;
  return Ht("div", Dt({}, jr(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), o), n || Ht(EW, null));
}, PEe = TW, OEe = function(t) {
  var n = t.children, o = t.innerProps;
  return Ht("div", Dt({}, jr(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), o), n || Ht(yD, null));
}, _Ee = function(t, n) {
  var o = t.isDisabled, a = t.theme, l = a.spacing.baseUnit, u = a.colors;
  return $t({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: o ? u.neutral10 : u.neutral20,
    marginBottom: l * 2,
    marginTop: l * 2
  });
}, DEe = function(t) {
  var n = t.innerProps;
  return Ht("span", Dt({}, n, jr(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, NEe = Ps(Oz || (Oz = iwe([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), MEe = function(t, n) {
  var o = t.isFocused, a = t.size, l = t.theme, u = l.colors, f = l.spacing.baseUnit;
  return $t({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: a,
    lineHeight: 1,
    marginRight: a,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: o ? u.neutral60 : u.neutral20,
    padding: f * 2
  });
}, pP = function(t) {
  var n = t.delay, o = t.offset;
  return Ht("span", {
    css: /* @__PURE__ */ D_({
      animation: "".concat(NEe, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: o ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, process.env.NODE_ENV === "production" ? "" : ";label:LoadingDot;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */")
  });
}, LEe = function(t) {
  var n = t.innerProps, o = t.isRtl, a = t.size, l = a === void 0 ? 4 : a, u = Xc(t, TEe);
  return Ht("div", Dt({}, jr($t($t({}, u), {}, {
    innerProps: n,
    isRtl: o,
    size: l
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), Ht(pP, {
    delay: 0,
    offset: o
  }), Ht(pP, {
    delay: 160,
    offset: !0
  }), Ht(pP, {
    delay: 320,
    offset: !o
  }));
}, FEe = function(t, n) {
  var o = t.isDisabled, a = t.isFocused, l = t.theme, u = l.colors, f = l.borderRadius, h = l.spacing;
  return $t({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: h.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: o ? u.neutral5 : u.neutral0,
    borderColor: o ? u.neutral10 : a ? u.primary : u.neutral20,
    borderRadius: f,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: a ? "0 0 0 1px ".concat(u.primary) : void 0,
    "&:hover": {
      borderColor: a ? u.primary : u.neutral30
    }
  });
}, BEe = function(t) {
  var n = t.children, o = t.isDisabled, a = t.isFocused, l = t.innerRef, u = t.innerProps, f = t.menuIsOpen;
  return Ht("div", Dt({
    ref: l
  }, jr(t, "control", {
    control: !0,
    "control--is-disabled": o,
    "control--is-focused": a,
    "control--menu-is-open": f
  }), u, {
    "aria-disabled": o || void 0
  }), n);
}, VEe = BEe, $Ee = ["data"], zEe = function(t, n) {
  var o = t.theme.spacing;
  return n ? {} : {
    paddingBottom: o.baseUnit * 2,
    paddingTop: o.baseUnit * 2
  };
}, HEe = function(t) {
  var n = t.children, o = t.cx, a = t.getStyles, l = t.getClassNames, u = t.Heading, f = t.headingProps, h = t.innerProps, v = t.label, g = t.theme, b = t.selectProps;
  return Ht("div", Dt({}, jr(t, "group", {
    group: !0
  }), h), Ht(u, Dt({}, f, {
    selectProps: b,
    theme: g,
    getStyles: a,
    getClassNames: l,
    cx: o
  }), v), Ht("div", null, n));
}, jEe = function(t, n) {
  var o = t.theme, a = o.colors, l = o.spacing;
  return $t({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: a.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: l.baseUnit * 3,
    paddingRight: l.baseUnit * 3,
    textTransform: "uppercase"
  });
}, GEe = function(t) {
  var n = gW(t);
  n.data;
  var o = Xc(n, $Ee);
  return Ht("div", Dt({}, jr(t, "groupHeading", {
    "group-heading": !0
  }), o));
}, WEe = HEe, UEe = ["innerRef", "isDisabled", "isHidden", "inputClassName"], XEe = function(t, n) {
  var o = t.isDisabled, a = t.value, l = t.theme, u = l.spacing, f = l.colors;
  return $t($t({
    visibility: o ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: a ? "translateZ(0)" : ""
  }, ZEe), n ? {} : {
    margin: u.baseUnit / 2,
    paddingBottom: u.baseUnit / 2,
    paddingTop: u.baseUnit / 2,
    color: f.neutral80
  });
}, IW = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, ZEe = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": $t({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, IW)
}, YEe = function(t) {
  return $t({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, IW);
}, JEe = function(t) {
  var n = t.cx, o = t.value, a = gW(t), l = a.innerRef, u = a.isDisabled, f = a.isHidden, h = a.inputClassName, v = Xc(a, UEe);
  return Ht("div", Dt({}, jr(t, "input", {
    "input-container": !0
  }), {
    "data-value": o || ""
  }), Ht("input", Dt({
    className: n({
      input: !0
    }, h),
    ref: l,
    style: YEe(f),
    disabled: u
  }, v)));
}, QEe = JEe, KEe = function(t, n) {
  var o = t.theme, a = o.spacing, l = o.borderRadius, u = o.colors;
  return $t({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: u.neutral10,
    borderRadius: l / 2,
    margin: a.baseUnit / 2
  });
}, qEe = function(t, n) {
  var o = t.theme, a = o.borderRadius, l = o.colors, u = t.cropWithEllipsis;
  return $t({
    overflow: "hidden",
    textOverflow: u || u === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: a / 2,
    color: l.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, eTe = function(t, n) {
  var o = t.theme, a = o.spacing, l = o.borderRadius, u = o.colors, f = t.isFocused;
  return $t({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: l / 2,
    backgroundColor: f ? u.dangerLight : void 0,
    paddingLeft: a.baseUnit,
    paddingRight: a.baseUnit,
    ":hover": {
      backgroundColor: u.dangerLight,
      color: u.danger
    }
  });
}, AW = function(t) {
  var n = t.children, o = t.innerProps;
  return Ht("div", o, n);
}, tTe = AW, nTe = AW;
function rTe(e) {
  var t = e.children, n = e.innerProps;
  return Ht("div", Dt({
    role: "button"
  }, n), t || Ht(yD, {
    size: 14
  }));
}
var oTe = function(t) {
  var n = t.children, o = t.components, a = t.data, l = t.innerProps, u = t.isDisabled, f = t.removeProps, h = t.selectProps, v = o.Container, g = o.Label, b = o.Remove;
  return Ht(v, {
    data: a,
    innerProps: $t($t({}, jr(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": u
    })), l),
    selectProps: h
  }, Ht(g, {
    data: a,
    innerProps: $t({}, jr(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: h
  }, n), Ht(b, {
    data: a,
    innerProps: $t($t({}, jr(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, f),
    selectProps: h
  }));
}, iTe = oTe, aTe = function(t, n) {
  var o = t.isDisabled, a = t.isFocused, l = t.isSelected, u = t.theme, f = u.spacing, h = u.colors;
  return $t({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: l ? h.primary : a ? h.primary25 : "transparent",
    color: o ? h.neutral20 : l ? h.neutral0 : "inherit",
    padding: "".concat(f.baseUnit * 2, "px ").concat(f.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: o ? void 0 : l ? h.primary : h.primary50
    }
  });
}, sTe = function(t) {
  var n = t.children, o = t.isDisabled, a = t.isFocused, l = t.isSelected, u = t.innerRef, f = t.innerProps;
  return Ht("div", Dt({}, jr(t, "option", {
    option: !0,
    "option--is-disabled": o,
    "option--is-focused": a,
    "option--is-selected": l
  }), {
    ref: u,
    "aria-disabled": o
  }, f), n);
}, lTe = sTe, uTe = function(t, n) {
  var o = t.theme, a = o.spacing, l = o.colors;
  return $t({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: l.neutral50,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, cTe = function(t) {
  var n = t.children, o = t.innerProps;
  return Ht("div", Dt({}, jr(t, "placeholder", {
    placeholder: !0
  }), o), n);
}, dTe = cTe, fTe = function(t, n) {
  var o = t.isDisabled, a = t.theme, l = a.spacing, u = a.colors;
  return $t({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: o ? u.neutral40 : u.neutral80,
    marginLeft: l.baseUnit / 2,
    marginRight: l.baseUnit / 2
  });
}, pTe = function(t) {
  var n = t.children, o = t.isDisabled, a = t.innerProps;
  return Ht("div", Dt({}, jr(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": o
  }), a), n);
}, hTe = pTe, mTe = {
  ClearIndicator: OEe,
  Control: VEe,
  DropdownIndicator: REe,
  DownChevron: EW,
  CrossIcon: yD,
  Group: WEe,
  GroupHeading: GEe,
  IndicatorsContainer: wEe,
  IndicatorSeparator: DEe,
  Input: QEe,
  LoadingIndicator: LEe,
  Menu: uEe,
  MenuList: dEe,
  MenuPortal: gEe,
  LoadingMessage: mEe,
  NoOptionsMessage: hEe,
  MultiValue: iTe,
  MultiValueContainer: tTe,
  MultiValueLabel: nTe,
  MultiValueRemove: rTe,
  Option: lTe,
  Placeholder: dTe,
  SelectContainer: bEe,
  SingleValue: hTe,
  ValueContainer: xEe
}, vTe = function(t) {
  return $t($t({}, mTe), t.components);
}, _z = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function gTe(e, t) {
  return !!(e === t || _z(e) && _z(t));
}
function yTe(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!gTe(e[n], t[n]))
      return !1;
  return !0;
}
function bTe(e, t) {
  t === void 0 && (t = yTe);
  var n = null;
  function o() {
    for (var a = [], l = 0; l < arguments.length; l++)
      a[l] = arguments[l];
    if (n && n.lastThis === this && t(a, n.lastArgs))
      return n.lastResult;
    var u = e.apply(this, a);
    return n = {
      lastResult: u,
      lastArgs: a,
      lastThis: this
    }, u;
  }
  return o.clear = function() {
    n = null;
  }, o;
}
function STe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var xTe = process.env.NODE_ENV === "production" ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: STe
}, CTe = function(t) {
  return Ht("span", Dt({
    css: xTe
  }, t));
}, Dz = CTe, wTe = {
  guidance: function(t) {
    var n = t.isSearchable, o = t.isMulti, a = t.isDisabled, l = t.tabSelectsValue, u = t.context;
    switch (u) {
      case "menu":
        return "Use Up and Down to choose options".concat(a ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(l ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(o ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, o = t.label, a = o === void 0 ? "" : o, l = t.labels, u = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(a, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(l.length > 1 ? "s" : "", " ").concat(l.join(","), ", selected.");
      case "select-option":
        return u ? "option ".concat(a, " is disabled. Select another option.") : "option ".concat(a, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, o = t.focused, a = t.options, l = t.label, u = l === void 0 ? "" : l, f = t.selectValue, h = t.isDisabled, v = t.isSelected, g = function(E, T) {
      return E && E.length ? "".concat(E.indexOf(T) + 1, " of ").concat(E.length) : "";
    };
    if (n === "value" && f)
      return "value ".concat(u, " focused, ").concat(g(f, o), ".");
    if (n === "menu") {
      var b = h ? " disabled" : "", S = "".concat(v ? "selected" : "focused").concat(b);
      return "option ".concat(u, " ").concat(S, ", ").concat(g(a, o), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, o = t.resultsMessage;
    return "".concat(o).concat(n ? " for search term " + n : "", ".");
  }
}, ETe = function(t) {
  var n = t.ariaSelection, o = t.focusedOption, a = t.focusedValue, l = t.focusableOptions, u = t.isFocused, f = t.selectValue, h = t.selectProps, v = t.id, g = h.ariaLiveMessages, b = h.getOptionLabel, S = h.inputValue, w = h.isMulti, E = h.isOptionDisabled, T = h.isSearchable, A = h.menuIsOpen, P = h.options, _ = h.screenReaderStatus, D = h.tabSelectsValue, L = h["aria-label"], F = h["aria-live"], V = gt(function() {
    return $t($t({}, wTe), g || {});
  }, [g]), $ = gt(function() {
    var te = "";
    if (n && V.onChange) {
      var Ee = n.option, me = n.options, J = n.removedValue, Q = n.removedValues, ge = n.value, Y = function(Ce) {
        return Array.isArray(Ce) ? null : Ce;
      }, q = J || Ee || Y(ge), de = q ? b(q) : "", K = me || Q || void 0, ne = K ? K.map(b) : [], pe = $t({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: q && E(q, f),
        label: de,
        labels: ne
      }, n);
      te = V.onChange(pe);
    }
    return te;
  }, [n, V, E, f, b]), U = gt(function() {
    var te = "", Ee = o || a, me = !!(o && f && f.includes(o));
    if (Ee && V.onFocus) {
      var J = {
        focused: Ee,
        label: b(Ee),
        isDisabled: E(Ee, f),
        isSelected: me,
        options: l,
        context: Ee === o ? "menu" : "value",
        selectValue: f
      };
      te = V.onFocus(J);
    }
    return te;
  }, [o, a, b, E, V, l, f]), W = gt(function() {
    var te = "";
    if (A && P.length && V.onFilter) {
      var Ee = _({
        count: l.length
      });
      te = V.onFilter({
        inputValue: S,
        resultsMessage: Ee
      });
    }
    return te;
  }, [l, S, A, V, P, _]), H = gt(function() {
    var te = "";
    if (V.guidance) {
      var Ee = a ? "value" : A ? "menu" : "input";
      te = V.guidance({
        "aria-label": L,
        context: Ee,
        isDisabled: o && E(o, f),
        isMulti: w,
        isSearchable: T,
        tabSelectsValue: D
      });
    }
    return te;
  }, [L, o, a, w, E, T, A, V, f, D]), G = "".concat(U, " ").concat(W, " ").concat(H), oe = Ht(B0, null, Ht("span", {
    id: "aria-selection"
  }, $), Ht("span", {
    id: "aria-context"
  }, G)), ce = (n == null ? void 0 : n.action) === "initial-input-focus";
  return Ht(B0, null, Ht(Dz, {
    id: v
  }, ce && oe), Ht(Dz, {
    "aria-live": F,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, u && !ce && oe));
}, TTe = ETe, e_ = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], ITe = new RegExp("[" + e_.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), kW = {};
for (var hP = 0; hP < e_.length; hP++)
  for (var mP = e_[hP], vP = 0; vP < mP.letters.length; vP++)
    kW[mP.letters[vP]] = mP.base;
var RW = function(t) {
  return t.replace(ITe, function(n) {
    return kW[n];
  });
}, ATe = bTe(RW), Nz = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, kTe = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, RTe = function(t) {
  return function(n, o) {
    if (n.data.__isNew__)
      return !0;
    var a = $t({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: kTe,
      trim: !0,
      matchFrom: "any"
    }, t), l = a.ignoreCase, u = a.ignoreAccents, f = a.stringify, h = a.trim, v = a.matchFrom, g = h ? Nz(o) : o, b = h ? Nz(f(n)) : f(n);
    return l && (g = g.toLowerCase(), b = b.toLowerCase()), u && (g = ATe(g), b = RW(b)), v === "start" ? b.substr(0, g.length) === g : b.indexOf(g) > -1;
  };
}, PTe = ["innerRef"];
function OTe(e) {
  var t = e.innerRef, n = Xc(e, PTe), o = tEe(n, "onExited", "in", "enter", "exit", "appear");
  return Ht("input", Dt({
    ref: t
  }, o, {
    css: /* @__PURE__ */ D_({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, process.env.NODE_ENV === "production" ? "" : ";label:DummyInput;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var _Te = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function DTe(e) {
  var t = e.isEnabled, n = e.onBottomArrive, o = e.onBottomLeave, a = e.onTopArrive, l = e.onTopLeave, u = Ue(!1), f = Ue(!1), h = Ue(0), v = Ue(null), g = re(function(A, P) {
    if (v.current !== null) {
      var _ = v.current, D = _.scrollTop, L = _.scrollHeight, F = _.clientHeight, V = v.current, $ = P > 0, U = L - F - D, W = !1;
      U > P && u.current && (o && o(A), u.current = !1), $ && f.current && (l && l(A), f.current = !1), $ && P > U ? (n && !u.current && n(A), V.scrollTop = L, W = !0, u.current = !0) : !$ && -P > D && (a && !f.current && a(A), V.scrollTop = 0, W = !0, f.current = !0), W && _Te(A);
    }
  }, [n, o, a, l]), b = re(function(A) {
    g(A, A.deltaY);
  }, [g]), S = re(function(A) {
    h.current = A.changedTouches[0].clientY;
  }, []), w = re(function(A) {
    var P = h.current - A.changedTouches[0].clientY;
    g(A, P);
  }, [g]), E = re(function(A) {
    if (A) {
      var P = Kwe ? {
        passive: !1
      } : !1;
      A.addEventListener("wheel", b, P), A.addEventListener("touchstart", S, P), A.addEventListener("touchmove", w, P);
    }
  }, [w, S, b]), T = re(function(A) {
    A && (A.removeEventListener("wheel", b, !1), A.removeEventListener("touchstart", S, !1), A.removeEventListener("touchmove", w, !1));
  }, [w, S, b]);
  return dt(function() {
    if (t) {
      var A = v.current;
      return E(A), function() {
        T(A);
      };
    }
  }, [t, E, T]), function(A) {
    v.current = A;
  };
}
var Mz = ["boxSizing", "height", "overflow", "paddingRight", "position"], Lz = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function Fz(e) {
  e.preventDefault();
}
function Bz(e) {
  e.stopPropagation();
}
function Vz() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function $z() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var zz = !!(typeof window < "u" && window.document && window.document.createElement), qb = 0, Iv = {
  capture: !1,
  passive: !1
};
function NTe(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, o = n === void 0 ? !0 : n, a = Ue({}), l = Ue(null), u = re(function(h) {
    if (zz) {
      var v = document.body, g = v && v.style;
      if (o && Mz.forEach(function(E) {
        var T = g && g[E];
        a.current[E] = T;
      }), o && qb < 1) {
        var b = parseInt(a.current.paddingRight, 10) || 0, S = document.body ? document.body.clientWidth : 0, w = window.innerWidth - S + b || 0;
        Object.keys(Lz).forEach(function(E) {
          var T = Lz[E];
          g && (g[E] = T);
        }), g && (g.paddingRight = "".concat(w, "px"));
      }
      v && $z() && (v.addEventListener("touchmove", Fz, Iv), h && (h.addEventListener("touchstart", Vz, Iv), h.addEventListener("touchmove", Bz, Iv))), qb += 1;
    }
  }, [o]), f = re(function(h) {
    if (zz) {
      var v = document.body, g = v && v.style;
      qb = Math.max(qb - 1, 0), o && qb < 1 && Mz.forEach(function(b) {
        var S = a.current[b];
        g && (g[b] = S);
      }), v && $z() && (v.removeEventListener("touchmove", Fz, Iv), h && (h.removeEventListener("touchstart", Vz, Iv), h.removeEventListener("touchmove", Bz, Iv)));
    }
  }, [o]);
  return dt(function() {
    if (t) {
      var h = l.current;
      return u(h), function() {
        f(h);
      };
    }
  }, [t, u, f]), function(h) {
    l.current = h;
  };
}
function MTe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var LTe = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, FTe = process.env.NODE_ENV === "production" ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: MTe
};
function BTe(e) {
  var t = e.children, n = e.lockEnabled, o = e.captureEnabled, a = o === void 0 ? !0 : o, l = e.onBottomArrive, u = e.onBottomLeave, f = e.onTopArrive, h = e.onTopLeave, v = DTe({
    isEnabled: a,
    onBottomArrive: l,
    onBottomLeave: u,
    onTopArrive: f,
    onTopLeave: h
  }), g = NTe({
    isEnabled: n
  }), b = function(w) {
    v(w), g(w);
  };
  return Ht(B0, null, n && Ht("div", {
    onClick: LTe,
    css: FTe
  }), t(b));
}
function VTe() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var $Te = process.env.NODE_ENV === "production" ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: VTe
}, zTe = function(t) {
  var n = t.name, o = t.onFocus;
  return Ht("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: o,
    css: $Te,
    value: "",
    onChange: function() {
    }
  });
}, HTe = zTe, jTe = function(t) {
  return t.label;
}, GTe = function(t) {
  return t.label;
}, WTe = function(t) {
  return t.value;
}, UTe = function(t) {
  return !!t.isDisabled;
}, XTe = {
  clearIndicator: PEe,
  container: yEe,
  control: FEe,
  dropdownIndicator: kEe,
  group: zEe,
  groupHeading: jEe,
  indicatorsContainer: CEe,
  indicatorSeparator: _Ee,
  input: XEe,
  loadingIndicator: MEe,
  loadingMessage: pEe,
  menu: aEe,
  menuList: cEe,
  menuPortal: vEe,
  multiValue: KEe,
  multiValueLabel: qEe,
  multiValueRemove: eTe,
  noOptionsMessage: fEe,
  option: aTe,
  placeholder: uTe,
  singleValue: fTe,
  valueContainer: SEe
}, ZTe = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, YTe = 4, PW = 4, JTe = 38, QTe = PW * 2, KTe = {
  baseUnit: PW,
  controlHeight: JTe,
  menuGutter: QTe
}, gP = {
  borderRadius: YTe,
  colors: ZTe,
  spacing: KTe
}, qTe = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: Pz(),
  captureMenuScroll: !Pz(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: RTe(),
  formatGroupLabel: jTe,
  getOptionLabel: GTe,
  getOptionValue: WTe,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: UTe,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Jwe(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function Hz(e, t, n, o) {
  var a = NW(e, t, n), l = MW(e, t, n), u = DW(e, t), f = fE(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: a,
    isSelected: l,
    label: u,
    value: f,
    index: o
  };
}
function OW(e, t) {
  return e.options.map(function(n, o) {
    if ("options" in n) {
      var a = n.options.map(function(u, f) {
        return Hz(e, u, t, f);
      }).filter(function(u) {
        return jz(e, u);
      });
      return a.length > 0 ? {
        type: "group",
        data: n,
        options: a,
        index: o
      } : void 0;
    }
    var l = Hz(e, n, t, o);
    return jz(e, l) ? l : void 0;
  }).filter(qwe);
}
function _W(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, sW(n.options.map(function(o) {
      return o.data;
    }))) : t.push(n.data), t;
  }, []);
}
function eIe(e, t) {
  return _W(OW(e, t));
}
function jz(e, t) {
  var n = e.inputValue, o = n === void 0 ? "" : n, a = t.data, l = t.isSelected, u = t.label, f = t.value;
  return (!FW(e) || !l) && LW(e, {
    label: u,
    value: f,
    data: a
  }, o);
}
function tIe(e, t) {
  var n = e.focusedValue, o = e.selectValue, a = o.indexOf(n);
  if (a > -1) {
    var l = t.indexOf(n);
    if (l > -1)
      return n;
    if (a < t.length)
      return t[a];
  }
  return null;
}
function nIe(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var DW = function(t, n) {
  return t.getOptionLabel(n);
}, fE = function(t, n) {
  return t.getOptionValue(n);
};
function NW(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function MW(e, t, n) {
  if (n.indexOf(t) > -1)
    return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var o = fE(e, t);
  return n.some(function(a) {
    return fE(e, a) === o;
  });
}
function LW(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var FW = function(t) {
  var n = t.hideSelectedOptions, o = t.isMulti;
  return n === void 0 ? o : n;
}, rIe = 1, BW = /* @__PURE__ */ function(e) {
  KCe(n, e);
  var t = twe(n);
  function n(o) {
    var a;
    if (JCe(this, n), a = t.call(this, o), a.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    }, a.blockOptionHover = !1, a.isComposing = !1, a.commonProps = void 0, a.initialTouchX = 0, a.initialTouchY = 0, a.instancePrefix = "", a.openAfterFocus = !1, a.scrollToFocusedOptionOnUpdate = !1, a.userIsDragging = void 0, a.controlRef = null, a.getControlRef = function(f) {
      a.controlRef = f;
    }, a.focusedOptionRef = null, a.getFocusedOptionRef = function(f) {
      a.focusedOptionRef = f;
    }, a.menuListRef = null, a.getMenuListRef = function(f) {
      a.menuListRef = f;
    }, a.inputRef = null, a.getInputRef = function(f) {
      a.inputRef = f;
    }, a.focus = a.focusInput, a.blur = a.blurInput, a.onChange = function(f, h) {
      var v = a.props, g = v.onChange, b = v.name;
      h.name = b, a.ariaOnChange(f, h), g(f, h);
    }, a.setValue = function(f, h, v) {
      var g = a.props, b = g.closeMenuOnSelect, S = g.isMulti, w = g.inputValue;
      a.onInputChange("", {
        action: "set-value",
        prevInputValue: w
      }), b && (a.setState({
        inputIsHiddenAfterUpdate: !S
      }), a.onMenuClose()), a.setState({
        clearFocusValueOnUpdate: !0
      }), a.onChange(f, {
        action: h,
        option: v
      });
    }, a.selectOption = function(f) {
      var h = a.props, v = h.blurInputOnSelect, g = h.isMulti, b = h.name, S = a.state.selectValue, w = g && a.isOptionSelected(f, S), E = a.isOptionDisabled(f, S);
      if (w) {
        var T = a.getOptionValue(f);
        a.setValue(S.filter(function(A) {
          return a.getOptionValue(A) !== T;
        }), "deselect-option", f);
      } else if (!E)
        g ? a.setValue([].concat(sW(S), [f]), "select-option", f) : a.setValue(f, "select-option");
      else {
        a.ariaOnChange(f, {
          action: "select-option",
          option: f,
          name: b
        });
        return;
      }
      v && a.blurInput();
    }, a.removeValue = function(f) {
      var h = a.props.isMulti, v = a.state.selectValue, g = a.getOptionValue(f), b = v.filter(function(w) {
        return a.getOptionValue(w) !== g;
      }), S = jC(h, b, b[0] || null);
      a.onChange(S, {
        action: "remove-value",
        removedValue: f
      }), a.focusInput();
    }, a.clearValue = function() {
      var f = a.state.selectValue;
      a.onChange(jC(a.props.isMulti, [], null), {
        action: "clear",
        removedValues: f
      });
    }, a.popValue = function() {
      var f = a.props.isMulti, h = a.state.selectValue, v = h[h.length - 1], g = h.slice(0, h.length - 1), b = jC(f, g, g[0] || null);
      a.onChange(b, {
        action: "pop-value",
        removedValue: v
      });
    }, a.getValue = function() {
      return a.state.selectValue;
    }, a.cx = function() {
      for (var f = arguments.length, h = new Array(f), v = 0; v < f; v++)
        h[v] = arguments[v];
      return Wwe.apply(void 0, [a.props.classNamePrefix].concat(h));
    }, a.getOptionLabel = function(f) {
      return DW(a.props, f);
    }, a.getOptionValue = function(f) {
      return fE(a.props, f);
    }, a.getStyles = function(f, h) {
      var v = a.props.unstyled, g = XTe[f](h, v);
      g.boxSizing = "border-box";
      var b = a.props.styles[f];
      return b ? b(g, h) : g;
    }, a.getClassNames = function(f, h) {
      var v, g;
      return (v = (g = a.props.classNames)[f]) === null || v === void 0 ? void 0 : v.call(g, h);
    }, a.getElementId = function(f) {
      return "".concat(a.instancePrefix, "-").concat(f);
    }, a.getComponents = function() {
      return vTe(a.props);
    }, a.buildCategorizedOptions = function() {
      return OW(a.props, a.state.selectValue);
    }, a.getCategorizedOptions = function() {
      return a.props.menuIsOpen ? a.buildCategorizedOptions() : [];
    }, a.buildFocusableOptions = function() {
      return _W(a.buildCategorizedOptions());
    }, a.getFocusableOptions = function() {
      return a.props.menuIsOpen ? a.buildFocusableOptions() : [];
    }, a.ariaOnChange = function(f, h) {
      a.setState({
        ariaSelection: $t({
          value: f
        }, h)
      });
    }, a.onMenuMouseDown = function(f) {
      f.button === 0 && (f.stopPropagation(), f.preventDefault(), a.focusInput());
    }, a.onMenuMouseMove = function(f) {
      a.blockOptionHover = !1;
    }, a.onControlMouseDown = function(f) {
      if (!f.defaultPrevented) {
        var h = a.props.openMenuOnClick;
        a.state.isFocused ? a.props.menuIsOpen ? f.target.tagName !== "INPUT" && f.target.tagName !== "TEXTAREA" && a.onMenuClose() : h && a.openMenu("first") : (h && (a.openAfterFocus = !0), a.focusInput()), f.target.tagName !== "INPUT" && f.target.tagName !== "TEXTAREA" && f.preventDefault();
      }
    }, a.onDropdownIndicatorMouseDown = function(f) {
      if (!(f && f.type === "mousedown" && f.button !== 0) && !a.props.isDisabled) {
        var h = a.props, v = h.isMulti, g = h.menuIsOpen;
        a.focusInput(), g ? (a.setState({
          inputIsHiddenAfterUpdate: !v
        }), a.onMenuClose()) : a.openMenu("first"), f.preventDefault();
      }
    }, a.onClearIndicatorMouseDown = function(f) {
      f && f.type === "mousedown" && f.button !== 0 || (a.clearValue(), f.preventDefault(), a.openAfterFocus = !1, f.type === "touchend" ? a.focusInput() : setTimeout(function() {
        return a.focusInput();
      }));
    }, a.onScroll = function(f) {
      typeof a.props.closeMenuOnScroll == "boolean" ? f.target instanceof HTMLElement && TT(f.target) && a.props.onMenuClose() : typeof a.props.closeMenuOnScroll == "function" && a.props.closeMenuOnScroll(f) && a.props.onMenuClose();
    }, a.onCompositionStart = function() {
      a.isComposing = !0;
    }, a.onCompositionEnd = function() {
      a.isComposing = !1;
    }, a.onTouchStart = function(f) {
      var h = f.touches, v = h && h.item(0);
      v && (a.initialTouchX = v.clientX, a.initialTouchY = v.clientY, a.userIsDragging = !1);
    }, a.onTouchMove = function(f) {
      var h = f.touches, v = h && h.item(0);
      if (v) {
        var g = Math.abs(v.clientX - a.initialTouchX), b = Math.abs(v.clientY - a.initialTouchY), S = 5;
        a.userIsDragging = g > S || b > S;
      }
    }, a.onTouchEnd = function(f) {
      a.userIsDragging || (a.controlRef && !a.controlRef.contains(f.target) && a.menuListRef && !a.menuListRef.contains(f.target) && a.blurInput(), a.initialTouchX = 0, a.initialTouchY = 0);
    }, a.onControlTouchEnd = function(f) {
      a.userIsDragging || a.onControlMouseDown(f);
    }, a.onClearIndicatorTouchEnd = function(f) {
      a.userIsDragging || a.onClearIndicatorMouseDown(f);
    }, a.onDropdownIndicatorTouchEnd = function(f) {
      a.userIsDragging || a.onDropdownIndicatorMouseDown(f);
    }, a.handleInputChange = function(f) {
      var h = a.props.inputValue, v = f.currentTarget.value;
      a.setState({
        inputIsHiddenAfterUpdate: !1
      }), a.onInputChange(v, {
        action: "input-change",
        prevInputValue: h
      }), a.props.menuIsOpen || a.onMenuOpen();
    }, a.onInputFocus = function(f) {
      a.props.onFocus && a.props.onFocus(f), a.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (a.openAfterFocus || a.props.openMenuOnFocus) && a.openMenu("first"), a.openAfterFocus = !1;
    }, a.onInputBlur = function(f) {
      var h = a.props.inputValue;
      if (a.menuListRef && a.menuListRef.contains(document.activeElement)) {
        a.inputRef.focus();
        return;
      }
      a.props.onBlur && a.props.onBlur(f), a.onInputChange("", {
        action: "input-blur",
        prevInputValue: h
      }), a.onMenuClose(), a.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, a.onOptionHover = function(f) {
      a.blockOptionHover || a.state.focusedOption === f || a.setState({
        focusedOption: f
      });
    }, a.shouldHideSelectedOptions = function() {
      return FW(a.props);
    }, a.onValueInputFocus = function(f) {
      f.preventDefault(), f.stopPropagation(), a.focus();
    }, a.onKeyDown = function(f) {
      var h = a.props, v = h.isMulti, g = h.backspaceRemovesValue, b = h.escapeClearsValue, S = h.inputValue, w = h.isClearable, E = h.isDisabled, T = h.menuIsOpen, A = h.onKeyDown, P = h.tabSelectsValue, _ = h.openMenuOnFocus, D = a.state, L = D.focusedOption, F = D.focusedValue, V = D.selectValue;
      if (!E && !(typeof A == "function" && (A(f), f.defaultPrevented))) {
        switch (a.blockOptionHover = !0, f.key) {
          case "ArrowLeft":
            if (!v || S)
              return;
            a.focusValue("previous");
            break;
          case "ArrowRight":
            if (!v || S)
              return;
            a.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (S)
              return;
            if (F)
              a.removeValue(F);
            else {
              if (!g)
                return;
              v ? a.popValue() : w && a.clearValue();
            }
            break;
          case "Tab":
            if (a.isComposing || f.shiftKey || !T || !P || !L || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            _ && a.isOptionSelected(L, V))
              return;
            a.selectOption(L);
            break;
          case "Enter":
            if (f.keyCode === 229)
              break;
            if (T) {
              if (!L || a.isComposing)
                return;
              a.selectOption(L);
              break;
            }
            return;
          case "Escape":
            T ? (a.setState({
              inputIsHiddenAfterUpdate: !1
            }), a.onInputChange("", {
              action: "menu-close",
              prevInputValue: S
            }), a.onMenuClose()) : w && b && a.clearValue();
            break;
          case " ":
            if (S)
              return;
            if (!T) {
              a.openMenu("first");
              break;
            }
            if (!L)
              return;
            a.selectOption(L);
            break;
          case "ArrowUp":
            T ? a.focusOption("up") : a.openMenu("last");
            break;
          case "ArrowDown":
            T ? a.focusOption("down") : a.openMenu("first");
            break;
          case "PageUp":
            if (!T)
              return;
            a.focusOption("pageup");
            break;
          case "PageDown":
            if (!T)
              return;
            a.focusOption("pagedown");
            break;
          case "Home":
            if (!T)
              return;
            a.focusOption("first");
            break;
          case "End":
            if (!T)
              return;
            a.focusOption("last");
            break;
          default:
            return;
        }
        f.preventDefault();
      }
    }, a.instancePrefix = "react-select-" + (a.props.instanceId || ++rIe), a.state.selectValue = kz(o.value), o.menuIsOpen && a.state.selectValue.length) {
      var l = a.buildFocusableOptions(), u = l.indexOf(a.state.selectValue[0]);
      a.state.focusedOption = l[u];
    }
    return a;
  }
  return QCe(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Rz(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(a) {
      var l = this.props, u = l.isDisabled, f = l.menuIsOpen, h = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (h && !u && a.isDisabled || // ensure focus is on the Input when the menu opens
      h && f && !a.menuIsOpen) && this.focusInput(), h && u && !a.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !h && !u && a.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Rz(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(a, l) {
      this.props.onInputChange(a, l);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(a) {
      var l = this, u = this.state, f = u.selectValue, h = u.isFocused, v = this.buildFocusableOptions(), g = a === "first" ? 0 : v.length - 1;
      if (!this.props.isMulti) {
        var b = v.indexOf(f[0]);
        b > -1 && (g = b);
      }
      this.scrollToFocusedOptionOnUpdate = !(h && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: v[g]
      }, function() {
        return l.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(a) {
      var l = this.state, u = l.selectValue, f = l.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var h = u.indexOf(f);
        f || (h = -1);
        var v = u.length - 1, g = -1;
        if (u.length) {
          switch (a) {
            case "previous":
              h === 0 ? g = 0 : h === -1 ? g = v : g = h - 1;
              break;
            case "next":
              h > -1 && h < v && (g = h + 1);
              break;
          }
          this.setState({
            inputIsHidden: g !== -1,
            focusedValue: u[g]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", l = this.props.pageSize, u = this.state.focusedOption, f = this.getFocusableOptions();
      if (f.length) {
        var h = 0, v = f.indexOf(u);
        u || (v = -1), a === "up" ? h = v > 0 ? v - 1 : f.length - 1 : a === "down" ? h = (v + 1) % f.length : a === "pageup" ? (h = v - l, h < 0 && (h = 0)) : a === "pagedown" ? (h = v + l, h > f.length - 1 && (h = f.length - 1)) : a === "last" && (h = f.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: f[h],
          focusedValue: null
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(gP) : $t($t({}, gP), this.props.theme) : gP;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var a = this.clearValue, l = this.cx, u = this.getStyles, f = this.getClassNames, h = this.getValue, v = this.selectOption, g = this.setValue, b = this.props, S = b.isMulti, w = b.isRtl, E = b.options, T = this.hasValue();
      return {
        clearValue: a,
        cx: l,
        getStyles: u,
        getClassNames: f,
        getValue: h,
        hasValue: T,
        isMulti: S,
        isRtl: w,
        options: E,
        selectOption: v,
        selectProps: b,
        setValue: g,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var a = this.state.selectValue;
      return a.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var a = this.props, l = a.isClearable, u = a.isMulti;
      return l === void 0 ? u : l;
    }
  }, {
    key: "isOptionDisabled",
    value: function(a, l) {
      return NW(this.props, a, l);
    }
  }, {
    key: "isOptionSelected",
    value: function(a, l) {
      return MW(this.props, a, l);
    }
  }, {
    key: "filterOption",
    value: function(a, l) {
      return LW(this.props, a, l);
    }
  }, {
    key: "formatOptionLabel",
    value: function(a, l) {
      if (typeof this.props.formatOptionLabel == "function") {
        var u = this.props.inputValue, f = this.state.selectValue;
        return this.props.formatOptionLabel(a, {
          context: l,
          inputValue: u,
          selectValue: f
        });
      } else
        return this.getOptionLabel(a);
    }
  }, {
    key: "formatGroupLabel",
    value: function(a) {
      return this.props.formatGroupLabel(a);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var a = this.props, l = a.isDisabled, u = a.isSearchable, f = a.inputId, h = a.inputValue, v = a.tabIndex, g = a.form, b = a.menuIsOpen, S = a.required, w = this.getComponents(), E = w.Input, T = this.state, A = T.inputIsHidden, P = T.ariaSelection, _ = this.commonProps, D = f || this.getElementId("input"), L = $t($t($t({
          "aria-autocomplete": "list",
          "aria-expanded": b,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": S,
          role: "combobox"
        }, b && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !u && {
          "aria-readonly": !0
        }), this.hasValue() ? (P == null ? void 0 : P.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return u ? /* @__PURE__ */ Fe.createElement(E, Dt({}, _, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: D,
          innerRef: this.getInputRef,
          isDisabled: l,
          isHidden: A,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: v,
          form: g,
          type: "text",
          value: h
        }, L)) : /* @__PURE__ */ Fe.createElement(OTe, Dt({
          id: D,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: cE,
          onFocus: this.onInputFocus,
          disabled: l,
          tabIndex: v,
          inputMode: "none",
          form: g,
          value: ""
        }, L));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var a = this, l = this.getComponents(), u = l.MultiValue, f = l.MultiValueContainer, h = l.MultiValueLabel, v = l.MultiValueRemove, g = l.SingleValue, b = l.Placeholder, S = this.commonProps, w = this.props, E = w.controlShouldRenderValue, T = w.isDisabled, A = w.isMulti, P = w.inputValue, _ = w.placeholder, D = this.state, L = D.selectValue, F = D.focusedValue, V = D.isFocused;
      if (!this.hasValue() || !E)
        return P ? null : /* @__PURE__ */ Fe.createElement(b, Dt({}, S, {
          key: "placeholder",
          isDisabled: T,
          isFocused: V,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), _);
      if (A)
        return L.map(function(U, W) {
          var H = U === F, G = "".concat(a.getOptionLabel(U), "-").concat(a.getOptionValue(U));
          return /* @__PURE__ */ Fe.createElement(u, Dt({}, S, {
            components: {
              Container: f,
              Label: h,
              Remove: v
            },
            isFocused: H,
            isDisabled: T,
            key: G,
            index: W,
            removeProps: {
              onClick: function() {
                return a.removeValue(U);
              },
              onTouchEnd: function() {
                return a.removeValue(U);
              },
              onMouseDown: function(ce) {
                ce.preventDefault();
              }
            },
            data: U
          }), a.formatOptionLabel(U, "value"));
        });
      if (P)
        return null;
      var $ = L[0];
      return /* @__PURE__ */ Fe.createElement(g, Dt({}, S, {
        data: $,
        isDisabled: T
      }), this.formatOptionLabel($, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var a = this.getComponents(), l = a.ClearIndicator, u = this.commonProps, f = this.props, h = f.isDisabled, v = f.isLoading, g = this.state.isFocused;
      if (!this.isClearable() || !l || h || !this.hasValue() || v)
        return null;
      var b = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Fe.createElement(l, Dt({}, u, {
        innerProps: b,
        isFocused: g
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var a = this.getComponents(), l = a.LoadingIndicator, u = this.commonProps, f = this.props, h = f.isDisabled, v = f.isLoading, g = this.state.isFocused;
      if (!l || !v)
        return null;
      var b = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Fe.createElement(l, Dt({}, u, {
        innerProps: b,
        isDisabled: h,
        isFocused: g
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var a = this.getComponents(), l = a.DropdownIndicator, u = a.IndicatorSeparator;
      if (!l || !u)
        return null;
      var f = this.commonProps, h = this.props.isDisabled, v = this.state.isFocused;
      return /* @__PURE__ */ Fe.createElement(u, Dt({}, f, {
        isDisabled: h,
        isFocused: v
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var a = this.getComponents(), l = a.DropdownIndicator;
      if (!l)
        return null;
      var u = this.commonProps, f = this.props.isDisabled, h = this.state.isFocused, v = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ Fe.createElement(l, Dt({}, u, {
        innerProps: v,
        isDisabled: f,
        isFocused: h
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var a = this, l = this.getComponents(), u = l.Group, f = l.GroupHeading, h = l.Menu, v = l.MenuList, g = l.MenuPortal, b = l.LoadingMessage, S = l.NoOptionsMessage, w = l.Option, E = this.commonProps, T = this.state.focusedOption, A = this.props, P = A.captureMenuScroll, _ = A.inputValue, D = A.isLoading, L = A.loadingMessage, F = A.minMenuHeight, V = A.maxMenuHeight, $ = A.menuIsOpen, U = A.menuPlacement, W = A.menuPosition, H = A.menuPortalTarget, G = A.menuShouldBlockScroll, oe = A.menuShouldScrollIntoView, ce = A.noOptionsMessage, te = A.onMenuScrollToTop, Ee = A.onMenuScrollToBottom;
      if (!$)
        return null;
      var me = function(K, ne) {
        var pe = K.type, Oe = K.data, Ce = K.isDisabled, xe = K.isSelected, ie = K.label, ye = K.value, we = T === Oe, fe = Ce ? void 0 : function() {
          return a.onOptionHover(Oe);
        }, ze = Ce ? void 0 : function() {
          return a.selectOption(Oe);
        }, Ve = "".concat(a.getElementId("option"), "-").concat(ne), Ie = {
          id: Ve,
          onClick: ze,
          onMouseMove: fe,
          onMouseOver: fe,
          tabIndex: -1
        };
        return /* @__PURE__ */ Fe.createElement(w, Dt({}, E, {
          innerProps: Ie,
          data: Oe,
          isDisabled: Ce,
          isSelected: xe,
          key: Ve,
          label: ie,
          type: pe,
          value: ye,
          isFocused: we,
          innerRef: we ? a.getFocusedOptionRef : void 0
        }), a.formatOptionLabel(K.data, "menu"));
      }, J;
      if (this.hasOptions())
        J = this.getCategorizedOptions().map(function(de) {
          if (de.type === "group") {
            var K = de.data, ne = de.options, pe = de.index, Oe = "".concat(a.getElementId("group"), "-").concat(pe), Ce = "".concat(Oe, "-heading");
            return /* @__PURE__ */ Fe.createElement(u, Dt({}, E, {
              key: Oe,
              data: K,
              options: ne,
              Heading: f,
              headingProps: {
                id: Ce,
                data: de.data
              },
              label: a.formatGroupLabel(de.data)
            }), de.options.map(function(xe) {
              return me(xe, "".concat(pe, "-").concat(xe.index));
            }));
          } else if (de.type === "option")
            return me(de, "".concat(de.index));
        });
      else if (D) {
        var Q = L({
          inputValue: _
        });
        if (Q === null)
          return null;
        J = /* @__PURE__ */ Fe.createElement(b, E, Q);
      } else {
        var ge = ce({
          inputValue: _
        });
        if (ge === null)
          return null;
        J = /* @__PURE__ */ Fe.createElement(S, E, ge);
      }
      var Y = {
        minMenuHeight: F,
        maxMenuHeight: V,
        menuPlacement: U,
        menuPosition: W,
        menuShouldScrollIntoView: oe
      }, q = /* @__PURE__ */ Fe.createElement(sEe, Dt({}, E, Y), function(de) {
        var K = de.ref, ne = de.placerProps, pe = ne.placement, Oe = ne.maxHeight;
        return /* @__PURE__ */ Fe.createElement(h, Dt({}, E, Y, {
          innerRef: K,
          innerProps: {
            onMouseDown: a.onMenuMouseDown,
            onMouseMove: a.onMenuMouseMove,
            id: a.getElementId("listbox")
          },
          isLoading: D,
          placement: pe
        }), /* @__PURE__ */ Fe.createElement(BTe, {
          captureEnabled: P,
          onTopArrive: te,
          onBottomArrive: Ee,
          lockEnabled: G
        }, function(Ce) {
          return /* @__PURE__ */ Fe.createElement(v, Dt({}, E, {
            innerRef: function(ie) {
              a.getMenuListRef(ie), Ce(ie);
            },
            isLoading: D,
            maxHeight: Oe,
            focusedOption: T
          }), J);
        }));
      });
      return H || W === "fixed" ? /* @__PURE__ */ Fe.createElement(g, Dt({}, E, {
        appendTo: H,
        controlElement: this.controlRef,
        menuPlacement: U,
        menuPosition: W
      }), q) : q;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var a = this, l = this.props, u = l.delimiter, f = l.isDisabled, h = l.isMulti, v = l.name, g = l.required, b = this.state.selectValue;
      if (g && !this.hasValue() && !f)
        return /* @__PURE__ */ Fe.createElement(HTe, {
          name: v,
          onFocus: this.onValueInputFocus
        });
      if (!(!v || f))
        if (h)
          if (u) {
            var S = b.map(function(T) {
              return a.getOptionValue(T);
            }).join(u);
            return /* @__PURE__ */ Fe.createElement("input", {
              name: v,
              type: "hidden",
              value: S
            });
          } else {
            var w = b.length > 0 ? b.map(function(T, A) {
              return /* @__PURE__ */ Fe.createElement("input", {
                key: "i-".concat(A),
                name: v,
                type: "hidden",
                value: a.getOptionValue(T)
              });
            }) : /* @__PURE__ */ Fe.createElement("input", {
              name: v,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ Fe.createElement("div", null, w);
          }
        else {
          var E = b[0] ? this.getOptionValue(b[0]) : "";
          return /* @__PURE__ */ Fe.createElement("input", {
            name: v,
            type: "hidden",
            value: E
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var a = this.commonProps, l = this.state, u = l.ariaSelection, f = l.focusedOption, h = l.focusedValue, v = l.isFocused, g = l.selectValue, b = this.getFocusableOptions();
      return /* @__PURE__ */ Fe.createElement(TTe, Dt({}, a, {
        id: this.getElementId("live-region"),
        ariaSelection: u,
        focusedOption: f,
        focusedValue: h,
        isFocused: v,
        selectValue: g,
        focusableOptions: b
      }));
    }
  }, {
    key: "render",
    value: function() {
      var a = this.getComponents(), l = a.Control, u = a.IndicatorsContainer, f = a.SelectContainer, h = a.ValueContainer, v = this.props, g = v.className, b = v.id, S = v.isDisabled, w = v.menuIsOpen, E = this.state.isFocused, T = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ Fe.createElement(f, Dt({}, T, {
        className: g,
        innerProps: {
          id: b,
          onKeyDown: this.onKeyDown
        },
        isDisabled: S,
        isFocused: E
      }), this.renderLiveRegion(), /* @__PURE__ */ Fe.createElement(l, Dt({}, T, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: S,
        isFocused: E,
        menuIsOpen: w
      }), /* @__PURE__ */ Fe.createElement(h, Dt({}, T, {
        isDisabled: S
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ Fe.createElement(u, Dt({}, T, {
        isDisabled: S
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(a, l) {
      var u = l.prevProps, f = l.clearFocusValueOnUpdate, h = l.inputIsHiddenAfterUpdate, v = l.ariaSelection, g = l.isFocused, b = l.prevWasFocused, S = a.options, w = a.value, E = a.menuIsOpen, T = a.inputValue, A = a.isMulti, P = kz(w), _ = {};
      if (u && (w !== u.value || S !== u.options || E !== u.menuIsOpen || T !== u.inputValue)) {
        var D = E ? eIe(a, P) : [], L = f ? tIe(l, P) : null, F = nIe(l, D);
        _ = {
          selectValue: P,
          focusedOption: F,
          focusedValue: L,
          clearFocusValueOnUpdate: !1
        };
      }
      var V = h != null && a !== u ? {
        inputIsHidden: h,
        inputIsHiddenAfterUpdate: void 0
      } : {}, $ = v, U = g && b;
      return g && !U && ($ = {
        value: jC(A, P, P[0] || null),
        options: P,
        action: "initial-input-focus"
      }, U = !b), (v == null ? void 0 : v.action) === "initial-input-focus" && ($ = null), $t($t($t({}, _), V), {}, {
        prevProps: a,
        ariaSelection: $,
        prevWasFocused: U
      });
    }
  }]), n;
}(fJ);
BW.defaultProps = qTe;
var oIe = /* @__PURE__ */ fr(function(e, t) {
  var n = YCe(e);
  return /* @__PURE__ */ Fe.createElement(BW, Dt({
    ref: t
  }, n));
}), iIe = oIe, aIe = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
function t_() {
  return t_ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, t_.apply(this, arguments);
}
function sIe(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var VW = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = sIe(t, aIe);
  return t_({}, n);
}, lIe = function(t) {
  var n = typeof t == "string";
  return n && ["sm", "md", "lg"].includes(t);
}, uIe = function(t) {
  return lIe(t) ? t : t === "xs" ? "sm" : t === "xl" ? "lg" : "md";
}, El = function(t) {
  var n = wl(), o = uIe(n.components.Input.defaultProps.size), a = t ?? o, l = bhe(typeof a == "string" ? [a] : a, {
    fallback: "md"
  }) || o;
  return l;
};
function yg() {
  return yg = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, yg.apply(this, arguments);
}
var cIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.isDisabled, f = t.isRtl, h = t.hasValue, v = t.selectProps.chakraStyles, g = yg({
    position: "relative",
    direction: f ? "rtl" : void 0
  }, u ? {
    cursor: "not-allowed"
  } : {}), b = v != null && v.container ? v.container(g, t) : g;
  return /* @__PURE__ */ Tt.createElement(qr, yg({}, l, {
    className: a({
      "--is-disabled": u,
      "--is-rtl": f,
      "--has-value": h
    }, o),
    sx: b
  }), n);
}, dIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.isMulti, u = t.hasValue, f = t.innerProps, h = t.selectProps, v = h.chakraStyles, g = h.size, b = h.variant, S = h.focusBorderColor, w = h.errorBorderColor, E = h.controlShouldRenderValue, T = El(g), A = Xn("Input", {
    size: T,
    variant: b,
    focusBorderColor: S,
    errorBorderColor: w
  }), P = {
    display: l && u && E ? "flex" : "grid",
    alignItems: "center",
    flex: 1,
    paddingY: "2px",
    paddingX: A.field.px,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, _ = v != null && v.valueContainer ? v.valueContainer(P, t) : P;
  return /* @__PURE__ */ Tt.createElement(qr, yg({}, f, {
    className: a({
      "value-container": !0,
      "value-container--is-multi": l,
      "value-container--has-value": u
    }, o),
    sx: _
  }), n);
}, fIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps.chakraStyles, f = {
    display: "flex",
    alignItems: "center",
    alignSelf: "stretch",
    flexShrink: 0
  }, h = u != null && u.indicatorsContainer ? u.indicatorsContainer(f, t) : f;
  return /* @__PURE__ */ Tt.createElement(qr, yg({}, l, {
    className: a({
      indicators: !0
    }, o),
    sx: h
  }), n);
}, pIe = ["height", "h"];
function ks() {
  return ks = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, ks.apply(this, arguments);
}
function hIe(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var mIe = function(t) {
  var n = t.className, o = t.cx, a = t.children, l = t.innerRef, u = t.innerProps, f = t.isDisabled, h = t.isFocused, v = t.menuIsOpen, g = t.selectProps, b = g.chakraStyles, S = g.size, w = g.variant, E = g.focusBorderColor, T = g.errorBorderColor, A = g.isInvalid, P = g.isReadOnly, _ = El(S), D = Xn("Input", {
    size: _,
    variant: w,
    focusBorderColor: E,
    errorBorderColor: T
  }), L = D.field, F = L.height, V = L.h, $ = hIe(L, pIe), U = F || V, W = ks({}, $, {
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    flexWrap: "wrap",
    padding: 0,
    overflow: "hidden",
    height: "auto",
    minH: U
  }, f ? {
    pointerEvents: "none"
  } : {}), H = b != null && b.control ? b.control(W, t) : W;
  return /* @__PURE__ */ Tt.createElement(qr, ks({
    ref: l,
    className: o({
      control: !0,
      "control--is-disabled": f,
      "control--is-focused": h,
      "control--menu-is-open": v
    }, n),
    sx: H
  }, u, {
    "data-focus": h ? !0 : void 0,
    "data-focus-visible": h ? !0 : void 0,
    "data-invalid": A ? !0 : void 0,
    "data-disabled": f ? !0 : void 0,
    "data-readonly": P ? !0 : void 0
  }), a);
}, vIe = function(t) {
  var n = t.className, o = t.cx, a = t.selectProps, l = a.chakraStyles, u = a.useBasicStyles, f = a.variant, h = ks({
    opacity: 1
  }, u || f !== "outline" ? {
    display: "none"
  } : {}), v = l != null && l.indicatorSeparator ? l.indicatorSeparator(h, t) : h;
  return /* @__PURE__ */ Tt.createElement(aT, {
    className: o({
      "indicator-separator": !0
    }, n),
    sx: v,
    orientation: "vertical"
  });
}, gIe = function(t) {
  return /* @__PURE__ */ Tt.createElement(ho, ks({
    role: "presentation",
    focusable: "false",
    "aria-hidden": "true"
  }, t), /* @__PURE__ */ Tt.createElement("path", {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }));
}, yIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps, f = u.chakraStyles, h = u.useBasicStyles, v = u.size, g = u.focusBorderColor, b = u.errorBorderColor, S = u.variant, w = El(v), E = Xn("Input", {
    size: w,
    variant: S,
    focusBorderColor: g,
    errorBorderColor: b
  }), T = {
    sm: "16px",
    md: "20px",
    lg: "24px"
  }, A = T[w], P = ks({}, E.addon, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "100%",
    borderRadius: 0,
    borderWidth: 0,
    fontSize: A
  }, h && {
    background: "transparent",
    padding: 0,
    width: 6,
    marginRight: 2,
    marginLeft: 1,
    cursor: "inherit"
  }), _ = f != null && f.dropdownIndicator ? f.dropdownIndicator(P, t) : P, D = {
    height: "1em",
    width: "1em"
  }, L = f != null && f.downChevron ? f.downChevron(D, t) : D;
  return /* @__PURE__ */ Tt.createElement(qr, ks({}, l, {
    className: a({
      indicator: !0,
      "dropdown-indicator": !0
    }, o),
    sx: _
  }), n || /* @__PURE__ */ Tt.createElement(gIe, {
    sx: L
  }));
}, bIe = function(t) {
  return /* @__PURE__ */ Tt.createElement(ho, ks({
    focusable: "false",
    "aria-hidden": !0
  }, t), /* @__PURE__ */ Tt.createElement("path", {
    fill: "currentColor",
    d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
  }));
}, SIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps, f = u.chakraStyles, h = u.size, v = El(h), g = Gi("CloseButton", {
    size: v
  }), b = ks({}, g, {
    marginX: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    cursor: "pointer"
  }), S = f != null && f.clearIndicator ? f.clearIndicator(b, t) : b, w = {
    width: "1em",
    height: "1em"
  }, E = f != null && f.crossIcon ? f.crossIcon(w, t) : w;
  return /* @__PURE__ */ Tt.createElement(qr, ks({
    role: "button",
    className: a({
      indicator: !0,
      "clear-indicator": !0
    }, o),
    sx: S,
    "aria-label": "Clear selected options"
  }, l), n || /* @__PURE__ */ Tt.createElement(bIe, {
    sx: E
  }));
}, xIe = function(t) {
  var n = t.className, o = t.cx, a = t.innerProps, l = t.selectProps, u = l.chakraStyles, f = l.size, h = t.color, v = t.emptyColor, g = t.speed, b = t.thickness, S = t.spinnerSize, w = El(f), E = {
    sm: "xs",
    md: "sm",
    lg: "md"
  }, T = E[w], A = {
    marginRight: 3
  }, P = u != null && u.loadingIndicator ? u.loadingIndicator(A, t) : A;
  return /* @__PURE__ */ Tt.createElement(eT, ks({
    className: o({
      indicator: !0,
      "loading-indicator": !0
    }, n),
    sx: P
  }, a, {
    size: S || T,
    color: h,
    emptyColor: v,
    speed: g,
    thickness: b
  }));
};
const CIe = mIe;
var wIe = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
function O0() {
  return O0 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, O0.apply(this, arguments);
}
function EIe(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var TIe = function(t) {
  var n = t.className, o = t.cx, a = t.value, l = t.selectProps, u = l.chakraStyles, f = l.isReadOnly, h = VW(t), v = h.innerRef, g = h.isDisabled, b = h.isHidden, S = h.inputClassName, w = EIe(h, wIe), E = {
    gridArea: "1 / 2",
    minW: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0
  }, T = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    color: "inherit",
    marginX: "0.125rem",
    paddingY: "0.125rem",
    visibility: g ? "hidden" : "visible",
    // Force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: a ? "translateZ(0)" : "",
    _after: O0({
      content: 'attr(data-value) " "',
      visibility: "hidden",
      whiteSpace: "pre",
      padding: 0
    }, E)
  }, A = u != null && u.inputContainer ? u.inputContainer(T, t) : T, P = O0({
    background: 0,
    opacity: b ? 0 : 1,
    width: "100%"
  }, E), _ = u != null && u.input ? u.input(P, t) : P;
  return /* @__PURE__ */ Tt.createElement(qr, {
    className: o({
      "input-container": !0
    }, n),
    "data-value": a || "",
    sx: A
  }, /* @__PURE__ */ Tt.createElement(De.input, O0({
    className: o({
      input: !0
    }, S),
    ref: v,
    sx: _,
    disabled: g,
    readOnly: f ? !0 : void 0
  }, w)));
};
const IIe = TIe;
var AIe = ["data"];
function kIe(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function xa() {
  return xa = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, xa.apply(this, arguments);
}
var RIe = function(t) {
  var n = {
    bottom: "top",
    top: "bottom"
  };
  return t ? n[t] : "top";
}, PIe = function(t) {
  var n, o = t.className, a = t.cx, l = t.children, u = t.innerProps, f = t.innerRef, h = t.placement, v = t.selectProps.chakraStyles, g = (n = {
    position: "absolute"
  }, n[RIe(h)] = "100%", n.marginY = "8px", n.width = "100%", n.zIndex = 1, n), b = v != null && v.menu ? v.menu(g, t) : g;
  return /* @__PURE__ */ Tt.createElement(K2, null, /* @__PURE__ */ Tt.createElement(qr, xa({}, u, {
    ref: f,
    className: a({
      menu: !0
    }, o),
    sx: b
  }), l));
};
const OIe = PIe;
var _Ie = function(t) {
  var n, o = t.className, a = t.cx, l = t.innerRef, u = t.children, f = t.maxHeight, h = t.isMulti, v = t.innerProps, g = t.selectProps, b = g.chakraStyles, S = g.size, w = g.variant, E = g.focusBorderColor, T = g.errorBorderColor, A = Xn("Menu"), P = El(S), _ = Xn("Input", {
    size: P,
    variant: w,
    focusBorderColor: E,
    errorBorderColor: T
  }), D = _.field, L = xa({}, A.list, {
    minW: "100%",
    maxHeight: f + "px",
    overflowY: "auto",
    // This is hacky, but it works. May be removed in the future
    "--input-border-radius": D == null ? void 0 : D["--input-border-radius"],
    borderRadius: (D == null ? void 0 : D.borderRadius) || ((n = A.list) == null ? void 0 : n.borderRadius),
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }), F = b != null && b.menuList ? b.menuList(L, t) : L;
  return /* @__PURE__ */ Tt.createElement(qr, xa({
    role: "listbox"
  }, v, {
    className: a({
      "menu-list": !0,
      "menu-list--is-multi": h
    }, o),
    sx: F,
    ref: l
  }), u);
}, DIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps, f = u.chakraStyles, h = u.size, v = El(h), g = {
    sm: "6px",
    md: "8px",
    lg: "10px"
  }, b = {
    color: "chakra-subtle-text",
    textAlign: "center",
    paddingY: g[v],
    fontSize: v
  }, S = f != null && f.loadingMessage ? f.loadingMessage(b, t) : b;
  return /* @__PURE__ */ Tt.createElement(qr, xa({}, l, {
    className: a({
      "menu-notice": !0,
      "menu-notice--loading": !0
    }, o),
    sx: S
  }), n);
}, NIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps, f = u.chakraStyles, h = u.size, v = El(h), g = {
    sm: "6px",
    md: "8px",
    lg: "10px"
  }, b = {
    color: "chakra-subtle-text",
    textAlign: "center",
    paddingY: g[v],
    fontSize: v
  }, S = f != null && f.noOptionsMessage ? f.noOptionsMessage(b, t) : b;
  return /* @__PURE__ */ Tt.createElement(qr, xa({}, l, {
    className: a({
      "menu-notice": !0,
      "menu-notice--no-options": !0
    }, o),
    sx: S
  }), n);
}, MIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.theme, u = t.getStyles, f = t.Heading, h = t.headingProps, v = t.label, g = t.selectProps, b = t.innerProps, S = t.getClassNames, w = g.chakraStyles, E = {}, T = w != null && w.group ? w.group(E, t) : E;
  return /* @__PURE__ */ Tt.createElement(qr, xa({}, b, {
    className: a({
      group: !0
    }, o),
    sx: T
  }), /* @__PURE__ */ Tt.createElement(f, xa({}, h, {
    selectProps: g,
    cx: a,
    theme: l,
    getStyles: u,
    getClassNames: S
  }), v), /* @__PURE__ */ Tt.createElement(qr, null, n));
}, LIe = function(t) {
  var n = t.cx, o = t.className, a = t.selectProps, l = a.chakraStyles, u = a.size, f = a.hasStickyGroupHeaders, h = VW(t);
  h.data;
  var v = kIe(h, AIe), g = Xn("Menu"), b = El(u), S = {
    sm: "xs",
    md: "sm",
    lg: "md"
  }, w = {
    sm: "0.4rem 0.8rem",
    md: "0.5rem 1rem",
    lg: "0.6rem 1.2rem"
  }, E = xa({}, g.groupTitle, {
    fontSize: S[b],
    padding: w[b],
    margin: 0,
    borderBottomWidth: f ? "1px" : 0,
    position: f ? "sticky" : "static",
    top: -2,
    bg: g.list.bg,
    zIndex: 1
  }), T = l != null && l.groupHeading ? l.groupHeading(E, t) : E;
  return /* @__PURE__ */ Tt.createElement(qr, xa({}, v, {
    className: n({
      "group-heading": !0
    }, o),
    sx: T
  }));
}, FIe = function(t) {
  return /* @__PURE__ */ Tt.createElement("svg", xa({
    viewBox: "0 0 14 14",
    width: "1em",
    height: "1em"
  }, t), /* @__PURE__ */ Tt.createElement("polygon", {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }));
}, BIe = function(t) {
  var n = t.className, o = t.cx, a = t.innerRef, l = t.innerProps, u = t.children, f = t.isFocused, h = t.isDisabled, v = t.isSelected, g = t.selectProps, b = g.chakraStyles, S = g.size, w = g.isMulti, E = g.hideSelectedOptions, T = g.selectedOptionStyle, A = g.selectedOptionColorScheme, P = Xn("Menu").item, _ = El(S), D = {
    sm: "0.6rem",
    md: "0.8rem",
    lg: "1rem"
  }, L = {
    sm: "0.3rem",
    md: "0.4rem",
    lg: "0.5rem"
  }, F = JF(A + ".500", A + ".300"), V = JF("white", "black"), $ = T === "check" && (!w || E === !1), U = T === "color", W = xa({}, P, {
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    width: "100%",
    textAlign: "start",
    fontSize: _,
    paddingX: D[_],
    paddingY: L[_]
  }, U && {
    _selected: {
      bg: F,
      color: V,
      _active: {
        bg: F
      }
    }
  }), H = b != null && b.option ? b.option(W, t) : W;
  return /* @__PURE__ */ Tt.createElement(qr, xa({
    role: "option"
  }, l, {
    className: o({
      option: !0,
      "option--is-disabled": h,
      "option--is-focused": f,
      "option--is-selected": v
    }, n),
    sx: H,
    ref: a,
    "data-focus": f ? !0 : void 0,
    "aria-disabled": h ? !0 : void 0,
    "aria-selected": v
  }), $ && /* @__PURE__ */ Tt.createElement(lT, {
    fontSize: "0.8em",
    marginEnd: "0.75rem",
    opacity: v ? 1 : 0
  }, /* @__PURE__ */ Tt.createElement(FIe, null)), u);
};
function gl() {
  return gl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, gl.apply(this, arguments);
}
var VIe = function(t) {
  return typeof t == "object" && t !== null && "colorScheme" in t && typeof t.colorScheme == "string";
}, $Ie = function(t) {
  return typeof t == "object" && t !== null && "variant" in t && typeof t.variant == "string";
}, $W = function(t) {
  return typeof t == "object" && t !== null && "isFixed" in t && typeof t.isFixed == "boolean";
}, zIe = function(t) {
  var n = t.children, o = t.className, a = t.components, l = t.cx, u = t.data, f = t.innerProps, h = t.isDisabled, v = t.isFocused, g = t.removeProps, b = t.selectProps, S = t.cropWithEllipsis, w = a.Container, E = a.Label, T = a.Remove, A = b.chakraStyles, P = b.colorScheme, _ = b.tagVariant, D = b.size, L = El(D), F = "", V = "", $ = !1;
  VIe(u) && (F = u.colorScheme), $Ie(u) && (V = u.variant), $W(u) && ($ = u.isFixed);
  var U = Xn("Tag", {
    size: L,
    colorScheme: F || P,
    variant: V || _ || ($ ? "solid" : "subtle")
  }), W = gl({}, U.container, {
    display: "flex",
    alignItems: "center",
    minWidth: 0,
    // resolves flex/text-overflow bug
    margin: "0.125rem"
  }), H = A != null && A.multiValue ? A.multiValue(W, t) : W, G = gl({}, U.label, {
    overflow: "hidden",
    textOverflow: S || S === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }), oe = A != null && A.multiValueLabel ? A.multiValueLabel(G, t) : G, ce = gl({}, U.closeButton, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }), te = A != null && A.multiValueRemove ? A.multiValueRemove(ce, t) : ce;
  return /* @__PURE__ */ Tt.createElement(w, {
    data: u,
    innerProps: gl({
      className: l({
        "multi-value": !0,
        "multi-value--is-disabled": h
      }, o)
    }, f),
    sx: H,
    selectProps: b
  }, /* @__PURE__ */ Tt.createElement(E, {
    data: u,
    innerProps: {
      className: l({
        "multi-value__label": !0
      }, o)
    },
    sx: oe,
    selectProps: b
  }, n), /* @__PURE__ */ Tt.createElement(T, {
    data: u,
    innerProps: gl({
      className: l({
        "multi-value__remove": !0
      }, o),
      "aria-label": "Remove " + (n || "option")
    }, g),
    sx: te,
    selectProps: b,
    isFocused: v
  }));
}, HIe = function(t) {
  var n = t.children, o = t.innerProps, a = t.sx;
  return /* @__PURE__ */ Tt.createElement(De.span, gl({}, o, {
    sx: a
  }), n);
}, jIe = function(t) {
  var n = t.children, o = t.innerProps, a = t.sx;
  return /* @__PURE__ */ Tt.createElement(De.span, gl({}, o, {
    sx: a
  }), n);
}, GIe = function(t) {
  return /* @__PURE__ */ Tt.createElement(ho, gl({
    verticalAlign: "inherit",
    viewBox: "0 0 512 512"
  }, t), /* @__PURE__ */ Tt.createElement("path", {
    fill: "currentColor",
    d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
  }));
}, WIe = function(t) {
  var n = t.children, o = t.innerProps, a = t.isFocused, l = t.data, u = t.sx;
  return $W(l) && l.isFixed ? null : /* @__PURE__ */ Tt.createElement(qr, gl({}, o, {
    role: "button",
    sx: u,
    "data-focus": a ? !0 : void 0,
    "data-focus-visible": a ? !0 : void 0
  }), n || /* @__PURE__ */ Tt.createElement(GIe, null));
};
const UIe = zIe;
function n_() {
  return n_ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, n_.apply(this, arguments);
}
var XIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.innerProps, u = t.selectProps.chakraStyles, f = {
    gridArea: "1 / 1 / 2 / 3",
    color: "chakra-placeholder-color",
    mx: "0.125rem",
    userSelect: "none"
  }, h = u != null && u.placeholder ? u.placeholder(f, t) : f;
  return /* @__PURE__ */ Tt.createElement(qr, n_({}, l, {
    className: a({
      placeholder: !0
    }, o),
    sx: h
  }), n);
};
const ZIe = XIe;
function r_() {
  return r_ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, r_.apply(this, arguments);
}
var YIe = function(t) {
  var n = t.children, o = t.className, a = t.cx, l = t.isDisabled, u = t.innerProps, f = t.selectProps.chakraStyles, h = {
    gridArea: "1 / 1 / 2 / 3",
    mx: "0.125rem",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, v = f != null && f.singleValue ? f.singleValue(h, t) : h;
  return /* @__PURE__ */ Tt.createElement(qr, r_({
    className: a({
      "single-value": !0,
      "single-value--is-disabled": l
    }, o),
    sx: v
  }, u), n);
};
const JIe = YIe;
var QIe = {
  ClearIndicator: SIe,
  Control: CIe,
  DropdownIndicator: yIe,
  Group: MIe,
  GroupHeading: LIe,
  IndicatorSeparator: vIe,
  IndicatorsContainer: fIe,
  Input: IIe,
  LoadingIndicator: xIe,
  LoadingMessage: DIe,
  Menu: OIe,
  MenuList: _Ie,
  MultiValue: UIe,
  MultiValueContainer: HIe,
  MultiValueLabel: jIe,
  MultiValueRemove: WIe,
  NoOptionsMessage: NIe,
  Option: BIe,
  Placeholder: ZIe,
  SelectContainer: cIe,
  SingleValue: JIe,
  ValueContainer: dIe
};
const pE = QIe;
var KIe = ["components", "theme", "size", "colorScheme", "isDisabled", "isInvalid", "isReadOnly", "required", "isRequired", "inputId", "tagVariant", "selectedOptionStyle", "selectedOptionColorScheme", "selectedOptionColor", "variant", "focusBorderColor", "errorBorderColor", "chakraStyles", "onFocus", "onBlur", "menuIsOpen"];
function hE() {
  return hE = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, hE.apply(this, arguments);
}
function qIe(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var eAe = function(t) {
  var n, o = t.components, a = o === void 0 ? {} : o;
  t.theme;
  var l = t.size, u = t.colorScheme, f = u === void 0 ? "gray" : u, h = t.isDisabled, v = t.isInvalid, g = t.isReadOnly, b = t.required, S = t.isRequired, w = t.inputId, E = t.tagVariant, T = t.selectedOptionStyle, A = T === void 0 ? "color" : T, P = t.selectedOptionColorScheme, _ = t.selectedOptionColor, D = t.variant, L = t.focusBorderColor, F = t.errorBorderColor, V = t.chakraStyles, $ = V === void 0 ? {} : V, U = t.onFocus, W = t.onBlur, H = t.menuIsOpen, G = qIe(t, KIe), oe = wl(), ce = oe.components.Input.defaultProps.variant, te = yh({
    id: w,
    isDisabled: h,
    isInvalid: v,
    isRequired: S,
    isReadOnly: g,
    onFocus: U,
    onBlur: W
  }), Ee = H ?? (te.readOnly ? !1 : void 0), me = A, J = ["color", "check"];
  J.includes(A) || (me = "color");
  var Q = P || _ || "blue";
  typeof Q != "string" && (Q = "blue");
  var ge = hE({
    // Allow overriding of custom components
    components: hE({}, pE, a),
    // Custom select props
    colorScheme: f,
    size: l,
    tagVariant: E,
    selectedOptionStyle: me,
    selectedOptionColorScheme: Q,
    variant: D ?? ce,
    chakraStyles: $,
    focusBorderColor: L,
    errorBorderColor: F,
    // Extract custom props from form control
    onFocus: te.onFocus,
    onBlur: te.onBlur,
    isDisabled: te.disabled,
    isInvalid: !!te["aria-invalid"],
    inputId: te.id,
    isReadOnly: te.readOnly,
    required: b ?? te.required,
    menuIsOpen: Ee
  }, G, {
    // aria-invalid can be passed to react-select, so we allow that to
    // override the `isInvalid` prop
    "aria-invalid": (n = G["aria-invalid"]) != null ? n : te["aria-invalid"]
  });
  return ge;
};
function o_() {
  return o_ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, o_.apply(this, arguments);
}
var tAe = /* @__PURE__ */ fr(function(e, t) {
  var n = eAe(e);
  return /* @__PURE__ */ Tt.createElement(iIe, o_({
    ref: t
  }, n));
});
const nAe = tAe;
/*!
 * OverlayScrollbars
 * Version: 2.4.6
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
const yl = (e, t) => {
  const { o: n, u: o, _: a } = e;
  let l = n, u;
  const f = (g, b) => {
    const S = l, w = g, E = b || (o ? !o(S, w) : S !== w);
    return (E || a) && (l = w, u = S), [l, E, u];
  };
  return [t ? (g) => f(t(l, u), g) : f, (g) => [l, !!g, u]];
}, bD = typeof window < "u", zW = bD && Node.ELEMENT_NODE, { toString: rAe, hasOwnProperty: yP } = Object.prototype, oAe = /^\[object (.+)\]$/, wh = (e) => e === void 0, IT = (e) => e === null, iAe = (e) => wh(e) || IT(e) ? `${e}` : rAe.call(e).replace(oAe, "$1").toLowerCase(), gu = (e) => typeof e == "number", IS = (e) => typeof e == "string", HW = (e) => typeof e == "boolean", Su = (e) => typeof e == "function", xu = (e) => Array.isArray(e), nS = (e) => typeof e == "object" && !xu(e) && !IT(e), AT = (e) => {
  const t = !!e && e.length, n = gu(t) && t > -1 && t % 1 == 0;
  return xu(e) || !Su(e) && n ? t > 0 && nS(e) ? t - 1 in e : !0 : !1;
}, mE = (e) => {
  if (!e || !nS(e) || iAe(e) !== "object")
    return !1;
  let t;
  const n = "constructor", o = e[n], a = o && o.prototype, l = yP.call(e, n), u = a && yP.call(a, "isPrototypeOf");
  if (o && !l && !u)
    return !1;
  for (t in e)
    ;
  return wh(t) || yP.call(e, t);
}, _0 = (e) => {
  const t = HTMLElement;
  return e ? t ? e instanceof t : e.nodeType === zW : !1;
}, kT = (e) => {
  const t = Element;
  return e ? t ? e instanceof t : e.nodeType === zW : !1;
};
function Vn(e, t) {
  if (AT(e))
    for (let n = 0; n < e.length && t(e[n], n, e) !== !1; n++)
      ;
  else
    e && Vn(Object.keys(e), (n) => t(e[n], n, e));
  return e;
}
const RT = (e, t) => e.indexOf(t) >= 0, Ic = (e, t) => e.concat(t), nr = (e, t, n) => (!n && !IS(t) && AT(t) ? Array.prototype.push.apply(e, t) : e.push(t), e), Pg = (e) => {
  const t = Array.from, n = [];
  return t && e ? t(e) : (e instanceof Set ? e.forEach((o) => {
    nr(n, o);
  }) : Vn(e, (o) => {
    nr(n, o);
  }), n);
}, jW = (e) => xu(e) ? e : [e], vE = (e) => !!e && !e.length, Gz = (e) => Pg(new Set(e)), Rs = (e, t, n) => {
  Vn(e, (a) => a && a.apply(void 0, t || [])), !n && (e.length = 0);
}, PT = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Vc = (e) => e ? Object.keys(e) : [], Wn = (e, t, n, o, a, l, u) => {
  const f = [t, n, o, a, l, u];
  return (typeof e != "object" || IT(e)) && !Su(e) && (e = {}), Vn(f, (h) => {
    Vn(h, (v, g) => {
      const b = h[g];
      if (e === b)
        return !0;
      const S = xu(b);
      if (b && mE(b)) {
        const w = e[g];
        let E = w;
        S && !xu(w) ? E = [] : !S && !mE(w) && (E = {}), e[g] = Wn(E, b);
      } else
        e[g] = S ? b.slice() : b;
    });
  }), e;
}, GW = (e, t) => Vn(Wn({}, e), (n, o, a) => {
  n === void 0 ? delete a[o] : t && n && mE(n) && (a[o] = GW(n, t));
}), SD = (e) => {
  for (const t in e)
    return !1;
  return !0;
}, $i = (e, t, n) => {
  if (wh(n))
    return e ? e.getAttribute(t) : null;
  e && e.setAttribute(t, n);
}, WW = (e, t) => new Set(($i(e, t) || "").split(" ")), ha = (e, t) => {
  e && e.removeAttribute(t);
}, oh = (e, t, n, o) => {
  if (n) {
    const a = WW(e, t);
    a[o ? "add" : "delete"](n);
    const l = Pg(a).join(" ").trim();
    $i(e, t, l);
  }
}, aAe = (e, t, n) => WW(e, t).has(n), i_ = bD && Element.prototype, UW = (e, t) => {
  const n = [], o = t ? kT(t) && t : document;
  return o ? nr(n, o.querySelectorAll(e)) : n;
}, sAe = (e, t) => {
  const n = t ? kT(t) && t : document;
  return n ? n.querySelector(e) : null;
}, gE = (e, t) => kT(e) ? (i_.matches || i_.msMatchesSelector).call(e, t) : !1, a_ = (e) => e ? Pg(e.childNodes) : [], _c = (e) => e && e.parentElement, zv = (e, t) => {
  if (kT(e)) {
    const n = i_.closest;
    if (n)
      return n.call(e, t);
    do {
      if (gE(e, t))
        return e;
      e = _c(e);
    } while (e);
  }
}, lAe = (e, t, n) => {
  const o = zv(e, t), a = e && sAe(n, o), l = zv(a, t) === o;
  return o && a ? o === e || a === e || l && zv(zv(e, n), t) !== o : !1;
}, ws = () => {
}, Dc = (e) => {
  if (AT(e))
    Vn(Pg(e), (t) => Dc(t));
  else if (e) {
    const t = _c(e);
    t && t.removeChild(e);
  }
}, xD = (e, t, n) => {
  if (n && e) {
    let o = t, a;
    return AT(n) ? (a = document.createDocumentFragment(), Vn(n, (l) => {
      l === o && (o = l.previousSibling), a.appendChild(l);
    })) : a = n, t && (o ? o !== t && (o = o.nextSibling) : o = e.firstChild), e.insertBefore(a, o || null), () => Dc(n);
  }
  return ws;
}, ys = (e, t) => xD(e, null, t), uAe = (e, t) => xD(_c(e), e, t), Wz = (e, t) => xD(_c(e), e && e.nextSibling, t), ih = (e) => {
  const t = document.createElement("div");
  return $i(t, "class", e), t;
}, XW = (e) => {
  const t = ih();
  return t.innerHTML = e.trim(), Vn(a_(t), (n) => Dc(n));
}, Za = bD ? window : {}, Ew = Math.max, cAe = Math.min, rS = Math.round, ZW = Za.cancelAnimationFrame, YW = Za.requestAnimationFrame, yE = Za.setTimeout, s_ = Za.clearTimeout, l_ = (e) => e.charAt(0).toUpperCase() + e.slice(1), dAe = () => ih().style, fAe = ["-webkit-", "-moz-", "-o-", "-ms-"], pAe = ["WebKit", "Moz", "O", "MS", "webkit", "moz", "o", "ms"], bP = {}, SP = {}, hAe = (e) => {
  let t = SP[e];
  if (PT(SP, e))
    return t;
  const n = l_(e), o = dAe();
  return Vn(fAe, (a) => {
    const l = a.replace(/-/g, "");
    return !(t = [e, a + e, l + n, l_(l) + n].find((f) => o[f] !== void 0));
  }), SP[e] = t || "";
}, OT = (e) => {
  let t = bP[e] || Za[e];
  return PT(bP, e) || (Vn(pAe, (n) => (t = t || Za[n + l_(e)], !t)), bP[e] = t), t;
}, mAe = OT("MutationObserver"), Uz = OT("IntersectionObserver"), bE = OT("ResizeObserver"), u_ = OT("ScrollTimeline"), Zt = (e, ...t) => e.bind(0, ...t), rf = (e) => {
  let t;
  const n = e ? yE : YW, o = e ? s_ : ZW;
  return [(a) => {
    o(t), t = n(a, Su(e) ? e() : e);
  }, () => o(t)];
}, JW = (e, t) => {
  let n, o, a, l = ws;
  const { v: u, p: f, S: h } = t || {}, v = function(E) {
    l(), s_(n), n = o = void 0, l = ws, e.apply(this, E);
  }, g = (w) => h && o ? h(o, w) : w, b = () => {
    l !== ws && v(g(a) || a);
  }, S = function() {
    const E = Pg(arguments), T = Su(u) ? u() : u;
    if (gu(T) && T >= 0) {
      const P = Su(f) ? f() : f, _ = gu(P) && P >= 0, D = T > 0 ? yE : YW, L = T > 0 ? s_ : ZW, V = g(E) || E, $ = v.bind(0, V);
      l();
      const U = D($, T);
      l = () => L(U), _ && !n && (n = yE(b, P)), o = a = V;
    } else
      v(E);
  };
  return S.m = b, S;
}, vAe = /[^\x20\t\r\n\f]+/g, QW = (e, t, n) => {
  const o = e && e.classList;
  let a, l = 0, u = !1;
  if (o && t && IS(t)) {
    const f = t.match(vAe) || [];
    for (u = f.length > 0; a = f[l++]; )
      u = !!n(o, a) && u;
  }
  return u;
}, CD = (e, t) => {
  QW(e, t, (n, o) => n.remove(o));
}, Sf = (e, t) => (QW(e, t, (n, o) => n.add(o)), Zt(CD, e, t)), gAe = /^--/, Xz = (e, t) => e.getPropertyValue(t) || e[t] || "", wD = (e) => {
  const t = e || 0;
  return isFinite(t) ? t : 0;
}, GC = (e) => wD(parseFloat(e || "")), WC = (e) => `${(wD(e) * 100).toFixed(3)}%`, h0 = (e) => `${wD(e)}px`;
function cf(e, t) {
  e && Vn(t, (n, o) => {
    try {
      const a = e.style, l = gu(n) ? h0(n) : n + "";
      gAe.test(o) ? a.setProperty(o, l) : a[o] = l;
    } catch {
    }
  });
}
function $c(e, t, n) {
  const o = IS(t);
  let a = o ? "" : {};
  if (e) {
    const l = Za.getComputedStyle(e, n) || e.style;
    a = o ? Xz(l, t) : t.reduce((u, f) => (u[f] = Xz(l, f), u), a);
  }
  return a;
}
const ng = (e) => $c(e, "direction") === "rtl", Zz = (e, t, n) => {
  const o = t ? `${t}-` : "", a = n ? `-${n}` : "", l = `${o}top${a}`, u = `${o}right${a}`, f = `${o}bottom${a}`, h = `${o}left${a}`, v = $c(e, [l, u, f, h]);
  return {
    t: GC(v[l]),
    r: GC(v[u]),
    b: GC(v[f]),
    l: GC(v[h])
  };
}, Av = (e, t) => `translate${nS(e) ? `(${e.x},${e.y})` : `${t ? "X" : "Y"}(${e})`}`, KW = "paddingTop", ED = "paddingRight", TD = "paddingLeft", SE = "paddingBottom", xE = "marginLeft", CE = "marginRight", D0 = "marginBottom", m0 = "overflowX", v0 = "overflowY", zc = "width", Hc = "height", bg = "hidden", yAe = {
  w: 0,
  h: 0
}, _T = (e, t) => t ? {
  w: t[`${e}Width`],
  h: t[`${e}Height`]
} : yAe, bAe = (e) => _T("inner", e || Za), N0 = Zt(_T, "offset"), Tw = Zt(_T, "client"), wE = Zt(_T, "scroll"), EE = (e) => {
  const t = parseFloat($c(e, zc)) || 0, n = parseFloat($c(e, Hc)) || 0;
  return {
    w: t - rS(t),
    h: n - rS(n)
  };
}, fu = (e) => e.getBoundingClientRect(), c_ = (e) => !!(e && (e[Hc] || e[zc])), qW = (e, t) => {
  const n = c_(e);
  return !c_(t) && n;
}, DT = (e, t, n, o) => {
  if (e && t) {
    let a = !0;
    return Vn(n, (l) => {
      const u = o ? o(e[l]) : e[l], f = o ? o(t[l]) : t[l];
      u !== f && (a = !1);
    }), a;
  }
  return !1;
}, eU = (e, t) => DT(e, t, ["w", "h"]), tU = (e, t) => DT(e, t, ["x", "y"]), SAe = (e, t) => DT(e, t, ["t", "r", "b", "l"]), Yz = (e, t, n) => DT(e, t, [zc, Hc], n && ((o) => rS(o)));
let UC;
const Jz = "passive", xAe = () => {
  if (wh(UC)) {
    UC = !1;
    try {
      Za.addEventListener(Jz, ws, Object.defineProperty({}, Jz, {
        get() {
          UC = !0;
        }
      }));
    } catch {
    }
  }
  return UC;
}, nU = (e) => e.split(" "), Qz = (e, t, n, o) => {
  Vn(nU(t), (a) => {
    e.removeEventListener(a, n, o);
  });
}, $r = (e, t, n, o) => {
  var a;
  const l = xAe(), u = (a = l && o && o.$) != null ? a : l, f = o && o.O || !1, h = o && o.C || !1, v = l ? {
    passive: u,
    capture: f
  } : f;
  return Zt(Rs, nU(t).map((g) => {
    const b = h ? (S) => {
      Qz(e, g, b, f), n(S);
    } : n;
    return e.addEventListener(g, b, v), Zt(Qz, e, g, b, f);
  }));
}, rU = (e) => e.stopPropagation(), Kz = (e) => e.preventDefault(), CAe = {
  x: 0,
  y: 0
}, xP = (e) => {
  const t = e && fu(e);
  return t ? {
    x: t.left + Za.pageYOffset,
    y: t.top + Za.pageXOffset
  } : CAe;
}, oU = (e, t, n) => n ? n.n ? -e : n.i ? t - e : e : e, wAe = (e, t) => [t && t.i ? e : 0, oU(e, e, t)], xf = (e, t) => {
  const { x: n, y: o } = gu(t) ? {
    x: t,
    y: t
  } : t || {};
  gu(n) && (e.scrollLeft = n), gu(o) && (e.scrollTop = o);
}, Sg = (e) => ({
  x: e.scrollLeft,
  y: e.scrollTop
}), qz = (e, t) => {
  Vn(jW(t), e);
}, d_ = (e) => {
  const t = /* @__PURE__ */ new Map(), n = (l, u) => {
    if (l) {
      const f = t.get(l);
      qz((h) => {
        f && f[h ? "delete" : "clear"](h);
      }, u);
    } else
      t.forEach((f) => {
        f.clear();
      }), t.clear();
  }, o = (l, u) => {
    if (IS(l)) {
      const v = t.get(l) || /* @__PURE__ */ new Set();
      return t.set(l, v), qz((g) => {
        Su(g) && v.add(g);
      }, u), Zt(n, l, u);
    }
    HW(u) && u && n();
    const f = Vc(l), h = [];
    return Vn(f, (v) => {
      const g = l[v];
      g && nr(h, o(v, g));
    }), Zt(Rs, h);
  }, a = (l, u) => {
    Vn(Pg(t.get(l)), (f) => {
      u && !vE(u) ? f.apply(0, u) : f();
    });
  };
  return o(e || {}), [o, n, a];
}, e5 = (e) => JSON.stringify(e, (t, n) => {
  if (Su(n))
    throw 0;
  return n;
}), t5 = (e, t) => e ? `${t}`.split(".").reduce((n, o) => n && PT(n, o) ? n[o] : void 0, e) : void 0, EAe = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: !1,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, iU = (e, t) => {
  const n = {}, o = Ic(Vc(t), Vc(e));
  return Vn(o, (a) => {
    const l = e[a], u = t[a];
    if (nS(l) && nS(u))
      Wn(n[a] = {}, iU(l, u)), SD(n[a]) && delete n[a];
    else if (PT(t, a) && u !== l) {
      let f = !0;
      if (xu(l) || xu(u))
        try {
          e5(l) === e5(u) && (f = !1);
        } catch {
        }
      f && (n[a] = u);
    }
  }), n;
}, TAe = (e, t, n) => (o) => [t5(e, o), n || t5(t, o) !== void 0], AS = "data-overlayscrollbars", aU = "os-environment", sU = `${aU}-flexbox-glue`, IAe = `${sU}-max`, lU = "os-scrollbar-hidden", CP = `${AS}-initialize`, bl = AS, uU = `${bl}-overflow-x`, cU = `${bl}-overflow-y`, rg = "overflowVisible", AAe = "scrollbarHidden", n5 = "scrollbarPressed", TE = "updating", of = `${AS}-viewport`, wP = "arrange", dU = "scrollbarHidden", og = rg, f_ = `${AS}-padding`, kAe = og, r5 = `${AS}-content`, ID = "os-size-observer", RAe = `${ID}-appear`, PAe = `${ID}-listener`, OAe = "os-trinsic-observer", _Ae = "os-no-css-vars", DAe = "os-theme-none", Ea = "os-scrollbar", NAe = `${Ea}-rtl`, MAe = `${Ea}-horizontal`, LAe = `${Ea}-vertical`, fU = `${Ea}-track`, AD = `${Ea}-handle`, FAe = `${Ea}-visible`, BAe = `${Ea}-cornerless`, o5 = `${Ea}-transitionless`, i5 = `${Ea}-interaction`, a5 = `${Ea}-unusable`, p_ = `${Ea}-auto-hide`, s5 = `${p_}-hidden`, l5 = `${Ea}-wheel`, VAe = `${fU}-interactive`, $Ae = `${AD}-interactive`, pU = {}, hU = {}, zAe = (e) => {
  Vn(e, (t) => Vn(t, (n, o) => {
    pU[o] = t[o];
  }));
}, mU = (e, t, n) => Vc(e).map((o) => {
  const { static: a, instance: l } = e[o], [u, f, h] = n || [], v = n ? l : a;
  if (v) {
    const g = n ? v(u, f, t) : v(t);
    return (h || hU)[o] = g;
  }
}), Og = (e) => hU[e], HAe = "__osOptionsValidationPlugin", jAe = "__osSizeObserverPlugin", kD = "__osScrollbarsHidingPlugin", GAe = "__osClickScrollPlugin";
let EP;
const u5 = (e, t, n, o) => {
  ys(e, t);
  const a = Tw(t), l = N0(t), u = EE(n);
  return o && Dc(t), {
    x: l.h - a.h + u.h,
    y: l.w - a.w + u.w
  };
}, WAe = (e) => {
  let t = !1;
  const n = Sf(e, lU);
  try {
    t = $c(e, hAe("scrollbar-width")) === "none" || $c(e, "display", "::-webkit-scrollbar") === "none";
  } catch {
  }
  return n(), t;
}, UAe = (e, t) => {
  cf(e, {
    [m0]: bg,
    [v0]: bg,
    direction: "rtl"
  }), xf(e, {
    x: 0
  });
  const n = xP(e), o = xP(t);
  xf(e, {
    x: -999
  });
  const a = xP(t);
  return {
    i: n.x === o.x,
    n: o.x !== a.x
  };
}, XAe = (e, t) => {
  const n = Sf(e, sU), o = fu(e), a = fu(t), l = Yz(a, o, !0), u = Sf(e, IAe), f = fu(e), h = fu(t), v = Yz(h, f, !0);
  return n(), u(), l && v;
}, ZAe = () => {
  const { body: e } = document, n = XW(`<div class="${aU}"><div></div></div>`)[0], o = n.firstChild, [a, , l] = d_(), [u, f] = yl({
    o: u5(e, n, o),
    u: tU
  }, Zt(u5, e, n, o, !0)), [h] = f(), v = WAe(n), g = {
    x: h.x === 0,
    y: h.y === 0
  }, b = {
    elements: {
      host: null,
      padding: !v,
      viewport: (A) => v && A === A.ownerDocument.body && A,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, S = Wn({}, EAe), w = Zt(Wn, {}, S), E = Zt(Wn, {}, b), T = {
    L: h,
    A: g,
    I: v,
    T: $c(n, "zIndex") === "-1",
    V: !!u_,
    U: UAe(n, o),
    B: XAe(n, o),
    j: Zt(a, "r"),
    N: E,
    G: (A) => Wn(b, A) && E(),
    q: w,
    F: (A) => Wn(S, A) && w(),
    W: Wn({}, b),
    X: Wn({}, S)
  };
  return ha(n, "style"), Dc(n), Za.addEventListener("resize", () => {
    let A;
    if (!v && (!g.x || !g.y)) {
      const P = Og(kD);
      A = !!(P ? P.P() : ws)(T, u);
    }
    l("r", [A]);
  }), T;
}, Ca = () => (EP || (EP = ZAe()), EP), RD = (e, t) => Su(t) ? t.apply(0, e) : t, YAe = (e, t, n, o) => {
  const a = wh(o) ? n : o;
  return RD(e, a) || t.apply(0, e);
}, vU = (e, t, n, o) => {
  const a = wh(o) ? n : o, l = RD(e, a);
  return !!l && (_0(l) ? l : t.apply(0, e));
}, JAe = (e, t) => {
  const { nativeScrollbarsOverlaid: n, body: o } = t || {}, { A: a, I: l, N: u } = Ca(), { nativeScrollbarsOverlaid: f, body: h } = u().cancel, v = n ?? f, g = wh(o) ? h : o, b = (a.x || a.y) && v, S = e && (IT(g) ? !l : g);
  return !!b || !!S;
}, PD = /* @__PURE__ */ new WeakMap(), QAe = (e, t) => {
  PD.set(e, t);
}, KAe = (e) => {
  PD.delete(e);
}, gU = (e) => PD.get(e), qAe = (e, t, n) => {
  let o = !1;
  const a = n ? /* @__PURE__ */ new WeakMap() : !1, l = () => {
    o = !0;
  }, u = (f) => {
    if (a && n) {
      const h = n.map((v) => {
        const [g, b] = v || [];
        return [b && g ? (f || UW)(g, e) : [], b];
      });
      Vn(h, (v) => Vn(v[0], (g) => {
        const b = v[1], S = a.get(g) || [];
        if (e.contains(g) && b) {
          const E = $r(g, b.trim(), (T) => {
            o ? (E(), a.delete(g)) : t(T);
          });
          a.set(g, nr(S, E));
        } else
          Rs(S), a.delete(g);
      }));
    }
  };
  return u(), [l, u];
}, c5 = (e, t, n, o) => {
  let a = !1;
  const { Y: l, K: u, J: f, Z: h, tt: v, nt: g } = o || {}, b = JW(() => a && n(!0), {
    v: 33,
    p: 99
  }), [S, w] = qAe(e, b, f), E = l || [], T = u || [], A = Ic(E, T), P = (D, L) => {
    if (!vE(L)) {
      const F = v || ws, V = g || ws, $ = [], U = [];
      let W = !1, H = !1;
      if (Vn(L, (G) => {
        const { attributeName: oe, target: ce, type: te, oldValue: Ee, addedNodes: me, removedNodes: J } = G, Q = te === "attributes", ge = te === "childList", Y = e === ce, q = Q && oe, de = q ? $i(ce, oe || "") : null, K = q && Ee !== de, ne = RT(T, oe) && K;
        if (t && (ge || !Y)) {
          const pe = Q && K, Oe = pe && h && gE(ce, h), xe = (Oe ? !F(ce, oe, Ee, de) : !Q || pe) && !V(G, !!Oe, e, o);
          Vn(me, (ie) => nr($, ie)), Vn(J, (ie) => nr($, ie)), H = H || xe;
        }
        !t && Y && K && !F(ce, oe, Ee, de) && (nr(U, oe), W = W || ne);
      }), w((G) => Gz($).reduce((oe, ce) => (nr(oe, UW(G, ce)), gE(ce, G) ? nr(oe, ce) : oe), [])), t)
        return !D && H && n(!1), [!1];
      if (!vE(U) || W) {
        const G = [Gz(U), W];
        return !D && n.apply(0, G), G;
      }
    }
  }, _ = new mAe(Zt(P, !1));
  return [() => (_.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: A,
    subtree: t,
    childList: t,
    characterData: t
  }), a = !0, () => {
    a && (S(), _.disconnect(), a = !1);
  }), () => {
    if (a)
      return b.m(), P(!0, _.takeRecords());
  }];
}, yU = (e, t, n) => {
  const { ot: a, st: l } = n || {}, u = Og(jAe), { U: f } = Ca(), h = Zt(ng, e), [v] = yl({
    o: !1,
    _: !0
  });
  return () => {
    const g = [], S = XW(`<div class="${ID}"><div class="${PAe}"></div></div>`)[0], w = S.firstChild, E = (T) => {
      const A = T instanceof ResizeObserverEntry, P = !A && xu(T);
      let _ = !1, D = !1, L = !0;
      if (A) {
        const [F, , V] = v(T.contentRect), $ = c_(F), U = qW(F, V);
        D = !V || U, _ = !D && !$, L = !_;
      } else
        P ? [, L] = T : D = T === !0;
      if (a && L) {
        const F = P ? T[0] : ng(S);
        xf(S, {
          x: oU(3333333, 3333333, F && f),
          y: 3333333
        });
      }
      _ || t({
        et: P ? T : void 0,
        ct: !P,
        st: D
      });
    };
    if (bE) {
      const T = new bE((A) => E(A.pop()));
      T.observe(w), nr(g, () => {
        T.disconnect();
      });
    } else if (u) {
      const [T, A] = u(w, E, l);
      nr(g, Ic([Sf(S, RAe), $r(S, "animationstart", T)], A));
    } else
      return ws;
    if (a) {
      const [T] = yl({
        o: void 0
      }, h);
      nr(g, $r(S, "scroll", (A) => {
        const P = T(), [_, D, L] = P;
        D && (CD(w, "ltr rtl"), Sf(w, _ ? "rtl" : "ltr"), E([!!_, D, L])), rU(A);
      }));
    }
    return Zt(Rs, nr(g, ys(e, S)));
  };
}, eke = (e, t) => {
  let n;
  const o = (h) => h.h === 0 || h.isIntersecting || h.intersectionRatio > 0, a = ih(OAe), [l] = yl({
    o: !1
  }), u = (h, v) => {
    if (h) {
      const g = l(o(h)), [, b] = g;
      return b && !v && t(g) && [g];
    }
  }, f = (h, v) => u(v.pop(), h);
  return [() => {
    const h = [];
    if (Uz)
      n = new Uz(Zt(f, !1), {
        root: e
      }), n.observe(a), nr(h, () => {
        n.disconnect();
      });
    else {
      const v = () => {
        const g = N0(a);
        u(g);
      };
      nr(h, yU(a, v)()), v();
    }
    return Zt(Rs, nr(h, ys(e, a)));
  }, () => n && f(!0, n.takeRecords())];
}, tke = (e, t) => {
  let n, o, a, l, u;
  const { I: f } = Ca(), h = `[${bl}]`, v = `[${of}]`, g = ["tabindex"], b = ["wrap", "cols", "rows"], S = ["id", "class", "style", "open"], w = {
    rt: !1,
    lt: ng(e.it)
  }, { it: E, ut: T, ft: A, _t: P, dt: _, vt: D, ht: L } = e, { B: F, j: V } = Ca(), [$] = yl({
    u: eU,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const q = D(og, rg), de = D(wP, ""), K = de && Sg(T);
    L(og, rg), L(wP, ""), L("", TE, !0);
    const ne = wE(A), pe = wE(T), Oe = EE(T);
    return L(og, rg, q), L(wP, "", de), L("", TE), xf(T, K), {
      w: pe.w + ne.w + Oe.w,
      h: pe.h + ne.h + Oe.h
    };
  }), U = P ? b : Ic(S, b), W = JW(t, {
    v: () => n,
    p: () => o,
    S(q, de) {
      const [K] = q, [ne] = de;
      return [Ic(Vc(K), Vc(ne)).reduce((pe, Oe) => (pe[Oe] = K[Oe] || ne[Oe], pe), {})];
    }
  }), H = (q) => {
    Vn(q || g, (de) => {
      if (RT(g, de)) {
        const K = $i(E, de);
        IS(K) ? $i(T, de, K) : ha(T, de);
      }
    });
  }, G = (q, de) => {
    const [K, ne] = q, pe = {
      gt: ne
    };
    return Wn(w, {
      rt: K
    }), !de && t(pe), pe;
  }, oe = ({ ct: q, et: de, st: K }) => {
    const pe = !(q && !K && !de) && f ? W : t, [Oe, Ce] = de || [];
    de && Wn(w, {
      lt: Oe
    }), pe({
      ct: q || K,
      st: K,
      bt: Ce
    });
  }, ce = (q, de) => {
    const [, K] = $(), ne = {
      wt: K
    };
    return K && !de && (q ? t : W)(ne), ne;
  }, te = (q, de, K) => {
    const ne = {
      yt: de
    };
    return de && !K ? W(ne) : _ || H(q), ne;
  }, [Ee, me] = A || !F ? eke(E, G) : [], J = !_ && yU(E, oe, {
    st: !0,
    ot: !0
  }), [Q, ge] = c5(E, !1, te, {
    K: S,
    Y: Ic(S, g)
  }), Y = _ && bE && new bE((q) => {
    const de = q[q.length - 1].contentRect;
    oe({
      ct: !0,
      st: qW(de, u)
    }), u = de;
  });
  return [() => {
    H(), Y && Y.observe(E);
    const q = J && J(), de = Ee && Ee(), K = Q(), ne = V((pe) => {
      const [, Oe] = $();
      W({
        St: pe,
        wt: Oe
      });
    });
    return () => {
      Y && Y.disconnect(), q && q(), de && de(), l && l(), K(), ne();
    };
  }, ({ $t: q, xt: de, Ot: K }) => {
    const ne = {}, [pe] = q("update.ignoreMutation"), [Oe, Ce] = q("update.attributes"), [xe, ie] = q("update.elementEvents"), [ye, we] = q("update.debounce"), fe = ie || Ce, ze = de || K, Ve = (Ie) => Su(pe) && pe(Ie);
    if (fe) {
      a && a(), l && l();
      const [Ie, qe] = c5(A || T, !0, ce, {
        Y: Ic(U, Oe || []),
        J: xe,
        Z: h,
        nt: (Qe, lt) => {
          const { target: tn, attributeName: Yt } = Qe;
          return (!lt && Yt && !_ ? lAe(tn, h, v) : !1) || !!zv(tn, `.${Ea}`) || !!Ve(Qe);
        }
      });
      l = Ie(), a = qe;
    }
    if (we)
      if (W.m(), xu(ye)) {
        const Ie = ye[0], qe = ye[1];
        n = gu(Ie) && Ie, o = gu(qe) && qe;
      } else
        gu(ye) ? (n = ye, o = !1) : (n = !1, o = !1);
    if (ze) {
      const Ie = ge(), qe = me && me(), Qe = a && a();
      Ie && Wn(ne, te(Ie[0], Ie[1], ze)), qe && Wn(ne, G(qe[0], ze)), Qe && Wn(ne, ce(Qe[0], ze));
    }
    return ne;
  }, w];
}, h_ = (e, t, n) => Ew(e, cAe(t, n)), nke = (e, t, n) => {
  const o = rS(t), [a, l] = wAe(o, n), u = (l - e) / l, f = e / a, h = e / l, v = n ? n.n ? u : n.i ? f : h : h;
  return h_(0, 1, v);
}, bU = (e, t, n) => {
  if (n) {
    const h = t ? zc : Hc, { Ct: v, Ht: g } = n, b = fu(g)[h], S = fu(v)[h];
    return h_(0, 1, b / S);
  }
  const o = t ? "x" : "y", { zt: a, It: l } = e, u = l[o], f = a[o];
  return h_(0, 1, u / (u + f));
}, d5 = (e, t, n, o) => {
  const a = bU(e, o, t);
  return 1 / a * (1 - a) * n;
}, rke = (e, t, n, o) => {
  const { N: a, T: l } = Ca(), { scrollbars: u } = a(), { slot: f } = u, { At: h, it: v, ut: g, Et: b, Tt: S, Dt: w, dt: E } = t, { scrollbars: T } = b ? {} : e, { slot: A } = T || {}, P = /* @__PURE__ */ new Map(), _ = (Ce) => u_ && new u_({
    source: S,
    axis: Ce
  }), D = _("x"), L = _("y"), F = vU([h, v, g], () => E && w ? h : v, f, A), V = (Ce) => E && !w && _c(Ce) === g, $ = (Ce, xe, ie) => {
    const ye = 0.5 * (ie ? 1 : -1), we = xe && ie ? -1 : 1;
    return {
      transform: [Av(h0(0 + ye), xe), Av(h0(Ce * we + ye), xe)]
    };
  }, U = (Ce, xe) => Wn(Ce, xe ? {
    clear: ["left"]
  } : {}), W = (Ce) => {
    P.forEach((xe, ie) => {
      (Ce ? RT(jW(Ce), ie) : !0) && (Vn(xe || [], (we) => {
        we && we.cancel();
      }), P.delete(ie));
    });
  }, H = (Ce, xe, ie, ye) => {
    const we = P.get(Ce) || [], fe = we.find((ze) => ze && ze.timeline === xe);
    fe ? fe.effect = new KeyframeEffect(Ce, ie, {
      composite: ye
    }) : P.set(Ce, Ic(we, [Ce.animate(ie, {
      timeline: xe,
      composite: ye
    })]));
  }, G = (Ce, xe, ie) => {
    const ye = ie ? Sf : CD;
    Vn(Ce, (we) => {
      ye(we.kt, xe);
    });
  }, oe = (Ce, xe) => {
    Vn(Ce, (ie) => {
      const [ye, we] = xe(ie);
      cf(ye, we);
    });
  }, ce = (Ce, xe) => {
    oe(Ce, (ie) => {
      const { Ht: ye } = ie;
      return [ye, {
        [xe ? zc : Hc]: WC(bU(n, xe))
      }];
    });
  }, te = (Ce, xe) => {
    D && L ? Vn(Ce, (ie) => {
      const { kt: ye, Ht: we } = ie, fe = Zt(d5, n, ie), ze = xe && ng(ye), Ve = fe(ze ? 1 : 0, xe), Ie = fe(ze ? 0 : 1, xe);
      H(we, xe ? D : L, U({
        transform: [Av(WC(Ve), xe), Av(WC(Ie), xe)]
      }, ze));
    }) : oe(Ce, (ie) => {
      const { Ht: ye, kt: we } = ie, { U: fe } = Ca(), ze = xe ? "x" : "y", { zt: Ve } = n, Ie = ng(we), qe = d5(n, ie, nke(Sg(S)[ze], Ve[ze], xe && Ie && fe), xe);
      return [ye, {
        transform: Av(WC(qe), xe)
      }];
    });
  }, Ee = (Ce) => {
    const { kt: xe } = Ce, ie = V(xe) && xe, { x: ye, y: we } = Sg(S);
    return [ie, {
      transform: ie ? Av({
        x: h0(ye),
        y: h0(we)
      }) : ""
    }];
  }, me = [], J = [], Q = [], ge = (Ce, xe, ie) => {
    const ye = HW(ie), we = ye ? ie : !0, fe = ye ? !ie : !0;
    we && G(J, Ce, xe), fe && G(Q, Ce, xe);
  }, Y = () => {
    ce(J, !0), ce(Q);
  }, q = () => {
    te(J, !0), te(Q);
  }, de = () => {
    if (E)
      if (D && L) {
        const { zt: Ce } = n, xe = !!J.find(({ kt: ye }) => ng(ye)), ie = (ye, we, fe, ze, Ve) => H(ye, we, U($(fe, ze, Ve), xe), "add");
        Vn(Ic(Q, J), ({ kt: ye }) => {
          V(ye) ? (ie(ye, D, Ce.x, !0, xe), ie(ye, L, Ce.y)) : W(ye);
        });
      } else
        oe(J, Ee), oe(Q, Ee);
  }, K = (Ce) => {
    const xe = Ce ? MAe : LAe, ie = Ce ? J : Q, ye = vE(ie) ? o5 : "", we = ih(`${Ea} ${xe} ${ye}`), fe = ih(fU), ze = ih(AD), Ve = {
      kt: we,
      Ct: fe,
      Ht: ze
    };
    return l || Sf(we, _Ae), nr(ie, Ve), nr(me, [ys(we, fe), ys(fe, ze), Zt(Dc, we), W, o(Ve, ge, te, Ce)]), Ve;
  }, ne = Zt(K, !0), pe = Zt(K, !1), Oe = () => (ys(F, J[0].kt), ys(F, Q[0].kt), yE(() => {
    ge(o5);
  }, 300), Zt(Rs, me));
  return ne(), pe(), [{
    Mt: Y,
    Rt: q,
    Pt: de,
    Lt: ge,
    Vt: {
      V: D,
      Ut: J,
      Bt: ne,
      jt: Zt(oe, J)
    },
    Nt: {
      V: L,
      Ut: Q,
      Bt: pe,
      jt: Zt(oe, Q)
    }
  }, Oe];
}, oke = (e, t, n) => {
  const { it: o, Tt: a, Gt: l } = t;
  return (u, f, h, v) => {
    const { kt: g, Ct: b, Ht: S } = u, [w, E] = rf(333), [T, A] = rf(), P = Zt(h, [u], v), _ = !!a.scrollBy, D = `client${v ? "X" : "Y"}`, L = v ? zc : Hc, F = v ? "left" : "top", V = v ? "w" : "h", $ = v ? "x" : "y", U = (G) => G.propertyName.indexOf(L) > -1, W = () => {
      const G = "pointerup pointerleave pointercancel lostpointercapture", oe = (ce, te) => (Ee) => {
        const { zt: me } = n, J = N0(b)[V] - N0(S)[V], ge = te * Ee / J * me[$];
        xf(a, {
          [$]: ce + ge
        });
      };
      return $r(b, "pointerdown", (ce) => {
        const te = zv(ce.target, `.${AD}`) === S, Ee = te ? S : b, me = e.scrollbars, { button: J, isPrimary: Q, pointerType: ge } = ce, { pointers: Y } = me;
        if (J === 0 && Q && me[te ? "dragScroll" : "clickScroll"] && (Y || []).includes(ge)) {
          const de = !te && ce.shiftKey, K = Zt(fu, S), ne = Zt(fu, b), pe = (Qe, lt) => (Qe || K())[F] - (lt || ne())[F], Oe = rS(fu(a)[L]) / N0(a)[V] || 1, Ce = oe(Sg(a)[$] || 0, 1 / Oe), xe = ce[D], ie = K(), ye = ne(), we = ie[L], fe = pe(ie, ye) + we / 2, ze = xe - ye[F], Ve = te ? 0 : ze - fe, Ie = (Qe) => {
            Rs(qe), Ee.releasePointerCapture(Qe.pointerId);
          }, qe = [Zt(oh, o, bl, n5), $r(l, G, Ie), $r(l, "selectstart", (Qe) => Kz(Qe), {
            $: !1
          }), $r(b, G, Ie), $r(b, "pointermove", (Qe) => {
            const lt = Qe[D] - xe;
            (te || de) && Ce(Ve + lt);
          })];
          if (oh(o, bl, n5, !0), Ee.setPointerCapture(ce.pointerId), de)
            Ce(Ve);
          else if (!te) {
            const Qe = Og(GAe);
            Qe && nr(qe, Qe(Ce, pe, Ve, we, ze));
          }
        }
      });
    };
    let H = !0;
    return Zt(Rs, [$r(g, "pointerenter", () => {
      f(i5, !0);
    }), $r(g, "pointerleave pointercancel", () => {
      f(i5, !1);
    }), $r(g, "wheel", (G) => {
      const { deltaX: oe, deltaY: ce, deltaMode: te } = G;
      _ && H && te === 0 && _c(g) === o && a.scrollBy({
        left: oe,
        top: ce,
        behavior: "smooth"
      }), H = !1, f(l5, !0), w(() => {
        H = !0, f(l5);
      }), Kz(G);
    }, {
      $: !1,
      O: !0
    }), $r(S, "transitionstart", (G) => {
      if (U(G)) {
        const oe = () => {
          P(), T(oe);
        };
        oe();
      }
    }), $r(S, "transitionend transitioncancel", (G) => {
      U(G) && (A(), P());
    }), $r(g, "mousedown", Zt($r, l, "click", rU, {
      C: !0,
      O: !0
    }), {
      O: !0
    }), W(), E, A]);
  };
}, ike = (e, t, n, o, a, l) => {
  let u, f, h, v, g, b = ws, S = 0;
  const [w, E] = rf(), [T, A] = rf(), [P, _] = rf(100), [D, L] = rf(100), [F, V] = rf(100), [$, U] = rf(() => S), [W, H] = rke(e, a, o, oke(t, a, o)), { it: G, qt: oe, Dt: ce } = a, { Lt: te, Mt: Ee, Rt: me, Pt: J } = W, Q = (K) => {
    te(p_, K, !0), te(p_, K, !1);
  }, ge = (K, ne) => {
    if (U(), K)
      te(s5);
    else {
      const pe = Zt(te, s5, !0);
      S > 0 && !ne ? $(pe) : pe();
    }
  }, Y = (K) => K.pointerType === "mouse", q = (K) => {
    Y(K) && (v = f, v && ge(!0));
  }, de = [_, U, L, V, A, E, () => b(), $r(G, "pointerover", q, {
    C: !0
  }), $r(G, "pointerenter", q), $r(G, "pointerleave", (K) => {
    Y(K) && (v = !1, f && ge(!1));
  }), $r(G, "pointermove", (K) => {
    Y(K) && u && w(() => {
      _(), ge(!0), D(() => {
        u && ge(!1);
      });
    });
  }), $r(oe, "scroll", (K) => {
    T(() => {
      me(), h && ge(!0), P(() => {
        h && !v && ge(!1);
      });
    }), l(K), J();
  })];
  return [() => Zt(Rs, nr(de, H())), ({ $t: K, Ot: ne, Ft: pe, Wt: Oe }) => {
    const { Xt: Ce, Yt: xe, Kt: ie } = Oe || {}, { bt: ye, st: we } = pe || {}, { lt: fe } = n, { A: ze } = Ca(), { zt: Ve, Jt: Ie, Zt: qe } = o, [Qe, lt] = K("showNativeOverlaidScrollbars"), [tn, Yt] = K("scrollbars.theme"), [hn, vn] = K("scrollbars.visibility"), [nn, rn] = K("scrollbars.autoHide"), [mn, un] = K("scrollbars.autoHideSuspend"), [Tn] = K("scrollbars.autoHideDelay"), [je, Ot] = K("scrollbars.dragScroll"), [an, Xe] = K("scrollbars.clickScroll"), _e = we && !ne, Je = qe.x || qe.y, Kt = Ce || xe || ye || ne, He = ie || vn, tt = Qe && ze.x && ze.y, ft = (mt, kt) => {
      const Mn = hn === "visible" || hn === "auto" && mt === "scroll";
      return te(FAe, Mn, kt), Mn;
    };
    if (S = Tn, _e && (mn && Je ? (Q(!1), b(), F(() => {
      b = $r(oe, "scroll", Zt(Q, !0), {
        C: !0
      });
    })) : Q(!0)), lt && te(DAe, tt), Yt && (te(g), te(tn, !0), g = tn), un && !mn && Q(!0), rn && (u = nn === "move", f = nn === "leave", h = nn !== "never", ge(!h, !0)), Ot && te($Ae, je), Xe && te(VAe, an), He) {
      const mt = ft(Ie.x, !0), kt = ft(Ie.y, !1);
      te(BAe, !(mt && kt));
    }
    Kt && (Ee(), me(), J(), te(a5, !Ve.x, !0), te(a5, !Ve.y, !1), te(NAe, fe && !ce));
  }, {}, W];
}, ake = (e) => {
  const t = Ca(), { N: n, I: o } = t, a = Og(kD), l = a && a.H, { elements: u } = n(), { host: f, padding: h, viewport: v, content: g } = u, b = _0(e), S = b ? {} : e, { elements: w } = S, { host: E, padding: T, viewport: A, content: P } = w || {}, _ = b ? e : S.target, D = gE(_, "textarea"), L = _.ownerDocument, F = L.documentElement, V = _ === L.body, $ = L.defaultView, U = Zt(YAe, [_]), W = Zt(vU, [_]), H = Zt(RD, [_]), G = Zt(ih, ""), oe = Zt(U, G, v), ce = Zt(W, G, g), te = oe(A), Ee = te === _, me = Ee && V, J = !Ee && ce(P), Q = !Ee && _0(te) && te === J, ge = Q && !!H(g), Y = ge ? oe() : te, q = ge ? J : ce(), K = me ? F : Q ? Y : te, ne = D ? U(G, f, E) : _, pe = me ? K : ne, Oe = Q ? q : J, Ce = L.activeElement, xe = !Ee && $.top === $ && Ce === _, ie = {
    At: _,
    it: pe,
    ut: K,
    Qt: !Ee && W(G, h, T),
    ft: Oe,
    tn: !Ee && !o && l && l(t),
    Tt: me ? F : K,
    qt: me ? L : K,
    nn: $,
    Gt: L,
    _t: D,
    Dt: V,
    Et: b,
    dt: Ee,
    sn: Q,
    vt: (rn, mn) => aAe(K, Ee ? bl : of, Ee ? mn : rn),
    ht: (rn, mn, un) => oh(K, Ee ? bl : of, Ee ? mn : rn, un)
  }, ye = Vc(ie).reduce((rn, mn) => {
    const un = ie[mn];
    return nr(rn, un && _0(un) && !_c(un) ? un : !1);
  }, []), we = (rn) => rn ? RT(ye, rn) : null, { At: fe, it: ze, Qt: Ve, ut: Ie, ft: qe, tn: Qe } = ie, lt = [() => {
    ha(ze, bl), ha(ze, CP), ha(fe, CP), V && (ha(F, bl), ha(F, CP));
  }], tn = D && we(ze);
  let Yt = D ? fe : a_([qe, Ie, Ve, ze, fe].find((rn) => we(rn) === !1));
  const hn = me ? fe : qe || Ie, vn = Zt(Rs, lt);
  return [ie, () => {
    $i(ze, bl, Ee ? "viewport" : "host"), $i(Ve, f_, ""), $i(qe, r5, ""), Ee || $i(Ie, of, "");
    const rn = V && !Ee ? Sf(_c(_), lU) : ws, mn = (un) => {
      ys(_c(un), a_(un)), Dc(un);
    };
    if (tn && (Wz(fe, ze), nr(lt, () => {
      Wz(ze, fe), Dc(ze);
    })), ys(hn, Yt), ys(ze, Ve), ys(Ve || ze, !Ee && Ie), ys(Ie, qe), nr(lt, () => {
      rn(), ha(Ve, f_), ha(qe, r5), ha(Ie, uU), ha(Ie, cU), ha(Ie, of), we(qe) && mn(qe), we(Ie) && mn(Ie), we(Ve) && mn(Ve);
    }), o && !Ee && (oh(Ie, of, dU, !0), nr(lt, Zt(ha, Ie, of))), Qe && (uAe(Ie, Qe), nr(lt, Zt(Dc, Qe))), xe) {
      const un = "tabindex", Tn = $i(Ie, un);
      $i(Ie, un, "-1"), Ie.focus();
      const je = () => Tn ? $i(Ie, un, Tn) : ha(Ie, un), Ot = $r(L, "pointerdown keydown", () => {
        je(), Ot();
      });
      nr(lt, [je, Ot]);
    } else
      Ce && Ce.focus && Ce.focus();
    return Yt = 0, vn;
  }, vn];
}, ske = ({ ft: e }) => ({ Ft: t, en: n, Ot: o }) => {
  const { B: a } = Ca(), { gt: l } = t || {}, { rt: u } = n;
  (e || !a) && (l || o) && cf(e, {
    [Hc]: u ? "" : "100%"
  });
}, lke = ({ it: e, Qt: t, ut: n, dt: o }, a) => {
  const [l, u] = yl({
    u: SAe,
    o: Zz()
  }, Zt(Zz, e, "padding", ""));
  return ({ $t: f, Ft: h, en: v, Ot: g }) => {
    let [b, S] = u(g);
    const { I: w, B: E } = Ca(), { ct: T, wt: A, bt: P } = h || {}, { lt: _ } = v, [D, L] = f("paddingAbsolute");
    (T || S || (g || !E && A)) && ([b, S] = l(g));
    const V = !o && (L || P || S);
    if (V) {
      const $ = !D || !t && !w, U = b.r + b.l, W = b.t + b.b, H = {
        [CE]: $ && !_ ? -U : 0,
        [D0]: $ ? -W : 0,
        [xE]: $ && _ ? -U : 0,
        top: $ ? -b.t : 0,
        right: $ ? _ ? -b.r : "auto" : 0,
        left: $ ? _ ? "auto" : -b.l : 0,
        [zc]: $ ? `calc(100% + ${U}px)` : ""
      }, G = {
        [KW]: $ ? b.t : 0,
        [ED]: $ ? b.r : 0,
        [SE]: $ ? b.b : 0,
        [TD]: $ ? b.l : 0
      };
      cf(t || n, H), cf(n, G), Wn(a, {
        Qt: b,
        cn: !$,
        k: t ? G : Wn({}, H, G)
      });
    }
    return {
      rn: V
    };
  };
}, uke = ({ it: e, Qt: t, ut: n, tn: o, dt: a, ht: l, Dt: u, nn: f }, h) => {
  const v = Zt(Ew, 0), g = "visible", b = 42, S = {
    u: eU,
    o: {
      w: 0,
      h: 0
    }
  }, w = {
    u: tU,
    o: {
      x: bg,
      y: bg
    }
  }, E = (de, K) => {
    const ne = Za.devicePixelRatio % 1 !== 0 ? 1 : 0, pe = {
      w: v(de.w - K.w),
      h: v(de.h - K.h)
    };
    return {
      w: pe.w > ne ? pe.w : 0,
      h: pe.h > ne ? pe.h : 0
    };
  }, T = (de) => de.indexOf(g) === 0, { L: A, B: P, I: _, A: D } = Ca(), L = Og(kD), F = !a && !_ && (D.x || D.y), V = u && a, [$, U] = yl(S, Zt(EE, n)), [W, H] = yl(S, Zt(wE, n)), [G, oe] = yl(S), [ce, te] = yl(S), [Ee] = yl(w), me = (de, K) => {
    if (cf(n, {
      [Hc]: ""
    }), K) {
      const { cn: ne, Qt: pe } = h, { ln: Oe, M: Ce } = de, xe = EE(e), ie = Tw(e), ye = $c(n, "boxSizing") === "content-box", we = ne || ye ? pe.b + pe.t : 0, fe = !(D.x && ye);
      cf(n, {
        [Hc]: ie.h + xe.h + (Oe.x && fe ? Ce.x : 0) - we
      });
    }
  }, J = (de, K) => {
    const ne = !_ && !de ? b : 0, pe = (Ve, Ie, qe) => {
      const Qe = $c(n, Ve), tn = (K ? K[Ve] : Qe) === "scroll";
      return [Qe, tn, tn && !_ ? Ie ? ne : qe : 0, Ie && !!ne];
    }, [Oe, Ce, xe, ie] = pe(m0, D.x, A.x), [ye, we, fe, ze] = pe(v0, D.y, A.y);
    return {
      Jt: {
        x: Oe,
        y: ye
      },
      ln: {
        x: Ce,
        y: we
      },
      M: {
        x: xe,
        y: fe
      },
      R: {
        x: ie,
        y: ze
      }
    };
  }, Q = (de, K, ne, pe) => {
    const Oe = (we, fe) => {
      const ze = T(we), Ve = fe && ze && we.replace(`${g}-`, "") || "";
      return [fe && !ze ? we : "", T(Ve) ? "hidden" : Ve];
    }, [Ce, xe] = Oe(ne.x, K.x), [ie, ye] = Oe(ne.y, K.y);
    return pe[m0] = xe && ie ? xe : Ce, pe[v0] = ye && Ce ? ye : ie, J(de, pe);
  }, ge = (de, K, ne, pe) => {
    const { M: Oe, R: Ce } = de, { x: xe, y: ie } = Ce, { x: ye, y: we } = Oe, { k: fe } = h, ze = K ? xE : CE, Ve = K ? TD : ED, Ie = fe[ze], qe = fe[D0], Qe = fe[Ve], lt = fe[SE];
    pe[zc] = `calc(100% + ${we + Ie * -1}px)`, pe[ze] = -we + Ie, pe[D0] = -ye + qe, ne && (pe[Ve] = Qe + (ie ? we : 0), pe[SE] = lt + (xe ? ye : 0));
  }, [Y, q] = L ? L.D(F, P, n, o, h, J, ge) : [() => F, () => [ws]];
  return ({ $t: de, Ft: K, en: ne, Ot: pe }, { rn: Oe }) => {
    const { ct: Ce, yt: xe, wt: ie, gt: ye, bt: we, St: fe } = K || {}, { rt: ze, lt: Ve } = ne, [Ie, qe] = de("showNativeOverlaidScrollbars"), [Qe, lt] = de("overflow"), tn = Ie && D.x && D.y, Yt = !a && !P && (Ce || ie || xe || qe || ye), hn = Ce || Oe || ie || we || fe || qe, vn = T(Qe.x), nn = T(Qe.y), rn = vn || nn;
    let mn = U(pe), un = H(pe), Tn = oe(pe), je = te(pe), Ot;
    if (qe && _ && l(dU, AAe, !tn), Yt && (Ot = J(tn), me(Ot, ze)), hn) {
      rn && l(og, rg, !1);
      const [Ro, Gr] = q(tn, Ve, Ot), [ni, Yc] = mn = $(pe), [Ia, Tl] = un = W(pe), Os = Tw(n);
      let Wr = Ia, Ja = Os;
      Ro(), (Tl || Yc || qe) && Gr && !tn && Y(Gr, Ia, ni, Ve) && (Ja = Tw(n), Wr = wE(n));
      const Wi = bAe(f), Qa = {
        w: v(Ew(Ia.w, Wr.w) + ni.w),
        h: v(Ew(Ia.h, Wr.h) + ni.h)
      }, Po = {
        w: v((V ? Wi.w : Ja.w + v(Os.w - Ia.w)) + ni.w),
        h: v((V ? Wi.h : Ja.h + v(Os.h - Ia.h)) + ni.h)
      };
      je = ce(Po), Tn = G(E(Qa, Po), pe);
    }
    const [an, Xe] = je, [_e, Je] = Tn, [Kt, He] = un, [tt, ft] = mn, mt = {
      x: _e.w > 0,
      y: _e.h > 0
    }, kt = vn && nn && (mt.x || mt.y) || vn && mt.x && !mt.y || nn && mt.y && !mt.x;
    if (Oe || we || fe || ft || He || Xe || Je || lt || qe || Yt || hn) {
      const Ro = {
        [CE]: 0,
        [D0]: 0,
        [xE]: 0,
        [zc]: "",
        [m0]: "",
        [v0]: ""
      }, Gr = Q(tn, mt, Qe, Ro), ni = Y(Gr, Kt, tt, Ve);
      a || ge(Gr, Ve, ni, Ro), Yt && me(Gr, ze), a ? ($i(e, uU, Ro[m0]), $i(e, cU, Ro[v0])) : cf(n, Ro);
    }
    oh(e, bl, rg, kt), oh(t, f_, kAe, kt), a || oh(n, of, og, rn);
    const [sn, Qt] = Ee(J(tn).Jt);
    return Wn(h, {
      Jt: sn,
      It: {
        x: an.w,
        y: an.h
      },
      zt: {
        x: _e.w,
        y: _e.h
      },
      Zt: mt
    }), {
      Kt: Qt,
      Xt: Xe,
      Yt: Je
    };
  };
}, cke = (e) => {
  const [t, n, o] = ake(e), a = {
    Qt: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    cn: !1,
    k: {
      [CE]: 0,
      [D0]: 0,
      [xE]: 0,
      [KW]: 0,
      [ED]: 0,
      [SE]: 0,
      [TD]: 0
    },
    It: {
      x: 0,
      y: 0
    },
    zt: {
      x: 0,
      y: 0
    },
    Jt: {
      x: bg,
      y: bg
    },
    Zt: {
      x: !1,
      y: !1
    }
  }, { At: l, ut: u, ht: f, dt: h } = t, { I: v, A: g, B: b } = Ca(), S = !v && (g.x || g.y), w = [ske(t), lke(t, a), uke(t, a)];
  return [n, (E) => {
    const T = {}, P = (S || !b) && Sg(u);
    return f("", TE, !0), Vn(w, (_) => {
      Wn(T, _(E, T) || {});
    }), f("", TE), xf(u, P), !h && xf(l, 0), T;
  }, a, t, o];
}, dke = (e, t, n, o) => {
  const [a, l, u, f, h] = cke(e), [v, g, b] = tke(f, (P) => {
    A({}, P);
  }), [S, w, , E] = ike(e, t, b, u, f, o), T = (P) => Vc(P).some((_) => !!P[_]), A = (P, _) => {
    const { an: D, Ot: L, xt: F, un: V } = P, $ = D || {}, U = !!L, W = {
      $t: TAe(t, $, U),
      an: $,
      Ot: U
    };
    if (V)
      return w(W), !1;
    const H = _ || g(Wn({}, W, {
      xt: F
    })), G = l(Wn({}, W, {
      en: b,
      Ft: H
    }));
    w(Wn({}, W, {
      Ft: H,
      Wt: G
    }));
    const oe = T(H), ce = T(G), te = oe || ce || !SD($) || U;
    return te && n(P, {
      Ft: H,
      Wt: G
    }), te;
  };
  return [() => {
    const { At: P, ut: _, Gt: D, Dt: L } = f, F = L ? D.documentElement : P, V = Sg(F), $ = [v(), a(), S()];
    return xf(_, V), Zt(Rs, $);
  }, A, () => ({
    fn: b,
    _n: u
  }), {
    dn: f,
    vn: E
  }, h];
}, Ac = (e, t, n) => {
  const { q: o } = Ca(), a = _0(e), l = a ? e : e.target, u = gU(l);
  if (t && !u) {
    let f = !1;
    const h = [], v = {}, g = (H) => {
      const G = GW(H, !0), oe = Og(HAe);
      return oe ? oe(G, !0) : G;
    }, b = Wn({}, o(), g(t)), [S, w, E] = d_(), [T, A, P] = d_(n), _ = (H, G) => {
      P(H, G), E(H, G);
    }, [D, L, F, V, $] = dke(e, b, ({ an: H, Ot: G }, { Ft: oe, Wt: ce }) => {
      const { ct: te, bt: Ee, gt: me, wt: J, yt: Q, st: ge } = oe, { Xt: Y, Yt: q, Kt: de } = ce;
      _("updated", [W, {
        updateHints: {
          sizeChanged: !!te,
          directionChanged: !!Ee,
          heightIntrinsicChanged: !!me,
          overflowEdgeChanged: !!Y,
          overflowAmountChanged: !!q,
          overflowStyleChanged: !!de,
          contentMutation: !!J,
          hostMutation: !!Q,
          appear: !!ge
        },
        changedOptions: H || {},
        force: !!G
      }]);
    }, (H) => _("scroll", [W, H])), U = (H) => {
      KAe(l), Rs(h), f = !0, _("destroyed", [W, H]), w(), A();
    }, W = {
      options(H, G) {
        if (H) {
          const oe = G ? o() : {}, ce = iU(b, Wn(oe, g(H)));
          SD(ce) || (Wn(b, ce), L({
            an: ce
          }));
        }
        return Wn({}, b);
      },
      on: T,
      off: (H, G) => {
        H && G && A(H, G);
      },
      state() {
        const { fn: H, _n: G } = F(), { lt: oe } = H, { It: ce, zt: te, Jt: Ee, Zt: me, Qt: J, cn: Q } = G;
        return Wn({}, {
          overflowEdge: ce,
          overflowAmount: te,
          overflowStyle: Ee,
          hasOverflow: me,
          padding: J,
          paddingAbsolute: Q,
          directionRTL: oe,
          destroyed: f
        });
      },
      elements() {
        const { At: H, it: G, Qt: oe, ut: ce, ft: te, Tt: Ee, qt: me } = V.dn, { Vt: J, Nt: Q } = V.vn, ge = (q) => {
          const { Ht: de, Ct: K, kt: ne } = q;
          return {
            scrollbar: ne,
            track: K,
            handle: de
          };
        }, Y = (q) => {
          const { Ut: de, Bt: K } = q, ne = ge(de[0]);
          return Wn({}, ne, {
            clone: () => {
              const pe = ge(K());
              return L({
                un: !0
              }), pe;
            }
          });
        };
        return Wn({}, {
          target: H,
          host: G,
          padding: oe || ce,
          viewport: ce,
          content: te || ce,
          scrollOffsetElement: Ee,
          scrollEventElement: me,
          scrollbarHorizontal: Y(J),
          scrollbarVertical: Y(Q)
        });
      },
      update: (H) => L({
        Ot: H,
        xt: !0
      }),
      destroy: Zt(U, !1),
      plugin: (H) => v[Vc(H)[0]]
    };
    return nr(h, [$]), QAe(l, W), mU(pU, Ac, [W, S, v]), JAe(V.dn.Dt, !a && e.cancel) ? (U(!0), W) : (nr(h, D()), _("initialized", [W]), W.update(!0), W);
  }
  return u;
};
Ac.plugin = (e) => {
  const t = xu(e), n = t ? e : [e], o = n.map((a) => mU(a, Ac)[0]);
  return zAe(n), t ? o : o[0];
};
Ac.valid = (e) => {
  const t = e && e.elements, n = Su(t) && t();
  return mE(n) && !!gU(n.target);
};
Ac.env = () => {
  const { L: e, A: t, I: n, U: o, B: a, T: l, V: u, W: f, X: h, N: v, G: g, q: b, F: S } = Ca();
  return Wn({}, {
    scrollbarsSize: e,
    scrollbarsOverlaid: t,
    scrollbarsHiding: n,
    rtlScrollBehavior: o,
    flexboxGlue: a,
    cssCustomProperties: l,
    scrollTimeline: u,
    staticDefaultInitialization: f,
    staticDefaultOptions: h,
    getDefaultInitialization: v,
    setDefaultInitialization: g,
    getDefaultOptions: b,
    setDefaultOptions: S
  });
};
const fke = () => {
  if (typeof window > "u") {
    const v = () => {
    };
    return [v, v];
  }
  let e, t;
  const n = window, o = typeof n.requestIdleCallback == "function", a = n.requestAnimationFrame, l = n.cancelAnimationFrame, u = o ? n.requestIdleCallback : a, f = o ? n.cancelIdleCallback : l, h = () => {
    f(e), l(t);
  };
  return [
    (v, g) => {
      h(), e = u(
        o ? () => {
          h(), t = a(v);
        } : v,
        typeof g == "object" ? g : { timeout: 2233 }
      );
    },
    h
  ];
}, SU = (e) => {
  const { options: t, events: n, defer: o } = e || {}, [a, l] = gt(fke, []), u = Ue(null), f = Ue(o), h = Ue(t), v = Ue(n);
  return dt(() => {
    f.current = o;
  }, [o]), dt(() => {
    const { current: g } = u;
    h.current = t, Ac.valid(g) && g.options(t || {}, !0);
  }, [t]), dt(() => {
    const { current: g } = u;
    v.current = n, Ac.valid(g) && g.on(n || {}, !0);
  }, [n]), dt(
    () => () => {
      var g;
      l(), (g = u.current) == null || g.destroy();
    },
    []
  ), gt(
    () => [
      (g) => {
        const b = u.current;
        if (Ac.valid(b))
          return;
        const S = f.current, w = h.current || {}, E = v.current || {}, T = () => u.current = Ac(g, w, E);
        S ? a(T, S) : T();
      },
      () => u.current
    ],
    []
  );
}, pke = (e, t) => {
  const { element: n = "div", options: o, events: a, defer: l, children: u, ...f } = e, h = n, v = Ue(null), g = Ue(null), [b, S] = SU({ options: o, events: a, defer: l });
  return dt(() => {
    const { current: w } = v, { current: E } = g;
    return w && E && b({
      target: w,
      elements: {
        viewport: E,
        content: E
      }
    }), () => {
      var T;
      return (T = S()) == null ? void 0 : T.destroy();
    };
  }, [b, n]), pJ(
    t,
    () => ({
      osInstance: S,
      getElement: () => v.current
    }),
    []
  ), /* @__PURE__ */ Tt.createElement(h, { "data-overlayscrollbars-initialize": "", ref: v, ...f }, /* @__PURE__ */ Tt.createElement("div", { "data-overlayscrollbars-contents": "", ref: g }, u));
};
fr(pke);
const hke = {
  defer: !0,
  options: {
    scrollbars: {
      visibility: "auto",
      autoHide: "scroll",
      autoHideDelay: 1300,
      theme: "os-theme-dark",
      clickScroll: !0
    },
    overflow: { x: "hidden" }
  }
}, mke = {
  options: { scrollbars: { autoHide: "never" } }
}, vke = lCe(Jxe(hke), mke), xU = rr((e) => {
  const { children: t, viewport: n } = e, o = Ue(null), [a, l] = SU(vke);
  return dt(() => (o.current && n && a({
    target: o.current,
    elements: {
      viewport: n
    }
  }), () => {
    var u;
    return (u = l()) == null ? void 0 : u.destroy();
  }), [n, a, l]), /* @__PURE__ */ M(qr, { ref: o, "data-overlayscrollbars": "", border: "none", shadow: "dark-lg", borderRadius: "md", p: 1, children: t });
});
xU.displayName = "Scrollable";
const CU = rr(({ children: e, innerRef: t, ...n }) => {
  const [o, a] = ot(null);
  return dt(() => {
    !t || !(t instanceof Function) || t(o);
  }, [t, o]), /* @__PURE__ */ M(xU, { viewport: o, children: /* @__PURE__ */ M(pE.MenuList, { ...n, innerRef: a, children: e }) });
});
CU.displayName = "CustomMenuListComponent";
const wU = rr(({ children: e, ...t }) => (delete t.innerProps.onMouseMove, delete t.innerProps.onMouseOver, t.data.icon ? /* @__PURE__ */ M(pE.Option, { ...t, children: /* @__PURE__ */ M(Fc, { label: t.data.tooltip, children: /* @__PURE__ */ Nt(zo, { w: "full", h: "full", p: 1, ps: 2, pe: 2, children: [
  /* @__PURE__ */ M(zo, { ps: 1, pe: 3, alignItems: "center", justifyContent: "center", children: t.data.icon }),
  /* @__PURE__ */ Nt(zo, { flexDir: "column", children: [
    /* @__PURE__ */ M(du, { children: e }),
    t.data.description && /* @__PURE__ */ M(du, { "data-option-desc": !0, fontSize: "sm", colorScheme: "base", variant: "subtext", noOfLines: 1, children: t.data.description })
  ] })
] }) }) }) : /* @__PURE__ */ M(pE.Option, { ...t, children: /* @__PURE__ */ M(Fc, { label: t.data.tooltip, children: /* @__PURE__ */ Nt(zo, { w: "full", h: "full", flexDir: "column", p: 1, px: 4, children: [
  /* @__PURE__ */ M(du, { children: e }),
  t.data.description && /* @__PURE__ */ M(du, { "data-option-desc": !0, fontSize: "sm", colorScheme: "base", variant: "subtext", noOfLines: 1, children: t.data.description })
] }) }) })));
wU.displayName = "CustomOptionComponent";
const gke = {
  menuPortal: (e) => ({ ...e, zIndex: 9999 })
}, yke = {
  Option: wU,
  MenuList: CU
}, bke = rr((e) => {
  const { sx: t, selectRef: n, inputRef: o, ...a } = e, l = gt(
    () => ({
      container: (u, f) => ({ ...u, w: "full", ...t }),
      option: (u, f) => ({ ...u, p: 0 }),
      indicatorsContainer: (u, f) => ({
        ...u,
        w: 8,
        alignItems: "center",
        justifyContent: "center",
        "> div": { p: 0, w: "full", h: "full", bg: "unset" }
      }),
      dropdownIndicator: (u, f) => ({
        ...u,
        display: f.hasValue && f.selectProps.isClearable ? "none" : "flex"
      }),
      crossIcon: (u, f) => ({ ...u, boxSize: 2.5 }),
      inputContainer: (u, f) => ({
        ...u,
        cursor: "pointer"
      })
    }),
    [t]
  );
  return dt(() => {
    var u;
    o && (o.current = ((u = n == null ? void 0 : n.current) == null ? void 0 : u.inputRef) ?? null);
  }, [o, n]), /* @__PURE__ */ M(
    nAe,
    {
      ref: n,
      menuPortalTarget: document.body,
      colorScheme: "base",
      selectedOptionColorScheme: "base",
      components: yke,
      chakraStyles: l,
      styles: gke,
      variant: "filled",
      menuPosition: "fixed",
      ...a
    }
  );
});
bke.displayName = "Combobox";
const Ske = rr((e) => /* @__PURE__ */ M(zo, { h: 8, alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ M(du, { fontSize: "sm", color: "base.500", children: e.label }) }));
Ske.displayName = "ComboboxFallback";
let xke = Symbol("clean"), Bi = [], _g = (e, t) => {
  let n = [], o = {
    get() {
      return o.lc || o.listen(() => {
      })(), o.value;
    },
    l: t || 0,
    lc: 0,
    listen(a, l) {
      return o.lc = n.push(a, l || o.l) / 2, () => {
        let u = n.indexOf(a);
        ~u && (n.splice(u, 2), --o.lc || o.off());
      };
    },
    notify(a) {
      let l = !Bi.length;
      for (let u = 0; u < n.length; u += 2)
        Bi.push(
          n[u],
          n[u + 1],
          o.value,
          a
        );
      if (l) {
        for (let u = 0; u < Bi.length; u += 4) {
          let f;
          for (let h = u + 1; !f && (h += 4) < Bi.length; )
            Bi[h] < Bi[u + 1] && (f = Bi.push(
              Bi[u],
              Bi[u + 1],
              Bi[u + 2],
              Bi[u + 3]
            ));
          f || Bi[u](Bi[u + 2], Bi[u + 3]);
        }
        Bi.length = 0;
      }
    },
    off() {
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    set(a) {
      o.value !== a && (o.value = a, o.notify());
    },
    subscribe(a, l) {
      let u = o.listen(a, l);
      return a(o.value), u;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (o[xke] = () => {
    n = [], o.lc = 0, o.off();
  }), o;
};
function Cke(e, t, n) {
  let o = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((a, l) => {
    o.has(l) && n(a, l);
  });
}
const e0 = _g([]), wke = (e) => (dt(() => {
  if (e)
    return e0.set([...e0.get(), e]), () => {
      e0.set(e0.get().filter((n) => n !== e));
    };
}, [e]), { onCloseGlobal: re(() => {
  e0.get().forEach((n) => n());
}, []) });
function NT(e, t = {}) {
  let n = re(
    (a) => t.keys ? Cke(e, t.keys, a) : e.listen(a),
    [t.keys, e]
  ), o = e.get.bind(e);
  return x_(n, o, o);
}
const OD = _g(!1), _D = _g(!1), DD = _g(!1), ND = _g(!1), Eke = _g(0), XC = (e) => {
  OD.set(e.shiftKey), _D.set(e.ctrlKey), ND.set(e.altKey), DD.set(e.metaKey);
}, hDe = () => {
  dt(() => {
    if (!Eke.get())
      return window.addEventListener("keydown", XC), window.addEventListener("keyup", XC), () => {
        window.removeEventListener("keydown", XC), window.removeEventListener("keyup", XC);
      };
  }, []);
}, Tke = (e) => {
  OD.set(e);
}, Ike = (e) => {
  _D.set(e);
}, Ake = (e) => {
  ND.set(e);
}, kke = (e) => {
  DD.set(e);
}, MD = () => ({ setShift: Tke, setCtrl: Ike, setAlt: Ake, setMeta: kke }), LD = () => NT(OD), mDe = () => NT(_D), vDe = () => NT(ND), gDe = () => NT(DD);
var Rke = Le((e, t) => {
  const n = ko();
  return /* @__PURE__ */ Nt(ho, { ref: t, viewBox: "0 0 24 24", ...e, children: [
    /* @__PURE__ */ M("defs", { children: /* @__PURE__ */ Nt(
      "linearGradient",
      {
        x1: "28.154%",
        y1: "63.74%",
        x2: "74.629%",
        y2: "17.783%",
        id: n,
        children: [
          /* @__PURE__ */ M("stop", { stopColor: "currentColor", offset: "0%" }),
          /* @__PURE__ */ M("stop", { stopColor: "#fff", stopOpacity: "0", offset: "100%" })
        ]
      }
    ) }),
    /* @__PURE__ */ Nt("g", { transform: "translate(2)", fill: "none", children: [
      /* @__PURE__ */ M("circle", { stroke: `url(#${n})`, strokeWidth: "4", cx: "10", cy: "12", r: "10" }),
      /* @__PURE__ */ M(
        "path",
        {
          d: "M10 2C4.477 2 0 6.477 0 12",
          stroke: "currentColor",
          strokeWidth: "4"
        }
      ),
      /* @__PURE__ */ M("rect", { fill: "currentColor", x: "8", width: "4", height: "4", rx: "8" })
    ] })
  ] });
}), Pke = D9({
  d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z",
  displayName: "ChevronUpIcon"
}), Oke = D9({
  displayName: "ChevronDownIcon",
  d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
});
const _ke = Ps`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Dke = `${_ke} 1s linear infinite`;
function lo(e, t, n = !1) {
  e = String(e), t = String(t);
  const o = Array.from({ length: 21 }, (u, f) => f * 50), a = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 59, 64, 68, 73, 77, 82, 86, 95, 100];
  return o.reduce((u, f, h) => {
    const v = n ? a[h] / 100 : 1, g = n ? 50 : a[o.length - 1 - h];
    return u[f] = `hsl(${e} ${t}% ${g}% / ${v})`, u;
  }, {});
}
const cn = {
  base: { H: 220, S: 12 },
  working: { H: 47, S: 42 },
  gold: { H: 40, S: 70 },
  warning: { H: 28, S: 42 },
  ok: { H: 113, S: 42 },
  error: { H: 0, S: 42 },
  appYellow: { H: 66, S: 92 },
  appBlue: { H: 200, S: 76 },
  appGreen: { H: 110, S: 69 },
  appRed: { H: 16, S: 92 }
}, yDe = (e) => `hsl(${cn.base.H} ${cn.base.S}% ${e}%)`, Nke = {
  base: lo(cn.base.H, cn.base.S),
  baseAlpha: lo(cn.base.H, cn.base.S, !0),
  working: lo(cn.working.H, cn.working.S),
  workingAlpha: lo(cn.working.H, cn.working.S, !0),
  gold: lo(cn.gold.H, cn.gold.S),
  goldAlpha: lo(cn.gold.H, cn.gold.S, !0),
  warning: lo(cn.warning.H, cn.warning.S),
  warningAlpha: lo(cn.warning.H, cn.warning.S, !0),
  ok: lo(cn.ok.H, cn.ok.S),
  okAlpha: lo(cn.ok.H, cn.ok.S, !0),
  error: lo(cn.error.H, cn.error.S),
  errorAlpha: lo(cn.error.H, cn.error.S, !0),
  appYellow: lo(cn.appYellow.H, cn.appYellow.S),
  appYellowAlpha: lo(cn.appYellow.H, cn.appYellow.S, !0),
  appBlue: lo(cn.appBlue.H, cn.appBlue.S),
  appBlueAlpha: lo(cn.appBlue.H, cn.appBlue.S, !0),
  appGreen: lo(cn.appGreen.H, cn.appGreen.S),
  appGreenAlpha: lo(cn.appGreen.H, cn.appGreen.S, !0),
  appRed: lo(cn.appRed.H, cn.appRed.S),
  appRedAlpha: lo(cn.appRed.H, cn.appRed.S, !0)
}, { definePartsStyle: EU, defineMultiStyleConfig: Mke } = dn(I4.keys), Lke = {
  border: "none",
  bg: "base.850",
  borderRadius: "base",
  ":has(&div &button:hover)": { bg: "base.800" },
  transitionProperty: "common",
  transitionDuration: "0.1s"
}, Fke = (e) => ({
  gap: 2,
  fontWeight: "semibold",
  fontSize: "sm",
  border: "none",
  borderRadius: "base",
  color: "base.300",
  _hover: {},
  _expanded: {
    borderBottomRadius: "none"
  }
}), Bke = (e) => {
  const { colorScheme: t } = e;
  return {
    bg: `${t}.800`,
    borderRadius: "base",
    p: 0,
    transitionProperty: "common",
    transitionDuration: "0.1s"
  };
}, Vke = {
  ms: 2
}, $ke = EU((e) => ({
  container: Lke,
  button: Fke(e),
  panel: Bke(e),
  icon: Vke
})), zke = EU(() => ({
  root: {
    display: "flex",
    flexDirection: "column",
    gap: 4
  }
})), Hke = Mke({
  baseStyle: zke,
  variants: { aittor: $ke },
  defaultProps: {
    variant: "aittor",
    colorScheme: "base"
  }
}), jke = (e) => ({
  fontSize: 9,
  px: 2,
  py: 1,
  minW: 4,
  lineHeight: 1,
  borderRadius: "sm",
  bg: `${e.colorScheme}.200`,
  color: "base.900",
  fontWeight: "bold",
  letterSpacing: 0.6,
  wordBreak: "break-all",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis",
  overflow: "hidden"
}), Gke = {
  baseStyle: jke,
  defaultProps: {
    colorScheme: "base"
  }
}, Wke = (e, t) => t !== "outline" ? {
  borderWidth: "0px",
  borderStyle: "none"
} : e.size === "lg" ? {
  borderWidth: "1px",
  borderStyle: "solid"
} : e.size === "md" ? {
  borderWidth: "1px",
  borderStyle: "solid"
} : {
  borderWidth: "1px",
  borderStyle: "solid"
}, Uke = (e, t) => {
  const { colorScheme: n } = e, o = "base.400", a = n === "appYellow" ? `${n}.500` : `${n}.400`, l = "base.300", u = n === "appYellow" ? `${n}.300` : `${n}.300`, f = {
    fg: n === "base" ? "base.300" : a,
    fgHover: n === "base" ? "base.50" : u,
    fgDisabled: "base.600"
  }, h = { bg: "none", bgHover: "none", bgDisabled: "none" }, v = {
    borderColor: "none",
    borderColorDisabled: "none",
    borderColorHover: "none"
  };
  return t === "ghost" ? {
    ...f,
    ...h,
    ...v,
    bgHover: "baseAlpha.200"
  } : t === "link" ? {
    ...f,
    ...h,
    ...v
  } : t === "outline" ? {
    ...f,
    ...h,
    borderColor: n === "appYellow" ? `${n}Alpha.500` : `${n}Alpha.400`,
    borderColorDisabled: "base.600",
    borderColorHover: n === "appYellow" ? `${n}Alpha.700` : `${n}Alpha.600`
  } : {
    bg: n === "base" ? o : a,
    bgHover: n === "base" ? l : u,
    bgDisabled: "base.600",
    fg: "base.900",
    fgHover: "base.900",
    fgDisabled: "base.750",
    ...v
  };
}, ZC = (e, t) => {
  const { borderWidth: n, borderStyle: o } = Wke(e, t), { bg: a, bgDisabled: l, bgHover: u, fg: f, fgDisabled: h, fgHover: v, borderColor: g, borderColorDisabled: b, borderColorHover: S } = Uke(e, t), w = {
    bg: l,
    color: h,
    opacity: 1,
    borderColor: b,
    svg: {
      fill: h
    },
    _hover: {
      bg: l,
      color: h,
      borderColor: b,
      svg: {
        fill: h
      }
    }
  }, E = {
    bg: a,
    color: f,
    borderWidth: n,
    borderStyle: o,
    borderColor: g,
    svg: {
      fill: f
    }
  };
  return {
    ...E,
    _hover: {
      bg: u,
      color: v,
      borderColor: S,
      svg: {
        fill: v
      },
      _disabled: w
    },
    _active: { ...E },
    _disabled: w
  };
}, Xke = (e) => {
  const { colorScheme: t } = e, n = {
    bg: "none",
    color: `${t}.500`,
    svg: {
      fill: `${t}.500`
    },
    opacity: 0.7
  };
  return {
    fontSize: 14,
    h: "min-content",
    w: "min-content",
    minW: "unset",
    minH: "unset",
    bg: "none",
    color: `${t}.400`,
    svg: {
      fill: `${t}.400`
    },
    _disabled: n,
    _hover: {
      bg: "none",
      color: t === "base" ? "base.100" : `${t}.300`,
      svg: {
        fill: t === "base" ? "base.100" : `${t}.300`
      },
      _disabled: n
    },
    '&[data-checked="true"]': {
      color: "blue.300",
      svg: {
        fill: "blue.300"
      },
      _hover: {
        color: "blue.400",
        svg: {
          fill: "blue.400"
        }
      }
    }
  };
}, Zke = {
  baseStyle: {
    fontWeight: "semibold",
    svg: {
      transitionProperty: "all",
      transitionDuration: "faster"
    }
  },
  sizes: {
    sm: {
      fontSize: "sm",
      px: 3,
      py: 2
    },
    md: {
      fontSize: "md",
      px: 4,
      py: 2
    },
    lg: {
      fontSize: "lg",
      px: 4,
      py: 2,
      h: 12
    }
  },
  variants: {
    solid: (e) => ZC(e, "solid"),
    appTab: (e) => ({
      bg: "none",
      svg: {
        fill: "base.600"
      },
      _hover: {
        bg: "none",
        svg: {
          fill: "base.400"
        }
      },
      '&[data-selected="true"]': {
        bg: "none",
        svg: {
          fill: "base.100"
        }
      }
    }),
    outline: (e) => ZC(e, "outline"),
    ghost: (e) => ZC(e, "ghost"),
    link: (e) => ZC(e, "link"),
    promptOverlay: Xke
  },
  defaultProps: {
    variant: "solid",
    colorScheme: "base",
    size: "md"
  }
}, { defineMultiStyleConfig: Yke, definePartsStyle: Jke } = dn($4.keys), Qke = Jke({
  container: {
    backgroundColor: "base.750",
    p: 4,
    gap: 2,
    borderRadius: "base",
    minW: 64,
    flexBasis: 1,
    flexGrow: 1
  },
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    p: 0,
    fontSize: "md",
    fontWeight: "semibold"
  },
  body: {
    p: 0,
    display: "flex",
    alignItems: "center",
    gap: 4
  },
  footer: {
    p: 0
  }
}), Kke = Yke({
  variants: { lora: Qke }
}), { definePartsStyle: qke, defineMultiStyleConfig: eRe } = dn(A4.keys), tRe = (e) => {
  const { colorScheme: t } = e;
  return {
    bg: "base.700",
    borderColor: "base.600",
    color: "base.100",
    _checked: {
      bg: `${t}.500`,
      borderColor: `${t}.500`,
      color: `${t}.100`,
      _hover: {
        bg: `${t}.500`,
        borderColor: `${t}.500`
      },
      _disabled: {
        borderColor: "transparent",
        bg: "whiteAlpha.300",
        color: "whiteAlpha.500"
      }
    },
    _indeterminate: {
      bg: `${t}.600`,
      borderColor: `${t}.600`,
      color: `${t}.100`
    },
    _disabled: {
      bg: "whiteAlpha.100",
      borderColor: "transparent"
    },
    _focusVisible: {
      boxShadow: "none",
      outline: "none"
    },
    _invalid: {
      borderColor: "error.300"
    }
  };
}, nRe = qke((e) => ({
  control: tRe(e)
})), rRe = eRe({
  baseStyle: nRe,
  defaultProps: {
    colorScheme: "appBlue"
  }
}), oRe = dn(["root", "content"]), bc = {
  transitionProperty: "common",
  transitionDuration: "normal"
}, iRe = oRe.defineMultiStyleConfig({
  baseStyle: {
    root: {
      ...bc,
      w: "full",
      '[data-part="control"]': {
        ...bc,
        w: "full",
        alignItems: "center",
        gap: 2
      },
      '[data-part="trigger"]': {
        ...bc,
        gap: 4,
        alignItems: "center",
        bg: "base.700",
        w: "full",
        h: "28px",
        py: 1,
        px: 4,
        borderRadius: "base",
        _hover: {
          bg: "base.650"
        },
        "&[data-disabled]": {
          opacity: 0.5,
          cursor: "not-allowed",
          _hover: {
            bg: "base.700"
          }
        },
        "&[data-invalid]": {
          borderWidth: "1px",
          borderStyle: "solid",
          borderColor: "error.500"
        }
      },
      "[data-placeholder-shown]": {
        '[data-part="value-text"]': {
          color: "base.400"
        }
      },
      '[data-part="value-text"]': {
        ...bc,
        w: "full",
        h: "full",
        alignItems: "center",
        fontSize: "sm"
      },
      '[data-part="indicator"]': { svg: { boxSize: 4 } },
      '[data-part="clear-trigger"]': {
        // unused - ark requires the clear trigger be within the trigger component, but this makes it difficult to control
        // the width of the content. we are manually handling the clear button by placing it outside the trigger. so, this
        // styling does not apply.
      }
    },
    content: {
      ...bc,
      outline: "none !important",
      flexDir: "column",
      bg: "base.800",
      p: 2,
      gap: 1,
      borderRadius: "base",
      maxH: 96,
      overflowY: "scroll",
      "&[data-state='open']": {
        //
      },
      "&[data-state='closed']": {
        //
      },
      '[data-part="item-group"]': { ...bc, flexDir: "column", gap: 1 },
      '[data-part="item-group-label"]': {
        ...bc,
        py: 1,
        px: 2,
        color: "base.400",
        fontWeight: "semibold"
      },
      '[data-part="item"]': {
        ...bc,
        alignItems: "center",
        borderRadius: "base",
        py: 1,
        px: 2,
        cursor: "pointer",
        "&[data-highlighted]": {
          bg: "base.700"
        },
        '&[data-state="checked"]': {
          bg: "appBlue.300",
          '[data-part="item-text"]': {
            '[data-part="item-text-label"]': { color: "base.900" },
            '[data-part="item-text-description"]': { color: "base.900" }
          }
        },
        '&[data-state="checked"][data-highlighted]': {
          bg: "appBlue.200"
        },
        '[data-part="item-text"]': {
          ...bc,
          flexDir: "column",
          w: "full",
          '[data-part="item-text-label"]': {
            fontWeight: "semibold"
          },
          '[data-part="item-text-description"]': { color: "base.300" }
        },
        "&[data-disabled]": {
          cursor: "not-allowed",
          color: "base.500",
          '[data-part="item-text"]': {
            '[data-part="item-text-description"]': { color: "base.500" }
          }
        }
      }
    }
  }
}), { definePartsStyle: aRe, defineMultiStyleConfig: sRe } = dn(k4.keys), lRe = {
  fontSize: "sm",
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  color: "base.100",
  _invalid: {
    color: "error.300"
  }
}, uRe = () => ({
  color: "base.100",
  fontSize: "sm",
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "none" },
  _placeholder: { opacity: 0.6 },
  "::selection": {
    color: "blue.900",
    bg: "blue.300"
  }
}), cRe = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, dRe = aRe(() => ({
  preview: lRe,
  input: uRe(),
  textarea: cRe
})), fRe = sRe({
  variants: {
    aittor: dRe
  },
  defaultProps: {
    size: "sm",
    variant: "aittor"
  }
}), { definePartsStyle: pRe, defineMultiStyleConfig: hRe } = dn(R4.keys), mRe = pRe((e) => ({
  container: {
    display: "flex",
    flexDirection: e.orientation === "vertical" ? "column" : "row",
    alignItems: e.orientation === "vertical" ? "flex-start" : "center",
    gap: e.orientation === "vertical" ? 2 : 4,
    h: "unset",
    minH: 8,
    w: "full"
  },
  helperText: {
    w: "full",
    fontSize: "sm",
    color: "base.400",
    m: 0
  }
})), vRe = hRe({
  baseStyle: mRe
}), gRe = (e) => ({
  mb: e.orientation === "vertical" ? void 0 : 0,
  fontSize: "sm",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  whiteSpace: "nowrap",
  userSelect: "none",
  alignItems: "center",
  _disabled: {
    opacity: 0.4
  },
  color: "base.300",
  _invalid: {
    color: "error.300"
  }
}), yRe = {
  baseStyle: gRe
}, { defineMultiStyleConfig: bRe } = dn(P4.keys);
bRe({
  baseStyle: {
    text: {
      color: "error.300"
    }
  }
});
const SRe = () => ({
  color: "appBlue.300"
}), xRe = {
  variants: {
    appBlue: SRe
  }
}, xg = (e) => {
  const { variant: t } = e, n = t === "darkFilled" || t === "iterations" ? "base.800" : "base.700", o = t === "darkFilled" || t === "iterations" ? "base.750" : "base.650", a = "error.600", l = "error.500", f = {
    color: "base.100",
    bg: n,
    borderColor: n
  }, h = {
    borderColor: a,
    _hover: {
      borderColor: l
    }
  }, v = {
    bg: o,
    borderColor: o
  }, g = {
    ...v,
    _invalid: h
  };
  return {
    ...f,
    minH: "28px",
    borderWidth: 1,
    borderRadius: "base",
    outline: "none",
    boxShadow: "none",
    _hover: v,
    _focusVisible: g,
    _invalid: h,
    _disabled: {
      opacity: 0.35,
      _hover: f
    }
  };
}, { definePartsStyle: f5, defineMultiStyleConfig: CRe } = dn(O4.keys), wRe = CRe({
  variants: {
    filled: f5((e) => ({
      field: xg(e)
    })),
    darkFilled: f5((e) => ({
      field: xg(e)
    }))
  },
  defaultProps: {
    size: "sm",
    variant: "filled"
  }
}), { definePartsStyle: ERe, defineMultiStyleConfig: TRe } = dn(_4.keys), IRe = ERe(() => ({
  // define the part you're going to style
  button: {
    // this will style the MenuButton component
    bg: "base.500",
    color: "base.100",
    _hover: {
      bg: "base.600",
      color: "base.50",
      fontWeight: "semibold"
    }
  },
  list: {
    zIndex: 9999,
    color: "base.150",
    bg: "base.800",
    shadow: "dark-lg",
    border: "none",
    p: 2
  },
  item: {
    // this will style the MenuItem and MenuItemOption components
    borderRadius: "sm",
    fontSize: "sm",
    bg: "base.800",
    _hover: {
      bg: "base.700",
      svg: {
        opacity: 1
      }
    },
    _focus: {
      bg: "base.700"
    },
    svg: {
      opacity: 0.7,
      fontSize: 14
    },
    "&[data-destructive='true']": {
      color: "error.300",
      fill: "error.300",
      _hover: {
        bg: "error.600",
        color: "base.50",
        fill: "base.50"
      }
    },
    "&[aria-selected='true']": {
      fontWeight: "semibold",
      bg: "blue.300 !important",
      color: "base.800 !important",
      _hover: {
        color: "base.900 !important",
        bg: "blue.400 !important"
      }
    },
    "&[aria-selected='true'] [data-option-desc='true']": {
      color: "base.800"
    }
  },
  divider: {
    borderColor: "base.700"
  },
  groupTitle: {
    m: 0,
    px: 3,
    py: 2,
    color: "base.500"
  }
})), ARe = TRe({
  variants: {
    aittor: IRe
  },
  defaultProps: {
    variant: "aittor"
  }
}), { defineMultiStyleConfig: kRe, definePartsStyle: RRe } = dn(D4.keys), PRe = RRe(() => ({
  overlay: {
    bg: "blackAlpha.700"
  },
  dialogContainer: {},
  dialog: {
    maxH: "80vh",
    bg: "base.800"
  },
  header: {
    fontWeight: "semibold",
    fontSize: "lg",
    color: "base.300"
  },
  closeButton: {
    opacity: 0.5
  },
  body: {
    overflowY: "scroll"
  },
  footer: {}
})), ORe = kRe({
  baseStyle: PRe,
  defaultProps: { size: "lg" }
}), { defineMultiStyleConfig: _Re, definePartsStyle: TU } = dn(N4.keys), p5 = TU((e) => ({
  root: { h: "28px" },
  field: { ...xg(e), pe: 6, h: "full" },
  stepperGroup: {
    border: "none",
    w: 6
  },
  stepper: {
    color: "base.200",
    _hover: {
      bg: "base.700",
      color: "base.100"
    },
    _disabled: {
      _hover: {
        bg: "base.800",
        color: "base.200"
      }
    },
    _first: {
      border: "none",
      margin: 0,
      borderTopEndRadius: "base",
      borderBottomStartRadius: "base"
    },
    _last: {
      border: "none",
      margin: 0,
      borderBottomEndRadius: "base",
      borderTopStartRadius: "base"
    }
  }
})), DRe = TU((e) => ({
  root: { h: "28px" },
  field: {
    ...xg(e),
    pe: 6,
    ps: 6,
    borderInlineStartRadius: "base",
    h: "full",
    textAlign: "center",
    fontSize: "md",
    fontWeight: "semibold"
  },
  stepperGroup: {
    border: "none",
    w: 6
  },
  stepper: {
    color: "base.200",
    _hover: {
      bg: "base.700",
      color: "base.100"
    },
    _disabled: {
      _hover: {
        bg: "base.800",
        color: "base.200"
      }
    },
    _first: {
      border: "none",
      margin: 0,
      borderTopEndRadius: "base",
      borderBottomStartRadius: "base"
    },
    _last: {
      border: "none",
      margin: 0,
      borderBottomEndRadius: "base",
      borderTopStartRadius: "base"
    }
  }
})), NRe = _Re({
  variants: {
    filled: p5,
    darkFilled: p5,
    iterations: DRe
  },
  defaultProps: {
    size: "sm",
    variant: "filled"
  }
}), { defineMultiStyleConfig: MRe, definePartsStyle: IU } = dn(M4.keys), AU = Dr("popper-bg"), kU = Dr("popper-arrow-bg"), RU = Dr("popper-arrow-shadow-color"), LRe = () => ({
  [kU.variable]: "colors.base.800",
  [AU.variable]: "colors.base.800",
  [RU.variable]: "colors.base.600",
  minW: "unset",
  width: "unset",
  p: 4,
  bg: "base.800",
  border: "none",
  shadow: "dark-lg"
}), FRe = () => ({
  [kU.variable]: "colors.base.700",
  [AU.variable]: "colors.base.700",
  [RU.variable]: "colors.base.400",
  p: 4,
  bg: "base.700",
  border: "none",
  shadow: "dark-lg"
}), BRe = IU(() => ({
  content: LRe(),
  body: { padding: 0 }
})), VRe = IU(() => ({
  content: FRe(),
  body: { padding: 0 }
})), $Re = MRe({
  variants: {
    aittor: BRe,
    informational: VRe
  },
  defaultProps: {
    variant: "aittor"
  }
}), { defineMultiStyleConfig: zRe, definePartsStyle: HRe } = dn(L4.keys), jRe = zRe({
  baseStyle: HRe(({ theme: e, colorScheme: t, hasStripe: n, isIndeterminate: o }) => {
    const a = `${t}.300`, l = !o && n, u = `linear-gradient(
      to right,
      transparent 0%,
      ${pee(e, a)} 50%,
      transparent 100%
    )`;
    return {
      track: {
        borderRadius: "2px",
        bg: "base.800"
      },
      filledTrack: {
        borderRadius: "2px",
        ...l && WP(),
        ...o ? { bgImage: u } : { bgColor: a }
      }
    };
  })
}), GRe = Pt("skeleton-start-color"), WRe = Pt("skeleton-end-color"), URe = {
  borderRadius: "base",
  maxW: "full",
  maxH: "full",
  [GRe.variable]: "colors.base.700",
  [WRe.variable]: "colors.base.500"
}, XRe = {
  baseStyle: URe
}, { definePartsStyle: ZRe, defineMultiStyleConfig: YRe } = dn(F4.keys), JRe = () => ({
  h: "28px"
}), QRe = () => ({
  bg: "base.600",
  h: 2
}), KRe = (e) => ({
  bg: "base.400",
  h: 2
}), qRe = (e) => {
  const { orientation: t } = e;
  return {
    w: 5,
    h: 5,
    bg: "base.400",
    borderColor: "base.200",
    borderWidth: 3,
    _hover: {
      transform: t === "vertical" ? "translateX(-50%) scale(1.15)" : "translateY(-50%) scale(1.15)",
      transition: "transform 0.1s",
      _active: {
        transform: t === "vertical" ? "translateX(-50%) scale(1.22)" : "translateY(-50%) scale(1.22)",
        transition: "transform 0.05s"
      }
    }
  };
}, ePe = () => ({
  fontSize: "10px",
  color: "base.400",
  mt: 4
}), tPe = ZRe((e) => ({
  container: JRe(),
  track: QRe(),
  filledTrack: KRe(e),
  thumb: qRe(e),
  mark: ePe()
})), nPe = YRe({
  baseStyle: tPe,
  defaultProps: {
    colorScheme: "base"
  }
}), { defineMultiStyleConfig: rPe, definePartsStyle: oPe } = dn(B4.keys), iPe = (e) => ({
  bg: "base.600",
  p: 1,
  _focusVisible: {
    boxShadow: "none"
  },
  _checked: {
    bg: "blue.500"
  }
}), aPe = (e) => ({
  bg: "base.50"
}), sPe = oPe((e) => ({
  container: {},
  track: iPe(e),
  thumb: aPe(e)
})), lPe = rPe({
  variants: { aittor: sPe },
  defaultProps: {
    size: "md",
    variant: "aittor"
  }
}), { defineMultiStyleConfig: uPe, definePartsStyle: FD } = dn(V4.keys), cPe = () => ({
  display: "flex",
  gap: 4
}), dPe = () => ({}), fPe = (e) => ({
  display: "flex",
  flexDirection: "column",
  gap: 1
}), pPe = () => ({
  padding: 0,
  height: "100%"
}), hPe = FD((e) => ({
  root: cPe(),
  tab: dPe(),
  tablist: fPe(e),
  tabpanel: pPe()
})), mPe = FD(() => ({
  tab: {
    borderTopRadius: "base",
    px: 4,
    py: 1,
    fontSize: "sm",
    color: "base.200",
    _selected: {
      color: "blue.200"
    }
  },
  tabpanel: {
    p: 0,
    pt: 4,
    w: "full",
    h: "full"
  },
  tabpanels: {
    w: "full",
    h: "full"
  }
})), vPe = "base.750", YC = "base.800", gPe = FD(() => ({
  indicator: {},
  tablist: {
    bg: YC,
    borderRadius: "base",
    display: "grid",
    gridAutoFlow: "column",
    gridAutoColumns: "1fr"
  },
  tab: {
    gap: 4,
    bg: vPe,
    color: "base.400",
    fontSize: "sm",
    fontWeight: "semibold",
    borderInlineEnd: 1,
    borderInlineEndColor: YC,
    borderInlineEndStyle: "solid",
    _first: {
      borderTopStartRadius: "base"
    },
    // select the tab next to the selected tab
    '&[aria-selected="true"] + button': { borderBottomStartRadius: "lg" },
    // select the tab prev to the selected tab
    ':has(+ [aria-selected="true"])': { borderBottomEndRadius: "lg" },
    _selected: {
      bg: YC,
      color: "base.50"
    },
    _last: {
      borderTopEndRadius: "base",
      alignSelf: "start"
    },
    transitionProperty: "all"
  },
  tabpanels: { bg: YC, borderBottomRadius: "base" },
  tabpanel: {
    p: 0
  }
})), yPe = uPe({
  variants: {
    line: mPe,
    appTabs: hPe,
    collapse: gPe
  },
  defaultProps: {
    variant: "line",
    colorScheme: "blue"
  }
}), bPe = () => ({
  fontSize: "sm"
}), SPe = () => ({
  color: "error.400"
}), xPe = () => ({
  color: "base.400"
}), CPe = {
  baseStyle: bPe,
  variants: {
    subtext: xPe,
    error: SPe
  }
}, wPe = {
  variants: {
    filled: (e) => xg(e),
    darkFilled: (e) => xg(e)
  },
  defaultProps: {
    size: "md",
    variant: "filled"
  }
}, EPe = Dr("popper-arrow-bg"), TPe = () => ({
  borderRadius: "md",
  shadow: "dark-lg",
  bg: "base.200",
  color: "base.800",
  [EPe.variable]: "colors.base.200",
  pt: 1,
  px: 2,
  pb: 1
}), IPe = { baseStyle: TPe }, APe = {
  Accordion: Hke,
  Badge: Gke,
  Button: Zke,
  Card: Kke,
  Checkbox: rRe,
  CustomSelect: iRe,
  Editable: fRe,
  Form: vRe,
  FormLabel: yRe,
  Heading: xRe,
  Input: wRe,
  Menu: ARe,
  Modal: ORe,
  NumberInput: NRe,
  Popover: $Re,
  Progress: jRe,
  Skeleton: XRe,
  Slider: nPe,
  Switch: lPe,
  Tabs: yPe,
  Text: CPe,
  Textarea: wPe,
  Tooltip: IPe
}, kPe = {
  body: {
    bg: "base.900",
    color: "base.50"
  },
  first: {
    bg: "base.850",
    color: "base.50"
  },
  second: {
    bg: "base.800",
    color: "base.50"
  },
  third: {
    bg: "base.700",
    color: "base.50"
  },
  nodeBody: {
    bg: "base.800",
    color: "base.100"
  },
  nodeHeader: {
    bg: "base.900",
    color: "base.100"
  },
  nodeFooter: {
    bg: "base.900",
    color: "base.100"
  },
  danger: {
    color: "error.500 !important"
  }
}, RPe = {
  "::-webkit-scrollbar": {
    display: "none"
  },
  scrollbarWidth: "none"
}, PPe = {
  ".os-scrollbar": {
    /*      The size of the scrollbar */
    "--os-size": "9px",
    /*      The axis-perpedicular padding of the scrollbar (horizontal: padding-y, vertical: padding-x) */
    /* --os-padding-perpendicular: 0; */
    /*      The axis padding of the scrollbar (horizontal: padding-x, vertical: padding-y) */
    /* --os-padding-axis: 0; */
    /*      The border radius of the scrollbar track */
    /* --os-track-border-radius: 0; */
    /*      The background of the scrollbar track */
    /* --os-track-bg: rgba(0, 0, 0, 0.3); */
    /*      The :hover background of the scrollbar track */
    /* --os-track-bg-hover: rgba(0, 0, 0, 0.3); */
    /*      The :active background of the scrollbar track */
    /* --os-track-bg-active: rgba(0, 0, 0, 0.3); */
    /*      The border of the scrollbar track */
    /* --os-track-border: none; */
    /*      The :hover background of the scrollbar track */
    /* --os-track-border-hover: none; */
    /*      The :active background of the scrollbar track */
    /* --os-track-border-active: none; */
    /*      The border radius of the scrollbar handle */
    /* --os-handle-border-radius: 2px; */
    /*      The background of the scrollbar handle */
    /* --os-handle-bg: var(--app-colors-accentAlpha-500); */
    /*      The :hover background of the scrollbar handle */
    /* --os-handle-bg-hover: var(--app-colors-accentAlpha-700); */
    /*      The :active background of the scrollbar handle */
    /* --os-handle-bg-active: var(--app-colors-accentAlpha-800); */
    /*      The border of the scrollbar handle */
    /* --os-handle-border: none; */
    /*      The :hover border of the scrollbar handle */
    /* --os-handle-border-hover: none; */
    /*      The :active border of the scrollbar handle */
    /* --os-handle-border-active: none; */
    /*      The min size of the scrollbar handle */
    "--os-handle-min-size": "50px"
    /*      The max size of the scrollbar handle */
    /* --os-handle-max-size: none; */
    /*      The axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size: 100%; */
    /*      The :hover axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size-hover: 100%; */
    /*      The :active axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size-active: 100%; */
    /*      Increases the interactive area of the scrollbar handle. */
    /* --os-handle-interactive-area-offset: 0; */
  },
  ".os-scrollbar-handle": {
    cursor: "grab"
  },
  ".os-scrollbar-handle:active": {
    cursor: "grabbing"
  }
}, h5 = {
  backgroundColor: "blueAlpha.150 !important",
  borderColor: "blue.400 !important",
  borderRadius: "base !important",
  borderStyle: "dashed !important"
}, OPe = {
  ".react-flow__nodesselection-rect": {
    ...h5,
    padding: "1rem !important",
    boxSizing: "content-box !important",
    transform: "translate(-1rem, -1rem) !important"
  },
  ".react-flow__selection": h5
}, _Pe = {
  blue: "0 0 10px 0 var(--app-colors-blue-600)",
  blueHover: "0 0 10px 0 var(--app-colors-blue-500)",
  ok: "0 0 7px var(--app-colors-ok-400)",
  working: "0 0 7px var(--app-colors-working-400)",
  error: "0 0 7px var(--app-colors-error-400)",
  selected: "0px 0px 0px 1px var(--app-colors-base-900), 0px 0px 0px 4px var(--app-colors-blue-500)",
  hoverSelected: "0px 0px 0px 1px var(--app-colors-base-900), 0px 0px 0px 4px var(--app-colors-blue-400)",
  hoverUnselected: "0px 0px 0px 1px var(--app-colors-base-900), 0px 0px 0px 3px var(--app-colors-blue-400)",
  nodeSelected: "0 0 0 3px var(--app-colors-blue-500)",
  nodeHovered: "0 0 0 2px var(--app-colors-blue-400)",
  nodeHoveredSelected: "0 0 0 3px var(--app-colors-blue-400)",
  nodeInProgress: "0 0 0 2px var(--app-colors-yellow-400), 0 0 20px 2px var(--app-colors-orange-700)"
}, DPe = (e = 0.75) => [
  0.5,
  1,
  1.5,
  2,
  2.5,
  3,
  3.5,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  52,
  56,
  60,
  64,
  72,
  80,
  96
].reduce(
  (o, a) => (o[a] = `${a * (0.25 * e)}rem`, o),
  { px: "1px" }
), m5 = DPe(0.75), bDe = {
  config: {
    cssVarPrefix: "aittor"
  },
  direction: "ltr",
  colors: Nke,
  components: APe,
  layerStyles: kPe,
  shadows: _Pe,
  space: m5,
  sizes: m5,
  styles: {
    global: {
      body: { bg: "base.900", color: "base.50" },
      "*": { ...RPe },
      ...PPe,
      ...OPe
    }
  },
  fonts: {
    body: "'Inter Variable', sans-serif",
    heading: "'Inter Variable', sans-serif"
  },
  radii: {
    base: "4px",
    lg: "8px",
    md: "4px",
    sm: "2px"
  },
  fontSizes: {
    xs: "0.65rem",
    sm: "0.75rem",
    md: "0.9rem",
    lg: "1.025rem",
    xl: "1.15rem",
    "2xl": "1.3rem",
    "3xl": "1.575rem",
    "4xl": "1.925rem",
    "5xl": "2.5rem",
    "6xl": "3.25rem",
    "7xl": "4rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
}, SDe = {
  defaultOptions: { isClosable: !0, position: "bottom-right" }
}, NPe = rr(
  Le((e, t) => {
    const { isDestructive: n = !1, isLoading: o = !1, isDisabled: a, icon: l, ...u } = e;
    return /* @__PURE__ */ M(
      yj,
      {
        ref: t,
        icon: o ? /* @__PURE__ */ M(Rke, { animation: Dke }) : l,
        isDisabled: o || a,
        "data-destructive": n,
        ...u
      }
    );
  })
);
NPe.displayName = "MenuItem";
const MPe = {
  variants: {
    enter: {
      visibility: "visible",
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.07,
        ease: [0.4, 0, 0.2, 1]
      }
    },
    exit: {
      transitionEnd: {
        visibility: "hidden"
      },
      opacity: 0,
      scale: 0.8,
      transition: {
        duration: 0.07,
        easings: "easeOut"
      }
    }
  }
}, LPe = rr(
  Le((e, t) => /* @__PURE__ */ M(wf, { children: /* @__PURE__ */ M(bj, { ref: t, motionProps: MPe, onContextMenu: ACe, ...e }) }))
);
LPe.displayName = "MenuList";
const xDe = rr((e) => {
  const { isOpen: t, onOpen: n, onClose: o } = Qpe(), [a, l] = ot([-1, -1]), u = Ue(null), f = Ue([-1, -1]), h = Ue(0);
  wke(o);
  const v = re(
    (g) => {
      var b;
      if (g.shiftKey) {
        o();
        return;
      }
      ((b = u.current) != null && b.contains(g.target) || g.target === u.current) && (window.clearTimeout(h.current), g.preventDefault(), f.current[0] !== g.pageX || f.current[1] !== g.pageY ? (o(), h.current = window.setTimeout(() => {
        n(), l([g.pageX, g.pageY]);
      }, 100)) : (n(), l([g.pageX, g.pageY]))), f.current = [g.pageX, g.pageY];
    },
    [o, n]
  );
  return dt(
    () => () => {
      window.clearTimeout(h.current);
    },
    []
  ), Zpe("contextmenu", v), /* @__PURE__ */ Nt(ah, { children: [
    e.children(u),
    /* @__PURE__ */ M(wf, { ...e.portalProps, children: /* @__PURE__ */ Nt(K2, { isLazy: !0, isOpen: t, gutter: 0, placement: "auto-end", onClose: o, ...e.menuProps, children: [
      /* @__PURE__ */ M(
        xj,
        {
          "aria-hidden": !0,
          w: 1,
          h: 1,
          position: "absolute",
          left: a[0],
          top: a[1],
          cursor: "default",
          bg: "transparent",
          size: "sm",
          _hover: FPe,
          pointerEvents: "none",
          ...e.menuButtonProps
        }
      ),
      e.renderMenu()
    ] }) })
  ] });
}), FPe = { bg: "transparent" }, BPe = Symbol(), BD = Symbol(), t0 = "a", Iw = "w";
let VPe = (e, t) => new Proxy(e, t);
const m_ = Object.getPrototypeOf, v_ = /* @__PURE__ */ new WeakMap(), PU = (e) => e && (v_.has(e) ? v_.get(e) : m_(e) === Object.prototype || m_(e) === Array.prototype), v5 = (e) => typeof e == "object" && e !== null, $Pe = (e) => {
  if (Array.isArray(e))
    return Array.from(e);
  const t = Object.getOwnPropertyDescriptors(e);
  return Object.values(t).forEach((n) => {
    n.configurable = !0;
  }), Object.create(m_(e), t);
}, OU = (e) => e[BD] || e, _U = (e, t, n, o) => {
  if (!PU(e))
    return e;
  let a = o && o.get(e);
  if (!a) {
    const h = OU(e);
    a = ((v) => Object.values(Object.getOwnPropertyDescriptors(v)).some((g) => !g.configurable && !g.writable))(h) ? [h, $Pe(h)] : [h], o == null || o.set(e, a);
  }
  const [l, u] = a;
  let f = n && n.get(l);
  return f && f[1].f === !!u || (f = ((h, v) => {
    const g = { f: v };
    let b = !1;
    const S = (E, T) => {
      if (!b) {
        let A = g[t0].get(h);
        if (A || (A = {}, g[t0].set(h, A)), E === Iw)
          A[Iw] = !0;
        else {
          let P = A[E];
          P || (P = /* @__PURE__ */ new Set(), A[E] = P), P.add(T);
        }
      }
    }, w = { get: (E, T) => T === BD ? h : (S("k", T), _U(Reflect.get(E, T), g[t0], g.c, g.t)), has: (E, T) => T === BPe ? (b = !0, g[t0].delete(h), !0) : (S("h", T), Reflect.has(E, T)), getOwnPropertyDescriptor: (E, T) => (S("o", T), Reflect.getOwnPropertyDescriptor(E, T)), ownKeys: (E) => (S(Iw), Reflect.ownKeys(E)) };
    return v && (w.set = w.deleteProperty = () => !1), [w, g];
  })(l, !!u), f[1].p = VPe(u || l, f[0]), n && n.set(l, f)), f[1][t0] = t, f[1].c = n, f[1].t = o, f[1].p;
}, DU = (e, t, n, o) => {
  if (Object.is(e, t))
    return !1;
  if (!v5(e) || !v5(t))
    return !0;
  const a = n.get(OU(e));
  if (!a)
    return !0;
  if (o) {
    const u = o.get(e);
    if (u && u.n === t)
      return u.g;
    o.set(e, { n: t, g: !1 });
  }
  let l = null;
  try {
    for (const u of a.h || [])
      if (l = Reflect.has(e, u) !== Reflect.has(t, u), l)
        return l;
    if (a[Iw] === !0) {
      if (l = ((u, f) => {
        const h = Reflect.ownKeys(u), v = Reflect.ownKeys(f);
        return h.length !== v.length || h.some((g, b) => g !== v[b]);
      })(e, t), l)
        return l;
    } else
      for (const u of a.o || [])
        if (l = !!Reflect.getOwnPropertyDescriptor(e, u) != !!Reflect.getOwnPropertyDescriptor(t, u), l)
          return l;
    for (const u of a.k || [])
      if (l = DU(e[u], t[u], n, o), l)
        return l;
    return l === null && (l = !0), l;
  } finally {
    o && o.set(e, { n: t, g: l });
  }
}, zPe = (e) => PU(e) && e[BD] || null, g5 = (e, t = !0) => {
  v_.set(e, t);
};
var IE = process.env.NODE_ENV !== "production", TP = (e) => typeof e == "object" && e !== null, Zp = /* @__PURE__ */ new WeakMap(), g0 = /* @__PURE__ */ new WeakSet(), HPe = (e = Object.is, t = (v, g) => new Proxy(v, g), n = (v) => TP(v) && !g0.has(v) && (Array.isArray(v) || !(Symbol.iterator in v)) && !(v instanceof WeakMap) && !(v instanceof WeakSet) && !(v instanceof Error) && !(v instanceof Number) && !(v instanceof Date) && !(v instanceof String) && !(v instanceof RegExp) && !(v instanceof ArrayBuffer), o = (v) => {
  switch (v.status) {
    case "fulfilled":
      return v.value;
    case "rejected":
      throw v.reason;
    default:
      throw v;
  }
}, a = /* @__PURE__ */ new WeakMap(), l = (v, g, b = o) => {
  const S = a.get(v);
  if ((S == null ? void 0 : S[0]) === g)
    return S[1];
  const w = Array.isArray(v) ? [] : Object.create(Object.getPrototypeOf(v));
  return g5(w, !0), a.set(v, [g, w]), Reflect.ownKeys(v).forEach((E) => {
    const T = Reflect.get(v, E);
    g0.has(T) ? (g5(T, !1), w[E] = T) : T instanceof Promise ? Object.defineProperty(w, E, {
      get() {
        return b(T);
      }
    }) : Zp.has(T) ? w[E] = Cf(T, b) : w[E] = T;
  }), Object.freeze(w);
}, u = /* @__PURE__ */ new WeakMap(), f = [1, 1], h = (v) => {
  if (!TP(v))
    throw new Error("object required");
  const g = u.get(v);
  if (g)
    return g;
  let b = f[0];
  const S = /* @__PURE__ */ new Set(), w = (W, H = ++f[0]) => {
    b !== H && (b = H, S.forEach((G) => G(W, H)));
  };
  let E = f[1];
  const T = (W = ++f[1]) => (E !== W && !S.size && (E = W, P.forEach(([H]) => {
    const G = H[1](W);
    G > b && (b = G);
  })), b), A = (W) => (H, G) => {
    const oe = [...H];
    oe[1] = [W, ...oe[1]], w(oe, G);
  }, P = /* @__PURE__ */ new Map(), _ = (W, H) => {
    if (IE && P.has(W))
      throw new Error("prop listener already exists");
    if (S.size) {
      const G = H[3](A(W));
      P.set(W, [H, G]);
    } else
      P.set(W, [H]);
  }, D = (W) => {
    var G;
    const H = P.get(W);
    H && (P.delete(W), (G = H[1]) == null || G.call(H));
  }, L = (W) => (S.add(W), S.size === 1 && P.forEach(([G, oe], ce) => {
    if (IE && oe)
      throw new Error("remove already exists");
    const te = G[3](A(ce));
    P.set(ce, [G, te]);
  }), () => {
    S.delete(W), S.size === 0 && P.forEach(([G, oe], ce) => {
      oe && (oe(), P.set(ce, [G]));
    });
  }), F = Array.isArray(v) ? [] : Object.create(Object.getPrototypeOf(v)), $ = t(F, {
    deleteProperty(W, H) {
      const G = Reflect.get(W, H);
      D(H);
      const oe = Reflect.deleteProperty(W, H);
      return oe && w(["delete", [H], G]), oe;
    },
    set(W, H, G, oe) {
      var me;
      const ce = Reflect.has(W, H), te = Reflect.get(W, H, oe);
      if (ce && (e(te, G) || u.has(G) && e(te, u.get(G))))
        return !0;
      D(H), TP(G) && (G = zPe(G) || G);
      let Ee = G;
      if (!((me = Object.getOwnPropertyDescriptor(W, H)) != null && me.set))
        if (G instanceof Promise)
          G.then((J) => {
            G.status = "fulfilled", G.value = J, w(["resolve", [H], J]);
          }).catch((J) => {
            G.status = "rejected", G.reason = J, w(["reject", [H], J]);
          });
        else {
          !Zp.has(G) && n(G) && (Ee = VD(G));
          const J = !g0.has(Ee) && Zp.get(Ee);
          J && _(H, J);
        }
      return Reflect.set(W, H, Ee, oe), w(["set", [H], G, te]), !0;
    }
  });
  u.set(v, $);
  const U = [F, T, l, L];
  return Zp.set($, U), Reflect.ownKeys(v).forEach((W) => {
    const H = Object.getOwnPropertyDescriptor(v, W);
    H.get || H.set ? Object.defineProperty(F, W, H) : $[W] = v[W];
  }), $;
}) => [
  // public functions
  h,
  // shared state
  Zp,
  g0,
  // internal things
  e,
  t,
  n,
  o,
  a,
  l,
  u,
  f
], [jPe] = HPe();
function VD(e = {}) {
  return jPe(e);
}
function AE(e, t, n) {
  const o = Zp.get(e);
  IE && !o && console.warn("Please use proxy object");
  let a;
  const l = [], u = o[3];
  let f = !1;
  const v = u((g) => {
    if (l.push(g), n) {
      t(l.splice(0));
      return;
    }
    a || (a = Promise.resolve().then(() => {
      a = void 0, f && t(l.splice(0));
    }));
  });
  return f = !0, () => {
    f = !1, v();
  };
}
function Cf(e, t) {
  const n = Zp.get(e);
  IE && !n && console.warn("Please use proxy object");
  const [o, a, l] = n;
  return l(o, a(), t);
}
function Cg(e) {
  return g0.add(e), e;
}
function GPe(e, t) {
  Object.keys(t).forEach((a) => {
    if (Object.getOwnPropertyDescriptor(e, a))
      throw new Error("object property already defined");
    const l = t[a], { get: u, set: f } = typeof l == "function" ? { get: l } : l, h = {};
    h.get = () => u(Cf(o)), f && (h.set = (v) => f(o, v)), Object.defineProperty(e, a, h);
  });
  const o = VD(e);
  return o;
}
var WPe = (e, t) => Object.is(e, t);
function y5(e, t, n, o, a) {
  let l = Reflect.get(Cf(e), t);
  const u = a || WPe;
  function f() {
    const h = Cf(e);
    u(l, h[t]) || (n(h[t]), l = Reflect.get(h, t));
  }
  return AE(e, f, o);
}
function b5(e, t, n) {
  typeof n.value == "object" && (n.value = Hv(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function Hv(e) {
  if (typeof e != "object")
    return e;
  var t = 0, n, o, a, l = Object.prototype.toString.call(e);
  if (l === "[object Object]" ? a = Object.create(e.__proto__ || null) : l === "[object Array]" ? a = Array(e.length) : l === "[object Set]" ? (a = /* @__PURE__ */ new Set(), e.forEach(function(u) {
    a.add(Hv(u));
  })) : l === "[object Map]" ? (a = /* @__PURE__ */ new Map(), e.forEach(function(u, f) {
    a.set(Hv(f), Hv(u));
  })) : l === "[object Date]" ? a = /* @__PURE__ */ new Date(+e) : l === "[object RegExp]" ? a = new RegExp(e.source, e.flags) : l === "[object DataView]" ? a = new e.constructor(Hv(e.buffer)) : l === "[object ArrayBuffer]" ? a = e.slice(0) : l.slice(-6) === "Array]" && (a = new e.constructor(e)), a) {
    for (o = Object.getOwnPropertySymbols(e); t < o.length; t++)
      b5(a, o[t], Object.getOwnPropertyDescriptor(e, o[t]));
    for (t = 0, o = Object.getOwnPropertyNames(e); t < o.length; t++)
      Object.hasOwnProperty.call(a, n = o[t]) && a[n] === e[n] || b5(a, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return a || e;
}
var UPe = Object.defineProperty, XPe = (e, t, n) => t in e ? UPe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, vt = (e, t, n) => (XPe(e, typeof t != "symbol" ? t + "" : t, n), n);
function ZPe(e) {
  for (; e.length > 0; )
    e.pop();
  return e;
}
var S5 = (e, ...t) => (typeof e == "function" ? e(...t) : e) ?? void 0, xc = (e) => e, IP = () => {
}, YPe = (...e) => (...t) => {
  e.forEach(function(n) {
    n == null || n(...t);
  });
}, x5 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (e++, e.toString(36));
})(), JPe = () => process.env.NODE_ENV !== "production", M0 = (e) => Array.isArray(e), L0 = (e) => !(e == null || typeof e != "object" || M0(e)), QPe = (e) => typeof e == "number" && !Number.isNaN(e), ml = (e) => typeof e == "string", kE = (e) => typeof e == "function";
function RE(e) {
  if (!KPe(e) || e === void 0)
    return e;
  const t = Reflect.ownKeys(e).filter((o) => typeof o == "string"), n = {};
  for (const o of t) {
    const a = e[o];
    a !== void 0 && (n[o] = RE(a));
  }
  return n;
}
var KPe = (e) => e && typeof e == "object" && e.constructor === Object;
function AP(...e) {
  const t = e.length === 1 ? e[0] : e[1];
  (e.length === 2 ? e[0] : !0) && process.env.NODE_ENV !== "production" && console.warn(t);
}
function Aw(...e) {
  const t = e.length === 1 ? e[0] : e[1];
  if ((e.length === 2 ? e[0] : !0) && process.env.NODE_ENV !== "production")
    throw new Error(t);
}
function NU(e, ...t) {
  for (const n of t) {
    const o = RE(n);
    for (const a in o)
      L0(n[a]) ? (e[a] || (e[a] = {}), NU(e[a], n[a])) : e[a] = n[a];
  }
  return e;
}
function C5(e) {
  return Hv(e);
}
function pa(e) {
  return ml(e) ? { type: e } : e;
}
function tf(e) {
  return e ? M0(e) ? e.slice() : [e] : [];
}
function MU(e) {
  return L0(e) && e.predicate != null;
}
var qPe = () => !0;
function $D(e, t, n, o) {
  return (a) => {
    var l;
    return ml(a) ? !!((l = e[a]) != null && l.call(e, t, n, o)) : kE(a) ? a(t, n, o) : a.predicate(e)(t, n, o);
  };
}
function eOe(...e) {
  return {
    predicate: (t) => (n, o, a) => e.map($D(t, n, o, a)).some(Boolean)
  };
}
function tOe(...e) {
  return {
    predicate: (t) => (n, o, a) => e.map($D(t, n, o, a)).every(Boolean)
  };
}
function nOe(e) {
  return {
    predicate: (t) => (n, o, a) => !$D(t, n, o, a)(e)
  };
}
function rOe(...e) {
  return (t, n, o) => o.state.matches(...e);
}
var LU = { or: eOe, and: tOe, not: nOe, stateIn: rOe };
function FU(e, t) {
  return e = e ?? qPe, (n, o, a) => {
    if (ml(e)) {
      const l = t[e];
      return kE(l) ? l(n, o, a) : l;
    }
    return MU(e) ? e.predicate(t)(n, o, a) : e == null ? void 0 : e(n, o, a);
  };
}
function kP(e, t) {
  return (n, o, a) => MU(e) ? e.predicate(t)(n, o, a) : e;
}
function oOe(e) {
  const t = e.computed ?? xc({}), n = e.context ?? xc({}), o = VD({
    value: e.initial ?? "",
    previousValue: "",
    event: xc({}),
    previousEvent: xc({}),
    context: GPe(n, t),
    done: !1,
    tags: [],
    hasTag(a) {
      return this.tags.includes(a);
    },
    matches(...a) {
      return a.includes(this.value);
    },
    can(a) {
      return xc(this).nextEvents.includes(a);
    },
    get nextEvents() {
      var u, f;
      const a = ((f = (u = e.states) == null ? void 0 : u[this.value]) == null ? void 0 : f.on) ?? {}, l = (e == null ? void 0 : e.on) ?? {};
      return Object.keys({ ...a, ...l });
    },
    get changed() {
      return this.event.value === "machine.init" || !this.previousValue ? !1 : this.value !== this.previousValue;
    }
  });
  return xc(o);
}
function JC(e, t) {
  return (n, o) => {
    if (QPe(e))
      return e;
    if (kE(e))
      return e(n, o);
    if (ml(e)) {
      const a = Number.parseFloat(e);
      if (!Number.isNaN(a))
        return a;
      if (t) {
        const l = t == null ? void 0 : t[e];
        return Aw(
          l == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${e}\`. It doesn't exist in \`options.delays\``
        ), kE(l) ? l(n, o) : l;
      }
    }
  };
}
function iOe(e) {
  return ml(e) ? { target: e } : e;
}
function aOe(e, t) {
  return (n, o, a) => tf(e).map(iOe).find((l) => FU(l.guard, t)(n, o, a) ?? l.target ?? l.actions);
}
var sOe = class BU {
  // Let's get started!
  constructor(t, n) {
    var a, l, u, f, h, v;
    vt(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    ), vt(this, "state"), vt(this, "initialState"), vt(this, "initialContext"), vt(this, "id"), vt(
      this,
      "type",
      "machine"
      /* Machine */
    ), vt(this, "activityEvents", /* @__PURE__ */ new Map()), vt(this, "delayedEvents", /* @__PURE__ */ new Map()), vt(this, "stateListeners", /* @__PURE__ */ new Set()), vt(this, "contextListeners", /* @__PURE__ */ new Set()), vt(this, "eventListeners", /* @__PURE__ */ new Set()), vt(this, "doneListeners", /* @__PURE__ */ new Set()), vt(this, "contextWatchers", /* @__PURE__ */ new Set()), vt(this, "removeStateListener", IP), vt(this, "removeEventListener", IP), vt(this, "removeContextListener", IP), vt(this, "parent"), vt(this, "children", /* @__PURE__ */ new Map()), vt(this, "guardMap"), vt(this, "actionMap"), vt(this, "delayMap"), vt(this, "activityMap"), vt(this, "sync"), vt(this, "options"), vt(this, "config"), vt(this, "start", (g) => {
      if (this.state.value = "", this.status === "Running")
        return this;
      this.status = "Running", this.removeStateListener = AE(
        this.state,
        () => {
          this.stateListeners.forEach((A) => {
            A(this.stateSnapshot);
          });
        },
        this.sync
      ), this.removeEventListener = y5(
        this.state,
        "event",
        (A) => {
          this.executeActions(this.config.onEvent, A), this.eventListeners.forEach((P) => {
            P(A);
          });
        },
        this.sync
      ), this.removeContextListener = AE(
        this.state.context,
        () => {
          this.log("Context:", this.contextSnapshot), this.contextListeners.forEach((A) => {
            A(this.contextSnapshot);
          });
        },
        this.sync || this.options.debug
      ), this.setupContextWatchers(), this.executeActivities(
        pa(
          "machine.start"
          /* Start */
        ),
        tf(this.config.activities),
        "machine.start"
        /* Start */
      ), this.executeActions(this.config.entry, pa(
        "machine.start"
        /* Start */
      ));
      const b = pa(
        "machine.init"
        /* Init */
      ), S = L0(g) ? g.value : g, w = L0(g) ? g.context : void 0;
      w && this.setContext(w);
      const E = {
        target: S ?? this.config.initial
      }, T = this.getNextStateInfo(E, b);
      return this.initialState = T, this.performStateChangeEffects(this.state.value, T, b), this;
    }), vt(this, "setupContextWatchers", () => {
      var g;
      for (const [b, S] of Object.entries(this.config.watch ?? {})) {
        const w = (g = this.options.compareFns) == null ? void 0 : g[b], E = y5(
          this.state.context,
          b,
          () => {
            this.executeActions(S, this.state.event);
          },
          this.sync,
          w
        );
        this.contextWatchers.add(E);
      }
    }), vt(this, "stop", () => {
      if (this.status !== "Stopped")
        return this.performExitEffects(this.state.value, pa(
          "machine.stop"
          /* Stop */
        )), this.executeActions(this.config.exit, pa(
          "machine.stop"
          /* Stop */
        )), this.setState(""), this.setEvent(
          "machine.stop"
          /* Stop */
        ), this.stopStateListeners(), this.stopChildren(), this.stopActivities(), this.stopDelayedEvents(), this.stopContextWatchers(), this.stopEventListeners(), this.stopContextListeners(), this.status = "Stopped", this;
    }), vt(this, "stopEventListeners", () => {
      this.eventListeners.clear(), this.removeEventListener();
    }), vt(this, "stopContextListeners", () => {
      this.contextListeners.clear(), this.removeContextListener();
    }), vt(this, "stopStateListeners", () => {
      this.removeStateListener(), this.stateListeners.clear();
    }), vt(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((g) => g()), this.contextWatchers.clear();
    }), vt(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((g) => {
        g.forEach((b) => b());
      }), this.delayedEvents.clear();
    }), vt(this, "stopActivities", (g) => {
      var b, S;
      g ? ((b = this.activityEvents.get(g)) == null || b.forEach((w) => w()), (S = this.activityEvents.get(g)) == null || S.clear(), this.activityEvents.delete(g)) : (this.activityEvents.forEach((w) => {
        w.forEach((E) => E()), w.clear();
      }), this.activityEvents.clear());
    }), vt(this, "sendChild", (g, b) => {
      const S = pa(g), w = S5(b, this.contextSnapshot), E = this.children.get(w);
      E || Aw(`[@zag-js/core] Cannot send '${S.type}' event to unknown child`), E.send(S);
    }), vt(this, "stopChild", (g) => {
      this.children.has(g) || Aw(`[@zag-js/core > stop-child] Cannot stop unknown child ${g}`), this.children.get(g).stop(), this.children.delete(g);
    }), vt(this, "removeChild", (g) => {
      this.children.delete(g);
    }), vt(this, "stopChildren", () => {
      this.children.forEach((g) => g.stop()), this.children.clear();
    }), vt(this, "setParent", (g) => {
      this.parent = g;
    }), vt(this, "spawn", (g, b) => {
      const S = S5(g);
      return b && (S.id = b), S.type = "machine.actor", S.setParent(this), this.children.set(S.id, xc(S)), S.onDone(() => {
        this.removeChild(S.id);
      }).start(), xc(Cg(S));
    }), vt(this, "stopActivity", (g) => {
      var S;
      if (!this.state.value)
        return;
      const b = this.activityEvents.get(this.state.value);
      (S = b == null ? void 0 : b.get(g)) == null || S(), b == null || b.delete(g);
    }), vt(this, "addActivityCleanup", (g, b, S) => {
      var w;
      g && (this.activityEvents.has(g) ? (w = this.activityEvents.get(g)) == null || w.set(b, S) : this.activityEvents.set(g, /* @__PURE__ */ new Map([[b, S]])));
    }), vt(this, "setState", (g) => {
      this.state.previousValue = this.state.value, this.state.value = g;
      const b = this.getStateNode(g);
      g == null ? ZPe(this.state.tags) : this.state.tags = tf(b == null ? void 0 : b.tags);
    }), vt(this, "transformContext", (g) => {
      var b, S;
      return (S = (b = this.options) == null ? void 0 : b.transformContext) == null || S.call(b, g), g;
    }), vt(this, "setContext", (g) => {
      g && NU(this.state.context, this.transformContext(g));
    }), vt(this, "withContext", (g) => {
      const b = this.transformContext(g), S = { ...this.config.context, ...RE(b) };
      return new BU({ ...this.config, context: S }, this.options);
    }), vt(this, "setOptions", (g) => {
      const b = RE(g);
      this.actionMap = { ...this.actionMap, ...b.actions }, this.delayMap = { ...this.delayMap, ...b.delays }, this.activityMap = { ...this.activityMap, ...b.activities }, this.guardMap = { ...this.guardMap, ...b.guards };
    }), vt(this, "getStateNode", (g) => {
      var b;
      if (g)
        return (b = this.config.states) == null ? void 0 : b[g];
    }), vt(this, "getNextStateInfo", (g, b) => {
      const S = this.determineTransition(g, b), w = !(S != null && S.target), E = (S == null ? void 0 : S.target) ?? this.state.value, T = this.state.value !== E, A = this.getStateNode(E), _ = {
        reenter: !w && !T && !(S != null && S.internal),
        transition: S,
        stateNode: A,
        target: E,
        changed: T
      };
      return this.log("NextState:", `[${b.type}]`, this.state.value, "---->", _.target), _;
    }), vt(this, "getActionFromDelayedTransition", (g) => {
      const b = pa(
        "machine.after"
        /* After */
      ), w = JC(g.delay, this.delayMap)(this.contextSnapshot, b);
      let E;
      return {
        entry: () => {
          E = globalThis.setTimeout(() => {
            const T = this.getNextStateInfo(g, b);
            this.performStateChangeEffects(this.state.value, T, b);
          }, w);
        },
        exit: () => {
          globalThis.clearTimeout(E);
        }
      };
    }), vt(this, "getDelayedEventActions", (g) => {
      const b = this.getStateNode(g), S = pa(
        "machine.after"
        /* After */
      );
      if (!b || !b.after)
        return;
      const w = [], E = [];
      if (M0(b.after)) {
        const T = this.determineTransition(b.after, S);
        if (!T)
          return;
        const A = this.getActionFromDelayedTransition(T);
        w.push(A.entry), E.push(A.exit);
      } else if (L0(b.after))
        for (const T in b.after) {
          const A = b.after[T];
          let P = {};
          if (M0(A)) {
            const D = this.determineTransition(A, S);
            D && (P = D);
          } else
            ml(A) ? P = { target: A, delay: T } : P = { ...A, delay: T };
          const _ = this.getActionFromDelayedTransition(P);
          w.push(_.entry), E.push(_.exit);
        }
      return { entries: w, exits: E };
    }), vt(this, "executeActions", (g, b) => {
      var w;
      const S = kP(g, this.guardMap)(this.contextSnapshot, b, this.guardMeta);
      for (const E of tf(S)) {
        const T = ml(E) ? (w = this.actionMap) == null ? void 0 : w[E] : E;
        AP(
          ml(E) && !T,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${E}\``
        ), T == null || T(this.state.context, b, this.meta);
      }
    }), vt(this, "executeActivities", (g, b, S) => {
      var w;
      for (const E of b) {
        const T = ml(E) ? (w = this.activityMap) == null ? void 0 : w[E] : E;
        if (!T) {
          AP(`[@zag-js/core > execute-activity] No implementation found for activity: \`${E}\``);
          continue;
        }
        const A = T(this.state.context, g, this.meta);
        if (A) {
          const P = ml(E) ? E : E.name || x5();
          this.addActivityCleanup(S ?? this.state.value, P, A);
        }
      }
    }), vt(this, "createEveryActivities", (g, b) => {
      if (!g)
        return;
      const S = pa(
        "machine.every"
        /* Every */
      );
      if (M0(g)) {
        const w = tf(g).find((P) => {
          const _ = P.delay, L = JC(_, this.delayMap)(this.contextSnapshot, S);
          return FU(P.guard, this.guardMap)(this.contextSnapshot, S, this.guardMeta) ?? L != null;
        });
        if (!w)
          return;
        const T = JC(w.delay, this.delayMap)(this.contextSnapshot, S);
        b(() => {
          const P = globalThis.setInterval(() => {
            this.executeActions(w.actions, S);
          }, T);
          return () => {
            globalThis.clearInterval(P);
          };
        });
      } else
        for (const w in g) {
          const E = g == null ? void 0 : g[w], A = JC(w, this.delayMap)(this.contextSnapshot, S);
          b(() => {
            const _ = globalThis.setInterval(() => {
              this.executeActions(E, S);
            }, A);
            return () => {
              globalThis.clearInterval(_);
            };
          });
        }
    }), vt(this, "setEvent", (g) => {
      this.state.previousEvent = this.state.event, this.state.event = Cg(pa(g));
    }), vt(this, "performExitEffects", (g, b) => {
      const S = this.state.value;
      if (S === "")
        return;
      const w = g ? this.getStateNode(g) : void 0;
      this.stopActivities(S);
      const E = kP(w == null ? void 0 : w.exit, this.guardMap)(this.contextSnapshot, b, this.guardMeta), T = tf(E), A = this.delayedEvents.get(S);
      A && T.push(...A), this.executeActions(T, b), this.eventListeners.clear();
    }), vt(this, "performEntryEffects", (g, b) => {
      const S = this.getStateNode(g), w = tf(S == null ? void 0 : S.activities);
      this.createEveryActivities(S == null ? void 0 : S.every, (P) => {
        w.unshift(P);
      }), w.length > 0 && this.executeActivities(b, w);
      const E = kP(S == null ? void 0 : S.entry, this.guardMap)(
        this.contextSnapshot,
        b,
        this.guardMeta
      ), T = tf(E), A = this.getDelayedEventActions(g);
      S != null && S.after && A && (this.delayedEvents.set(g, A == null ? void 0 : A.exits), T.push(...A.entries)), this.executeActions(T, b), (S == null ? void 0 : S.type) === "final" && (this.state.done = !0, this.doneListeners.forEach((P) => {
        P(this.stateSnapshot);
      }), this.stop());
    }), vt(this, "performTransitionEffects", (g, b) => {
      const S = this.determineTransition(g, b);
      this.executeActions(S == null ? void 0 : S.actions, b);
    }), vt(this, "performStateChangeEffects", (g, b, S) => {
      this.setEvent(S);
      const w = b.changed || b.reenter;
      w && this.performExitEffects(g, S), this.performTransitionEffects(b.transition, S), this.setState(b.target), w && this.performEntryEffects(b.target, S);
    }), vt(this, "determineTransition", (g, b) => {
      const S = aOe(g, this.guardMap);
      return S == null ? void 0 : S(this.contextSnapshot, b, this.guardMeta);
    }), vt(this, "sendParent", (g) => {
      var S;
      this.parent || Aw("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      const b = pa(g);
      (S = this.parent) == null || S.send(b);
    }), vt(this, "log", (...g) => {
      JPe() && this.options.debug && console.log(...g);
    }), vt(this, "send", (g) => {
      const b = pa(g);
      this.transition(this.state.value, b);
    }), vt(this, "transition", (g, b) => {
      var A, P;
      const S = ml(g) ? this.getStateNode(g) : g == null ? void 0 : g.stateNode, w = pa(b);
      if (!S && !this.config.on) {
        const _ = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${g}, \`event\`: ${w.type}`;
        AP(_);
        return;
      }
      const E = ((A = S == null ? void 0 : S.on) == null ? void 0 : A[w.type]) ?? ((P = this.config.on) == null ? void 0 : P[w.type]), T = this.getNextStateInfo(E, w);
      return this.performStateChangeEffects(this.state.value, T, w), T.stateNode;
    }), vt(this, "subscribe", (g) => (this.stateListeners.add(g), this.status === "Running" && g(this.stateSnapshot), () => {
      this.stateListeners.delete(g);
    })), vt(this, "onDone", (g) => (this.doneListeners.add(g), this)), vt(this, "onTransition", (g) => (this.stateListeners.add(g), this.status === "Running" && g(this.stateSnapshot), this)), vt(this, "onChange", (g) => (this.contextListeners.add(g), this)), vt(this, "onEvent", (g) => (this.eventListeners.add(g), this)), this.config = C5(t), this.options = C5(n ?? {}), this.id = this.config.id ?? `machine-${x5()}`, this.guardMap = ((a = this.options) == null ? void 0 : a.guards) ?? {}, this.actionMap = ((l = this.options) == null ? void 0 : l.actions) ?? {}, this.delayMap = ((u = this.options) == null ? void 0 : u.delays) ?? {}, this.activityMap = ((f = this.options) == null ? void 0 : f.activities) ?? {}, this.sync = ((h = this.options) == null ? void 0 : h.sync) ?? !1, this.state = oOe(this.config), this.initialContext = Cf(this.state.context), this.transformContext(this.state.context);
    const o = pa(
      "machine.created"
      /* Created */
    );
    this.executeActions((v = this.config) == null ? void 0 : v.created, o);
  }
  // immutable state value
  get stateSnapshot() {
    return xc(Cf(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const t = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return t.stateSnapshot;
      },
      get initialContext() {
        return t.initialContext;
      },
      get initialState() {
        var n;
        return ((n = t.initialState) == null ? void 0 : n.target) ?? "";
      }
    };
  }
  get meta() {
    var t;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((t = this.initialState) == null ? void 0 : t.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (n) => this.actionMap[n],
      getGuard: (n) => this.guardMap[n]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
}, VU = (e, t) => new sOe(e, t), lOe = (...e) => e.map((t) => {
  var n;
  return (n = t == null ? void 0 : t.trim) == null ? void 0 : n.call(t);
}).filter(Boolean).join(" "), uOe = /^on[A-Z]/;
function ji(...e) {
  let t = {};
  for (let n of e) {
    for (let o in t) {
      if (uOe.test(o) && typeof t[o] == "function" && typeof n[o] == "function") {
        t[o] = YPe(t[o], n[o]);
        continue;
      }
      if (o === "className" || o === "class") {
        t[o] = lOe(t[o], n[o]);
        continue;
      }
      if (o === "style") {
        t[o] = Object.assign({}, t[o] ?? {}, n[o] ?? {});
        continue;
      }
      t[o] = n[o] !== void 0 ? n[o] : t[o];
    }
    for (let o in n)
      t[o] === void 0 && (t[o] = n[o]);
  }
  return t;
}
function cOe(e) {
  return new Proxy({}, {
    get() {
      return e;
    }
  });
}
var dOe = cOe((e) => e), fOe = typeof document < "u" ? ph : dt, w5 = (e) => (e == null ? void 0 : e.constructor.name) === "Array", $U = (e, t) => {
  if (Object.is(e, t))
    return !0;
  if (e == null && t != null || e != null && t == null)
    return !1;
  if (typeof (e == null ? void 0 : e.isEqual) == "function" && typeof (t == null ? void 0 : t.isEqual) == "function")
    return e.isEqual(t);
  if (typeof e == "function" && typeof t == "function")
    return e.toString() === t.toString();
  if (w5(e) && w5(t))
    return Array.from(e).toString() === Array.from(t).toString();
  if (typeof e != "object" || typeof t != "object")
    return !1;
  const n = Object.keys(t ?? /* @__PURE__ */ Object.create(null)), o = n.length;
  for (let a = 0; a < o; a++)
    if (!Reflect.has(e, n[a]))
      return !1;
  for (let a = 0; a < o; a++) {
    const l = n[a];
    if (!$U(e[l], t[l]))
      return !1;
  }
  return !0;
};
function zU(e) {
  if (!pOe(e) || e === void 0)
    return e;
  const t = Reflect.ownKeys(e).filter((o) => typeof o == "string"), n = {};
  for (const o of t) {
    const a = e[o];
    a !== void 0 && (n[o] = zU(a));
  }
  return n;
}
var pOe = (e) => e && typeof e == "object" && e.constructor === Object;
function hOe(e, t) {
  const n = Ue(!1), o = Ue(!1);
  dt(() => {
    if (n.current && o.current)
      return e();
    o.current = !0;
  }, t), dt(() => (n.current = !0, () => {
    n.current = !1;
  }), []);
}
var { use: E5 } = Tt, mOe = /* @__PURE__ */ new WeakMap();
function vOe(e, t) {
  const { actions: n, context: o, sync: a } = t ?? {}, l = Ue(), u = Ue(), f = x_(
    re((b) => AE(e.state, b, a), [a]),
    () => {
      const b = Cf(e.state, E5);
      try {
        if (l.current && u.current && !DU(l.current, b, u.current, /* @__PURE__ */ new WeakMap()))
          return l.current;
      } catch {
      }
      return b;
    },
    () => Cf(e.state, E5)
  );
  e.setOptions({ actions: n });
  const h = gt(() => zU(o ?? {}), [o]);
  hOe(() => {
    Object.entries(h).map(([E, T]) => ({
      key: E,
      curr: T,
      prev: f.context[E],
      equal: $U(f.context[E], T)
    })).every(({ equal: E }) => E) || e.setContext(h);
  }, [h]);
  const v = /* @__PURE__ */ new WeakMap();
  dt(() => {
    l.current = f, u.current = v;
  });
  const g = gt(() => /* @__PURE__ */ new WeakMap(), []);
  return _U(f, v, g, mOe);
}
function gOe(e) {
  const t = Ue();
  return t.current || (t.current = { v: e() }), t.current.v;
}
function yOe(e, t) {
  const { state: n, context: o } = t ?? {}, a = gOe(() => {
    const l = typeof e == "function" ? e() : e;
    return o ? l.withContext(o) : l;
  });
  return fOe(() => (a.start(n), () => {
    a.stop();
  }), []), a;
}
function HU(e, t) {
  const n = yOe(e, t);
  return [vOe(n, t), n.send, n];
}
const Dg = () => (e, t) => t.reduce(
  (n, o) => {
    const [a, l] = n, u = o;
    return l[u] !== void 0 && (a[u] = l[u]), delete l[u], [a, l];
  },
  [{}, { ...e }]
);
function bOe(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function jU(...e) {
  return (t) => e.forEach((n) => bOe(n, t));
}
const RP = (e) => {
  const t = fr((n, o) => {
    const { asChild: a, children: l, ...u } = n;
    if (!a)
      return S_(e, { ...u, ref: o }, l);
    const f = Gc.only(l);
    return hh(f) ? ya(f, {
      ...ji(u, f.props),
      ref: o ? jU(o, f.ref) : f.ref
    }) : null;
  });
  return t.displayName = e.displayName || e.name, t;
}, SOe = () => {
  const e = /* @__PURE__ */ new Map();
  return new Proxy(RP, {
    apply(t, n, o) {
      return RP(o[0]);
    },
    get(t, n) {
      const o = n;
      return e.has(o) || e.set(o, RP(o)), e.get(o);
    }
  });
}, Ta = SOe();
function xOe(e) {
  return Dg()(e, [
    "lazyMount",
    "onExitComplete",
    "present",
    "unmountOnExit"
  ]);
}
function COe(e, t, n) {
  return {
    isPresent: e.matches("mounted", "unmountSuspended"),
    setNode(o) {
      o && t({ type: "NODE.SET", node: o });
    }
  };
}
var { and: wOe, or: EOe } = LU;
function n0(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function TOe(e) {
  const t = e.present ? "mounted" : "unmounted";
  return VU(
    {
      initial: t,
      watch: {
        present: ["raisePresenceChange", "setPrevPresent"]
      },
      context: {
        node: null,
        styles: null,
        prevAnimationName: "",
        present: !1,
        ...e
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        },
        "PRESENCE.CHANGED": [
          {
            guard: "isPresent",
            target: "mounted",
            actions: ["setPrevAnimationName"]
          },
          {
            guard: EOe("isAnimationNone", "isDisplayNone"),
            target: "unmounted"
          },
          {
            guard: wOe("wasPresent", "isAnimating"),
            target: "unmountSuspended"
          },
          { target: "unmounted" }
        ]
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: "unmounted",
            "ANIMATION.OUT": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            "ANIMATION.END": "unmounted"
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName", "invokeOnExitComplete"],
          on: {
            MOUNT: "mounted"
          }
        }
      }
    },
    {
      guards: {
        isPresent: (n) => !!n.present,
        isAnimationNone: (n) => n0(n.styles) === "none",
        isDisplayNone: (n) => {
          var o;
          return ((o = n.styles) == null ? void 0 : o.display) === "none";
        },
        wasPresent: (n) => !!n.prevPresent,
        isAnimating: (n) => n.prevAnimationName !== n0(n.styles)
      },
      actions: {
        invokeOnExitComplete(n) {
          var o;
          (o = n.onExitComplete) == null || o.call(n);
        },
        setNode(n, o) {
          n.node = Cg(o.node);
        },
        setStyles(n, o) {
          const a = o.node.ownerDocument.defaultView || window;
          n.styles = Cg(a.getComputedStyle(o.node));
        },
        raisePresenceChange(n, o, { send: a }) {
          a("PRESENCE.CHANGED");
        },
        setPrevPresent(n) {
          n.prevPresent = n.present;
        },
        setPrevAnimationName(n) {
          requestAnimationFrame(() => {
            n.prevAnimationName = n0(n.styles);
          });
        },
        clearPrevAnimationName(n) {
          n.prevAnimationName = "";
        }
      },
      activities: {
        trackAnimationEvents(n, o, { send: a }) {
          const l = n.node;
          if (!l)
            return;
          const u = (h) => {
            h.target === l && (n.prevAnimationName = n0(n.styles));
          }, f = (h) => {
            const g = n0(n.styles).includes(h.animationName);
            h.target === l && g && a("ANIMATION.END");
          };
          return l.addEventListener("animationstart", u), l.addEventListener("animationcancel", f), l.addEventListener("animationend", f), () => {
            l.removeEventListener("animationstart", u), l.removeEventListener("animationcancel", f), l.removeEventListener("animationend", f);
          };
        }
      }
    }
  );
}
function kw(e, t = {}) {
  const { sync: n = !1 } = t, o = IOe(e);
  return re(
    (...a) => {
      var l;
      return n ? queueMicrotask(() => {
        var u;
        return (u = o.current) == null ? void 0 : u.call(o, ...a);
      }) : (l = o.current) == null ? void 0 : l.call(o, ...a);
    },
    [n, o]
  );
}
function IOe(e) {
  const t = Ue(e);
  return t.current = e, t;
}
const AOe = (e) => {
  const { lazyMount: t, unmountOnExit: n, ...o } = e, a = Ue(!1), l = {
    ...o,
    onExitComplete: kw(e.onExitComplete)
  }, [u, f] = HU(TOe(l), { context: l }), h = COe(u, f);
  h.isPresent && (a.current = !0);
  const v = !h.isPresent && !a.current && t || n && !h.isPresent && a.current;
  return {
    getPresenceProps: (b) => ({
      ref: jU(h.setNode, b),
      "data-state": e.present ? "open" : "closed",
      hidden: !h.isPresent
    }),
    isPresent: h.isPresent,
    isUnmounted: v
  };
};
function kOe(e, t) {
  return `${e} returned \`undefined\`. Seems you forgot to wrap component within ${t}`;
}
function MT(e = {}) {
  const {
    name: t,
    strict: n = !0,
    hookName: o = "useContext",
    providerName: a = "Provider",
    errorMessage: l
  } = e, u = wa(void 0);
  u.displayName = t;
  function f() {
    var v;
    const h = dr(u);
    if (!h && n) {
      const g = new Error(l ?? kOe(o, a));
      throw g.name = "ContextError", (v = Error.captureStackTrace) == null || v.call(Error, g, f), g;
    }
    return h;
  }
  return [u.Provider, f, u];
}
const [ROe, GU] = MT({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});
var Rw = (e, t = []) => ({
  parts: (...n) => {
    if (POe(t))
      return Rw(e, n);
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...n) => Rw(e, [...t, ...n]),
  rename: (n) => Rw(n, t),
  keys: () => t,
  build: () => [...new Set(t)].reduce(
    (n, o) => Object.assign(n, {
      [o]: {
        selector: [
          `&[data-scope="${kv(e)}"][data-part="${kv(o)}"]`,
          `& [data-scope="${kv(e)}"][data-part="${kv(o)}"]`
        ].join(", "),
        attrs: { "data-scope": kv(e), "data-part": kv(o) }
      }
    }),
    {}
  )
}), kv = (e) => e.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase(), POe = (e) => e.length === 0, qo = (e) => e ? "" : void 0, OOe = (e) => e ? "true" : void 0, jc = (e) => typeof e == "object" && (e == null ? void 0 : e.nodeType) === Node.ELEMENT_NODE && typeof (e == null ? void 0 : e.nodeName) == "string";
function oS(e, t) {
  return !e || !t || !jc(e) || !jc(t) ? !1 : e === t || e.contains(t);
}
var _Oe = (e) => oS(e.currentTarget, e.target), DOe = (e) => e.nodeType === Node.DOCUMENT_NODE ? e : e.ownerDocument ?? document;
function NOe(e) {
  const t = {
    getRootNode: (n) => {
      var o;
      return ((o = n.getRootNode) == null ? void 0 : o.call(n)) ?? document;
    },
    getDoc: (n) => DOe(t.getRootNode(n)),
    getWin: (n) => t.getDoc(n).defaultView ?? window,
    getActiveElement: (n) => t.getDoc(n).activeElement,
    isActiveElement: (n, o) => o === t.getActiveElement(n),
    focus(n, o) {
      o != null && (t.isActiveElement(n, o) || o.focus({ preventScroll: !0 }));
    },
    getById: (n, o) => t.getRootNode(n).getElementById(o),
    setValue: (n, o) => {
      if (n == null || o == null)
        return;
      const a = o.toString();
      n.value !== a && (n.value = o.toString());
    }
  };
  return { ...t, ...e };
}
var WU = (e) => e.nodeType === Node.DOCUMENT_NODE, MOe = (e) => e.nodeType !== void 0, LOe = (e) => e && MOe(e) && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in e;
function zD(e) {
  return WU(e) ? e : (e == null ? void 0 : e.ownerDocument) ?? document;
}
function HD(e) {
  var t;
  return LOe(e) ? HD(e.host) : WU(e) ? e.defaultView ?? window : jc(e) ? ((t = e.ownerDocument) == null ? void 0 : t.defaultView) ?? window : window;
}
function FOe(e, t) {
  return e.find((n) => n.id === t);
}
function BOe(e, t) {
  const n = FOe(e, t);
  return n ? e.indexOf(n) : -1;
}
var VOe = (e) => e.dataset.valuetext ?? e.textContent ?? "", $Oe = (e, t) => e.trim().toLowerCase().startsWith(t.toLowerCase()), zOe = (e, t) => e.map((n, o) => e[(Math.max(t, 0) + o) % e.length]);
function HOe(e, t, n) {
  const o = n ? BOe(e, n) : -1;
  let a = n ? zOe(e, o) : e;
  return t.length === 1 && (a = a.filter((u) => u.id !== n)), a.find((u) => $Oe(VOe(u), t));
}
function jOe(e, t) {
  const { state: n, activeId: o, key: a, timeout: l = 350 } = t, u = n.keysSoFar + a, h = u.length > 1 && Array.from(u).every((w) => w === u[0]) ? u[0] : u;
  let v = e.slice();
  const g = HOe(v, h, o);
  function b() {
    clearTimeout(n.timer), n.timer = -1;
  }
  function S(w) {
    n.keysSoFar = w, b(), w !== "" && (n.timer = +setTimeout(() => {
      S(""), b();
    }, l));
  }
  return S(u), g;
}
var g_ = /* @__PURE__ */ Object.assign(jOe, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: GOe
});
function GOe(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function PE(e) {
  var t;
  return ((t = e.composedPath) == null ? void 0 : t.call(e)[0]) ?? e.target;
}
function WOe(e) {
  if (e == null || !jc(e))
    return !1;
  try {
    const t = e.ownerDocument.defaultView || window;
    return e instanceof t.HTMLInputElement && e.selectionStart != null || /(textarea|select)/.test(e.localName) || e.isContentEditable;
  } catch {
    return !1;
  }
}
function sf(e) {
  const t = globalThis.requestAnimationFrame(e);
  return () => {
    globalThis.cancelAnimationFrame(t);
  };
}
var y_ = (e, t, n, o) => {
  const a = typeof e == "function" ? e() : e;
  return a == null || a.addEventListener(t, n, o), () => {
    a == null || a.removeEventListener(t, n, o);
  };
}, UOe = (e) => e.button === 2 || XOe() && e.ctrlKey && e.button === 0, XOe = () => /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
function T5(e, t, n) {
  if (!e)
    return;
  const o = e.ownerDocument.defaultView || window, a = new o.CustomEvent(t, n);
  return e.dispatchEvent(a);
}
var ZOe = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
}, I5 = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function A5(e, t = {}) {
  const { dir: n = "ltr", orientation: o = "horizontal" } = t;
  let { key: a } = e;
  return a = ZOe[a] ?? a, n === "rtl" && o === "horizontal" && a in I5 && (a = I5[a]), a;
}
var YOe = (e, t) => e.indexOf(t) !== -1, JOe = (e, ...t) => e.concat(t), QOe = (e, t) => e.filter((n) => n !== t), KOe = (e, t) => YOe(e, t) ? QOe(e, t) : JOe(e, t), k5 = (e) => (e == null ? void 0 : e.constructor.name) === "Array", Pw = (e, t) => {
  if (Object.is(e, t))
    return !0;
  if (e == null && t != null || e != null && t == null)
    return !1;
  if (typeof (e == null ? void 0 : e.isEqual) == "function" && typeof (t == null ? void 0 : t.isEqual) == "function")
    return e.isEqual(t);
  if (typeof e == "function" && typeof t == "function")
    return e.toString() === t.toString();
  if (k5(e) && k5(t))
    return Array.from(e).toString() === Array.from(t).toString();
  if (typeof e != "object" || typeof t != "object")
    return !1;
  const n = Object.keys(t ?? /* @__PURE__ */ Object.create(null)), o = n.length;
  for (let a = 0; a < o; a++)
    if (!Reflect.has(e, n[a]))
      return !1;
  for (let a = 0; a < o; a++) {
    const l = n[a];
    if (!Pw(e[l], t[l]))
      return !1;
  }
  return !0;
}, qOe = (e, ...t) => (typeof e == "function" ? e(...t) : e) ?? void 0, F0 = (...e) => (...t) => {
  e.forEach(function(n) {
    n == null || n(...t);
  });
}, e_e = (e) => e == null;
function jD(e) {
  if (!t_e(e) || e === void 0)
    return e;
  const t = Reflect.ownKeys(e).filter((o) => typeof o == "string"), n = {};
  for (const o of t) {
    const a = e[o];
    a !== void 0 && (n[o] = jD(a));
  }
  return n;
}
var t_e = (e) => e && typeof e == "object" && e.constructor === Object;
function n_e(...e) {
  const t = e.length === 1 ? e[0] : e[1];
  (e.length === 2 ? e[0] : !0) && process.env.NODE_ENV !== "production" && console.warn(t);
}
const r_e = (e) => typeof e == "function", UU = (e, ...t) => r_e(e) ? e(...t) : e, [CDe, XU] = MT({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: !1
});
function ZU(e, t, n) {
  if (!e)
    return;
  const o = e.ownerDocument.defaultView || window, a = new o.MutationObserver((l) => {
    for (const u of l)
      u.type === "attributes" && u.attributeName && t.includes(u.attributeName) && n(u);
  });
  return a.observe(e, { attributes: !0, attributeFilter: t }), () => a.disconnect();
}
var o_e = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}, i_e = (e) => e.ownerDocument.defaultView || window;
function a_e(e, t) {
  const { type: n = "HTMLInputElement", property: o = "value" } = t, a = i_e(e)[n].prototype;
  return Object.getOwnPropertyDescriptor(a, o) ?? {};
}
function s_e(e, t, n = {}) {
  var a;
  (a = a_e(e, n).set) == null || a.call(e, t);
}
function l_e(e) {
  return u_e(e) ? e.form : e.closest("form");
}
function u_e(e) {
  return e.matches("textarea, input, select, button");
}
function c_e(e, t) {
  if (!e)
    return;
  const n = l_e(e);
  return n == null || n.addEventListener("reset", t, { passive: !0 }), () => {
    n == null || n.removeEventListener("reset", t);
  };
}
function d_e(e, t) {
  const n = e == null ? void 0 : e.closest("fieldset");
  if (n)
    return t(n.disabled), ZU(n, ["disabled"], () => t(n.disabled));
}
function f_e(e, t) {
  if (!e)
    return;
  const { onFieldsetDisabledChange: n, onFormReset: o } = t, a = [c_e(e, o), d_e(e, n)];
  return () => {
    a.forEach((l) => l == null ? void 0 : l());
  };
}
var b_, Wp = /* @__PURE__ */ new Map(), p_e = (e) => e.getBoundingClientRect();
function R5(e, t) {
  const { scope: n = "rect", getRect: o = p_e, onChange: a } = t, l = h_e({ scope: n, getRect: o }), u = Wp.get(e);
  return u ? (u.callbacks.push(a), a(o(e))) : (Wp.set(e, {
    rect: {},
    callbacks: [a]
  }), Wp.size === 1 && (b_ = requestAnimationFrame(l))), function() {
    const h = Wp.get(e);
    if (!h)
      return;
    const v = h.callbacks.indexOf(a);
    v > -1 && h.callbacks.splice(v, 1), h.callbacks.length === 0 && (Wp.delete(e), Wp.size === 0 && cancelAnimationFrame(b_));
  };
}
function h_e(e) {
  const { scope: t, getRect: n } = e, o = v_e(t);
  return function a() {
    const l = [];
    Wp.forEach((u, f) => {
      const h = n(f);
      o(u.rect, h) || (u.rect = h, l.push(u));
    }), l.forEach((u) => {
      u.callbacks.forEach((f) => f(u.rect));
    }), b_ = requestAnimationFrame(a);
  };
}
var YU = (e, t) => e.width === t.width && e.height === t.height, JU = (e, t) => e.top === t.top && e.left === t.left, m_e = (e, t) => YU(e, t) && JU(e, t);
function v_e(e) {
  return e === "size" ? YU : e === "position" ? JU : m_e;
}
var P5 = (e, t, n, o) => (e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o));
function g_e(e) {
  const t = typeof e == "boolean";
  return {
    ancestorResize: t ? e : e.ancestorResize ?? !0,
    ancestorScroll: t ? e : e.ancestorScroll ?? !0,
    referenceResize: t ? e : e.referenceResize ?? !0
  };
}
function y_e(e, t, n, o = !1) {
  const { ancestorScroll: a, ancestorResize: l, referenceResize: u } = g_e(o), f = a || l, h = [];
  f && jc(e) && h.push(...gg(e));
  function v() {
    let b = [R5(t, { scope: "size", onChange: n })];
    return u && jc(e) && b.push(R5(e, { onChange: n })), b.push(F0(...h.map((S) => P5(S, "resize", n)))), () => b.forEach((S) => S());
  }
  function g() {
    return F0(...h.map((b) => P5(b, "scroll", n, { passive: !0 })));
  }
  return F0(v(), g());
}
function O5(e = 0, t = 0, n = 0, o = 0) {
  if (typeof DOMRect == "function")
    return new DOMRect(e, t, n, o);
  const a = {
    x: e,
    y: t,
    width: n,
    height: o,
    top: t,
    right: e + n,
    bottom: t + o,
    left: e
  };
  return { ...a, toJSON: () => a };
}
function b_e(e) {
  if (!e)
    return O5();
  const { x: t, y: n, width: o, height: a } = e;
  return O5(t, n, o, a);
}
function S_e(e, t) {
  return {
    contextElement: jc(e) ? e : void 0,
    getBoundingClientRect: () => {
      const n = e, o = t == null ? void 0 : t(n);
      return o || !n ? b_e(o) : n.getBoundingClientRect();
    }
  };
}
var r0 = (e) => ({ variable: e, reference: `var(${e})` }), Sc = {
  arrowSize: r0("--arrow-size"),
  arrowSizeHalf: r0("--arrow-size-half"),
  arrowBg: r0("--arrow-background"),
  transformOrigin: r0("--transform-origin"),
  arrowOffset: r0("--arrow-offset")
}, x_e = (e) => ({
  top: "bottom center",
  "top-start": e ? `${e.x}px bottom` : "left bottom",
  "top-end": e ? `${e.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": e ? `${e.x}px top` : "top left",
  "bottom-end": e ? `${e.x}px top` : "top right",
  left: "right center",
  "left-start": e ? `right ${e.y}px` : "right top",
  "left-end": e ? `right ${e.y}px` : "right bottom",
  right: "left center",
  "right-start": e ? `left ${e.y}px` : "left top",
  "right-end": e ? `left ${e.y}px` : "left bottom"
}), C_e = {
  name: "transformOrigin",
  fn({ placement: e, elements: t, middlewareData: n }) {
    const { arrow: o } = n, a = x_e(o)[e], { floating: l } = t;
    return l.style.setProperty(Sc.transformOrigin.variable, a), {
      data: { transformOrigin: a }
    };
  }
}, w_e = (e) => {
  if (e)
    return {
      name: "shiftArrow",
      fn({ placement: t, middlewareData: n }) {
        if (!n.arrow)
          return {};
        const { x: o, y: a } = n.arrow, l = t.split("-")[0];
        return Object.assign(e.style, {
          left: o != null ? `${o}px` : "",
          top: a != null ? `${a}px` : "",
          [l]: `calc(100% + ${Sc.arrowOffset.reference})`
        }), {};
      }
    };
};
function E_e(e) {
  const [t, n] = e.split("-");
  return { side: t, align: n, hasAlign: n != null };
}
var T_e = {
  strategy: "absolute",
  placement: "bottom",
  listeners: !0,
  gutter: 8,
  flip: !0,
  slide: !0,
  overlap: !1,
  sameWidth: !1,
  fitViewport: !1,
  overflowPadding: 8,
  arrowPadding: 4
};
function _5(e, t) {
  const n = e.devicePixelRatio || 1;
  return Math.round(t * n) / n;
}
function QU(e) {
  return qOe(e.boundary);
}
function I_e(e, t) {
  if (e)
    return zwe({
      element: e,
      padding: t.arrowPadding
    });
}
function A_e(e, t) {
  if (!e_e(t.offset ?? t.gutter))
    return gwe(({ placement: n }) => {
      var f;
      const o = ((e == null ? void 0 : e.clientHeight) || 0) / 2, a = ((f = t.offset) == null ? void 0 : f.mainAxis) ?? t.gutter, l = typeof a == "number" ? a + o : a ?? o, { hasAlign: u } = E_e(n);
      return jD({
        crossAxis: u ? t.shift : void 0,
        mainAxis: l,
        alignmentAxis: t.shift
      });
    });
}
function k_e(e) {
  if (e.flip)
    return Vwe({
      boundary: QU(e),
      padding: e.overflowPadding,
      fallbackPlacements: e.flip === !0 ? void 0 : e.flip
    });
}
function R_e(e) {
  if (!(!e.slide && !e.overlap))
    return Bwe({
      boundary: QU(e),
      mainAxis: e.slide,
      crossAxis: e.overlap,
      padding: e.overflowPadding
    });
}
function P_e(e) {
  return $we({
    padding: e.overflowPadding,
    apply({ elements: t, rects: n, availableHeight: o, availableWidth: a }) {
      const l = t.floating, u = Math.round(n.reference.width);
      a = Math.floor(a), o = Math.floor(o), l.style.setProperty("--reference-width", `${u}px`), l.style.setProperty("--available-width", `${a}px`), l.style.setProperty("--available-height", `${o}px`);
    }
  });
}
function O_e(e, t, n = {}) {
  const o = S_e(e, n.getAnchorRect);
  if (!t || !o)
    return;
  const a = Object.assign({}, T_e, n), l = t.querySelector("[data-part=arrow]"), u = [
    A_e(l, a),
    k_e(a),
    R_e(a),
    I_e(l, a),
    w_e(l),
    C_e,
    P_e(a)
  ], { placement: f, strategy: h, onComplete: v, onPositioned: g } = a, b = async () => {
    if (!o || !t)
      return;
    const E = await Hwe(o, t, {
      placement: f,
      middleware: u,
      strategy: h
    });
    v == null || v(E), g == null || g({ placed: !0 });
    const T = HD(t), A = _5(T, E.x), P = _5(T, E.y);
    t.style.setProperty("--x", `${A}px`), t.style.setProperty("--y", `${P}px`);
    const _ = t.firstElementChild;
    if (_) {
      const D = T.getComputedStyle(_).zIndex;
      t.style.setProperty("--z-index", D);
    }
  }, S = async () => {
    n.updatePosition ? (await n.updatePosition({ updatePosition: b }), g == null || g({ placed: !0 })) : await b();
  }, w = a.listeners ? y_e(o, t, S, a.listeners) : void 0;
  return S(), () => {
    var E;
    w == null || w(), g == null || g({ placed: !1 }), (E = a.onCleanup) == null || E.call(a);
  };
}
function D5(e, t, n = {}) {
  const { defer: o, ...a } = n, l = o ? sf : (f) => f(), u = [];
  return u.push(
    l(() => {
      const f = typeof e == "function" ? e() : e, h = typeof t == "function" ? t() : t;
      u.push(O_e(f, h, a));
    })
  ), () => {
    u.forEach((f) => f == null ? void 0 : f());
  };
}
var __e = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function D_e(e = {}) {
  const { placement: t, sameWidth: n, fitViewport: o, strategy: a = "absolute" } = e;
  return {
    arrow: {
      position: "absolute",
      width: Sc.arrowSize.reference,
      height: Sc.arrowSize.reference,
      [Sc.arrowSizeHalf.variable]: `calc(${Sc.arrowSize.reference} / 2)`,
      [Sc.arrowOffset.variable]: `calc(${Sc.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      transform: t ? __e[t.split("-")[0]] : void 0,
      background: Sc.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: a,
      isolation: "isolate",
      minWidth: n ? void 0 : "max-content",
      width: n ? "var(--reference-width)" : void 0,
      maxWidth: o ? "var(--available-width)" : void 0,
      maxHeight: o ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: t ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}
var KU = (e) => typeof e == "object" && e !== null && e.nodeType === 1, N_e = (e) => KU(e) && e.tagName === "IFRAME";
function M_e(e) {
  return KU(e) ? e.offsetWidth > 0 || e.offsetHeight > 0 || e.getClientRects().length > 0 : !1;
}
function L_e(e) {
  return parseInt(e.getAttribute("tabindex") || "0", 10) < 0;
}
var qU = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
function GD(e) {
  return !e || e.closest("[inert]") ? !1 : e.matches(qU) && M_e(e);
}
function WD(e, t) {
  if (!e)
    return [];
  const n = Array.from(e.querySelectorAll(qU)), o = n.filter(N5);
  return t && N5(e) && o.unshift(e), o.forEach((a, l) => {
    if (N_e(a) && a.contentDocument) {
      const u = a.contentDocument.body, f = WD(u);
      o.splice(l, 1, ...f);
    }
  }), !o.length && t ? n : o;
}
function N5(e) {
  return e != null && e.tabIndex > 0 ? !0 : GD(e) && !L_e(e);
}
function F_e(e, t) {
  const n = WD(e, t), o = n[0] || null, a = n[n.length - 1] || null;
  return [o, a];
}
function B_e(e, t) {
  const n = WD(e), o = (e == null ? void 0 : e.ownerDocument) || document, a = t ?? o.activeElement;
  if (!a)
    return null;
  const l = n.indexOf(a);
  return n[l + 1] || null;
}
function V_e(e, t = {}) {
  const { triggerElement: n, onFocus: o } = t, a = (e == null ? void 0 : e.ownerDocument) || document, l = a.body;
  function u(f) {
    if (f.key !== "Tab")
      return;
    let h = null;
    const [v, g] = F_e(e, !0), b = !v && !g;
    f.shiftKey && (a.activeElement === v || b) ? h = n : !f.shiftKey && a.activeElement === n ? h = v : !f.shiftKey && (a.activeElement === g || b) && (h = B_e(l, n)), h && (f.preventDefault(), (o == null ? void 0 : o(h)) ?? h.focus());
  }
  return a == null || a.addEventListener("keydown", u, !0), () => {
    a == null || a.removeEventListener("keydown", u, !0);
  };
}
function $_e(e, t) {
  const { defer: n, triggerElement: o, ...a } = t, l = n ? sf : (f) => f(), u = [];
  return u.push(
    l(() => {
      const f = typeof e == "function" ? e() : e, h = typeof o == "function" ? o() : o;
      u.push(V_e(f, { triggerElement: h, ...a }));
    })
  ), () => {
    u.forEach((f) => f == null ? void 0 : f());
  };
}
function z_e(e) {
  const t = {
    each(n) {
      var o;
      for (let a = 0; a < ((o = e.frames) == null ? void 0 : o.length); a += 1) {
        const l = e.frames[a];
        l && n(l);
      }
    },
    addEventListener(n, o, a) {
      return t.each((l) => {
        try {
          l.document.addEventListener(n, o, a);
        } catch {
        }
      }), () => {
        try {
          t.removeEventListener(n, o, a);
        } catch {
        }
      };
    },
    removeEventListener(n, o, a) {
      t.each((l) => {
        try {
          l.document.removeEventListener(n, o, a);
        } catch {
        }
      });
    }
  };
  return t;
}
var M5 = "pointerdown.outside", L5 = "focus.outside";
function H_e(e) {
  const t = e.composedPath() ?? [e.target];
  for (const n of t)
    if (jc(n) && GD(n))
      return !0;
  return !1;
}
var j_e = (e) => "clientY" in e;
function G_e(e, t) {
  if (!j_e(t) || !e)
    return !1;
  const n = e.getBoundingClientRect();
  return n.width === 0 || n.height === 0 ? !1 : n.top <= t.clientY && t.clientY <= n.top + n.height && n.left <= t.clientX && t.clientX <= n.left + n.width;
}
function W_e(e, t) {
  const { exclude: n, onFocusOutside: o, onPointerDownOutside: a, onInteractOutside: l } = t;
  if (!e)
    return;
  const u = zD(e), f = HD(e), h = z_e(f);
  function v(T) {
    const A = PE(T);
    return !jc(A) || oS(e, A) || G_e(e, T) ? !1 : !(n != null && n(A));
  }
  let g;
  function b(T) {
    function A() {
      if (!(!e || !v(T))) {
        if (a || l) {
          const P = F0(a, l);
          e.addEventListener(M5, P, { once: !0 });
        }
        T5(e, M5, {
          bubbles: !1,
          cancelable: !0,
          detail: {
            originalEvent: T,
            contextmenu: UOe(T),
            focusable: H_e(T)
          }
        });
      }
    }
    T.pointerType === "touch" ? (h.removeEventListener("click", A), u.removeEventListener("click", A), g = A, u.addEventListener("click", A, { once: !0 }), h.addEventListener("click", A, { once: !0 })) : A();
  }
  const S = /* @__PURE__ */ new Set(), w = setTimeout(() => {
    S.add(h.addEventListener("pointerdown", b, !0)), S.add(y_(u, "pointerdown", b, !0));
  }, 0);
  function E(T) {
    if (!(!e || !v(T))) {
      if (o || l) {
        const A = F0(o, l);
        e.addEventListener(L5, A, { once: !0 });
      }
      T5(e, L5, {
        bubbles: !1,
        cancelable: !0,
        detail: {
          originalEvent: T,
          contextmenu: !1,
          focusable: GD(PE(T))
        }
      });
    }
  }
  return S.add(y_(u, "focusin", E, !0)), S.add(h.addEventListener("focusin", E, !0)), () => {
    clearTimeout(w), g && (h.removeEventListener("click", g), u.removeEventListener("click", g)), S.forEach((T) => T());
  };
}
function U_e(e, t) {
  const { defer: n } = t, o = n ? sf : (l) => l(), a = [];
  return a.push(
    o(() => {
      const l = typeof e == "function" ? e() : e;
      a.push(W_e(l, t));
    })
  ), () => {
    a.forEach((l) => l == null ? void 0 : l());
  };
}
function X_e(e, t) {
  const n = (o) => {
    o.key === "Escape" && (t == null || t(o));
  };
  return y_(zD(e), "keydown", n);
}
var fl = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((e) => e.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(e) {
    var o;
    const t = this.indexOf(e), n = this.topMostPointerBlockingLayer() ? this.indexOf((o = this.topMostPointerBlockingLayer()) == null ? void 0 : o.node) : -1;
    return t < n;
  },
  isTopMost(e) {
    const t = this.layers[this.count() - 1];
    return (t == null ? void 0 : t.node) === e;
  },
  getNestedLayers(e) {
    return Array.from(this.layers).slice(this.indexOf(e) + 1);
  },
  isInNestedLayer(e, t) {
    return this.getNestedLayers(e).some((n) => oS(n.node, t));
  },
  isInBranch(e) {
    return Array.from(this.branches).some((t) => oS(t, e));
  },
  add(e) {
    this.layers.push(e);
  },
  addBranch(e) {
    this.branches.push(e);
  },
  remove(e) {
    const t = this.indexOf(e);
    t < 0 || (t < this.count() - 1 && this.getNestedLayers(e).forEach((o) => o.dismiss()), this.layers.splice(t, 1));
  },
  removeBranch(e) {
    const t = this.branches.indexOf(e);
    t >= 0 && this.branches.splice(t, 1);
  },
  indexOf(e) {
    return this.layers.findIndex((t) => t.node === e);
  },
  dismiss(e) {
    var t;
    (t = this.layers[this.indexOf(e)]) == null || t.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
}, F5;
function B5() {
  fl.layers.forEach(({ node: e }) => {
    e.style.pointerEvents = fl.isBelowPointerBlockingLayer(e) ? "none" : "auto";
  });
}
function Z_e(e) {
  e.style.pointerEvents = "";
}
var PP = "data-inert";
function Y_e(e) {
  const t = zD(e);
  return fl.hasPointerBlockingLayer() && !t.body.hasAttribute(PP) && (F5 = document.body.style.pointerEvents, t.body.style.pointerEvents = "none", t.body.setAttribute(PP, "")), () => {
    fl.hasPointerBlockingLayer() || (t.body.style.pointerEvents = F5, t.body.removeAttribute(PP), t.body.style.length === 0 && t.body.removeAttribute("style"));
  };
}
function J_e(e, t) {
  if (!e) {
    n_e("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss: n, pointerBlocking: o, exclude: a, debug: l } = t, u = { dismiss: n, node: e, pointerBlocking: o };
  fl.add(u), B5();
  function f(S) {
    var E, T;
    const w = PE(S.detail.originalEvent);
    fl.isBelowPointerBlockingLayer(e) || fl.isInBranch(w) || ((E = t.onPointerDownOutside) == null || E.call(t, S), (T = t.onInteractOutside) == null || T.call(t, S), !S.defaultPrevented && (l && console.log("onPointerDownOutside:", S.detail.originalEvent), n == null || n()));
  }
  function h(S) {
    var E, T;
    const w = PE(S.detail.originalEvent);
    fl.isInBranch(w) || ((E = t.onFocusOutside) == null || E.call(t, S), (T = t.onInteractOutside) == null || T.call(t, S), !S.defaultPrevented && (l && console.log("onFocusOutside:", S.detail.originalEvent), n == null || n()));
  }
  function v(S) {
    var w;
    fl.isTopMost(e) && ((w = t.onEscapeKeyDown) == null || w.call(t, S), !S.defaultPrevented && n && (S.preventDefault(), n()));
  }
  function g(S) {
    if (!e)
      return !1;
    const w = typeof a == "function" ? a() : a;
    return (Array.isArray(w) ? w : [w]).some((T) => oS(T, S)) || fl.isInNestedLayer(e, S);
  }
  const b = [
    o ? Y_e(e) : void 0,
    X_e(e, v),
    U_e(e, { exclude: g, onFocusOutside: h, onPointerDownOutside: f })
  ];
  return () => {
    fl.remove(e), B5(), Z_e(e), b.forEach((S) => S == null ? void 0 : S());
  };
}
function Q_e(e, t) {
  const { defer: n } = t, o = n ? sf : (l) => l(), a = [];
  return a.push(
    o(() => {
      const l = typeof e == "function" ? e() : e;
      a.push(J_e(l, t));
    })
  ), () => {
    a.forEach((l) => l == null ? void 0 : l());
  };
}
var K_e = Object.defineProperty, q_e = (e, t, n) => t in e ? K_e(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Kn = (e, t, n) => (q_e(e, typeof t != "symbol" ? t + "" : t, n), n);
function e2e(e) {
  let t, n, o = 2166136261;
  for (t = 0, n = e.length; t < n; t++)
    o ^= e.charCodeAt(t), o += (o << 1) + (o << 4) + (o << 7) + (o << 8) + (o << 24);
  return `00000${(o >>> 0).toString(36)}`.slice(-6);
}
var OP = (e) => typeof e == "object" && e !== null && !Array.isArray(e), _P = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Ow = {
  itemToValue(e) {
    return typeof e == "string" ? e : OP(e) && _P(e, "value") ? e.value : "";
  },
  itemToString(e) {
    return typeof e == "string" ? e : OP(e) && _P(e, "label") ? e.label : Ow.itemToValue(e);
  },
  itemToDisabled(e) {
    return OP(e) && _P(e, "disabled") ? !!e.disabled : !1;
  }
}, e6 = class {
  constructor(e) {
    this.options = e, Kn(this, "nodes", /* @__PURE__ */ new Map()), Kn(this, "disabledValues", /* @__PURE__ */ new Set()), Kn(this, "_firstValue", null), Kn(this, "_lastValue", null), Kn(this, "hash", ""), Kn(this, "isEqual", (t) => this.hash === t.hash), Kn(this, "iterate", () => {
      const { items: t } = this.options, n = /* @__PURE__ */ new Set();
      for (let o = 0; o < t.length; o++) {
        const a = t[o], l = this.itemToValue(a), u = this.itemToString(a), f = this.itemToDisabled(a);
        n.add(l);
        const h = {
          // freeze item to prevent mutation by frameworks like Solid.js
          item: Object.freeze(a),
          index: o,
          label: u,
          value: l,
          previousValue: this.itemToValue(t[o - 1]) ?? null,
          nextValue: this.itemToValue(t[o + 1]) ?? null
        };
        this.nodes.set(l, h), f && this.disabledValues.add(l), o === 0 && (this._firstValue = l), o === t.length - 1 && (this._lastValue = l);
      }
      return this.hash = e2e(Array.from(n).join("")), this;
    }), Kn(this, "setItems", (t) => (this.options.items = t, this.iterate())), Kn(this, "item", (t) => {
      var n;
      return t === null ? null : ((n = this.nodes.get(t)) == null ? void 0 : n.item) ?? null;
    }), Kn(this, "items", (t) => t.map((n) => this.item(n)).filter(Boolean)), Kn(this, "at", (t) => {
      for (const n of this.nodes.values())
        if (n.index === t)
          return n.item;
      return null;
    }), Kn(this, "sortFn", (t, n) => {
      const o = this.nodes.get(t), a = this.nodes.get(n);
      return ((o == null ? void 0 : o.index) ?? 0) - ((a == null ? void 0 : a.index) ?? 0);
    }), Kn(this, "sort", (t) => t.sort(this.sortFn)), Kn(this, "itemToValue", (t) => {
      var n, o;
      return t ? ((o = (n = this.options).itemToValue) == null ? void 0 : o.call(n, t)) ?? Ow.itemToValue(t) : "";
    }), Kn(this, "itemToString", (t) => {
      var n, o;
      return t ? ((o = (n = this.options).itemToString) == null ? void 0 : o.call(n, t)) ?? Ow.itemToString(t) : "";
    }), Kn(this, "itemToDisabled", (t) => {
      var n, o;
      return t ? ((o = (n = this.options).isItemDisabled) == null ? void 0 : o.call(n, t)) ?? Ow.itemToDisabled(t) : !1;
    }), Kn(this, "valueToString", (t) => {
      var n;
      return t == null ? "" : ((n = this.nodes.get(t)) == null ? void 0 : n.label) ?? "";
    }), Kn(this, "itemsToString", (t, n = ", ") => t.map((o) => this.itemToString(o)).filter(Boolean).join(n)), Kn(this, "has", (t) => t == null ? !1 : this.nodes.has(t)), Kn(this, "count", () => this.nodes.size), Kn(this, "first", () => {
      let t = this._firstValue;
      for (; t != null; ) {
        let n = this.nodes.get(t);
        if (n != null && !this.disabledValues.has(n.value))
          return t;
        t = (n == null ? void 0 : n.nextValue) ?? null;
      }
      return null;
    }), Kn(this, "last", () => {
      let t = this._lastValue;
      for (; t != null; ) {
        let n = this.nodes.get(t);
        if (n != null && !this.disabledValues.has(n.value))
          return t;
        t = (n == null ? void 0 : n.previousValue) ?? null;
      }
      return null;
    }), Kn(this, "next", (t) => {
      if (t == null)
        return null;
      const n = this.nodes.get(t);
      let o = (n == null ? void 0 : n.nextValue) ?? null;
      for (; o != null; ) {
        let a = this.nodes.get(o);
        if (a != null && !this.disabledValues.has(a.value))
          return o;
        o = (a == null ? void 0 : a.nextValue) ?? null;
      }
      return null;
    }), Kn(this, "prev", (t) => {
      if (t == null)
        return null;
      const n = this.nodes.get(t);
      let o = (n == null ? void 0 : n.previousValue) ?? null;
      for (; o != null; ) {
        let a = this.nodes.get(o);
        if (a != null && !this.disabledValues.has(a.value))
          return o;
        o = (a == null ? void 0 : a.previousValue) ?? null;
      }
      return null;
    }), Kn(this, "isItemDisabled", (t) => this.disabledValues.has(this.itemToValue(t))), Kn(this, "toArray", () => Array.from(this.nodes.values())), Kn(this, "indexOf", (t) => {
      var n;
      return t == null ? -1 : ((n = this.nodes.get(t)) == null ? void 0 : n.index) ?? -1;
    }), Kn(this, "getByText", (t, n) => {
      const o = this.indexOf(n);
      let a = n != null ? n2e(this.toArray(), o) : this.toArray();
      return t.length === 1 && (a = a.filter((u) => u.value !== n)), a.find((u) => t2e(u.label, t));
    }), Kn(this, "search", (t, n) => {
      var S;
      const { state: o, currentValue: a, timeout: l = 350 } = n, u = o.keysSoFar + t, h = u.length > 1 && Array.from(u).every((w) => w === u[0]) ? u[0] : u, v = ((S = this.getByText(h, a)) == null ? void 0 : S.value) ?? null;
      function g() {
        clearTimeout(o.timer), o.timer = -1;
      }
      function b(w) {
        o.keysSoFar = w, g(), w !== "" && (o.timer = +setTimeout(() => {
          b(""), g();
        }, l));
      }
      return b(u), v;
    }), Kn(this, "toJSON", () => ({
      size: this.count(),
      first: this.first(),
      last: this.last()
    })), this.iterate();
  }
}, t2e = (e, t) => e.toLowerCase().startsWith(t.toLowerCase()), n2e = (e, t) => e.map((n, o) => e[(Math.max(t, 0) + o) % e.length]), t6 = Rw("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "content",
  "root",
  "control"
), $a = t6.build(), UD = (e) => Cg(new e6(e));
UD.empty = () => Cg(new e6({ items: [] }));
var Bt = NOe({
  getRootId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.root) ?? `select:${e.id}`;
  },
  getContentId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.content) ?? `select:${e.id}:content`;
  },
  getTriggerId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.trigger) ?? `select:${e.id}:trigger`;
  },
  getClearTriggerId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.clearTrigger) ?? `select:${e.id}:clear-trigger`;
  },
  getLabelId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.label) ?? `select:${e.id}:label`;
  },
  getControlId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.control) ?? `select:${e.id}:control`;
  },
  getItemId: (e, t) => {
    var n, o;
    return ((o = (n = e.ids) == null ? void 0 : n.item) == null ? void 0 : o.call(n, t)) ?? `select:${e.id}:option:${t}`;
  },
  getHiddenSelectId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.hiddenSelect) ?? `select:${e.id}:select`;
  },
  getPositionerId: (e) => {
    var t;
    return ((t = e.ids) == null ? void 0 : t.positioner) ?? `select:${e.id}:positioner`;
  },
  getItemGroupId: (e, t) => {
    var n, o;
    return ((o = (n = e.ids) == null ? void 0 : n.itemGroup) == null ? void 0 : o.call(n, t)) ?? `select:${e.id}:optgroup:${t}`;
  },
  getItemGroupLabelId: (e, t) => {
    var n, o;
    return ((o = (n = e.ids) == null ? void 0 : n.itemGroupLabel) == null ? void 0 : o.call(n, t)) ?? `select:${e.id}:optgroup-label:${t}`;
  },
  getHiddenSelectEl: (e) => Bt.getById(e, Bt.getHiddenSelectId(e)),
  getContentEl: (e) => Bt.getById(e, Bt.getContentId(e)),
  getControlEl: (e) => Bt.getById(e, Bt.getControlId(e)),
  getTriggerEl: (e) => Bt.getById(e, Bt.getTriggerId(e)),
  getClearTriggerEl: (e) => Bt.getById(e, Bt.getClearTriggerId(e)),
  getPositionerEl: (e) => Bt.getById(e, Bt.getPositionerId(e)),
  getHighlightedOptionEl(e) {
    return e.highlightedValue ? Bt.getById(e, Bt.getItemId(e, e.highlightedValue)) : null;
  }
});
function r2e(e, t, n) {
  const o = e.context.isDisabled, a = e.context.invalid, l = e.context.readOnly, u = e.context.isInteractive, f = e.hasTag("open"), h = e.matches("focused"), v = e.context.highlightedItem, g = e.context.selectedItems, b = e.context.isTypingAhead;
  function S(E) {
    const { item: T } = E, A = e.context.collection.isItemDisabled(T), P = e.context.collection.itemToValue(T);
    return {
      value: P,
      isDisabled: !!(A || o),
      isHighlighted: e.context.highlightedValue === P,
      isSelected: e.context.value.includes(P)
    };
  }
  const w = D_e({
    ...e.context.positioning,
    placement: e.context.currentPlacement
  });
  return {
    isOpen: f,
    isFocused: h,
    highlightedItem: v,
    highlightedValue: e.context.highlightedValue,
    selectedItems: g,
    hasSelectedItems: e.context.hasSelectedItems,
    value: e.context.value,
    valueAsString: e.context.valueAsString,
    collection: e.context.collection,
    setCollection(E) {
      t({ type: "COLLECTION.SET", value: E });
    },
    reposition(E = {}) {
      t({ type: "POSITIONING.SET", options: E });
    },
    focus() {
      var E;
      (E = Bt.getTriggerEl(e.context)) == null || E.focus({ preventScroll: !0 });
    },
    open() {
      t("OPEN");
    },
    close() {
      t("CLOSE");
    },
    selectValue(E) {
      t({ type: "ITEM.SELECT", value: E });
    },
    setValue(E) {
      t({ type: "VALUE.SET", value: E });
    },
    highlightValue(E) {
      t({ type: "HIGHLIGHTED_VALUE.SET", value: E });
    },
    clearValue(E) {
      t(E ? { type: "ITEM.CLEAR", value: E } : { type: "VALUE.CLEAR" });
    },
    getItemState: S,
    rootProps: n.element({
      ...$a.root.attrs,
      dir: e.context.dir,
      id: Bt.getRootId(e.context),
      "data-invalid": qo(a),
      "data-readonly": qo(l)
    }),
    labelProps: n.label({
      dir: e.context.dir,
      id: Bt.getLabelId(e.context),
      ...$a.label.attrs,
      "data-disabled": qo(o),
      "data-invalid": qo(a),
      "data-readonly": qo(l),
      htmlFor: Bt.getHiddenSelectId(e.context),
      onClick() {
        var E;
        o || (E = Bt.getTriggerEl(e.context)) == null || E.focus({ preventScroll: !0 });
      }
    }),
    controlProps: n.element({
      ...$a.control.attrs,
      dir: e.context.dir,
      id: Bt.getControlId(e.context),
      "data-state": f ? "open" : "closed",
      "data-focus": qo(h),
      "data-disabled": qo(o),
      "data-invalid": qo(a)
    }),
    triggerProps: n.button({
      id: Bt.getTriggerId(e.context),
      disabled: o,
      dir: e.context.dir,
      type: "button",
      "aria-controls": Bt.getContentId(e.context),
      "aria-expanded": f,
      "data-state": f ? "open" : "closed",
      "aria-haspopup": "listbox",
      "aria-labelledby": Bt.getLabelId(e.context),
      ...$a.trigger.attrs,
      "data-disabled": qo(o),
      "data-invalid": qo(a),
      "aria-invalid": a,
      "data-readonly": qo(l),
      "data-placement": e.context.currentPlacement,
      "data-placeholder-shown": qo(!e.context.hasSelectedItems),
      onPointerDown(E) {
        E.button || E.ctrlKey || !u || (E.currentTarget.dataset.pointerType = E.pointerType, !(o || E.pointerType === "touch") && t({ type: "TRIGGER.CLICK" }));
      },
      onClick(E) {
        !u || E.button || E.currentTarget.dataset.pointerType === "touch" && t({ type: "TRIGGER.CLICK" });
      },
      onFocus() {
        t("TRIGGER.FOCUS");
      },
      onBlur() {
        t("TRIGGER.BLUR");
      },
      onKeyDown(E) {
        if (!u)
          return;
        const A = {
          ArrowUp() {
            t({ type: "TRIGGER.ARROW_UP" });
          },
          ArrowDown(P) {
            t({ type: P.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
          },
          ArrowLeft() {
            t({ type: "TRIGGER.ARROW_LEFT" });
          },
          ArrowRight() {
            t({ type: "TRIGGER.ARROW_RIGHT" });
          },
          Home() {
            t({ type: "TRIGGER.HOME" });
          },
          End() {
            t({ type: "TRIGGER.END" });
          },
          Enter() {
            t({ type: "TRIGGER.ENTER" });
          },
          Space(P) {
            t(b ? { type: "TRIGGER.TYPEAHEAD", key: P.key } : { type: "TRIGGER.ENTER" });
          }
        }[A5(E, e.context)];
        if (A) {
          A(E), E.preventDefault();
          return;
        }
        g_.isValidEvent(E) && (t({ type: "TRIGGER.TYPEAHEAD", key: E.key }), E.preventDefault());
      }
    }),
    indicatorProps: n.element({
      ...$a.indicator.attrs,
      dir: e.context.dir,
      "aria-hidden": !0,
      "data-state": f ? "open" : "closed"
    }),
    getItemProps(E) {
      const T = S(E);
      return n.element({
        id: Bt.getItemId(e.context, T.value),
        role: "option",
        ...$a.item.attrs,
        dir: e.context.dir,
        "data-value": T.value,
        "aria-selected": T.isSelected,
        "data-state": T.isSelected ? "checked" : "unchecked",
        "data-highlighted": qo(T.isHighlighted),
        "data-disabled": qo(T.isDisabled),
        "aria-disabled": OOe(T.isDisabled),
        onPointerMove(A) {
          T.isDisabled || A.pointerType !== "mouse" || T.value !== e.context.highlightedValue && t({ type: "ITEM.POINTER_MOVE", value: T.value });
        },
        onPointerUp() {
          T.isDisabled || t({ type: "ITEM.CLICK", src: "pointerup", value: T.value });
        },
        onPointerLeave(A) {
          const P = ["CONTENT.ARROW_UP", "CONTENT.ARROW_DOWN"].includes(e.event.type);
          T.isDisabled || A.pointerType !== "mouse" || P || t({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(E) {
      const T = S(E);
      return n.element({
        ...$a.itemText.attrs,
        dir: e.context.dir,
        "data-disabled": qo(T.isDisabled),
        "data-highlighted": qo(T.isHighlighted)
      });
    },
    getItemIndicatorProps(E) {
      const T = S(E);
      return n.element({
        "aria-hidden": !0,
        ...$a.itemIndicator.attrs,
        dir: e.context.dir,
        "data-state": T.isSelected ? "checked" : "unchecked",
        hidden: !T.isSelected
      });
    },
    getItemGroupLabelProps(E) {
      const { htmlFor: T } = E;
      return n.element({
        ...$a.itemGroupLabel.attrs,
        id: Bt.getItemGroupId(e.context, T),
        role: "group",
        dir: e.context.dir
      });
    },
    getItemGroupProps(E) {
      const { id: T } = E;
      return n.element({
        ...$a.itemGroup.attrs,
        "data-disabled": qo(o),
        id: Bt.getItemGroupId(e.context, T),
        "aria-labelledby": Bt.getItemGroupLabelId(e.context, T),
        dir: e.context.dir
      });
    },
    clearTriggerProps: n.button({
      ...$a.clearTrigger.attrs,
      id: Bt.getClearTriggerId(e.context),
      type: "button",
      "aria-label": "Clear value",
      disabled: o,
      hidden: !e.context.hasSelectedItems,
      dir: e.context.dir,
      onClick() {
        t("VALUE.CLEAR");
      }
    }),
    hiddenSelectProps: n.select({
      name: e.context.name,
      form: e.context.form,
      disabled: !u,
      multiple: e.context.multiple,
      "aria-hidden": !0,
      id: Bt.getHiddenSelectId(e.context),
      // defaultValue: state.context.selectedOption?.value,
      style: o_e,
      tabIndex: -1,
      // Some browser extensions will focus the hidden select.
      // Let's forward the focus to the trigger.
      onFocus() {
        var E;
        (E = Bt.getTriggerEl(e.context)) == null || E.focus({ preventScroll: !0 });
      },
      "aria-labelledby": Bt.getLabelId(e.context)
    }),
    positionerProps: n.element({
      ...$a.positioner.attrs,
      dir: e.context.dir,
      id: Bt.getPositionerId(e.context),
      style: w.floating
    }),
    contentProps: n.element({
      hidden: !f,
      dir: e.context.dir,
      id: Bt.getContentId(e.context),
      role: "listbox",
      ...$a.content.attrs,
      "data-state": f ? "open" : "closed",
      "aria-activedescendant": e.context.highlightedValue || "",
      "aria-multiselectable": e.context.multiple ? "true" : void 0,
      "aria-labelledby": Bt.getLabelId(e.context),
      tabIndex: 0,
      onKeyDown(E) {
        if (!u || !_Oe(E))
          return;
        const T = {
          ArrowUp() {
            t({ type: "CONTENT.ARROW_UP" });
          },
          ArrowDown() {
            t({ type: "CONTENT.ARROW_DOWN" });
          },
          Home() {
            t({ type: "CONTENT.HOME" });
          },
          End() {
            t({ type: "CONTENT.END" });
          },
          Enter() {
            t({ type: "CONTENT.ENTER" });
          },
          Space(P) {
            var _;
            b ? t({ type: "CONTENT.TYPEAHEAD", key: P.key }) : (_ = T.Enter) == null || _.call(T, P);
          }
        }, A = T[A5(E)];
        if (A) {
          A(E), E.preventDefault();
          return;
        }
        WOe(E.target) || g_.isValidEvent(E) && (t({ type: "CONTENT.TYPEAHEAD", key: E.key }), E.preventDefault());
      }
    })
  };
}
var { and: o0, not: $p } = LU;
function o2e(e) {
  const t = jD(e);
  return VU(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        selectOnBlur: !1,
        loop: !1,
        closeOnSelect: !0,
        disabled: !1,
        ...t,
        collection: t.collection ?? UD.empty(),
        typeahead: g_.defaultOptions,
        fieldsetDisabled: !1,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...t.positioning
        }
      },
      computed: {
        hasSelectedItems: (n) => n.value.length > 0,
        isTypingAhead: (n) => n.typeahead.keysSoFar !== "",
        isDisabled: (n) => !!n.disabled || n.fieldsetDisabled,
        isInteractive: (n) => !(n.isDisabled || n.readOnly),
        selectedItems: (n) => n.collection.items(n.value),
        highlightedItem: (n) => n.collection.item(n.highlightedValue),
        valueAsString: (n) => n.collection.itemsToString(n.selectedItems)
      },
      initial: "idle",
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectElement"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
            },
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        focused: {
          tags: ["closed"],
          entry: ["focusTriggerEl"],
          on: {
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
            },
            "TRIGGER.ENTER": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: o0($p("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: $p("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: o0($p("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: $p("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: $p("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: $p("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: $p("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["focusContentEl"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem", "proxyTabFocus"],
          on: {
            CLOSE: {
              target: "focused",
              actions: ["clearHighlightedItem", "invokeOnClose"]
            },
            "TRIGGER.CLICK": {
              target: "focused",
              actions: ["clearHighlightedItem", "invokeOnClose"]
            },
            "ITEM.CLICK": [
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "clearHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "multiple",
                actions: ["selectHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem", "clearHighlightedItem"]
              }
            ],
            "CONTENT.ENTER": [
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "clearHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "multiple",
                actions: ["selectHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem", "clearHighlightedItem"]
              }
            ],
            "CONTENT.INTERACT_OUTSIDE": [
              {
                guard: o0("selectOnBlur", "hasHighlightedItem"),
                target: "idle",
                actions: ["selectHighlightedItem", "invokeOnClose", "clearHighlightedItem"]
              },
              {
                guard: "isTargetFocusable",
                target: "idle",
                actions: ["clearHighlightedItem", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearHighlightedItem", "invokeOnClose"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: o0("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: o0("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (n) => !!n.loop,
        multiple: (n) => !!n.multiple,
        hasSelectedItems: (n) => n.hasSelectedItems,
        hasHighlightedItem: (n) => n.highlightedValue != null,
        isFirstItemHighlighted: (n) => n.highlightedValue === n.collection.first(),
        isLastItemHighlighted: (n) => n.highlightedValue === n.collection.last(),
        selectOnBlur: (n) => !!n.selectOnBlur,
        closeOnSelect: (n, o) => n.multiple ? !1 : !!(o.closeOnSelect ?? n.closeOnSelect),
        isTargetFocusable: (n, o) => !!o.focusable
      },
      activities: {
        proxyTabFocus(n) {
          return $_e(() => Bt.getContentEl(n), {
            defer: !0,
            triggerElement: Bt.getTriggerEl(n),
            onFocus(a) {
              sf(() => a.focus({ preventScroll: !0 }));
            }
          });
        },
        trackFormControlState(n, o, { initialContext: a }) {
          return f_e(Bt.getHiddenSelectEl(n), {
            onFieldsetDisabledChange(l) {
              n.fieldsetDisabled = l;
            },
            onFormReset() {
              uo.selectedItems(n, a.value);
            }
          });
        },
        trackDismissableElement(n, o, { send: a }) {
          let l = !1;
          return Q_e(() => Bt.getContentEl(n), {
            defer: !0,
            exclude: [Bt.getTriggerEl(n), Bt.getClearTriggerEl(n)],
            onFocusOutside: n.onFocusOutside,
            onPointerDownOutside: n.onPointerDownOutside,
            onInteractOutside(f) {
              var h;
              l = f.detail.focusable, (h = n.onInteractOutside) == null || h.call(n, f);
            },
            onDismiss() {
              a({ type: "CONTENT.INTERACT_OUTSIDE", focusable: l });
            }
          });
        },
        computePlacement(n) {
          return n.currentPlacement = n.positioning.placement, D5(() => Bt.getTriggerEl(n), () => Bt.getPositionerEl(n), {
            defer: !0,
            ...n.positioning,
            onComplete(l) {
              n.currentPlacement = l.placement;
            }
          });
        },
        scrollToHighlightedItem(n, o, { getState: a }) {
          const l = () => {
            if (a().event.type.startsWith("ITEM.POINTER"))
              return;
            const f = Bt.getHighlightedOptionEl(n);
            f == null || f.scrollIntoView({ block: "nearest" });
          };
          return sf(() => l()), ZU(Bt.getContentEl(n), ["aria-activedescendant"], l);
        }
      },
      actions: {
        reposition(n, o) {
          const a = () => Bt.getPositionerEl(n);
          D5(Bt.getTriggerEl(n), a, {
            ...n.positioning,
            ...o.options,
            defer: !0,
            listeners: !1,
            onComplete(l) {
              n.currentPlacement = l.placement;
            }
          });
        },
        toggleVisibility(n, o, { send: a }) {
          a({ type: n.open ? "OPEN" : "CLOSE", src: "controlled" });
        },
        highlightPreviousItem(n) {
          if (n.highlightedValue == null)
            return;
          const o = n.collection.prev(n.highlightedValue);
          uo.highlightedItem(n, o);
        },
        highlightNextItem(n) {
          if (n.highlightedValue == null)
            return;
          const o = n.collection.next(n.highlightedValue);
          uo.highlightedItem(n, o);
        },
        highlightFirstItem(n) {
          const o = n.collection.first();
          uo.highlightedItem(n, o);
        },
        highlightLastItem(n) {
          const o = n.collection.last();
          uo.highlightedItem(n, o);
        },
        focusContentEl(n) {
          sf(() => {
            var o;
            (o = Bt.getContentEl(n)) == null || o.focus({ preventScroll: !0 });
          });
        },
        focusTriggerEl(n) {
          sf(() => {
            var o;
            (o = Bt.getTriggerEl(n)) == null || o.focus({ preventScroll: !0 });
          });
        },
        selectHighlightedItem(n, o) {
          const a = o.value ?? n.highlightedValue;
          a != null && uo.selectedItem(n, a);
        },
        highlightFirstSelectedItem(n) {
          if (!n.hasSelectedItems)
            return;
          const [o] = n.collection.sort(n.value);
          uo.highlightedItem(n, o);
        },
        highlightItem(n, o) {
          uo.highlightedItem(n, o.value);
        },
        highlightMatchingItem(n, o) {
          const a = n.collection.search(o.key, {
            state: n.typeahead,
            currentValue: n.highlightedValue
          });
          a != null && uo.highlightedItem(n, a);
        },
        setHighlightedItem(n, o) {
          uo.highlightedItem(n, o.value);
        },
        clearHighlightedItem(n) {
          uo.highlightedItem(n, null, !0);
        },
        selectItem(n, o) {
          uo.selectedItem(n, o.value);
        },
        clearItem(n, o) {
          const a = n.value.filter((l) => l !== o.value);
          uo.selectedItems(n, a);
        },
        setSelectedItems(n, o) {
          uo.selectedItems(n, o.value);
        },
        clearSelectedItems(n) {
          uo.selectedItems(n, []);
        },
        selectPreviousItem(n) {
          const o = n.collection.prev(n.value[0]);
          uo.selectedItem(n, o);
        },
        selectNextItem(n) {
          const o = n.collection.next(n.value[0]);
          uo.selectedItem(n, o);
        },
        selectFirstItem(n) {
          const o = n.collection.first();
          uo.selectedItem(n, o);
        },
        selectLastItem(n) {
          const o = n.collection.last();
          uo.selectedItem(n, o);
        },
        selectMatchingItem(n, o) {
          const a = n.collection.search(o.key, {
            state: n.typeahead,
            currentValue: n.value[0]
          });
          a != null && uo.selectedItem(n, a);
        },
        scrollContentToTop(n) {
          var o;
          (o = Bt.getContentEl(n)) == null || o.scrollTo(0, 0);
        },
        invokeOnOpen(n) {
          var o;
          (o = n.onOpenChange) == null || o.call(n, { open: !0 });
        },
        invokeOnClose(n) {
          var o;
          (o = n.onOpenChange) == null || o.call(n, { open: !1 });
        },
        syncSelectElement(n) {
          const o = Bt.getHiddenSelectEl(n);
          o && s_e(o, n.value.join(","), { type: "HTMLSelectElement" });
        },
        setCollection(n, o) {
          n.collection = o.value;
        }
      }
    }
  );
}
function i2e(e) {
  const t = Bt.getHiddenSelectEl(e);
  if (!t)
    return;
  const n = Bt.getWin(e), o = new n.Event("change", { bubbles: !0 });
  t.dispatchEvent(o);
}
var QC = {
  change: (e) => {
    var t;
    (t = e.onValueChange) == null || t.call(e, {
      value: Array.from(e.value),
      items: e.selectedItems
    }), i2e(e);
  },
  highlightChange: (e) => {
    var t;
    (t = e.onHighlightChange) == null || t.call(e, {
      highlightedValue: e.highlightedValue,
      highlightedItem: e.highlightedItem
    });
  }
}, uo = {
  selectedItem: (e, t, n = !1) => {
    if (Pw(e.value, t) || t == null && !n)
      return;
    if (t == null && n) {
      e.value = [], QC.change(e);
      return;
    }
    const o = e.multiple ? KOe(e.value, t) : [t];
    e.value = o, QC.change(e);
  },
  selectedItems: (e, t) => {
    Pw(e.value, t) || (e.value = t, QC.change(e));
  },
  highlightedItem: (e, t, n = !1) => {
    Pw(e.highlightedValue, t) || t == null && !n || (e.highlightedValue = t ?? null, QC.highlightChange(e));
  }
};
const a2e = t6.extendWith("valueText"), s2e = () => {
  const [e, t] = ot(!0);
  return dt(() => {
    t(!1);
  }, []), e;
}, l2e = (e) => {
  const { children: t, container: n, disabled: o } = e, a = s2e(), l = XU();
  if (a || o)
    return t;
  const u = (l == null ? void 0 : l().ownerDocument) ?? document, f = (n == null ? void 0 : n.current) ?? u.body;
  return Gc.map(t, (h) => VE.createPortal(h, f));
}, [u2e, Ya] = MT({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
}), c2e = (e) => {
  const [t, n] = Dg()(e, [
    "isItemDisabled",
    "itemToValue",
    "itemToString",
    "items"
  ]), o = gt(
    () => UD(t),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Object.values(t)
  ), a = {
    id: ko(),
    getRootNode: XU(),
    collection: o,
    ...n,
    value: e.defaultValue
  }, l = {
    ...a,
    collection: o,
    value: e.value,
    onValueChange: kw(e.onValueChange, { sync: !0 }),
    onHighlightChange: kw(e.onHighlightChange),
    onOpenChange: kw(e.onOpenChange)
  }, [u, f] = HU(o2e(a), {
    context: l
  });
  return r2e(u, f, dOe);
}, d2e = (e, t) => {
  const [n, o] = xOe(e), [a, { children: l, ...u }] = Dg()(
    o,
    [
      "closeOnSelect",
      "defaultValue",
      "dir",
      "disabled",
      "form",
      "getRootNode",
      "highlightedValue",
      "id",
      "ids",
      "invalid",
      "isItemDisabled",
      "items",
      "itemToString",
      "itemToValue",
      "loop",
      "multiple",
      "name",
      "onFocusOutside",
      "onHighlightChange",
      "onInteractOutside",
      "onOpenChange",
      "onPointerDownOutside",
      "onValueChange",
      "open",
      "positioning",
      "readOnly",
      "selectOnBlur",
      "value"
    ]
  ), f = c2e(a), h = AOe(ji({ present: f.isOpen }, n)), v = UU(l, f), g = ji(f.rootProps, u);
  return /* @__PURE__ */ M(u2e, { value: f, children: /* @__PURE__ */ M(ROe, { value: h, children: /* @__PURE__ */ M(Ta.div, { ...g, ref: t, children: v }) }) });
}, V5 = fr(d2e), n6 = fr(
  (e, t) => {
    const n = Ya(), o = ji(n.clearTriggerProps, e);
    return /* @__PURE__ */ M(Ta.button, { ...o, ref: t });
  }
);
n6.displayName = "SelectClearTrigger";
const r6 = fr((e, t) => {
  const n = Ya(), o = GU(), a = ji(n.contentProps, o.getPresenceProps(t), e);
  return o.isUnmounted ? null : /* @__PURE__ */ M(Ta.div, { ...a });
});
r6.displayName = "SelectContent";
const o6 = fr((e, t) => {
  const n = Ya(), o = ji(n.controlProps, e);
  return /* @__PURE__ */ Nt(ah, { children: [
    /* @__PURE__ */ M(Ta.div, { ...o, ref: t }),
    /* @__PURE__ */ M("select", { ...n.hiddenSelectProps, children: n.collection.toArray().map((a) => /* @__PURE__ */ M("option", { value: a.value, children: a.label }, a.value)) })
  ] });
});
o6.displayName = "SelectControl";
const i6 = fr((e, t) => {
  const n = Ya(), o = ji(n.indicatorProps, e);
  return /* @__PURE__ */ M(Ta.div, { ...o, ref: t });
});
i6.displayName = "SelectIndicator";
const [f2e, a6] = MT({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
}), s6 = fr((e, t) => {
  const [n, { children: o, ...a }] = Dg()(e, ["item"]), l = Ya(), u = ji(l.getItemProps(n), a), f = l.getItemState(n), h = UU(o, f);
  return /* @__PURE__ */ M(f2e, { value: n, children: /* @__PURE__ */ M(Ta.div, { ...u, ref: t, children: h }) });
});
s6.displayName = "SelectItem";
const l6 = fr((e, t) => {
  const [n, o] = Dg()(e, ["id"]), a = Ya(), l = ji(a.getItemGroupProps(n), o);
  return /* @__PURE__ */ M(Ta.div, { ...l, ref: t });
});
l6.displayName = "SelectItemGroup";
const u6 = fr(
  (e, t) => {
    const [n, o] = Dg()(e, [
      "htmlFor"
    ]), a = Ya(), l = ji(a.getItemGroupLabelProps(n), o);
    return /* @__PURE__ */ M(Ta.div, { ...l, ref: t });
  }
);
u6.displayName = "SelectItemGroupLabel";
const c6 = fr(
  (e, t) => {
    const n = Ya(), o = a6(), a = ji(n.getItemIndicatorProps(o), e);
    return /* @__PURE__ */ M(Ta.div, { ...a, ref: t });
  }
);
c6.displayName = "SelectItemIndicator";
const d6 = fr((e, t) => {
  const n = Ya(), o = a6(), a = ji(n.getItemTextProps(o), e);
  return /* @__PURE__ */ M(Ta.span, { ...a, ref: t });
});
d6.displayName = "SelectItemText";
const f6 = fr((e, t) => {
  const n = Ya(), o = ji(n.labelProps, e);
  return /* @__PURE__ */ M(Ta.label, { ...o, ref: t });
});
f6.displayName = "SelectLabel";
const p6 = fr((e, t) => {
  const n = Ya(), o = ji(n.positionerProps, e);
  return GU().isUnmounted ? null : /* @__PURE__ */ M(Ta.div, { ...o, ref: t });
});
p6.displayName = "SelectPositioner";
const h6 = fr((e, t) => {
  const n = Ya(), o = ji(n.triggerProps, e);
  return /* @__PURE__ */ M(Ta.button, { ...o, ref: t });
});
h6.displayName = "SelectTrigger";
const m6 = fr((e, t) => {
  const { children: n, placeholder: o, ...a } = e, l = Ya();
  return /* @__PURE__ */ M(Ta.span, { ...a2e.build().valueText.attrs, ...a, ref: t, children: n || l.valueAsString || o });
});
m6.displayName = "SelectValueText";
const pl = Object.assign(V5, {
  Root: V5,
  ClearTrigger: n6,
  Content: r6,
  Control: o6,
  Indicator: i6,
  Item: s6,
  ItemGroup: l6,
  ItemGroupLabel: u6,
  ItemIndicator: c6,
  ItemText: d6,
  Label: f6,
  Positioner: p6,
  Trigger: h6,
  ValueText: m6
});
var v6 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, $5 = Tt.createContext && /* @__PURE__ */ Tt.createContext(v6), p2e = ["attr", "size", "title"];
function h2e(e, t) {
  if (e == null)
    return {};
  var n = m2e(e, t), o, a;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (a = 0; a < l.length; a++)
      o = l[a], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function m2e(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function OE() {
  return OE = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, OE.apply(this, arguments);
}
function z5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _E(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z5(Object(n), !0).forEach(function(o) {
      v2e(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z5(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function v2e(e, t, n) {
  return t = g2e(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function g2e(e) {
  var t = y2e(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function y2e(e, t) {
  if (typeof e != "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t || "default");
    if (typeof o != "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function g6(e) {
  return e && e.map((t, n) => /* @__PURE__ */ Tt.createElement(t.tag, _E({
    key: n
  }, t.attr), g6(t.child)));
}
function kS(e) {
  return (t) => /* @__PURE__ */ Tt.createElement(b2e, OE({
    attr: _E({}, e.attr)
  }, t), g6(e.child));
}
function b2e(e) {
  var t = (n) => {
    var {
      attr: o,
      size: a,
      title: l
    } = e, u = h2e(e, p2e), f = a || n.size || "1em", h;
    return n.className && (h = n.className), e.className && (h = (h ? h + " " : "") + e.className), /* @__PURE__ */ Tt.createElement("svg", OE({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, o, u, {
      className: h,
      style: _E(_E({
        color: e.color || n.color
      }, n.style), e.style),
      height: f,
      width: f,
      xmlns: "http://www.w3.org/2000/svg"
    }), l && /* @__PURE__ */ Tt.createElement("title", null, l), e.children);
  };
  return $5 !== void 0 ? /* @__PURE__ */ Tt.createElement($5.Consumer, null, (n) => t(n)) : t(v6);
}
function S2e(e) {
  return kS({ tag: "svg", attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M228,128a100,100,0,0,1-98.66,100H128a99.39,99.39,0,0,1-68.62-27.29,12,12,0,0,1,16.48-17.45,76,76,0,1,0-1.57-109c-.13.13-.25.25-.39.37L54.89,92H72a12,12,0,0,1,0,24H24a12,12,0,0,1-12-12V56a12,12,0,0,1,24,0V76.72L57.48,57.06A100,100,0,0,1,228,128Z" }, child: [] }] })(e);
}
function x2e(e) {
  return kS({ tag: "svg", attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M228,104a12,12,0,0,1-24,0V69l-59.51,59.51a12,12,0,0,1-17-17L187,52H152a12,12,0,0,1,0-24h64a12,12,0,0,1,12,12Zm-44,24a12,12,0,0,0-12,12v64H52V84h64a12,12,0,0,0,0-24H48A20,20,0,0,0,28,80V208a20,20,0,0,0,20,20H176a20,20,0,0,0,20-20V140A12,12,0,0,0,184,128Z" }, child: [] }] })(e);
}
function C2e(e) {
  return kS({ tag: "svg", attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M216.49,104.49l-80,80a12,12,0,0,1-17,0l-80-80a12,12,0,0,1,17-17L128,159l71.51-71.52a12,12,0,0,1,17,17Z" }, child: [] }] })(e);
}
const w2e = (e) => e.isDisabled === void 0 ? !1 : e.isDisabled, E2e = (e) => e.label, T2e = (e) => e.value, I2e = { sameWidth: !0, gutter: 4 }, A2e = (e, t) => e.group ? t.group ? e.group.localeCompare(t.group) : 1 : -1, k2e = (e, t, n, o) => {
  const a = e.find((l) => l.group === t.group);
  if (a)
    a.items.push(t);
  else {
    const l = { items: [t] };
    t.group && (l.group = t.group), e.push(l);
  }
  return e;
}, wDe = (e) => {
  const {
    items: t,
    selectedItem: n,
    onChange: o,
    isItemDisabled: a = w2e,
    itemToString: l = E2e,
    itemToValue: u = T2e,
    isClearable: f = !1,
    placeholder: h,
    positioning: v = I2e,
    groupSortFunc: g = A2e,
    invalid: b,
    disabled: S,
    ...w
  } = e, { t: E } = dD(), T = gt(() => n ? [n.value] : [], [n]), A = gt(() => {
    const V = t.reduce(k2e, []);
    return V.sort(g), V;
  }, [g, t]), P = re(
    (V) => {
      o(V.items[0] ?? null);
    },
    [o]
  ), _ = re(() => {
    o(null);
  }, [o]), D = gt(() => h ?? E("common.selectAnItem", "Select an Item"), [h, E]), L = Xn("CustomSelect"), F = yh({
    isDisabled: S,
    isInvalid: b
  });
  return /* @__PURE__ */ M(Fc, { label: n == null ? void 0 : n.description, placement: "top", openDelay: 500, children: /* @__PURE__ */ M(
    pl.Root,
    {
      value: T,
      items: t,
      onValueChange: P,
      isItemDisabled: a,
      itemToString: l,
      itemToValue: u,
      positioning: v,
      disabled: F.disabled,
      invalid: F["aria-invalid"],
      ...w,
      asChild: !0,
      children: /* @__PURE__ */ Nt(zo, { "data-part": "root", __css: L.root, children: [
        /* @__PURE__ */ M(pl.Control, { asChild: !0, children: /* @__PURE__ */ Nt(zo, { children: [
          /* @__PURE__ */ M(pl.Trigger, { asChild: !0, children: /* @__PURE__ */ Nt(zo, { as: "button", children: [
            /* @__PURE__ */ M(pl.ValueText, { asChild: !0, children: /* @__PURE__ */ M(zo, { children: (n == null ? void 0 : n.label) ?? D }) }),
            /* @__PURE__ */ M(pl.Indicator, { children: /* @__PURE__ */ M(ho, { as: C2e }) })
          ] }) }),
          f && /* @__PURE__ */ M(
            oW,
            {
              "aria-label": "Clear selection",
              variant: "ghost",
              size: "sm",
              icon: /* @__PURE__ */ M(S2e, {}),
              isDisabled: !n || F.disabled,
              onClick: _
            }
          )
        ] }) }),
        /* @__PURE__ */ M(l2e, { children: /* @__PURE__ */ M(pl.Positioner, { children: /* @__PURE__ */ M(pl.Content, { asChild: !0, children: /* @__PURE__ */ M(zo, { __css: L.content, children: A.map((V, $) => /* @__PURE__ */ M(B0, { children: /* @__PURE__ */ M(R2e, { itemGroup: V }) }, `${V.group}_${$}`)) }) }) }) })
      ] })
    }
  ) });
}, R2e = ({ itemGroup: e }) => e.group ? /* @__PURE__ */ M(pl.ItemGroup, { id: e.group, asChild: !0, children: /* @__PURE__ */ Nt(zo, { children: [
  e.group && /* @__PURE__ */ M(pl.ItemGroupLabel, { htmlFor: e.group, asChild: !0, children: /* @__PURE__ */ Nt(zo, { alignItems: "center", gap: 2, userSelect: "none", children: [
    /* @__PURE__ */ M(du, { flexShrink: 0, children: e.group }),
    /* @__PURE__ */ M(aT, {})
  ] }) }),
  e.items.map((t) => /* @__PURE__ */ M(H5, { item: t }, t.value))
] }) }) : /* @__PURE__ */ M(ah, { children: e.items.map((t) => /* @__PURE__ */ M(H5, { item: t }, t.value)) }), H5 = ({ item: e }) => /* @__PURE__ */ M(pl.Item, { item: e, asChild: !0, children: /* @__PURE__ */ M(zo, { children: /* @__PURE__ */ M(pl.ItemText, { asChild: !0, children: /* @__PURE__ */ Nt(zo, { children: [
  /* @__PURE__ */ M(du, { "data-part": "item-text-label", children: e.label }),
  (e == null ? void 0 : e.description) && /* @__PURE__ */ M(du, { "data-part": "item-text-description", noOfLines: 1, children: e == null ? void 0 : e.description })
] }) }) }) });
function P2e(e) {
  return kS({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M12 7.59 7.05 2.64 5.64 4.05 12 10.41l6.36-6.36-1.41-1.41L12 7.59zM5.64 19.95l1.41 1.41L12 16.41l4.95 4.95 1.41-1.41L12 13.59l-6.36 6.36z" }, child: [] }] })(e);
}
function O2e(e) {
  return kS({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "m12 19.24-4.95-4.95-1.41 1.42L12 22.07l6.36-6.36-1.41-1.42L12 19.24zM5.64 8.29l1.41 1.42L12 4.76l4.95 4.95 1.41-1.42L12 1.93 5.64 8.29z" }, child: [] }] })(e);
}
const KC = {
  color: "base.400",
  borderColor: "base.400",
  transitionDuration: "normal",
  transitionProperty: "common",
  ":hover, :hover *": {
    transitionDuration: "normal",
    transitionProperty: "common",
    color: "base.300",
    borderColor: "base.300"
  }
}, _2e = rr((e) => {
  const { t } = dD(), { children: n, label: o = t("common.advancedOptions", "Advanced Options"), isOpen: a, onToggle: l } = e;
  return /* @__PURE__ */ Nt(zo, { flexDir: "column", w: "full", children: [
    /* @__PURE__ */ Nt(zo, { as: "button", flexDir: "row", alignItems: "center", gap: 3, py: 4, px: 2, onClick: l, sx: KC, children: [
      /* @__PURE__ */ M(aT, { w: "unset", flexGrow: 1, sx: KC }),
      /* @__PURE__ */ Nt(zo, { flexDir: "row", alignItems: "center", gap: 2, children: [
        /* @__PURE__ */ M(ho, { as: a ? P2e : O2e, fontSize: "14px", sx: KC }),
        /* @__PURE__ */ M(du, { variant: "subtext", fontSize: "sm", fontWeight: "semibold", flexShrink: 0, sx: KC, children: o })
      ] })
    ] }),
    /* @__PURE__ */ M(b2, { in: a, animateOpacity: !0, children: n })
  ] });
});
_2e.displayName = "Expander";
const XD = wa({}), D2e = rr(({ children: e, ...t }) => /* @__PURE__ */ M(XD.Provider, { value: t, children: e }));
D2e.displayName = "FormControlGroup";
const N2e = rr(
  Le((e, t) => {
    const { orientation: n, isDisabled: o, ...a } = e, l = dr(XD), u = gt(() => n ?? l.orientation, [n, l.orientation]), f = gt(() => o ?? l.isDisabled, [o, l.isDisabled]);
    return /* @__PURE__ */ M(
      K9,
      {
        ref: t,
        orientation: u,
        isDisabled: f,
        ...a,
        ...l.formControlProps
      }
    );
  })
);
N2e.displayName = "FormControl";
const M2e = rr(
  Le((e, t) => {
    const n = dr(XD);
    return /* @__PURE__ */ M(q9, { ref: t, ...e, ...n.formLabelProps });
  })
);
M2e.displayName = "FormLabel";
const L2e = rr(
  Le((e, t) => {
    const { setShift: n } = MD(), o = re(
      (a) => {
        n(a.shiftKey);
      },
      [n]
    );
    return /* @__PURE__ */ M(F2, { ref: t, onPaste: cD, onKeyUp: o, onKeyDown: o, ...e });
  })
);
L2e.displayName = "Input";
const EDe = (e) => /* @__PURE__ */ Nt(YH, { href: e.href, isExternal: !0, children: [
  e.label,
  /* @__PURE__ */ M(ho, { display: "inline", verticalAlign: "middle", marginInlineStart: 2, as: x2e })
] }), y6 = rr((e) => {
  const { onKeyUp: t, onKeyDown: n, children: o, ...a } = e, { setShift: l } = MD(), u = re(
    (h) => {
      t == null || t(h), l(h.key === "Shift");
    },
    [t, l]
  ), f = re(
    (h) => {
      n == null || n(h), l(h.key === "Shift");
    },
    [n, l]
  );
  return /* @__PURE__ */ M($j, { onKeyUp: u, onKeyDown: f, ...a, children: o });
});
y6.displayName = "NumberInputField";
const F2e = (e) => /^[0-9\-.]$/i.test(e), B2e = (e, t) => Math.round(e / t) * t, V2e = rr(
  Le((e, t) => {
    const {
      value: n,
      min: o = 0,
      max: a,
      step: l = 1,
      fineStep: u,
      onChange: f,
      defaultValue: h,
      ...v
    } = e, [g, b] = ot(String(n)), [S, w] = ot(n), E = LD(), T = gt(() => E ? u ?? l : l, [E, u, l]), A = gt(() => Number.isInteger(l) && Number.isInteger(u ?? 1), [l, u]), P = gt(() => A ? "numeric" : "decimal", [A]), _ = gt(() => A ? 0 : 3, [A]), D = re(
      (F, V) => {
        b(F), !isNaN(V) && (w(V), f(V));
      },
      [f]
    ), L = re(
      (F) => {
        if (!F.target.value)
          D(String(h ?? o), Number(h) ?? o);
        else {
          const V = A ? B2e(S, u ?? l) : Number(S.toFixed(_)), $ = b1e(V, o, a);
          D(String($), $);
        }
      },
      [u, l, h, A, a, o, D, _, S]
    );
    return dt(() => {
      n !== S && (b(String(n)), w(n));
    }, [n, S]), /* @__PURE__ */ Nt(
      Bj,
      {
        ref: t,
        value: g,
        defaultValue: h,
        min: o,
        max: a,
        step: T,
        onChange: D,
        clampValueOnBlur: !1,
        isValidCharacter: F2e,
        focusInputOnChange: !1,
        onPaste: cD,
        inputMode: P,
        precision: _,
        variant: "filled",
        ...v,
        children: [
          /* @__PURE__ */ M(y6, { onBlur: L }),
          /* @__PURE__ */ Nt(Vj, { children: [
            /* @__PURE__ */ M(jj, { children: /* @__PURE__ */ M(Pke, {}) }),
            /* @__PURE__ */ M(Hj, { children: /* @__PURE__ */ M(Oke, {}) })
          ] })
        ]
      }
    );
  })
);
V2e.displayName = "CompositeNumberInput";
const b6 = { opacity: 0, y: 10 }, $2e = { ...b6, x: "-50%" }, S6 = {
  opacity: 1,
  y: 0,
  transition: { duration: 0.2, ease: "easeOut" }
}, z2e = { ...S6, x: "-50%" }, x6 = {
  opacity: 0,
  y: 10,
  transition: { duration: 0.2, ease: "anticipate" }
}, H2e = { ...x6, x: "-50%" }, j2e = {
  insetInlineStart: "0 !important",
  insetInlineEnd: "unset !important"
}, G2e = {
  insetInlineStart: "unset !important",
  insetInlineEnd: "0 !important"
}, zr = {
  initialFirstLast: b6,
  initialOther: $2e,
  exitFirstLast: x6,
  exitOther: H2e,
  animateFirstLast: S6,
  animateOther: z2e,
  firstMarkStyle: j2e,
  lastMarkStyle: G2e
}, C6 = rr(({ value: e, label: t, index: n, total: o }) => n === 0 ? /* @__PURE__ */ M(
  Sw,
  {
    as: ti.div,
    initial: zr.initialFirstLast,
    animate: zr.animateFirstLast,
    exit: zr.exitFirstLast,
    value: e,
    sx: zr.firstMarkStyle,
    children: t
  },
  e
) : n === o - 1 ? /* @__PURE__ */ M(
  Sw,
  {
    as: ti.div,
    initial: zr.initialFirstLast,
    animate: zr.animateFirstLast,
    exit: zr.exitFirstLast,
    value: e,
    sx: zr.lastMarkStyle,
    children: t
  },
  e
) : /* @__PURE__ */ M(
  Sw,
  {
    as: ti.div,
    initial: zr.initialOther,
    animate: zr.animateOther,
    exit: zr.exitOther,
    value: e,
    children: t
  },
  e
));
C6.displayName = "SliderMark";
const w6 = rr(({ value: e, label: t, index: n, total: o }) => n === 0 ? /* @__PURE__ */ M(
  bw,
  {
    as: ti.div,
    initial: zr.initialFirstLast,
    animate: zr.animateFirstLast,
    exit: zr.exitFirstLast,
    value: e,
    sx: zr.firstMarkStyle,
    children: t
  },
  e
) : n === o - 1 ? /* @__PURE__ */ M(
  bw,
  {
    as: ti.div,
    initial: zr.initialFirstLast,
    animate: zr.animateFirstLast,
    exit: zr.exitFirstLast,
    value: e,
    sx: zr.lastMarkStyle,
    children: t
  },
  e
) : /* @__PURE__ */ M(
  bw,
  {
    as: ti.div,
    initial: zr.initialOther,
    animate: zr.animateOther,
    exit: zr.exitOther,
    value: e,
    children: t
  },
  e
));
w6.displayName = "RangeSliderMark";
const W2e = rr(
  Le((e, t) => {
    const {
      value: n,
      min: o,
      max: a,
      step: l = 1,
      fineStep: u,
      onChange: f,
      onReset: h,
      formatValue: v = (H) => H.toString(),
      marks: g,
      withThumbTooltip: b = !1,
      ...S
    } = e, [w, E] = ot(!1), [T, A] = ot(!1), P = LD(), _ = gt(() => P ? u ?? l : l, [P, u, l]), D = yh({}), L = gt(() => n.map(v), [v, n]), F = re(() => E(!0), []), V = re(() => E(!1), []), $ = re(() => A(!0), []), U = re(() => A(!1), []), W = gt(() => g === !0 ? [o, a].map((H) => ({ value: H, label: v(H) })) : g ? g == null ? void 0 : g.map((H) => ({ value: H, label: v(H) })) : [], [g, v, a, o]);
    return /* @__PURE__ */ Nt(
      rG,
      {
        ref: t,
        value: n,
        min: o,
        max: a,
        step: _,
        onChange: f,
        onMouseEnter: F,
        onMouseLeave: V,
        focusThumbOnChange: !1,
        onChangeStart: $,
        onChangeEnd: U,
        ...S,
        ...D,
        children: [
          /* @__PURE__ */ M(Cu, { children: (W == null ? void 0 : W.length) && (w || T) && W.map((H, G) => /* @__PURE__ */ M(w6, { value: H.value, label: H.label, index: G, total: W.length }, H.value)) }),
          /* @__PURE__ */ M(oG, { children: /* @__PURE__ */ M(iG, {}) }),
          /* @__PURE__ */ M(Fc, { isOpen: b && (w || T), label: L[0], children: /* @__PURE__ */ M(MO, { index: 0, onDoubleClick: h, zIndex: 0 }) }),
          /* @__PURE__ */ M(Fc, { isOpen: b && (w || T), label: L[1], children: /* @__PURE__ */ M(MO, { index: 1, onDoubleClick: h, zIndex: 0 }) })
        ]
      }
    );
  })
);
W2e.displayName = "CompositeRangeSlider";
const U2e = (e) => e.toString(), X2e = rr(
  Le((e, t) => {
    const {
      value: n,
      min: o,
      max: a,
      step: l = 1,
      fineStep: u,
      onChange: f,
      onReset: h,
      defaultValue: v,
      formatValue: g = U2e,
      marks: b,
      withThumbTooltip: S = !1,
      ...w
    } = e, [E, T] = ot(!1), [A, P] = ot(!1), _ = LD(), D = gt(() => _ ? u ?? l : l, [_, u, l]), L = yh({}), F = gt(() => g(n), [g, n]), V = re(() => T(!0), []), $ = re(() => T(!1), []), U = re(() => P(!0), []), W = re(() => P(!1), []), H = gt(() => b === !0 ? [o, a].map((oe) => ({ value: oe, label: g(oe) })) : b ? b == null ? void 0 : b.map((oe) => ({ value: oe, label: g(oe) })) : [], [b, g, a, o]), G = re(() => {
      rCe(v) || f(v), h && h();
    }, [v, f, h]);
    return /* @__PURE__ */ Nt(
      aG,
      {
        ref: t,
        value: n,
        min: o,
        max: a,
        step: D,
        onChange: f,
        onMouseEnter: V,
        onMouseLeave: $,
        focusThumbOnChange: !1,
        onChangeStart: U,
        onChangeEnd: W,
        ...w,
        ...L,
        children: [
          /* @__PURE__ */ M(Cu, { children: (H == null ? void 0 : H.length) && (E || A) && H.map((oe, ce) => /* @__PURE__ */ M(C6, { value: oe.value, label: oe.label, index: ce, total: H.length }, oe.value)) }),
          /* @__PURE__ */ M(lG, { children: /* @__PURE__ */ M(uG, {}) }),
          /* @__PURE__ */ M(Fc, { isOpen: S && (E || A), label: F, children: /* @__PURE__ */ M(sG, { onDoubleClick: G, zIndex: 0 }) })
        ]
      }
    );
  })
);
X2e.displayName = "CompositeSlider";
const Z2e = rr(
  Le((e, t) => {
    const { children: n, badges: o, ...a } = e;
    return /* @__PURE__ */ Nt(hG, { ref: t, ...a, children: [
      n,
      /* @__PURE__ */ M(V2, {}),
      o == null ? void 0 : o.map((l, u) => /* @__PURE__ */ M(z2, { colorScheme: "appYellow", children: l }, `${l}.${u}`))
    ] });
  })
);
Z2e.displayName = "Tab";
const Y2e = rr(
  Le((e, t) => {
    const { ...n } = e, { setShift: o } = MD(), a = re(
      (l) => {
        o(l.shiftKey);
      },
      [o]
    );
    return /* @__PURE__ */ M(
      mG,
      {
        ref: t,
        onPaste: cD,
        onKeyUp: a,
        onKeyDown: a,
        minH: 20,
        ...n
      }
    );
  })
);
Y2e.displayName = "Textarea";
export {
  ND as $alt,
  _D as $ctrl,
  DD as $meta,
  OD as $shift,
  Y9 as Accordion,
  nW as AccordionButton,
  G9 as AccordionIcon,
  W9 as AccordionItem,
  Z9 as AccordionPanel,
  sge as AlertDialog,
  Fj as AlertDialogBody,
  cge as AlertDialogCloseButton,
  lge as AlertDialogContent,
  Nj as AlertDialogFooter,
  Mj as AlertDialogHeader,
  Lj as AlertDialogOverlay,
  z2 as Badge,
  qr as Box,
  YO as Button,
  GCe as ButtonGroup,
  cDe as Card,
  sDe as CardBody,
  lDe as CardFooter,
  uDe as CardHeader,
  iDe as ChakraProvider,
  ufe as Checkbox,
  Hge as CircularProgress,
  b2 as Collapse,
  bke as Combobox,
  Ske as ComboboxFallback,
  V2e as CompositeNumberInput,
  W2e as CompositeRangeSlider,
  X2e as CompositeSlider,
  pDe as ConfirmationAlertDialog,
  xDe as ContextMenu,
  wDe as CustomSelect,
  GQ as DarkMode,
  aT as Divider,
  Efe as Editable,
  hfe as EditableInput,
  mfe as EditablePreview,
  vfe as EditableTextarea,
  _2e as Expander,
  EDe as ExternalLink,
  gde as Fade,
  zo as Flex,
  N2e as FormControl,
  D2e as FormControlGroup,
  Wde as FormErrorMessage,
  Hde as FormHelperText,
  M2e as FormLabel,
  she as Grid,
  fhe as GridItem,
  dhe as HStack,
  phe as Heading,
  ho as Icon,
  oW as IconButton,
  Ade as Image,
  L2e as Input,
  ehe as InputGroup,
  ZH as InputRightElement,
  mhe as Kbd,
  YH as Link,
  B2 as List,
  ahe as ListIcon,
  ihe as ListItem,
  K2 as Menu,
  xj as MenuButton,
  hve as MenuDivider,
  Sj as MenuGroup,
  NPe as MenuItem,
  Cj as MenuItemOption,
  LPe as MenuList,
  fve as MenuOptionGroup,
  Ij as Modal,
  Fj as ModalBody,
  cge as ModalCloseButton,
  Dj as ModalContent,
  Nj as ModalFooter,
  Mj as ModalHeader,
  Lj as ModalOverlay,
  Hj as NumberDecrementStepper,
  jj as NumberIncrementStepper,
  Bj as NumberInput,
  y6 as NumberInputField,
  Vj as NumberInputStepper,
  rhe as OrderedList,
  Age as Popover,
  kge as PopoverAnchor,
  Rge as PopoverArrow,
  Pge as PopoverBody,
  Oge as PopoverCloseButton,
  Mge as PopoverContent,
  Lge as PopoverFooter,
  Ege as PopoverHeader,
  Tge as PopoverTrigger,
  wf as Portal,
  Uge as Progress,
  tye as Radio,
  Jge as RadioGroup,
  rG as RangeSlider,
  iG as RangeSliderFilledTrack,
  MO as RangeSliderThumb,
  oG as RangeSliderTrack,
  bde as ScaleFade,
  rye as Select,
  dye as Skeleton,
  wde as Slide,
  xde as SlideFade,
  aG as Slider,
  uG as SliderFilledTrack,
  sG as SliderThumb,
  lG as SliderTrack,
  V2 as Spacer,
  eT as Spinner,
  kCe as StandaloneAccordion,
  jye as Stat,
  Gye as StatArrow,
  Wye as StatGroup,
  Uye as StatHelpText,
  Xye as StatLabel,
  Zye as StatNumber,
  Yye as Switch,
  SDe as TOAST_OPTIONS,
  Z2e as Tab,
  cbe as TabList,
  dbe as TabPanel,
  fbe as TabPanels,
  ube as Tabs,
  du as Text,
  Y2e as Textarea,
  Fc as Tooltip,
  ohe as UnorderedList,
  che as VStack,
  De as chakra,
  oDe as createStandaloneToast,
  Pt as cssVar,
  tDe as extendTheme,
  Le as forwardRef,
  yDe as getArbitraryBaseColor,
  ACe as skipMouseEvent,
  Dke as spinAnimation,
  cD as stopPastePropagation,
  bDe as theme,
  rr as typedMemo,
  vDe as useAltModifier,
  mDe as useCtrlModifier,
  Qpe as useDisclosure,
  fDe as useEditableControls,
  wke as useGlobalMenuClose,
  MD as useGlobalModifiersImperativeAPI,
  hDe as useGlobalModifiersInit,
  gDe as useMetaModifier,
  LD as useShiftModifier,
  rDe as useToast,
  XQ as useToken
};
//# sourceMappingURL=main.js.map
